; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\公共组件\服务核心\WHService.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	??0CWHService@@AAE@XZ				; CWHService::CWHService
PUBLIC	?SetClipboardString@CWHService@@SA_NPBD@Z	; CWHService::SetClipboardString
PUBLIC	?GetMachineID@CWHService@@SA_NQAD@Z		; CWHService::GetMachineID
PUBLIC	?GetMachineIDEx@CWHService@@SA_NQAD@Z		; CWHService::GetMachineIDEx
PUBLIC	?GetMACAddress@CWHService@@SA_NQAD@Z		; CWHService::GetMACAddress
PUBLIC	?UnRegisterHotKey@CWHService@@SA_NPAUHWND__@@I@Z ; CWHService::UnRegisterHotKey
PUBLIC	?RegisterHotKey@CWHService@@SA_NPAUHWND__@@IG@Z	; CWHService::RegisterHotKey
PUBLIC	?GetWorkDirectory@CWHService@@SA_NQADG@Z	; CWHService::GetWorkDirectory
PUBLIC	?GetModuleVersion@CWHService@@SA_NPBDAAK@Z	; CWHService::GetModuleVersion
PUBLIC	?CompressData@CWHService@@SAKPAEKQAEK@Z		; CWHService::CompressData
PUBLIC	?UnCompressData@CWHService@@SAKPAEKQAEK@Z	; CWHService::UnCompressData
PUBLIC	??4CWHService@@QAEAAV0@ABV0@@Z			; CWHService::operator=
PUBLIC	??4CWHService@@QAEAAV0@$$QAV0@@Z		; CWHService::operator=
PUBLIC	??0CWHEncrypt@@QAE@ABV0@@Z			; CWHEncrypt::CWHEncrypt
PUBLIC	??4CWHEncrypt@@QAEAAV0@ABV0@@Z			; CWHEncrypt::operator=
PUBLIC	??_GCWHEncrypt@@UAEPAXI@Z			; CWHEncrypt::`scalar deleting destructor'
PUBLIC	??_ECWHEncrypt@@UAEPAXI@Z			; CWHEncrypt::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_7CWHEncrypt@@6B@				; CWHEncrypt::`vftable'
PUBLIC	?__LINE__Var@?0??SetClipboardString@CWHService@@SA_NPBD@Z@4JA ; `CWHService::SetClipboardString'::`1'::__LINE__Var
PUBLIC	??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	?__LINE__Var@?0??GetMachineIDEx@CWHService@@SA_NQAD@Z@4JA ; `CWHService::GetMachineIDEx'::`1'::__LINE__Var
PUBLIC	??_C@_03GIOIKFCO@C?3?2@				; `string'
PUBLIC	??_C@_03PFDPJNJH@D?3?2@				; `string'
PUBLIC	??_C@_03ENIDPKPC@E?3?2@				; `string'
PUBLIC	?__LINE__Var@?0??GetMACAddress@CWHService@@SA_NQAD@Z@4JA ; `CWHService::GetMACAddress'::`1'::__LINE__Var
PUBLIC	??_C@_0N@JFJMPEGD@NetApi32?4dll@		; `string'
PUBLIC	??_C@_07NLCOGFA@Netbios@			; `string'
PUBLIC	??_C@_04JFFKLGJF@?$CF02X@			; `string'
PUBLIC	?__LINE__Var@?0??GetWorkDirectory@CWHService@@SA_NQADG@Z@4JA ; `CWHService::GetWorkDirectory'::`1'::__LINE__Var
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_R4CWHEncrypt@@6B@				; CWHEncrypt::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWHEncrypt@@@8				; CWHEncrypt `RTTI Type Descriptor'
PUBLIC	??_R3CWHEncrypt@@8				; CWHEncrypt::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWHEncrypt@@8				; CWHEncrypt::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWHEncrypt@@8			; CWHEncrypt::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__GetVolumeInformationA@32:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__lstrcpynA@12:PROC
EXTRN	__imp__lstrcpyA@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__RegisterHotKey@16:PROC
EXTRN	__imp__UnregisterHotKey@8:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__SetClipboardData@8:PROC
EXTRN	__imp__EmptyClipboard@0:PROC
EXTRN	_GetFileVersionInfoA@16:PROC
EXTRN	_VerQueryValueA@16:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	?AfxGetMainWnd@@YGPAVCWnd@@XZ:PROC		; AfxGetMainWnd
EXTRN	?AfxGetInstanceHandle@@YGPAUHINSTANCE__@@XZ:PROC ; AfxGetInstanceHandle
EXTRN	??1CWHEncrypt@@UAE@XZ:PROC			; CWHEncrypt::~CWHEncrypt
EXTRN	?MD5Encrypt@CWHEncrypt@@SA_NPBDQAD@Z:PROC	; CWHEncrypt::MD5Encrypt
EXTRN	_compress:PROC
EXTRN	_uncompress:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CWHEncrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWHEncrypt@@8 DD FLAT:??_R0?AVCWHEncrypt@@@8 ; CWHEncrypt::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWHEncrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2CWHEncrypt@@8
rdata$r	SEGMENT
??_R2CWHEncrypt@@8 DD FLAT:??_R1A@?0A@EA@CWHEncrypt@@8	; CWHEncrypt::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWHEncrypt@@8
rdata$r	SEGMENT
??_R3CWHEncrypt@@8 DD 00H				; CWHEncrypt::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWHEncrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWHEncrypt@@@8
data$r	SEGMENT
??_R0?AVCWHEncrypt@@@8 DD FLAT:??_7type_info@@6B@	; CWHEncrypt `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWHEncrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4CWHEncrypt@@6B@
rdata$r	SEGMENT
??_R4CWHEncrypt@@6B@ DD 00H				; CWHEncrypt::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWHEncrypt@@@8
	DD	FLAT:??_R3CWHEncrypt@@8
rdata$r	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetWorkDirectory@CWHService@@SA_NQADG@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetWorkDirectory@CWHService@@SA_NQADG@Z@4JA DD 0eaH ; `CWHService::GetWorkDirectory'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_04JFFKLGJF@?$CF02X@
CONST	SEGMENT
??_C@_04JFFKLGJF@?$CF02X@ DB '%02X', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NLCOGFA@Netbios@
CONST	SEGMENT
??_C@_07NLCOGFA@Netbios@ DB 'Netbios', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFJMPEGD@NetApi32?4dll@
CONST	SEGMENT
??_C@_0N@JFJMPEGD@NetApi32?4dll@ DB 'NetApi32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetMACAddress@CWHService@@SA_NQAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMACAddress@CWHService@@SA_NQAD@Z@4JA DD 083H ; `CWHService::GetMACAddress'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_03ENIDPKPC@E?3?2@
CONST	SEGMENT
??_C@_03ENIDPKPC@E?3?2@ DB 'E:\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFDPJNJH@D?3?2@
CONST	SEGMENT
??_C@_03PFDPJNJH@D?3?2@ DB 'D:\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GIOIKFCO@C?3?2@
CONST	SEGMENT
??_C@_03GIOIKFCO@C?3?2@ DB 'C:\', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??GetMachineIDEx@CWHService@@SA_NQAD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMachineIDEx@CWHService@@SA_NQAD@Z@4JA DD 069H ; `CWHService::GetMachineIDEx'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0b9H, 0abH, 0b9H, 0b2H, 0d7H, 0e9H, 0bcH, 0feH, '\', 0b7H
	DB	0feH, 0ceH, 0f1H, 0baH, 0cbH, 0d0H, 0c4H, '\whservice.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??SetClipboardString@CWHService@@SA_NPBD@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??SetClipboardString@CWHService@@SA_NPBD@Z@4JA DD 025H ; `CWHService::SetClipboardString'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7CWHEncrypt@@6B@
CONST	SEGMENT
??_7CWHEncrypt@@6B@ DD FLAT:??_R4CWHEncrypt@@6B@	; CWHEncrypt::`vftable'
	DD	FLAT:??_ECWHEncrypt@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_ECWHEncrypt@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?GetMACAddress@CWHService@@SA_NQAD@Z DD 0ffffffe4H
	DD	00H
	DD	0fffffca8H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN24@GetMACAddr
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?SetClipboardString@CWHService@@SA_NPBD@Z DD 0fffffffeH
	DD	00H
	DD	0ffffff88H
	DD	00H
	DD	0fffffffeH
	DD	00H
	DD	FLAT:$LN17@SetClipboa
xdata$x	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_ECWHEncrypt@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_ECWHEncrypt@@UAEPAXI@Z PROC				; CWHEncrypt::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_ECWHEncrypt@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 02	 and	 eax, 2
  00031	74 44		 je	 SHORT $LN2@vector
  00033	68 00 00 00 00	 push	 OFFSET ??1CWHEncrypt@@UAE@XZ ; CWHEncrypt::~CWHEncrypt
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	51		 push	 ecx
  0003f	6a 04		 push	 4
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 1d		 je	 SHORT $LN3@vector
  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00058	8d 14 8d 04 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+4]
  0005f	52		 push	 edx
  00060	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00063	83 e8 04	 sub	 eax, 4
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0006c	83 c4 08	 add	 esp, 8
$LN3@vector:
  0006f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 e8 04	 sub	 eax, 4
  00075	eb 21		 jmp	 SHORT $LN5@vector
$LN2@vector:
  00077	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ??1CWHEncrypt@@UAE@XZ	; CWHEncrypt::~CWHEncrypt
  0007f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00082	83 e0 01	 and	 eax, 1
  00085	74 0e		 je	 SHORT $LN4@vector
  00087	6a 04		 push	 4
  00089	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00092	83 c4 08	 add	 esp, 8
$LN4@vector:
  00095	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@vector:
  00098	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a2	59		 pop	 ecx
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_ECWHEncrypt@@UAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_ECWHEncrypt@@UAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_ECWHEncrypt@@UAEPAXI@Z ENDP				; CWHEncrypt::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCWHEncrypt@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCWHEncrypt@@UAEPAXI@Z PROC				; CWHEncrypt::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CWHEncrypt@@UAE@XZ	; CWHEncrypt::~CWHEncrypt
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 04		 push	 4
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCWHEncrypt@@UAEPAXI@Z ENDP				; CWHEncrypt::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CWHEncrypt@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CWHEncrypt@@QAEAAV0@ABV0@@Z PROC			; CWHEncrypt::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??4CWHEncrypt@@QAEAAV0@ABV0@@Z ENDP			; CWHEncrypt::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CWHEncrypt@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CWHEncrypt@@QAE@ABV0@@Z PROC				; CWHEncrypt::CWHEncrypt, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWHEncrypt@@6B@
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0CWHEncrypt@@QAE@ABV0@@Z ENDP				; CWHEncrypt::CWHEncrypt
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CWHService@@QAEAAV0@$$QAV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CWHService@@QAEAAV0@$$QAV0@@Z PROC			; CWHService::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??4CWHService@@QAEAAV0@$$QAV0@@Z ENDP			; CWHService::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CWHService@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CWHService@@QAEAAV0@ABV0@@Z PROC			; CWHService::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??4CWHService@@QAEAAV0@ABV0@@Z ENDP			; CWHService::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?UnCompressData@CWHService@@SAKPAEKQAEK@Z
_TEXT	SEGMENT
_pcbSourceData$ = 8					; size = 4
_lSourceSize$ = 12					; size = 4
_cbResultData$ = 16					; size = 4
_lResultSize$ = 20					; size = 4
?UnCompressData@CWHService@@SAKPAEKQAEK@Z PROC		; CWHService::UnCompressData, COMDAT

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 306  : 	//解压数据
; 307  : 	if (uncompress(cbResultData,&lResultSize,pcbSourceData,lSourceSize)==0L)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lSourceSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pcbSourceData$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 14	 lea	 edx, DWORD PTR _lResultSize$[ebp]
  00014	52		 push	 edx
  00015	8b 45 10	 mov	 eax, DWORD PTR _cbResultData$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _uncompress
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
  00021	85 c0		 test	 eax, eax
  00023	75 05		 jne	 SHORT $LN2@UnCompress

; 308  : 	{
; 309  : 		return lResultSize;

  00025	8b 45 14	 mov	 eax, DWORD PTR _lResultSize$[ebp]
  00028	eb 02		 jmp	 SHORT $LN1@UnCompress
$LN2@UnCompress:

; 310  : 	}
; 311  : 
; 312  : 	return 0L;

  0002a	33 c0		 xor	 eax, eax
$LN1@UnCompress:

; 313  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?UnCompressData@CWHService@@SAKPAEKQAEK@Z ENDP		; CWHService::UnCompressData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?CompressData@CWHService@@SAKPAEKQAEK@Z
_TEXT	SEGMENT
_pcbSourceData$ = 8					; size = 4
_lSourceSize$ = 12					; size = 4
_cbResultData$ = 16					; size = 4
_lResultSize$ = 20					; size = 4
?CompressData@CWHService@@SAKPAEKQAEK@Z PROC		; CWHService::CompressData, COMDAT

; 293  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 294  : 	//压缩数据
; 295  : 	if (compress(cbResultData,&lResultSize,pcbSourceData,lSourceSize)==0L)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _lSourceSize$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pcbSourceData$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 14	 lea	 edx, DWORD PTR _lResultSize$[ebp]
  00014	52		 push	 edx
  00015	8b 45 10	 mov	 eax, DWORD PTR _cbResultData$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _compress
  0001e	83 c4 10	 add	 esp, 16			; 00000010H
  00021	85 c0		 test	 eax, eax
  00023	75 05		 jne	 SHORT $LN2@CompressDa

; 296  : 	{
; 297  : 		return lResultSize;

  00025	8b 45 14	 mov	 eax, DWORD PTR _lResultSize$[ebp]
  00028	eb 02		 jmp	 SHORT $LN1@CompressDa
$LN2@CompressDa:

; 298  : 	}
; 299  : 
; 300  : 	return 0L;

  0002a	33 c0		 xor	 eax, eax
$LN1@CompressDa:

; 301  : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?CompressData@CWHService@@SAKPAEKQAEK@Z ENDP		; CWHService::CompressData
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?GetModuleVersion@CWHService@@SA_NPBDAAK@Z
_TEXT	SEGMENT
_wVersion4$1 = -1056					; size = 2
_wVersion3$2 = -1052					; size = 2
_wVersion2$3 = -1048					; size = 2
_wVersion1$4 = -1044					; size = 2
_pFixedFileInfo$ = -1040				; size = 4
_uQuerySize$ = -1036					; size = 4
_dwFileHandle$ = -1032					; size = 4
_cbInfoBuffer$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_pszModuleName$ = 8					; size = 4
_dwVersionInfo$ = 12					; size = 4
?GetModuleVersion@CWHService@@SA_NPBDAAK@Z PROC		; CWHService::GetModuleVersion, COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 04 00
	00		 sub	 esp, 1248		; 000004e0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 259  : 	//设置结果
; 260  : 	dwVersionInfo=0L;

  00016	8b 45 0c	 mov	 eax, DWORD PTR _dwVersionInfo$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 261  : 
; 262  : 	//接收缓冲
; 263  : 	BYTE cbInfoBuffer[1024];
; 264  : 	ZeroMemory(cbInfoBuffer,sizeof(cbInfoBuffer));

  0001f	68 00 04 00 00	 push	 1024			; 00000400H
  00024	6a 00		 push	 0
  00026	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cbInfoBuffer$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 265  : 
; 266  : 	//模块信息
; 267  :     DWORD dwFileHandle=NULL;

  00035	c7 85 f8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwFileHandle$[ebp], 0

; 268  : 	if (GetFileVersionInfo(pszModuleName,dwFileHandle,sizeof(cbInfoBuffer),cbInfoBuffer)==FALSE) return false;

  0003f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _cbInfoBuffer$[ebp]
  00045	50		 push	 eax
  00046	68 00 04 00 00	 push	 1024			; 00000400H
  0004b	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR _dwFileHandle$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 08	 mov	 edx, DWORD PTR _pszModuleName$[ebp]
  00055	52		 push	 edx
  00056	e8 00 00 00 00	 call	 _GetFileVersionInfoA@16
  0005b	85 c0		 test	 eax, eax
  0005d	75 07		 jne	 SHORT $LN2@GetModuleV
  0005f	32 c0		 xor	 al, al
  00061	e9 25 01 00 00	 jmp	 $LN1@GetModuleV
$LN2@GetModuleV:

; 269  : 
; 270  : 	//获取信息
; 271  : 	UINT uQuerySize=0;

  00066	c7 85 f4 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _uQuerySize$[ebp], 0

; 272  : 	VS_FIXEDFILEINFO * pFixedFileInfo=NULL;

  00070	c7 85 f0 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR _pFixedFileInfo$[ebp], 0

; 273  :     if (VerQueryValue(cbInfoBuffer,TEXT("\\"),(VOID * *)&pFixedFileInfo,&uQuerySize)==FALSE) return false;

  0007a	8d 85 f4 fb ff
	ff		 lea	 eax, DWORD PTR _uQuerySize$[ebp]
  00080	50		 push	 eax
  00081	8d 8d f0 fb ff
	ff		 lea	 ecx, DWORD PTR _pFixedFileInfo$[ebp]
  00087	51		 push	 ecx
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  0008d	8d 95 fc fb ff
	ff		 lea	 edx, DWORD PTR _cbInfoBuffer$[ebp]
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 _VerQueryValueA@16
  00099	85 c0		 test	 eax, eax
  0009b	75 07		 jne	 SHORT $LN3@GetModuleV
  0009d	32 c0		 xor	 al, al
  0009f	e9 e7 00 00 00	 jmp	 $LN1@GetModuleV
$LN3@GetModuleV:

; 274  : 
; 275  : 	//设置结果
; 276  : 	if ((pFixedFileInfo!=NULL)&&(uQuerySize==sizeof(VS_FIXEDFILEINFO)))

  000a4	83 bd f0 fb ff
	ff 00		 cmp	 DWORD PTR _pFixedFileInfo$[ebp], 0
  000ab	0f 84 d8 00 00
	00		 je	 $LN4@GetModuleV
  000b1	83 bd f4 fb ff
	ff 34		 cmp	 DWORD PTR _uQuerySize$[ebp], 52 ; 00000034H
  000b8	0f 85 cb 00 00
	00		 jne	 $LN4@GetModuleV

; 277  : 	{
; 278  : 		//设置版本
; 279  : 		WORD wVersion1=HIWORD(pFixedFileInfo->dwFileVersionMS);

  000be	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pFixedFileInfo$[ebp]
  000c4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c7	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000ca	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000d0	66 89 8d ec fb
	ff ff		 mov	 WORD PTR _wVersion1$4[ebp], cx

; 280  : 		WORD wVersion2=LOWORD(pFixedFileInfo->dwFileVersionMS);

  000d7	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pFixedFileInfo$[ebp]
  000dd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e0	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000e6	66 89 8d e8 fb
	ff ff		 mov	 WORD PTR _wVersion2$3[ebp], cx

; 281  : 		WORD wVersion3=HIWORD(pFixedFileInfo->dwFileVersionLS);

  000ed	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pFixedFileInfo$[ebp]
  000f3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000f6	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000f9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000ff	66 89 8d e4 fb
	ff ff		 mov	 WORD PTR _wVersion3$2[ebp], cx

; 282  : 		WORD wVersion4=LOWORD(pFixedFileInfo->dwFileVersionLS);

  00106	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR _pFixedFileInfo$[ebp]
  0010c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0010f	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00115	66 89 8d e0 fb
	ff ff		 mov	 WORD PTR _wVersion4$1[ebp], cx

; 283  : 		dwVersionInfo=MAKELONG(MAKEWORD(wVersion4,wVersion3),MAKEWORD(wVersion2,wVersion1));

  0011c	0f b7 85 e0 fb
	ff ff		 movzx	 eax, WORD PTR _wVersion4$1[ebp]
  00123	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00128	0f b6 c8	 movzx	 ecx, al
  0012b	0f b7 95 e4 fb
	ff ff		 movzx	 edx, WORD PTR _wVersion3$2[ebp]
  00132	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00138	0f b6 c2	 movzx	 eax, dl
  0013b	c1 e0 08	 shl	 eax, 8
  0013e	0b c8		 or	 ecx, eax
  00140	0f b7 c9	 movzx	 ecx, cx
  00143	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00149	0f b7 d1	 movzx	 edx, cx
  0014c	0f b7 85 e8 fb
	ff ff		 movzx	 eax, WORD PTR _wVersion2$3[ebp]
  00153	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00158	0f b6 c8	 movzx	 ecx, al
  0015b	0f b7 85 ec fb
	ff ff		 movzx	 eax, WORD PTR _wVersion1$4[ebp]
  00162	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00167	0f b6 c0	 movzx	 eax, al
  0016a	c1 e0 08	 shl	 eax, 8
  0016d	0b c8		 or	 ecx, eax
  0016f	0f b7 c9	 movzx	 ecx, cx
  00172	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00178	0f b7 c1	 movzx	 eax, cx
  0017b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0017e	0b d0		 or	 edx, eax
  00180	8b 4d 0c	 mov	 ecx, DWORD PTR _dwVersionInfo$[ebp]
  00183	89 11		 mov	 DWORD PTR [ecx], edx

; 284  : 
; 285  : 		return true;

  00185	b0 01		 mov	 al, 1
  00187	eb 02		 jmp	 SHORT $LN1@GetModuleV
$LN4@GetModuleV:

; 286  : 	}
; 287  : 
; 288  : 	return false;

  00189	32 c0		 xor	 al, al
$LN1@GetModuleV:

; 289  : }

  0018b	5f		 pop	 edi
  0018c	5e		 pop	 esi
  0018d	5b		 pop	 ebx
  0018e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00191	33 cd		 xor	 ecx, ebp
  00193	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c3		 ret	 0
?GetModuleVersion@CWHService@@SA_NPBDAAK@Z ENDP		; CWHService::GetModuleVersion
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?GetWorkDirectory@CWHService@@SA_NQADG@Z
_TEXT	SEGMENT
$T1 = -336						; size = 4
_i$2 = -268						; size = 4
_szModulePath$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_szWorkDirectory$ = 8					; size = 4
_wBufferCount$ = 12					; size = 2
?GetWorkDirectory@CWHService@@SA_NQADG@Z PROC		; CWHService::GetWorkDirectory, COMDAT

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 235  : 	//模块路径
; 236  : 	TCHAR szModulePath[MAX_PATH]=TEXT("");

  00016	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0001b	88 85 f8 fe ff
	ff		 mov	 BYTE PTR _szModulePath$[ebp], al
  00021	68 03 01 00 00	 push	 259			; 00000103H
  00026	6a 00		 push	 0
  00028	8d 85 f9 fe ff
	ff		 lea	 eax, DWORD PTR _szModulePath$[ebp+1]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _memset
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  : 	GetModuleFileName(AfxGetInstanceHandle(),szModulePath,CountArray(szModulePath));

  00037	68 04 01 00 00	 push	 260			; 00000104H
  0003c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szModulePath$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?AfxGetInstanceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetInstanceHandle
  00048	50		 push	 eax
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 238  : 
; 239  : 	//分析文件
; 240  : 	for (INT i=lstrlen(szModulePath);i>=0;i--)

  0004f	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szModulePath$[ebp]
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0005c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
  00062	eb 0f		 jmp	 SHORT $LN4@GetWorkDir
$LN2@GetWorkDir:
  00064	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  0006a	83 e8 01	 sub	 eax, 1
  0006d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _i$2[ebp], eax
$LN4@GetWorkDir:
  00073	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR _i$2[ebp], 0
  0007a	7c 44		 jl	 SHORT $LN3@GetWorkDir

; 241  : 	{
; 242  : 		if (szModulePath[i]==TEXT('\\'))

  0007c	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00082	0f be 8c 05 f8
	fe ff ff	 movsx	 ecx, BYTE PTR _szModulePath$[ebp+eax]
  0008a	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0008d	75 2f		 jne	 SHORT $LN5@GetWorkDir

; 243  : 		{
; 244  : 			szModulePath[i]=0;

  0008f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _i$2[ebp]
  00095	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0009b	81 bd b0 fe ff
	ff 04 01 00 00	 cmp	 DWORD PTR $T1[ebp], 260	; 00000104H
  000a5	73 02		 jae	 SHORT $LN7@GetWorkDir
  000a7	eb 05		 jmp	 SHORT $LN8@GetWorkDir
$LN7@GetWorkDir:
  000a9	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN8@GetWorkDir:
  000ae	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  000b4	c6 84 0d f8 fe
	ff ff 00	 mov	 BYTE PTR _szModulePath$[ebp+ecx], 0

; 245  : 			break;

  000bc	eb 02		 jmp	 SHORT $LN3@GetWorkDir
$LN5@GetWorkDir:

; 246  : 		}
; 247  : 	}

  000be	eb a4		 jmp	 SHORT $LN2@GetWorkDir
$LN3@GetWorkDir:

; 248  : 
; 249  : 	//设置结果
; 250  : 	ASSERT(szModulePath[0]!=0);

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	6b c8 00	 imul	 ecx, eax, 0
  000c8	0f be 94 0d f8
	fe ff ff	 movsx	 edx, BYTE PTR _szModulePath$[ebp+ecx]
  000d0	85 d2		 test	 edx, edx
  000d2	75 18		 jne	 SHORT $LN9@GetWorkDir
  000d4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetWorkDirectory@CWHService@@SA_NQADG@Z@4JA
  000d9	83 c0 10	 add	 eax, 16			; 00000010H
  000dc	50		 push	 eax
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000e2	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000e7	85 c0		 test	 eax, eax
  000e9	74 01		 je	 SHORT $LN9@GetWorkDir
  000eb	cc		 int	 3
$LN9@GetWorkDir:

; 251  : 	lstrcpyn(szWorkDirectory,szModulePath,wBufferCount);

  000ec	0f b7 45 0c	 movzx	 eax, WORD PTR _wBufferCount$[ebp]
  000f0	50		 push	 eax
  000f1	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _szModulePath$[ebp]
  000f7	51		 push	 ecx
  000f8	8b 55 08	 mov	 edx, DWORD PTR _szWorkDirectory$[ebp]
  000fb	52		 push	 edx
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpynA@12

; 252  : 
; 253  : 	return true;

  00102	b0 01		 mov	 al, 1
$LN6@GetWorkDir:

; 254  : }

  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010a	33 cd		 xor	 ecx, ebp
  0010c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
?GetWorkDirectory@CWHService@@SA_NQADG@Z ENDP		; CWHService::GetWorkDirectory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?RegisterHotKey@CWHService@@SA_NPAUHWND__@@IG@Z
_TEXT	SEGMENT
tv137 = -73						; size = 1
_bSuccess$ = -8						; size = 4
_cbModifiers$ = -1					; size = 1
_hWnd$ = 8						; size = 4
_uKeyID$ = 12						; size = 4
_wHotKey$ = 16						; size = 2
?RegisterHotKey@CWHService@@SA_NPAUHWND__@@IG@Z PROC	; CWHService::RegisterHotKey, COMDAT

; 219  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 220  : 	//变量定义
; 221  : 	BYTE cbModifiers=0;

  00009	c6 45 ff 00	 mov	 BYTE PTR _cbModifiers$[ebp], 0

; 222  : 	if (HIBYTE(wHotKey)&HOTKEYF_ALT) cbModifiers|=MOD_ALT;

  0000d	0f b7 45 10	 movzx	 eax, WORD PTR _wHotKey$[ebp]
  00011	c1 e8 08	 shr	 eax, 8
  00014	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	83 e1 04	 and	 ecx, 4
  0001f	74 0a		 je	 SHORT $LN2@RegisterHo
  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbModifiers$[ebp]
  00025	83 c8 01	 or	 eax, 1
  00028	88 45 ff	 mov	 BYTE PTR _cbModifiers$[ebp], al
$LN2@RegisterHo:

; 223  : 	if (HIBYTE(wHotKey)&HOTKEYF_SHIFT) cbModifiers|=MOD_SHIFT;

  0002b	0f b7 45 10	 movzx	 eax, WORD PTR _wHotKey$[ebp]
  0002f	c1 e8 08	 shr	 eax, 8
  00032	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00037	0f b6 c8	 movzx	 ecx, al
  0003a	83 e1 01	 and	 ecx, 1
  0003d	74 0a		 je	 SHORT $LN3@RegisterHo
  0003f	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbModifiers$[ebp]
  00043	83 c8 04	 or	 eax, 4
  00046	88 45 ff	 mov	 BYTE PTR _cbModifiers$[ebp], al
$LN3@RegisterHo:

; 224  : 	if (HIBYTE(wHotKey)&HOTKEYF_CONTROL) cbModifiers|=MOD_CONTROL;

  00049	0f b7 45 10	 movzx	 eax, WORD PTR _wHotKey$[ebp]
  0004d	c1 e8 08	 shr	 eax, 8
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	0f b6 c8	 movzx	 ecx, al
  00058	83 e1 02	 and	 ecx, 2
  0005b	74 0a		 je	 SHORT $LN4@RegisterHo
  0005d	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbModifiers$[ebp]
  00061	83 c8 02	 or	 eax, 2
  00064	88 45 ff	 mov	 BYTE PTR _cbModifiers$[ebp], al
$LN4@RegisterHo:

; 225  : 
; 226  : 	//注册热键
; 227  : 	BOOL bSuccess=::RegisterHotKey(hWnd,uKeyID,cbModifiers,LOBYTE(wHotKey));

  00067	0f b7 45 10	 movzx	 eax, WORD PTR _wHotKey$[ebp]
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	0f b6 c8	 movzx	 ecx, al
  00073	51		 push	 ecx
  00074	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbModifiers$[ebp]
  00078	52		 push	 edx
  00079	8b 45 0c	 mov	 eax, DWORD PTR _uKeyID$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00080	51		 push	 ecx
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterHotKey@16
  00087	89 45 f8	 mov	 DWORD PTR _bSuccess$[ebp], eax

; 228  : 
; 229  : 	return (bSuccess==TRUE)?true:false;

  0008a	83 7d f8 01	 cmp	 DWORD PTR _bSuccess$[ebp], 1
  0008e	75 06		 jne	 SHORT $LN6@RegisterHo
  00090	c6 45 b7 01	 mov	 BYTE PTR tv137[ebp], 1
  00094	eb 04		 jmp	 SHORT $LN7@RegisterHo
$LN6@RegisterHo:
  00096	c6 45 b7 00	 mov	 BYTE PTR tv137[ebp], 0
$LN7@RegisterHo:
  0009a	8a 45 b7	 mov	 al, BYTE PTR tv137[ebp]

; 230  : }

  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?RegisterHotKey@CWHService@@SA_NPAUHWND__@@IG@Z ENDP	; CWHService::RegisterHotKey
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?UnRegisterHotKey@CWHService@@SA_NPAUHWND__@@I@Z
_TEXT	SEGMENT
tv68 = -69						; size = 1
_bSuccess$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_uKeyID$ = 12						; size = 4
?UnRegisterHotKey@CWHService@@SA_NPAUHWND__@@I@Z PROC	; CWHService::UnRegisterHotKey, COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 211  : 	//注销热键
; 212  : 	BOOL bSuccess=::UnregisterHotKey(hWnd,uKeyID);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _uKeyID$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _hWnd$[ebp]
  00010	51		 push	 ecx
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterHotKey@8
  00017	89 45 fc	 mov	 DWORD PTR _bSuccess$[ebp], eax

; 213  : 
; 214  : 	return (bSuccess==TRUE)?true:false;

  0001a	83 7d fc 01	 cmp	 DWORD PTR _bSuccess$[ebp], 1
  0001e	75 06		 jne	 SHORT $LN3@UnRegister
  00020	c6 45 bb 01	 mov	 BYTE PTR tv68[ebp], 1
  00024	eb 04		 jmp	 SHORT $LN4@UnRegister
$LN3@UnRegister:
  00026	c6 45 bb 00	 mov	 BYTE PTR tv68[ebp], 0
$LN4@UnRegister:
  0002a	8a 45 bb	 mov	 al, BYTE PTR tv68[ebp]

; 215  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?UnRegisterHotKey@CWHService@@SA_NPAUHWND__@@I@Z ENDP	; CWHService::UnRegisterHotKey
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?GetMACAddress@CWHService@@SA_NQAD@Z
_TEXT	SEGMENT
$T2 = -840						; size = 4
_i$3 = -708						; size = 4
_Adapter$4 = -704					; size = 348
_LanaEnum$5 = -356					; size = 256
_Ncb$6 = -100						; size = 64
_pNetBiosProc$7 = -36					; size = 4
_hInstance$ = -32					; size = 4
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_szMACAddress$ = 8					; size = 4
?GetMACAddress@CWHService@@SA_NQAD@Z PROC		; CWHService::GetMACAddress, COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?GetMACAddress@CWHService@@SA_NQAD@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 c4 c8 fc ff
	ff		 add	 esp, -824		; fffffcc8H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 e4	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	53		 push	 ebx
  0002a	56		 push	 esi
  0002b	57		 push	 edi
  0002c	50		 push	 eax
  0002d	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 132  : 	//变量定义
; 133  : 	HINSTANCE hInstance=NULL;

  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hInstance$[ebp], 0

; 134  : 
; 135  : 	//执行逻辑
; 136  : 	__try

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
  00044	c7 85 b8 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR $T2[ebp], 1

; 137  : 	{
; 138  : 		//加载 DLL
; 139  : 		hInstance=LoadLibrary(TEXT("NetApi32.dll"));

  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JFJMPEGD@NetApi32?4dll@
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  00059	89 45 e0	 mov	 DWORD PTR _hInstance$[ebp], eax

; 140  : 		if (hInstance==NULL) __leave;

  0005c	83 7d e0 00	 cmp	 DWORD PTR _hInstance$[ebp], 0
  00060	75 05		 jne	 SHORT $LN6@GetMACAddr
  00062	e9 83 01 00 00	 jmp	 $LN5@GetMACAddr
$LN6@GetMACAddr:

; 141  : 
; 142  : 		//获取函数
; 143  : 		typedef BYTE __stdcall NetBiosProc(NCB * Ncb);
; 144  : 		NetBiosProc * pNetBiosProc=(NetBiosProc *)GetProcAddress(hInstance,"Netbios");

  00067	68 00 00 00 00	 push	 OFFSET ??_C@_07NLCOGFA@Netbios@
  0006c	8b 45 e0	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0006f	50		 push	 eax
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00076	89 45 dc	 mov	 DWORD PTR _pNetBiosProc$7[ebp], eax

; 145  : 		if (pNetBiosProc==NULL) __leave;

  00079	83 7d dc 00	 cmp	 DWORD PTR _pNetBiosProc$7[ebp], 0
  0007d	75 05		 jne	 SHORT $LN7@GetMACAddr
  0007f	e9 66 01 00 00	 jmp	 $LN5@GetMACAddr
$LN7@GetMACAddr:

; 146  : 
; 147  : 		//变量定义
; 148  : 		NCB Ncb;
; 149  : 		LANA_ENUM LanaEnum;
; 150  : 		ZeroMemory(&Ncb,sizeof(Ncb));

  00084	6a 40		 push	 64			; 00000040H
  00086	6a 00		 push	 0
  00088	8d 45 9c	 lea	 eax, DWORD PTR _Ncb$6[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memset
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 151  : 		ZeroMemory(&LanaEnum,sizeof(LanaEnum));

  00094	68 00 01 00 00	 push	 256			; 00000100H
  00099	6a 00		 push	 0
  0009b	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _LanaEnum$5[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _memset
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  : 
; 153  : 		//枚举网卡
; 154  : 		Ncb.ncb_command=NCBENUM;

  000aa	c6 45 9c 37	 mov	 BYTE PTR _Ncb$6[ebp], 55 ; 00000037H

; 155  : 		Ncb.ncb_length=sizeof(LanaEnum);

  000ae	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000b3	66 89 45 a4	 mov	 WORD PTR _Ncb$6[ebp+8], ax

; 156  : 		Ncb.ncb_buffer=(BYTE *)&LanaEnum;

  000b7	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _LanaEnum$5[ebp]
  000bd	89 45 a0	 mov	 DWORD PTR _Ncb$6[ebp+4], eax

; 157  : 		if ((pNetBiosProc(&Ncb)!=NRC_GOODRET)||(LanaEnum.length==0)) __leave;

  000c0	8d 45 9c	 lea	 eax, DWORD PTR _Ncb$6[ebp]
  000c3	50		 push	 eax
  000c4	ff 55 dc	 call	 DWORD PTR _pNetBiosProc$7[ebp]
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	85 c9		 test	 ecx, ecx
  000cc	75 0b		 jne	 SHORT $LN9@GetMACAddr
  000ce	0f b6 85 9c fe
	ff ff		 movzx	 eax, BYTE PTR _LanaEnum$5[ebp]
  000d5	85 c0		 test	 eax, eax
  000d7	75 05		 jne	 SHORT $LN8@GetMACAddr
$LN9@GetMACAddr:
  000d9	e9 0c 01 00 00	 jmp	 $LN5@GetMACAddr
$LN8@GetMACAddr:

; 158  : 
; 159  : 		//获取地址
; 160  : 		if (LanaEnum.length>0)

  000de	0f b6 85 9c fe
	ff ff		 movzx	 eax, BYTE PTR _LanaEnum$5[ebp]
  000e5	85 c0		 test	 eax, eax
  000e7	0f 8e fd 00 00
	00		 jle	 $LN5@GetMACAddr

; 161  : 		{
; 162  : 			//变量定义
; 163  : 			tagAstatInfo Adapter;
; 164  : 			ZeroMemory(&Adapter,sizeof(Adapter));

  000ed	68 5c 01 00 00	 push	 348			; 0000015cH
  000f2	6a 00		 push	 0
  000f4	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _Adapter$4[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 _memset
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 165  : 
; 166  : 			//重置网卡
; 167  : 			Ncb.ncb_command=NCBRESET;

  00103	c6 45 9c 32	 mov	 BYTE PTR _Ncb$6[ebp], 50 ; 00000032H

; 168  : 			Ncb.ncb_lana_num=LanaEnum.lana[0];

  00107	b8 01 00 00 00	 mov	 eax, 1
  0010c	6b c8 00	 imul	 ecx, eax, 0
  0010f	8a 94 0d 9d fe
	ff ff		 mov	 dl, BYTE PTR _LanaEnum$5[ebp+ecx+1]
  00116	88 55 cc	 mov	 BYTE PTR _Ncb$6[ebp+48], dl

; 169  : 			if (pNetBiosProc(&Ncb)!=NRC_GOODRET) __leave;

  00119	8d 45 9c	 lea	 eax, DWORD PTR _Ncb$6[ebp]
  0011c	50		 push	 eax
  0011d	ff 55 dc	 call	 DWORD PTR _pNetBiosProc$7[ebp]
  00120	0f b6 c8	 movzx	 ecx, al
  00123	85 c9		 test	 ecx, ecx
  00125	74 05		 je	 SHORT $LN11@GetMACAddr
  00127	e9 be 00 00 00	 jmp	 $LN5@GetMACAddr
$LN11@GetMACAddr:

; 170  : 
; 171  : 			//获取状态
; 172  : 			Ncb.ncb_command=NCBASTAT;

  0012c	c6 45 9c 33	 mov	 BYTE PTR _Ncb$6[ebp], 51 ; 00000033H

; 173  : 			Ncb.ncb_length=sizeof(Adapter);

  00130	b8 5c 01 00 00	 mov	 eax, 348		; 0000015cH
  00135	66 89 45 a4	 mov	 WORD PTR _Ncb$6[ebp+8], ax

; 174  : 			Ncb.ncb_buffer=(BYTE *)&Adapter;

  00139	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _Adapter$4[ebp]
  0013f	89 45 a0	 mov	 DWORD PTR _Ncb$6[ebp+4], eax

; 175  : 			Ncb.ncb_lana_num=LanaEnum.lana[0];

  00142	b8 01 00 00 00	 mov	 eax, 1
  00147	6b c8 00	 imul	 ecx, eax, 0
  0014a	8a 94 0d 9d fe
	ff ff		 mov	 dl, BYTE PTR _LanaEnum$5[ebp+ecx+1]
  00151	88 55 cc	 mov	 BYTE PTR _Ncb$6[ebp+48], dl

; 176  : 			strcpy((char *)Ncb.ncb_callname,"*");

  00154	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK@
  00159	8d 45 a6	 lea	 eax, DWORD PTR _Ncb$6[ebp+10]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _strcpy
  00162	83 c4 08	 add	 esp, 8

; 177  : 			if (pNetBiosProc(&Ncb)!=NRC_GOODRET) __leave;

  00165	8d 45 9c	 lea	 eax, DWORD PTR _Ncb$6[ebp]
  00168	50		 push	 eax
  00169	ff 55 dc	 call	 DWORD PTR _pNetBiosProc$7[ebp]
  0016c	0f b6 c8	 movzx	 ecx, al
  0016f	85 c9		 test	 ecx, ecx
  00171	74 02		 je	 SHORT $LN12@GetMACAddr
  00173	eb 75		 jmp	 SHORT $LN5@GetMACAddr
$LN12@GetMACAddr:

; 178  : 
; 179  : 			//获取地址
; 180  : 			for (INT i=0;i<6;i++)

  00175	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$3[ebp], 0
  0017f	eb 0f		 jmp	 SHORT $LN4@GetMACAddr
$LN2@GetMACAddr:
  00181	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  00187	83 c0 01	 add	 eax, 1
  0018a	89 85 3c fd ff
	ff		 mov	 DWORD PTR _i$3[ebp], eax
$LN4@GetMACAddr:
  00190	83 bd 3c fd ff
	ff 06		 cmp	 DWORD PTR _i$3[ebp], 6
  00197	7d 51		 jge	 SHORT $LN5@GetMACAddr

; 181  : 			{
; 182  : 				ASSERT((i*2)<LEN_NETWORK_ID);

  00199	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  0019f	d1 e0		 shl	 eax, 1
  001a1	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  001a4	7c 19		 jl	 SHORT $LN16@GetMACAddr
  001a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??GetMACAddress@CWHService@@SA_NQAD@Z@4JA
  001ac	83 c1 33	 add	 ecx, 51			; 00000033H
  001af	51		 push	 ecx
  001b0	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001b5	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001ba	85 c0		 test	 eax, eax
  001bc	74 01		 je	 SHORT $LN16@GetMACAddr
  001be	cc		 int	 3
$LN16@GetMACAddr:

; 183  : 				_stprintf(&szMACAddress[i*2],TEXT("%02X"),Adapter.AdapterStatus.adapter_address[i]);

  001bf	8b 85 3c fd ff
	ff		 mov	 eax, DWORD PTR _i$3[ebp]
  001c5	0f b6 8c 05 40
	fd ff ff	 movzx	 ecx, BYTE PTR _Adapter$4[ebp+eax]
  001cd	51		 push	 ecx
  001ce	68 00 00 00 00	 push	 OFFSET ??_C@_04JFFKLGJF@?$CF02X@
  001d3	8b 95 3c fd ff
	ff		 mov	 edx, DWORD PTR _i$3[ebp]
  001d9	8b 45 08	 mov	 eax, DWORD PTR _szMACAddress$[ebp]
  001dc	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  001df	51		 push	 ecx
  001e0	e8 00 00 00 00	 call	 _sprintf
  001e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 184  : 			}

  001e8	eb 97		 jmp	 SHORT $LN2@GetMACAddr
$LN5@GetMACAddr:

; 185  : 		}
; 186  : 	}

  001ea	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  001f1	c7 85 b8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  001fb	e8 02 00 00 00	 call	 $LN21@GetMACAddr
  00200	eb 3e		 jmp	 SHORT $LN22@GetMACAddr
$LN19@GetMACAddr:
$LN24@GetMACAddr:
$LN21@GetMACAddr:

; 187  : 
; 188  : 	//结束清理
; 189  : 	__finally
; 190  : 	{
; 191  : 		//释放资源
; 192  : 		if (hInstance!=NULL)

  00202	83 7d e0 00	 cmp	 DWORD PTR _hInstance$[ebp], 0
  00206	74 11		 je	 SHORT $LN13@GetMACAddr

; 193  : 		{
; 194  : 			FreeLibrary(hInstance);

  00208	8b 45 e0	 mov	 eax, DWORD PTR _hInstance$[ebp]
  0020b	50		 push	 eax
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4

; 195  : 			hInstance=NULL;

  00212	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hInstance$[ebp], 0
$LN13@GetMACAddr:

; 196  : 		}
; 197  : 
; 198  : 		//错误断言
; 199  : 		if (AbnormalTermination()==TRUE)

  00219	83 bd b8 fc ff
	ff 01		 cmp	 DWORD PTR $T2[ebp], 1
  00220	75 1d		 jne	 SHORT $LN20@GetMACAddr

; 200  : 		{
; 201  : 			ASSERT(FALSE);

  00222	33 c0		 xor	 eax, eax
  00224	75 19		 jne	 SHORT $LN20@GetMACAddr
  00226	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??GetMACAddress@CWHService@@SA_NQAD@Z@4JA
  0022c	83 c1 46	 add	 ecx, 70			; 00000046H
  0022f	51		 push	 ecx
  00230	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00235	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0023a	85 c0		 test	 eax, eax
  0023c	74 01		 je	 SHORT $LN20@GetMACAddr
  0023e	cc		 int	 3
$LN20@GetMACAddr:
$LN23@GetMACAddr:
  0023f	c3		 ret	 0
$LN22@GetMACAddr:

; 202  : 		}
; 203  : 	}
; 204  : 
; 205  : 	return true;

  00240	b0 01		 mov	 al, 1

; 206  : }

  00242	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00245	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0024c	59		 pop	 ecx
  0024d	5f		 pop	 edi
  0024e	5e		 pop	 esi
  0024f	5b		 pop	 ebx
  00250	8b 4d e4	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00253	33 cd		 xor	 ecx, ebp
  00255	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025a	8b e5		 mov	 esp, ebp
  0025c	5d		 pop	 ebp
  0025d	c3		 ret	 0
?GetMACAddress@CWHService@@SA_NQAD@Z ENDP		; CWHService::GetMACAddress
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?GetMachineIDEx@CWHService@@SA_NQAD@Z
_TEXT	SEGMENT
_i$1 = -48						; size = 2
_pszHardDisk$ = -44					; size = 12
_wIndex$ = -32						; size = 2
_pbuf$ = -28						; size = 4
_wMacSize$ = -24					; size = 2
_szMACAddress$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_szMachineID$ = 8					; size = 4
?GetMachineIDEx@CWHService@@SA_NQAD@Z PROC		; CWHService::GetMachineIDEx, COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 106  : 	//变量定义
; 107  : 	TCHAR szMACAddress[LEN_NETWORK_ID]=TEXT("");

  00013	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  00018	88 45 ec	 mov	 BYTE PTR _szMACAddress$[ebp], al
  0001b	33 c0		 xor	 eax, eax
  0001d	89 45 ed	 mov	 DWORD PTR _szMACAddress$[ebp+1], eax
  00020	89 45 f1	 mov	 DWORD PTR _szMACAddress$[ebp+5], eax
  00023	89 45 f5	 mov	 DWORD PTR _szMACAddress$[ebp+9], eax

; 108  : 
; 109  : 	//网卡标识
; 110  : 	WORD wMacSize=GetMACAddress(szMACAddress);

  00026	8d 45 ec	 lea	 eax, DWORD PTR _szMACAddress$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?GetMACAddress@CWHService@@SA_NQAD@Z ; CWHService::GetMACAddress
  0002f	83 c4 04	 add	 esp, 4
  00032	66 0f b6 c8	 movzx	 cx, al
  00036	66 89 4d e8	 mov	 WORD PTR _wMacSize$[ebp], cx

; 111  : 
; 112  : 	//硬盘标识
; 113  : 	DWORD *pbuf=(DWORD*)szMACAddress;

  0003a	8d 45 ec	 lea	 eax, DWORD PTR _szMACAddress$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR _pbuf$[ebp], eax

; 114  : 	WORD wIndex=(wMacSize+sizeof(DWORD)-1)/sizeof(DWORD);

  00040	0f b7 45 e8	 movzx	 eax, WORD PTR _wMacSize$[ebp]
  00044	83 c0 03	 add	 eax, 3
  00047	c1 e8 02	 shr	 eax, 2
  0004a	66 89 45 e0	 mov	 WORD PTR _wIndex$[ebp], ax

; 115  : 	LPCTSTR pszHardDisk[]={TEXT("C:\\"),TEXT("D:\\"),TEXT("E:\\")};

  0004e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _pszHardDisk$[ebp], OFFSET ??_C@_03GIOIKFCO@C?3?2@
  00055	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pszHardDisk$[ebp+4], OFFSET ??_C@_03PFDPJNJH@D?3?2@
  0005c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pszHardDisk$[ebp+8], OFFSET ??_C@_03ENIDPKPC@E?3?2@

; 116  : 	for (WORD i=wIndex;i<CountArray(pszHardDisk);i++)

  00063	66 8b 45 e0	 mov	 ax, WORD PTR _wIndex$[ebp]
  00067	66 89 45 d0	 mov	 WORD PTR _i$1[ebp], ax
  0006b	eb 0c		 jmp	 SHORT $LN4@GetMachine
$LN2@GetMachine:
  0006d	66 8b 45 d0	 mov	 ax, WORD PTR _i$1[ebp]
  00071	66 83 c0 01	 add	 ax, 1
  00075	66 89 45 d0	 mov	 WORD PTR _i$1[ebp], ax
$LN4@GetMachine:
  00079	0f b7 45 d0	 movzx	 eax, WORD PTR _i$1[ebp]
  0007d	83 f8 03	 cmp	 eax, 3
  00080	73 56		 jae	 SHORT $LN3@GetMachine

; 117  : 	{
; 118  : 		ASSERT(CountArray(pszHardDisk)>(i-wIndex));

  00082	0f b7 45 d0	 movzx	 eax, WORD PTR _i$1[ebp]
  00086	0f b7 4d e0	 movzx	 ecx, WORD PTR _wIndex$[ebp]
  0008a	2b c1		 sub	 eax, ecx
  0008c	83 f8 03	 cmp	 eax, 3
  0008f	72 19		 jb	 SHORT $LN6@GetMachine
  00091	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??GetMachineIDEx@CWHService@@SA_NQAD@Z@4JA
  00097	83 c2 0d	 add	 edx, 13			; 0000000dH
  0009a	52		 push	 edx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000a0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000a5	85 c0		 test	 eax, eax
  000a7	74 01		 je	 SHORT $LN6@GetMachine
  000a9	cc		 int	 3
$LN6@GetMachine:

; 119  : 		GetVolumeInformation(pszHardDisk[i-wIndex],NULL,0,pbuf+i,NULL,NULL,0,NULL);

  000aa	6a 00		 push	 0
  000ac	6a 00		 push	 0
  000ae	6a 00		 push	 0
  000b0	6a 00		 push	 0
  000b2	0f b7 45 d0	 movzx	 eax, WORD PTR _i$1[ebp]
  000b6	8b 4d e4	 mov	 ecx, DWORD PTR _pbuf$[ebp]
  000b9	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000bc	52		 push	 edx
  000bd	6a 00		 push	 0
  000bf	6a 00		 push	 0
  000c1	0f b7 45 d0	 movzx	 eax, WORD PTR _i$1[ebp]
  000c5	0f b7 4d e0	 movzx	 ecx, WORD PTR _wIndex$[ebp]
  000c9	2b c1		 sub	 eax, ecx
  000cb	8b 54 85 d4	 mov	 edx, DWORD PTR _pszHardDisk$[ebp+eax*4]
  000cf	52		 push	 edx
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVolumeInformationA@32

; 120  : 	}

  000d6	eb 95		 jmp	 SHORT $LN2@GetMachine
$LN3@GetMachine:

; 121  : 
; 122  : 	//转换信息
; 123  : 	ASSERT(LEN_MACHINE_ID>=LEN_MD5);
; 124  : 	CWHEncrypt::MD5Encrypt(szMACAddress,szMachineID);

  000d8	8b 45 08	 mov	 eax, DWORD PTR _szMachineID$[ebp]
  000db	50		 push	 eax
  000dc	8d 4d ec	 lea	 ecx, DWORD PTR _szMACAddress$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ?MD5Encrypt@CWHEncrypt@@SA_NPBDQAD@Z ; CWHEncrypt::MD5Encrypt
  000e5	83 c4 08	 add	 esp, 8

; 125  : 
; 126  : 	return true;

  000e8	b0 01		 mov	 al, 1

; 127  : }

  000ea	5f		 pop	 edi
  000eb	5e		 pop	 esi
  000ec	5b		 pop	 ebx
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f0	33 cd		 xor	 ecx, ebp
  000f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
?GetMachineIDEx@CWHService@@SA_NQAD@Z ENDP		; CWHService::GetMachineIDEx
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?GetMachineID@CWHService@@SA_NQAD@Z
_TEXT	SEGMENT
_szMACAddress$ = -20					; size = 13
__$ArrayPad$ = -4					; size = 4
_szMachineID$ = 8					; size = 4
?GetMachineID@CWHService@@SA_NQAD@Z PROC		; CWHService::GetMachineID, COMDAT

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi

; 90   : 	//变量定义
; 91   : 	TCHAR szMACAddress[LEN_NETWORK_ID]=TEXT("");

  00013	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  00018	88 45 ec	 mov	 BYTE PTR _szMACAddress$[ebp], al
  0001b	33 c0		 xor	 eax, eax
  0001d	89 45 ed	 mov	 DWORD PTR _szMACAddress$[ebp+1], eax
  00020	89 45 f1	 mov	 DWORD PTR _szMACAddress$[ebp+5], eax
  00023	89 45 f5	 mov	 DWORD PTR _szMACAddress$[ebp+9], eax

; 92   : 
; 93   : 	//网卡标识
; 94   : 	GetMACAddress(szMACAddress);

  00026	8d 45 ec	 lea	 eax, DWORD PTR _szMACAddress$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?GetMACAddress@CWHService@@SA_NQAD@Z ; CWHService::GetMACAddress
  0002f	83 c4 04	 add	 esp, 4

; 95   : 
; 96   : 	//转换信息
; 97   : 	ASSERT(LEN_MACHINE_ID>=LEN_MD5);
; 98   : 	CWHEncrypt::MD5Encrypt(szMACAddress,szMachineID);

  00032	8b 45 08	 mov	 eax, DWORD PTR _szMachineID$[ebp]
  00035	50		 push	 eax
  00036	8d 4d ec	 lea	 ecx, DWORD PTR _szMACAddress$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?MD5Encrypt@CWHEncrypt@@SA_NPBDQAD@Z ; CWHEncrypt::MD5Encrypt
  0003f	83 c4 08	 add	 esp, 8

; 99   : 
; 100  : 	return true;

  00042	b0 01		 mov	 al, 1

; 101  : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GetMachineID@CWHService@@SA_NQAD@Z ENDP		; CWHService::GetMachineID
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?SetClipboardString@CWHService@@SA_NPBD@Z
_TEXT	SEGMENT
$T2 = -104						; size = 4
_hData$3 = -36						; size = 4
_bOpenClopboard$ = -32					; size = 4
_hData$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_pszString$ = 8						; size = 4
?SetClipboardString@CWHService@@SA_NPBD@Z PROC		; CWHService::SetClipboardString, COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?SetClipboardString@CWHService@@SA_NPBD@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 c4 a8	 add	 esp, -88		; ffffffa8H
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 38   : 	//变量定义
; 39   : 	HANDLE hData=NULL;

  00030	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hData$[ebp], 0

; 40   : 	BOOL bOpenClopboard=FALSE;

  00037	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _bOpenClopboard$[ebp], 0

; 41   : 
; 42   : 	//执行逻辑
; 43   : 	__try

  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0
  00045	c7 45 98 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1

; 44   : 	{
; 45   : 		//打开拷贝
; 46   : 		bOpenClopboard=OpenClipboard(AfxGetMainWnd()->m_hWnd);

  0004c	e8 00 00 00 00	 call	 ?AfxGetMainWnd@@YGPAVCWnd@@XZ ; AfxGetMainWnd
  00051	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  0005b	89 45 e0	 mov	 DWORD PTR _bOpenClopboard$[ebp], eax

; 47   : 		if (bOpenClopboard==FALSE) __leave;

  0005e	83 7d e0 00	 cmp	 DWORD PTR _bOpenClopboard$[ebp], 0
  00062	75 02		 jne	 SHORT $LN3@SetClipboa
  00064	eb 58		 jmp	 SHORT $LN2@SetClipboa
$LN3@SetClipboa:

; 48   : 
; 49   : 		//清空拷贝
; 50   : 		if (EmptyClipboard()==FALSE) __leave;

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EmptyClipboard@0
  0006c	85 c0		 test	 eax, eax
  0006e	75 02		 jne	 SHORT $LN4@SetClipboa
  00070	eb 4c		 jmp	 SHORT $LN2@SetClipboa
$LN4@SetClipboa:

; 51   : 
; 52   : 		//申请内存
; 53   : 		HANDLE hData=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,CountStringBuffer(pszString));

  00072	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00075	50		 push	 eax
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0007c	83 c0 01	 add	 eax, 1
  0007f	50		 push	 eax
  00080	6a 42		 push	 66			; 00000042H
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  00088	89 45 dc	 mov	 DWORD PTR _hData$3[ebp], eax

; 54   : 		if (hData==NULL) __leave;

  0008b	83 7d dc 00	 cmp	 DWORD PTR _hData$3[ebp], 0
  0008f	75 02		 jne	 SHORT $LN5@SetClipboa
  00091	eb 2b		 jmp	 SHORT $LN2@SetClipboa
$LN5@SetClipboa:

; 55   : 
; 56   : 		//复制数据
; 57   : 		lstrcpy((LPTSTR)GlobalLock(hData),pszString);

  00093	8b 45 08	 mov	 eax, DWORD PTR _pszString$[ebp]
  00096	50		 push	 eax
  00097	8b 4d dc	 mov	 ecx, DWORD PTR _hData$3[ebp]
  0009a	51		 push	 ecx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  000a1	50		 push	 eax
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcpyA@8

; 58   : 		GlobalUnlock(hData);

  000a8	8b 45 dc	 mov	 eax, DWORD PTR _hData$3[ebp]
  000ab	50		 push	 eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 59   : 
; 60   : 		//设置数据
; 61   : 		#ifndef _UNICODE
; 62   : 			::SetClipboardData(CF_TEXT,hData);

  000b2	8b 45 dc	 mov	 eax, DWORD PTR _hData$3[ebp]
  000b5	50		 push	 eax
  000b6	6a 01		 push	 1
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetClipboardData@8
$LN2@SetClipboa:

; 63   : 		#else
; 64   : 			::SetClipboardData(CF_UNICODETEXT,hData);
; 65   : 		#endif
; 66   : 	}

  000be	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  000c5	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000cc	e8 02 00 00 00	 call	 $LN14@SetClipboa
  000d1	eb 40		 jmp	 SHORT $LN15@SetClipboa
$LN12@SetClipboa:
$LN17@SetClipboa:
$LN14@SetClipboa:

; 67   : 
; 68   : 	//终止程序
; 69   : 	__finally
; 70   : 	{
; 71   : 		//释放内存
; 72   : 		if (hData!=NULL) GlobalUnlock(hData);

  000d3	83 7d e4 00	 cmp	 DWORD PTR _hData$[ebp], 0
  000d7	74 0a		 je	 SHORT $LN6@SetClipboa
  000d9	8b 45 e4	 mov	 eax, DWORD PTR _hData$[ebp]
  000dc	50		 push	 eax
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
$LN6@SetClipboa:

; 73   : 
; 74   : 		//关闭拷贝
; 75   : 		if (bOpenClopboard==TRUE) CloseClipboard();

  000e3	83 7d e0 01	 cmp	 DWORD PTR _bOpenClopboard$[ebp], 1
  000e7	75 06		 jne	 SHORT $LN7@SetClipboa
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
$LN7@SetClipboa:

; 76   : 
; 77   : 		//错误判断
; 78   : 		if (AbnormalTermination()==TRUE)

  000ef	83 7d 98 01	 cmp	 DWORD PTR $T2[ebp], 1
  000f3	75 1d		 jne	 SHORT $LN13@SetClipboa

; 79   : 		{
; 80   : 			ASSERT(FALSE);

  000f5	33 c0		 xor	 eax, eax
  000f7	75 19		 jne	 SHORT $LN13@SetClipboa
  000f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?0??SetClipboardString@CWHService@@SA_NPBD@Z@4JA
  000ff	83 c1 2b	 add	 ecx, 43			; 0000002bH
  00102	51		 push	 ecx
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@HAOGAJLP@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00108	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0010d	85 c0		 test	 eax, eax
  0010f	74 01		 je	 SHORT $LN13@SetClipboa
  00111	cc		 int	 3
$LN13@SetClipboa:
$LN16@SetClipboa:
  00112	c3		 ret	 0
$LN15@SetClipboa:

; 81   : 		}
; 82   : 	}
; 83   : 
; 84   : 	return true;

  00113	b0 01		 mov	 al, 1

; 85   : }

  00115	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	5f		 pop	 edi
  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	8b e5		 mov	 esp, ebp
  00125	5d		 pop	 ebp
  00126	c3		 ret	 0
?SetClipboardString@CWHService@@SA_NPBD@Z ENDP		; CWHService::SetClipboardString
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ??0CWHService@@AAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CWHService@@AAE@XZ PROC				; CWHService::CWHService, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : }

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0CWHService@@AAE@XZ ENDP				; CWHService::CWHService
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_bResult$ = -36						; size = 4
_bQuit$ = -32						; size = 4
_msg$ = -28						; size = 28
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00009	6a 01		 push	 1
  0000b	6a 12		 push	 18			; 00000012H
  0000d	6a 12		 push	 18			; 00000012H
  0000f	6a 00		 push	 0
  00011	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0001b	89 45 e0	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	8b 45 0c	 mov	 eax, DWORD PTR _nLine$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpszFileName$[ebp]
  00029	51		 push	 ecx
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00032	83 c4 14	 add	 esp, 20			; 00000014H
  00035	89 45 dc	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00038	83 7d e0 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  0003c	74 0a		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00048	8b 45 dc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00009	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 0c	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 __vsprintf_l
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1459 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00009	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a ff		 push	 -1
  00017	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 __vsnprintf_l
  00020	83 c4 14	 add	 esp, 20			; 00000014H

; 1463 :         #pragma warning(pop)
; 1464 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	83 ca 01	 or	 edx, 1
  00027	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002a	50		 push	 eax
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH
  00035	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00038	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003c	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003e	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00045	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00047	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004d	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whservice.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv66[ebp], eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  00012	83 e9 01	 sub	 ecx, 1
  00015	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00018	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001c	76 11		 jbe	 SHORT $LN1@vector
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00021	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00027	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  0002a	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  0002d	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
