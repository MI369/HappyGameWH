; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\公共组件\服务核心\WHMD5CheckSum.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	___local_stdio_printf_options
PUBLIC	__vswprintf_s_l
PUBLIC	_swprintf_s
PUBLIC	__vsnprintf_s_l
PUBLIC	__vsnprintf_s
PUBLIC	__vscprintf_l
PUBLIC	__vscprintf
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??B?$CTraceCategoryEx@$00$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<1,0>::operator unsigned int
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z		; ATL::CTrace::TraceV
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPBDI@Z		; ATL::CTrace::RegisterCategory
PUBLIC	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::~CHeapPtr<char,ATL::CCRTAllocator>
PUBLIC	??0CPreserveLastError@ATL@@QAE@XZ		; ATL::CPreserveLastError::CPreserveLastError
PUBLIC	??1CPreserveLastError@ATL@@QAE@XZ		; ATL::CPreserveLastError::~CPreserveLastError
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ		; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??0CWHMD5Checksum@@IAE@XZ			; CWHMD5Checksum::CWHMD5Checksum
PUBLIC	??1CWHMD5Checksum@@MAE@XZ			; CWHMD5Checksum::~CWHMD5Checksum
PUBLIC	?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z ; CWHMD5Checksum::GetMD5
PUBLIC	?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z ; CWHMD5Checksum::GetMD5
PUBLIC	?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z ; CWHMD5Checksum::GetMD5
PUBLIC	?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CWHMD5Checksum::Final
PUBLIC	?Transform@CWHMD5Checksum@@IAEXQAE@Z		; CWHMD5Checksum::Transform
PUBLIC	?Update@CWHMD5Checksum@@IAEXPAEK@Z		; CWHMD5Checksum::Update
PUBLIC	?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z	; CWHMD5Checksum::ULongToUInt8
PUBLIC	?ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z	; CWHMD5Checksum::ByteToDWord
PUBLIC	?RotateLeft@CWHMD5Checksum@@IAEKKH@Z		; CWHMD5Checksum::RotateLeft
PUBLIC	?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z		; CWHMD5Checksum::FF
PUBLIC	?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z		; CWHMD5Checksum::GG
PUBLIC	?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z		; CWHMD5Checksum::HH
PUBLIC	?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z		; CWHMD5Checksum::II
PUBLIC	??0CWHMD5Checksum@@QAE@ABV0@@Z			; CWHMD5Checksum::CWHMD5Checksum
PUBLIC	??4CWHMD5Checksum@@QAEAAV0@ABV0@@Z		; CWHMD5Checksum::operator=
PUBLIC	??_GCWHMD5Checksum@@MAEPAXI@Z			; CWHMD5Checksum::`scalar deleting destructor'
PUBLIC	??_ECWHMD5Checksum@@MAEPAXI@Z			; CWHMD5Checksum::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@		; `string'
PUBLIC	??_C@_1OE@IAPLKPHI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	??_C@_0BA@MKMIKKJB@atlTraceGeneral@		; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException@		; `string'
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	??_C@_0P@MBNHGHMI@atlTraceString@		; `string'
PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5@ ; `string'
PUBLIC	??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs@ ; `string'
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ ; `string'
PUBLIC	??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_R0PAVCException@@@8				; CException * `RTTI Type Descriptor'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_03CGPANDLG@?$CFTs@			; `string'
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
PUBLIC	??_7CWHMD5Checksum@@6B@				; CWHMD5Checksum::`vftable'
PUBLIC	?__LINE__Var@?0??GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z@4JA ; `CWHMD5Checksum::GetMD5'::`1'::__LINE__Var
PUBLIC	??_R0PAVCFileException@@@8			; CFileException * `RTTI Type Descriptor'
PUBLIC	??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	??_C@_0CO@LNOLBCMM@CWHMD5Checksum?3?3GetMD5?3?5CFileEx@ ; `string'
PUBLIC	__TI4PAVCFileException@@
PUBLIC	__CTA4PAVCFileException@@
PUBLIC	__CT??_R0PAVCFileException@@@84
PUBLIC	__CT??_R0PAVCException@@@84
PUBLIC	??_R0PAVCObject@@@8				; CObject * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVCObject@@@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	?__LINE__Var@?0??Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ@4JA ; `CWHMD5Checksum::Final'::`1'::__LINE__Var
PUBLIC	??_C@_02PLJDPFIO@00@				; `string'
PUBLIC	??_C@_03PHPAKPLH@0?$CFx@			; `string'
PUBLIC	??_C@_02NJNOFBBI@?$CFx@				; `string'
PUBLIC	?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA ; `CWHMD5Checksum::ByteToDWord'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA ; `CWHMD5Checksum::ULongToUInt8'::`1'::__LINE__Var
PUBLIC	??_R4CWHMD5Checksum@@6B@			; CWHMD5Checksum::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCWHMD5Checksum@@@8			; CWHMD5Checksum `RTTI Type Descriptor'
PUBLIC	??_R3CWHMD5Checksum@@8				; CWHMD5Checksum::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWHMD5Checksum@@8				; CWHMD5Checksum::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWHMD5Checksum@@8			; CWHMD5Checksum::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcscpy_s:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp____stdio_common_vswprintf_s:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsnprintf_s:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:PROC
EXTRN	__imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	??0CFile@@QAE@XZ:PROC				; CFile::CFile
EXTRN	?Open@CFile@@UAEHPBDIPAVCFileException@@@Z:PROC	; CFile::Open
EXTRN	??1CFile@@UAE@XZ:PROC				; CFile::~CFile
EXTRN	?AfxIsValidAddress@@YGHPBXIH@Z:PROC		; AfxIsValidAddress
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceGeneral$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceGeneral@ATL@@YAXXZ ; ATL::atlTraceGeneral$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CWHMD5Checksum@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWHMD5Checksum@@8 DD FLAT:??_R0?AVCWHMD5Checksum@@@8 ; CWHMD5Checksum::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWHMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ??_R2CWHMD5Checksum@@8
rdata$r	SEGMENT
??_R2CWHMD5Checksum@@8 DD FLAT:??_R1A@?0A@EA@CWHMD5Checksum@@8 ; CWHMD5Checksum::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWHMD5Checksum@@8
rdata$r	SEGMENT
??_R3CWHMD5Checksum@@8 DD 00H				; CWHMD5Checksum::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWHMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWHMD5Checksum@@@8
data$r	SEGMENT
??_R0?AVCWHMD5Checksum@@@8 DD FLAT:??_7type_info@@6B@	; CWHMD5Checksum `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWHMD5Checksum@@', 00H
data$r	ENDS
;	COMDAT ??_R4CWHMD5Checksum@@6B@
rdata$r	SEGMENT
??_R4CWHMD5Checksum@@6B@ DD 00H				; CWHMD5Checksum::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCWHMD5Checksum@@@8
	DD	FLAT:??_R3CWHMD5Checksum@@8
rdata$r	ENDS
;	COMDAT ?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA DD 011cH ; `CWHMD5Checksum::ULongToUInt8'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA DD 0104H ; `CWHMD5Checksum::ByteToDWord'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx@ DB '%x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PHPAKPLH@0?$CFx@
CONST	SEGMENT
??_C@_03PHPAKPLH@0?$CFx@ DB '0%x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PLJDPFIO@00@
CONST	SEGMENT
??_C@_02PLJDPFIO@00@ DB '00', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ@4JA DD 052H ; `CWHMD5Checksum::Final'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAVCObject@@@84
xdata$x	SEGMENT
__CT??_R0PAVCObject@@@84 DD 01H
	DD	FLAT:??_R0PAVCObject@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVCObject@@@8
data$r	SEGMENT
??_R0PAVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCObject@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAVCException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCException@@@84 DD 01H
	DD	FLAT:??_R0PAVCException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CT??_R0PAVCFileException@@@84
xdata$x	SEGMENT
__CT??_R0PAVCFileException@@@84 DD 01H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA4PAVCFileException@@
xdata$x	SEGMENT
__CTA4PAVCFileException@@ DD 04H
	DD	FLAT:__CT??_R0PAVCFileException@@@84
	DD	FLAT:__CT??_R0PAVCException@@@84
	DD	FLAT:__CT??_R0PAVCObject@@@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI4PAVCFileException@@
xdata$x	SEGMENT
__TI4PAVCFileException@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA4PAVCFileException@@
xdata$x	ENDS
;	COMDAT ??_C@_0CO@LNOLBCMM@CWHMD5Checksum?3?3GetMD5?3?5CFileEx@
CONST	SEGMENT
??_C@_0CO@LNOLBCMM@CWHMD5Checksum?3?3GetMD5?3?5CFileEx@ DB 'CWHMD5Checksu'
	DB	'm::GetMD5: CFileException caught', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0b9H, 0abH, 0b9H, 0b2H, 0d7H, 0e9H, 0bcH, 0feH, '\', 0b7H
	DB	0feH, 0ceH, 0f1H, 0baH, 0cbH, 0d0H, 0c4H, '\whmd5checksum.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0PAVCFileException@@@8
data$r	SEGMENT
??_R0PAVCFileException@@@8 DD FLAT:??_7type_info@@6B@	; CFileException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCFileException@@', 00H
data$r	ENDS
;	COMDAT ?__LINE__Var@?0??GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z@4JA DD 028H ; `CWHMD5Checksum::GetMD5'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7CWHMD5Checksum@@6B@
CONST	SEGMENT
??_7CWHMD5Checksum@@6B@ DD FLAT:??_R4CWHMD5Checksum@@6B@ ; CWHMD5Checksum::`vftable'
	DD	FLAT:??_ECWHMD5Checksum@@MAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?PADDING@@3PAEA DB 080H					; PADDING
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGPANDLG@?$CFTs@
CONST	SEGMENT
??_C@_03CGPANDLG@?$CFTs@ DB '%Ts', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_R0PAVCException@@@8
data$r	SEGMENT
??_R0PAVCException@@@8 DD FLAT:??_7type_info@@6B@	; CException * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVCException@@', 00H
data$r	ENDS
;	COMDAT ??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm'
	DB	00H, 'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't'
	DB	00H, 'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@ DB '%', 00H, 'h', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs@
CONST	SEGMENT
??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs@ DB '%', 00H, 'l', 00H
	DB	's', 00H, '%', 00H, 'l', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5@ DB '%', 00H, 'u', 00H, ' '
	DB	00H, '-', 00H, ' ', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5@
CONST	SEGMENT
??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5@ DB '%', 00H, 'l', 00H
	DB	's', 00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
;	COMDAT ??_C@_0P@MBNHGHMI@atlTraceString@
CONST	SEGMENT
??_C@_0P@MBNHGHMI@atlTraceString@ DB 'atlTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MKMIKKJB@atlTraceGeneral@
CONST	SEGMENT
??_C@_0BA@MKMIKKJB@atlTraceGeneral@ DB 'atlTraceGeneral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OE@IAPLKPHI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1OE@IAPLKPHI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm'
	DB	00H, 'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't'
	DB	00H, 'l', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@ DB '%', 00H, 'l', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_ECWHMD5Checksum@@MAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$2
__ehfuncinfo$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z$0
__ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$4 DD 00H
	DD	FLAT:??_R0PAVCFileException@@@8
	DD	0fffffb84H
	DD	FLAT:__catch$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$0
__tryblocktable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$4
__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z$0
__ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ$0
__ehfuncinfo$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z$1
__ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceString$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceString@ATL@@YAXXZ ; ATL::atlTraceString$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_ECWHMD5Checksum@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_ECWHMD5Checksum@@MAEPAXI@Z PROC			; CWHMD5Checksum::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_ECWHMD5Checksum@@MAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 02	 and	 eax, 2
  00031	74 41		 je	 SHORT $LN2@vector
  00033	68 00 00 00 00	 push	 OFFSET ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0003e	51		 push	 ecx
  0003f	6a 5c		 push	 92			; 0000005cH
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	52		 push	 edx
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 1a		 je	 SHORT $LN3@vector
  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	6b 48 fc 5c	 imul	 ecx, DWORD PTR [eax-4], 92
  00059	83 c1 04	 add	 ecx, 4
  0005c	51		 push	 ecx
  0005d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00060	83 ea 04	 sub	 edx, 4
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00069	83 c4 08	 add	 esp, 8
$LN3@vector:
  0006c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 e8 04	 sub	 eax, 4
  00072	eb 21		 jmp	 SHORT $LN5@vector
$LN2@vector:
  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
  0007c	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0007f	83 e0 01	 and	 eax, 1
  00082	74 0e		 je	 SHORT $LN4@vector
  00084	6a 5c		 push	 92			; 0000005cH
  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008f	83 c4 08	 add	 esp, 8
$LN4@vector:
  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@vector:
  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_ECWHMD5Checksum@@MAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_ECWHMD5Checksum@@MAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_ECWHMD5Checksum@@MAEPAXI@Z ENDP			; CWHMD5Checksum::`vector deleting destructor'
; Function compile flags: /Odtp /ZI
;	COMDAT ??_GCWHMD5Checksum@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCWHMD5Checksum@@MAEPAXI@Z PROC			; CWHMD5Checksum::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0e		 je	 SHORT $LN2@scalar
  0001c	6a 5c		 push	 92			; 0000005cH
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??_GCWHMD5Checksum@@MAEPAXI@Z ENDP			; CWHMD5Checksum::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??4CWHMD5Checksum@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_$S15$1 = -16						; size = 4
_$S14$2 = -12						; size = 4
_$S13$3 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CWHMD5Checksum@@QAEAAV0@ABV0@@Z PROC			; CWHMD5Checksum::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _$S13$3[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00015	8b 45 f8	 mov	 eax, DWORD PTR _$S13$3[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 f8	 mov	 DWORD PTR _$S13$3[ebp], eax
$LN4@operator:
  0001e	83 7d f8 40	 cmp	 DWORD PTR _$S13$3[ebp], 64 ; 00000040H
  00022	73 14		 jae	 SHORT $LN3@operator
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	03 45 f8	 add	 eax, DWORD PTR _$S13$3[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002d	03 4d f8	 add	 ecx, DWORD PTR _$S13$3[ebp]
  00030	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  00033	88 50 04	 mov	 BYTE PTR [eax+4], dl
  00036	eb dd		 jmp	 SHORT $LN2@operator
$LN3@operator:
  00038	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _$S14$2[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN7@operator
$LN5@operator:
  00041	8b 45 f4	 mov	 eax, DWORD PTR _$S14$2[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 f4	 mov	 DWORD PTR _$S14$2[ebp], eax
$LN7@operator:
  0004a	83 7d f4 02	 cmp	 DWORD PTR _$S14$2[ebp], 2
  0004e	73 16		 jae	 SHORT $LN6@operator
  00050	8b 45 f4	 mov	 eax, DWORD PTR _$S14$2[ebp]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	8b 55 f4	 mov	 edx, DWORD PTR _$S14$2[ebp]
  00059	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0005c	8b 54 96 44	 mov	 edx, DWORD PTR [esi+edx*4+68]
  00060	89 54 81 44	 mov	 DWORD PTR [ecx+eax*4+68], edx
  00064	eb db		 jmp	 SHORT $LN5@operator
$LN6@operator:
  00066	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _$S15$1[ebp], 0
  0006d	eb 09		 jmp	 SHORT $LN10@operator
$LN8@operator:
  0006f	8b 45 f0	 mov	 eax, DWORD PTR _$S15$1[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f0	 mov	 DWORD PTR _$S15$1[ebp], eax
$LN10@operator:
  00078	83 7d f0 04	 cmp	 DWORD PTR _$S15$1[ebp], 4
  0007c	73 16		 jae	 SHORT $LN9@operator
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _$S15$1[ebp]
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 55 f0	 mov	 edx, DWORD PTR _$S15$1[ebp]
  00087	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  0008a	8b 54 96 4c	 mov	 edx, DWORD PTR [esi+edx*4+76]
  0008e	89 54 81 4c	 mov	 DWORD PTR [ecx+eax*4+76], edx
  00092	eb db		 jmp	 SHORT $LN8@operator
$LN9@operator:
  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
??4CWHMD5Checksum@@QAEAAV0@ABV0@@Z ENDP			; CWHMD5Checksum::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??0CWHMD5Checksum@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CWHMD5Checksum@@QAE@ABV0@@Z PROC			; CWHMD5Checksum::CWHMD5Checksum, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWHMD5Checksum@@6B@
  00015	8b 75 08	 mov	 esi, DWORD PTR ___that$[ebp]
  00018	83 c6 04	 add	 esi, 4
  0001b	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0001e	83 c7 04	 add	 edi, 4
  00021	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00026	f3 a5		 rep movsd
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002e	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00031	89 50 44	 mov	 DWORD PTR [eax+68], edx
  00034	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  00037	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003d	83 c0 4c	 add	 eax, 76			; 0000004cH
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00046	8b 10		 mov	 edx, DWORD PTR [eax]
  00048	89 11		 mov	 DWORD PTR [ecx], edx
  0004a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00050	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00053	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00056	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00059	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
??0CWHMD5Checksum@@QAE@ABV0@@Z ENDP			; CWHMD5Checksum::CWHMD5Checksum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_I$ = -8						; size = 4
_this$ = -4						; size = 4
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z PROC		; CWHMD5Checksum::II, COMDAT
; _this$ = ecx

; 340  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 341  : 	DWORD I = (C ^ (B | ~D));

  0000c	8b 45 14	 mov	 eax, DWORD PTR _D$[ebp]
  0000f	f7 d0		 not	 eax
  00011	0b 45 0c	 or	 eax, DWORD PTR _B$[ebp]
  00014	33 45 10	 xor	 eax, DWORD PTR _C$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR _I$[ebp], eax

; 342  : 	A += I + X + T;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _I$[ebp]
  0001d	03 45 18	 add	 eax, DWORD PTR _X$[ebp]
  00020	03 45 20	 add	 eax, DWORD PTR _T$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00026	03 01		 add	 eax, DWORD PTR [ecx]
  00028	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0002b	89 02		 mov	 DWORD PTR [edx], eax

; 343  : 	A = RotateLeft(A, S);

  0002d	8b 45 1c	 mov	 eax, DWORD PTR _S$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	52		 push	 edx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?RotateLeft@CWHMD5Checksum@@IAEKKH@Z ; CWHMD5Checksum::RotateLeft
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00042	89 01		 mov	 DWORD PTR [ecx], eax

; 344  : 	A += B;

  00044	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	03 4d 0c	 add	 ecx, DWORD PTR _B$[ebp]
  0004c	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0004f	89 0a		 mov	 DWORD PTR [edx], ecx

; 345  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 1c 00	 ret	 28			; 0000001cH
?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ENDP		; CWHMD5Checksum::II
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_H$ = -8						; size = 4
_this$ = -4						; size = 4
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z PROC		; CWHMD5Checksum::HH, COMDAT
; _this$ = ecx

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 333  : 	DWORD H = (B ^ C ^ D);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0000f	33 45 10	 xor	 eax, DWORD PTR _C$[ebp]
  00012	33 45 14	 xor	 eax, DWORD PTR _D$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR _H$[ebp], eax

; 334  : 	A += H + X + T;

  00018	8b 45 f8	 mov	 eax, DWORD PTR _H$[ebp]
  0001b	03 45 18	 add	 eax, DWORD PTR _X$[ebp]
  0001e	03 45 20	 add	 eax, DWORD PTR _T$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00024	03 01		 add	 eax, DWORD PTR [ecx]
  00026	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00029	89 02		 mov	 DWORD PTR [edx], eax

; 335  : 	A = RotateLeft(A, S);

  0002b	8b 45 1c	 mov	 eax, DWORD PTR _S$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?RotateLeft@CWHMD5Checksum@@IAEKKH@Z ; CWHMD5Checksum::RotateLeft
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00040	89 01		 mov	 DWORD PTR [ecx], eax

; 336  : 	A += B;

  00042	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	03 4d 0c	 add	 ecx, DWORD PTR _B$[ebp]
  0004a	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  0004d	89 0a		 mov	 DWORD PTR [edx], ecx

; 337  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 1c 00	 ret	 28			; 0000001cH
?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ENDP		; CWHMD5Checksum::HH
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_G$ = -8						; size = 4
_this$ = -4						; size = 4
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z PROC		; CWHMD5Checksum::GG, COMDAT
; _this$ = ecx

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 325  : 	DWORD G = (B & D) | (C & ~D);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0000f	23 45 14	 and	 eax, DWORD PTR _D$[ebp]
  00012	8b 4d 14	 mov	 ecx, DWORD PTR _D$[ebp]
  00015	f7 d1		 not	 ecx
  00017	23 4d 10	 and	 ecx, DWORD PTR _C$[ebp]
  0001a	0b c1		 or	 eax, ecx
  0001c	89 45 f8	 mov	 DWORD PTR _G$[ebp], eax

; 326  : 	A += G + X + T;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _G$[ebp]
  00022	03 45 18	 add	 eax, DWORD PTR _X$[ebp]
  00025	03 45 20	 add	 eax, DWORD PTR _T$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0002b	03 01		 add	 eax, DWORD PTR [ecx]
  0002d	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax

; 327  : 	A = RotateLeft(A, S);

  00032	8b 45 1c	 mov	 eax, DWORD PTR _S$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?RotateLeft@CWHMD5Checksum@@IAEKKH@Z ; CWHMD5Checksum::RotateLeft
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00047	89 01		 mov	 DWORD PTR [ecx], eax

; 328  : 	A += B;

  00049	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	03 4d 0c	 add	 ecx, DWORD PTR _B$[ebp]
  00051	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00054	89 0a		 mov	 DWORD PTR [edx], ecx

; 329  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 1c 00	 ret	 28			; 0000001cH
?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ENDP		; CWHMD5Checksum::GG
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z
_TEXT	SEGMENT
_F$ = -8						; size = 4
_this$ = -4						; size = 4
_A$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_D$ = 20						; size = 4
_X$ = 24						; size = 4
_S$ = 28						; size = 4
_T$ = 32						; size = 4
?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z PROC		; CWHMD5Checksum::FF, COMDAT
; _this$ = ecx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 317  : 	DWORD F = (B & C) | (~B & D);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _B$[ebp]
  0000f	23 45 10	 and	 eax, DWORD PTR _C$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _B$[ebp]
  00015	f7 d1		 not	 ecx
  00017	23 4d 14	 and	 ecx, DWORD PTR _D$[ebp]
  0001a	0b c1		 or	 eax, ecx
  0001c	89 45 f8	 mov	 DWORD PTR _F$[ebp], eax

; 318  : 	A += F + X + T;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _F$[ebp]
  00022	03 45 18	 add	 eax, DWORD PTR _X$[ebp]
  00025	03 45 20	 add	 eax, DWORD PTR _T$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  0002b	03 01		 add	 eax, DWORD PTR [ecx]
  0002d	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00030	89 02		 mov	 DWORD PTR [edx], eax

; 319  : 	A = RotateLeft(A, S);

  00032	8b 45 1c	 mov	 eax, DWORD PTR _S$[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	52		 push	 edx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?RotateLeft@CWHMD5Checksum@@IAEKKH@Z ; CWHMD5Checksum::RotateLeft
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _A$[ebp]
  00047	89 01		 mov	 DWORD PTR [ecx], eax

; 320  : 	A += B;

  00049	8b 45 08	 mov	 eax, DWORD PTR _A$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	03 4d 0c	 add	 ecx, DWORD PTR _B$[ebp]
  00051	8b 55 08	 mov	 edx, DWORD PTR _A$[ebp]
  00054	89 0a		 mov	 DWORD PTR [edx], ecx

; 321  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 1c 00	 ret	 28			; 0000001cH
?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ENDP		; CWHMD5Checksum::FF
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?RotateLeft@CWHMD5Checksum@@IAEKKH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_n$ = 12						; size = 4
?RotateLeft@CWHMD5Checksum@@IAEKKH@Z PROC		; CWHMD5Checksum::RotateLeft, COMDAT
; _this$ = ecx

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 	//参数校验
; 308  : 	ASSERT( sizeof(x) == 4 );
; 309  : 	
; 310  : 	//返回结果
; 311  : 	return (x << n) | (x >> (32-n));

  0000c	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00012	d3 e0		 shl	 eax, cl
  00014	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00019	2b 4d 0c	 sub	 ecx, DWORD PTR _n$[ebp]
  0001c	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  0001f	d3 ea		 shr	 edx, cl
  00021	0b c2		 or	 eax, edx

; 312  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?RotateLeft@CWHMD5Checksum@@IAEKKH@Z ENDP		; CWHMD5Checksum::RotateLeft
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z
_TEXT	SEGMENT
_nLoopIndex$ = -12					; size = 4
_nOutIndex$ = -8					; size = 4
_this$ = -4						; size = 4
_Output$ = 8						; size = 4
_Input$ = 12						; size = 4
_nLength$ = 16						; size = 4
?ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z PROC		; CWHMD5Checksum::ByteToDWord, COMDAT
; _this$ = ecx

; 260  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 	//参数校验
; 262  : 	ASSERT( nLength % 4 == 0 );

  0000c	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	f7 f1		 div	 ecx
  00018	85 d2		 test	 edx, edx
  0001a	74 19		 je	 SHORT $LN6@ByteToDWor
  0001c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA
  00022	83 c2 02	 add	 edx, 2
  00025	52		 push	 edx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0002b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00030	85 c0		 test	 eax, eax
  00032	74 01		 je	 SHORT $LN6@ByteToDWor
  00034	cc		 int	 3
$LN6@ByteToDWor:

; 263  : 	ASSERT( AfxIsValidAddress(Output, nLength/4, TRUE) );

  00035	6a 01		 push	 1
  00037	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003a	c1 e8 02	 shr	 eax, 2
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _Output$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  00047	85 c0		 test	 eax, eax
  00049	75 19		 jne	 SHORT $LN7@ByteToDWor
  0004b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA
  00051	83 c2 03	 add	 edx, 3
  00054	52		 push	 edx
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0005a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005f	85 c0		 test	 eax, eax
  00061	74 01		 je	 SHORT $LN7@ByteToDWor
  00063	cc		 int	 3
$LN7@ByteToDWor:

; 264  : 	ASSERT( AfxIsValidAddress(Input, nLength, FALSE) );

  00064	6a 00		 push	 0
  00066	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  00073	85 c0		 test	 eax, eax
  00075	75 19		 jne	 SHORT $LN8@ByteToDWor
  00077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z@4JA
  0007d	83 c2 04	 add	 edx, 4
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00086	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0008b	85 c0		 test	 eax, eax
  0008d	74 01		 je	 SHORT $LN8@ByteToDWor
  0008f	cc		 int	 3
$LN8@ByteToDWor:

; 265  : 
; 266  : 	//变量定义
; 267  : 	UINT nOutIndex=0; 

  00090	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nOutIndex$[ebp], 0

; 268  : 	UINT nLoopIndex=0; 

  00097	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nLoopIndex$[ebp], 0

; 269  : 
; 270  : 	//转换拷贝
; 271  : 	for ( ;nLoopIndex < nLength; nOutIndex++, nLoopIndex += 4)

  0009e	eb 12		 jmp	 SHORT $LN4@ByteToDWor
$LN2@ByteToDWor:
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _nOutIndex$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 45 f8	 mov	 DWORD PTR _nOutIndex$[ebp], eax
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _nLoopIndex$[ebp]
  000ac	83 c1 04	 add	 ecx, 4
  000af	89 4d f4	 mov	 DWORD PTR _nLoopIndex$[ebp], ecx
$LN4@ByteToDWor:
  000b2	8b 45 f4	 mov	 eax, DWORD PTR _nLoopIndex$[ebp]
  000b5	3b 45 10	 cmp	 eax, DWORD PTR _nLength$[ebp]
  000b8	73 41		 jae	 SHORT $LN1@ByteToDWor

; 272  : 	{
; 273  : 		Output[nOutIndex] = (ULONG)Input[nLoopIndex]	| 

  000ba	8b 45 0c	 mov	 eax, DWORD PTR _Input$[ebp]
  000bd	03 45 f4	 add	 eax, DWORD PTR _nLoopIndex$[ebp]
  000c0	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c3	8b 55 0c	 mov	 edx, DWORD PTR _Input$[ebp]
  000c6	03 55 f4	 add	 edx, DWORD PTR _nLoopIndex$[ebp]
  000c9	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000cd	c1 e0 08	 shl	 eax, 8
  000d0	0b c8		 or	 ecx, eax
  000d2	8b 55 0c	 mov	 edx, DWORD PTR _Input$[ebp]
  000d5	03 55 f4	 add	 edx, DWORD PTR _nLoopIndex$[ebp]
  000d8	0f b6 42 02	 movzx	 eax, BYTE PTR [edx+2]
  000dc	c1 e0 10	 shl	 eax, 16			; 00000010H
  000df	0b c8		 or	 ecx, eax
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _Input$[ebp]
  000e4	03 55 f4	 add	 edx, DWORD PTR _nLoopIndex$[ebp]
  000e7	0f b6 42 03	 movzx	 eax, BYTE PTR [edx+3]
  000eb	c1 e0 18	 shl	 eax, 24			; 00000018H
  000ee	0b c8		 or	 ecx, eax
  000f0	8b 55 f8	 mov	 edx, DWORD PTR _nOutIndex$[ebp]
  000f3	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000f6	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 274  : 							(ULONG)Input[nLoopIndex+1] << 8 | 
; 275  : 							(ULONG)Input[nLoopIndex+2] << 16 | 
; 276  : 							(ULONG)Input[nLoopIndex+3] << 24;
; 277  : 	}

  000f9	eb a5		 jmp	 SHORT $LN2@ByteToDWor
$LN1@ByteToDWor:

; 278  : 
; 279  : 	return;
; 280  : }

  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c2 0c 00	 ret	 12			; 0000000cH
?ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z ENDP		; CWHMD5Checksum::ByteToDWord
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z
_TEXT	SEGMENT
_nLoopIndex$ = -12					; size = 4
_nInIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_Output$ = 8						; size = 4
_Input$ = 12						; size = 4
_nLength$ = 16						; size = 4
?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z PROC	; CWHMD5Checksum::ULongToUInt8, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 285  : 	//校验变量
; 286  : 	ASSERT( nLength % 4 == 0 );

  0000c	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	b9 04 00 00 00	 mov	 ecx, 4
  00016	f7 f1		 div	 ecx
  00018	85 d2		 test	 edx, edx
  0001a	74 19		 je	 SHORT $LN6@ULongToUIn
  0001c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA
  00022	83 c2 02	 add	 edx, 2
  00025	52		 push	 edx
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0002b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00030	85 c0		 test	 eax, eax
  00032	74 01		 je	 SHORT $LN6@ULongToUIn
  00034	cc		 int	 3
$LN6@ULongToUIn:

; 287  : 	ASSERT( AfxIsValidAddress(Output, nLength, TRUE) );

  00035	6a 01		 push	 1
  00037	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _Output$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  00044	85 c0		 test	 eax, eax
  00046	75 19		 jne	 SHORT $LN7@ULongToUIn
  00048	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA
  0004e	83 c2 03	 add	 edx, 3
  00051	52		 push	 edx
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00057	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005c	85 c0		 test	 eax, eax
  0005e	74 01		 je	 SHORT $LN7@ULongToUIn
  00060	cc		 int	 3
$LN7@ULongToUIn:

; 288  : 	ASSERT( AfxIsValidAddress(Input, nLength/4, FALSE) );

  00061	6a 00		 push	 0
  00063	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  00066	c1 e8 02	 shr	 eax, 2
  00069	50		 push	 eax
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress
  00073	85 c0		 test	 eax, eax
  00075	75 19		 jne	 SHORT $LN8@ULongToUIn
  00077	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?__LINE__Var@?0??ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z@4JA
  0007d	83 c2 04	 add	 edx, 4
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00086	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0008b	85 c0		 test	 eax, eax
  0008d	74 01		 je	 SHORT $LN8@ULongToUIn
  0008f	cc		 int	 3
$LN8@ULongToUIn:

; 289  : 
; 290  : 	//转换拷贝
; 291  : 	UINT nInIndex = 0;

  00090	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nInIndex$[ebp], 0

; 292  : 	UINT nLoopIndex = 0;

  00097	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nLoopIndex$[ebp], 0

; 293  : 	for ( ; nLoopIndex < nLength; nInIndex++, nLoopIndex += 4) 

  0009e	eb 12		 jmp	 SHORT $LN4@ULongToUIn
$LN2@ULongToUIn:
  000a0	8b 45 f8	 mov	 eax, DWORD PTR _nInIndex$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 45 f8	 mov	 DWORD PTR _nInIndex$[ebp], eax
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _nLoopIndex$[ebp]
  000ac	83 c1 04	 add	 ecx, 4
  000af	89 4d f4	 mov	 DWORD PTR _nLoopIndex$[ebp], ecx
$LN4@ULongToUIn:
  000b2	8b 45 f4	 mov	 eax, DWORD PTR _nLoopIndex$[ebp]
  000b5	3b 45 10	 cmp	 eax, DWORD PTR _nLength$[ebp]
  000b8	73 6d		 jae	 SHORT $LN1@ULongToUIn

; 294  : 	{
; 295  : 		Output[nLoopIndex] =   (UCHAR)(Input[nInIndex] & 0xff);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _nInIndex$[ebp]
  000bd	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  000c0	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000c3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000c9	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000cc	03 45 f4	 add	 eax, DWORD PTR _nLoopIndex$[ebp]
  000cf	88 10		 mov	 BYTE PTR [eax], dl

; 296  : 		Output[nLoopIndex+1] = (UCHAR)((Input[nInIndex] >> 8) & 0xff);

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _nInIndex$[ebp]
  000d4	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  000d7	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000da	c1 ea 08	 shr	 edx, 8
  000dd	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000e3	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000e6	03 45 f4	 add	 eax, DWORD PTR _nLoopIndex$[ebp]
  000e9	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 297  : 		Output[nLoopIndex+2] = (UCHAR)((Input[nInIndex] >> 16) & 0xff);

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _nInIndex$[ebp]
  000ef	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  000f2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000f5	c1 ea 10	 shr	 edx, 16			; 00000010H
  000f8	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000fe	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  00101	03 45 f4	 add	 eax, DWORD PTR _nLoopIndex$[ebp]
  00104	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 298  : 		Output[nLoopIndex+3] = (UCHAR)((Input[nInIndex] >> 24) & 0xff);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _nInIndex$[ebp]
  0010a	8b 4d 0c	 mov	 ecx, DWORD PTR _Input$[ebp]
  0010d	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00110	c1 ea 18	 shr	 edx, 24			; 00000018H
  00113	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00119	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  0011c	03 45 f4	 add	 eax, DWORD PTR _nLoopIndex$[ebp]
  0011f	88 50 03	 mov	 BYTE PTR [eax+3], dl

; 299  : 	}

  00122	e9 79 ff ff ff	 jmp	 $LN2@ULongToUIn
$LN1@ULongToUIn:

; 300  : 
; 301  : 	return;
; 302  : }

  00127	5f		 pop	 edi
  00128	5e		 pop	 esi
  00129	5b		 pop	 ebx
  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c2 0c 00	 ret	 12			; 0000000cH
?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z ENDP	; CWHMD5Checksum::ULongToUInt8
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?Update@CWHMD5Checksum@@IAEXPAEK@Z
_TEXT	SEGMENT
tv76 = -84						; size = 4
_nPartLen$ = -16					; size = 4
_i$ = -12						; size = 4
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_Input$ = 8						; size = 4
_nInputLen$ = 12					; size = 4
?Update@CWHMD5Checksum@@IAEXPAEK@Z PROC			; CWHMD5Checksum::Update, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 224  : 	//变量定义
; 225  : 	UINT nIndex = (UINT)((m_nCount[0] >> 3) & 0x3F);

  0000c	b8 04 00 00 00	 mov	 eax, 4
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 44 0a 44	 mov	 eax, DWORD PTR [edx+ecx+68]
  0001b	c1 e8 03	 shr	 eax, 3
  0001e	83 e0 3f	 and	 eax, 63			; 0000003fH
  00021	89 45 f8	 mov	 DWORD PTR _nIndex$[ebp], eax

; 226  : 
; 227  : 	//更新位数
; 228  : 	if ( ( m_nCount[0] += nInputLen << 3 )  <  ( nInputLen << 3) )

  00024	b8 04 00 00 00	 mov	 eax, 4
  00029	6b c8 00	 imul	 ecx, eax, 0
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _nInputLen$[ebp]
  0002f	c1 e2 03	 shl	 edx, 3
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4c 08 44	 mov	 ecx, DWORD PTR [eax+ecx+68]
  00039	03 ca		 add	 ecx, edx
  0003b	89 4d ac	 mov	 DWORD PTR tv76[ebp], ecx
  0003e	ba 04 00 00 00	 mov	 edx, 4
  00043	6b c2 00	 imul	 eax, edx, 0
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 55 ac	 mov	 edx, DWORD PTR tv76[ebp]
  0004c	89 54 01 44	 mov	 DWORD PTR [ecx+eax+68], edx
  00050	8b 45 0c	 mov	 eax, DWORD PTR _nInputLen$[ebp]
  00053	c1 e0 03	 shl	 eax, 3
  00056	39 45 ac	 cmp	 DWORD PTR tv76[ebp], eax
  00059	73 21		 jae	 SHORT $LN5@Update

; 229  : 	{
; 230  : 		m_nCount[1]++;

  0005b	b8 04 00 00 00	 mov	 eax, 4
  00060	c1 e0 00	 shl	 eax, 0
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	8b 54 01 44	 mov	 edx, DWORD PTR [ecx+eax+68]
  0006a	83 c2 01	 add	 edx, 1
  0006d	b8 04 00 00 00	 mov	 eax, 4
  00072	c1 e0 00	 shl	 eax, 0
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	89 54 01 44	 mov	 DWORD PTR [ecx+eax+68], edx
$LN5@Update:

; 231  : 	}
; 232  : 
; 233  : 	//设置变量
; 234  : 	m_nCount[1] += (nInputLen >> 29);

  0007c	b8 04 00 00 00	 mov	 eax, 4
  00081	c1 e0 00	 shl	 eax, 0
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _nInputLen$[ebp]
  00087	c1 e9 1d	 shr	 ecx, 29			; 0000001dH
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	03 4c 02 44	 add	 ecx, DWORD PTR [edx+eax+68]
  00091	b8 04 00 00 00	 mov	 eax, 4
  00096	c1 e0 00	 shl	 eax, 0
  00099	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	89 4c 02 44	 mov	 DWORD PTR [edx+eax+68], ecx

; 235  : 
; 236  : 	//重复转换
; 237  : 	UINT i=0;  

  000a0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 238  : 	UINT nPartLen = 64 - nIndex;

  000a7	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  000ac	2b 45 f8	 sub	 eax, DWORD PTR _nIndex$[ebp]
  000af	89 45 f0	 mov	 DWORD PTR _nPartLen$[ebp], eax

; 239  : 	if (nInputLen >= nPartLen)  

  000b2	8b 45 0c	 mov	 eax, DWORD PTR _nInputLen$[ebp]
  000b5	3b 45 f0	 cmp	 eax, DWORD PTR _nPartLen$[ebp]
  000b8	72 60		 jb	 SHORT $LN6@Update

; 240  : 	{
; 241  : 		memcpy( &m_lpszBuffer[nIndex], Input, nPartLen );

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _nPartLen$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 08	 mov	 ecx, DWORD PTR _Input$[ebp]
  000c1	51		 push	 ecx
  000c2	8b 55 f8	 mov	 edx, DWORD PTR _nIndex$[ebp]
  000c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000cc	51		 push	 ecx
  000cd	e8 00 00 00 00	 call	 _memcpy
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 242  : 		Transform( m_lpszBuffer );

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	83 c0 04	 add	 eax, 4
  000db	50		 push	 eax
  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?Transform@CWHMD5Checksum@@IAEXQAE@Z ; CWHMD5Checksum::Transform

; 243  : 		for (i = nPartLen; i + 63 < nInputLen; i += 64) 

  000e4	8b 45 f0	 mov	 eax, DWORD PTR _nPartLen$[ebp]
  000e7	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
  000ea	eb 09		 jmp	 SHORT $LN4@Update
$LN2@Update:
  000ec	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000ef	83 c0 40	 add	 eax, 64			; 00000040H
  000f2	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Update:
  000f5	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000f8	83 c0 3f	 add	 eax, 63			; 0000003fH
  000fb	3b 45 0c	 cmp	 eax, DWORD PTR _nInputLen$[ebp]
  000fe	73 11		 jae	 SHORT $LN3@Update

; 244  : 		{
; 245  : 			Transform( &Input[i] );

  00100	8b 45 08	 mov	 eax, DWORD PTR _Input$[ebp]
  00103	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  00106	50		 push	 eax
  00107	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	e8 00 00 00 00	 call	 ?Transform@CWHMD5Checksum@@IAEXQAE@Z ; CWHMD5Checksum::Transform

; 246  : 		}

  0010f	eb db		 jmp	 SHORT $LN2@Update
$LN3@Update:

; 247  : 		nIndex = 0;

  00111	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nIndex$[ebp], 0

; 248  : 	} 
; 249  : 	else 

  00118	eb 07		 jmp	 SHORT $LN7@Update
$LN6@Update:

; 250  : 	{
; 251  : 		i = 0;

  0011a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN7@Update:

; 252  : 	}
; 253  : 
; 254  : 	//拷贝缓冲
; 255  : 	memcpy( &m_lpszBuffer[nIndex], &Input[i], nInputLen-i);

  00121	8b 45 0c	 mov	 eax, DWORD PTR _nInputLen$[ebp]
  00124	2b 45 f4	 sub	 eax, DWORD PTR _i$[ebp]
  00127	50		 push	 eax
  00128	8b 4d 08	 mov	 ecx, DWORD PTR _Input$[ebp]
  0012b	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  0012e	51		 push	 ecx
  0012f	8b 55 f8	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00132	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00135	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00139	51		 push	 ecx
  0013a	e8 00 00 00 00	 call	 _memcpy
  0013f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 256  : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 08 00	 ret	 8
?Update@CWHMD5Checksum@@IAEXPAEK@Z ENDP			; CWHMD5Checksum::Update
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?Transform@CWHMD5Checksum@@IAEXQAE@Z
_TEXT	SEGMENT
_X$ = -88						; size = 64
_d$ = -24						; size = 4
_c$ = -20						; size = 4
_b$ = -16						; size = 4
_a$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_Block$ = 8						; size = 4
?Transform@CWHMD5Checksum@@IAEXQAE@Z PROC		; CWHMD5Checksum::Transform, COMDAT
; _this$ = ecx

; 129  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 130  : 	//变量定义
; 131  : 	ULONG a = m_lMD5[0];

  00019	b8 04 00 00 00	 mov	 eax, 4
  0001e	6b c8 00	 imul	 ecx, eax, 0
  00021	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 44 0a 4c	 mov	 eax, DWORD PTR [edx+ecx+76]
  00028	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax

; 132  : 	ULONG b = m_lMD5[1];

  0002b	b8 04 00 00 00	 mov	 eax, 4
  00030	c1 e0 00	 shl	 eax, 0
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  0003a	89 55 f0	 mov	 DWORD PTR _b$[ebp], edx

; 133  : 	ULONG c = m_lMD5[2];

  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	d1 e0		 shl	 eax, 1
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  0004b	89 55 ec	 mov	 DWORD PTR _c$[ebp], edx

; 134  : 	ULONG d = m_lMD5[3];

  0004e	b8 04 00 00 00	 mov	 eax, 4
  00053	6b c8 03	 imul	 ecx, eax, 3
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	8b 44 0a 4c	 mov	 eax, DWORD PTR [edx+ecx+76]
  0005d	89 45 e8	 mov	 DWORD PTR _d$[ebp], eax

; 135  : 
; 136  : 	//变量定义
; 137  : 	ULONG X[16];
; 138  : 
; 139  : 	//数据转换
; 140  : 	ByteToDWord( X, Block, 64 );

  00060	6a 40		 push	 64			; 00000040H
  00062	8b 45 08	 mov	 eax, DWORD PTR _Block$[ebp]
  00065	50		 push	 eax
  00066	8d 4d a8	 lea	 ecx, DWORD PTR _X$[ebp]
  00069	51		 push	 ecx
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?ByteToDWord@CWHMD5Checksum@@IAEXPAKPAEI@Z ; CWHMD5Checksum::ByteToDWord

; 141  : 
; 142  : 	//1轮转换
; 143  : 	FF (a, b, c, d, X[ 0], MD5_S11, MD5_T01); 

  00072	68 78 a4 6a d7	 push	 -680876936		; d76aa478H
  00077	6a 07		 push	 7
  00079	b8 04 00 00 00	 mov	 eax, 4
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00085	52		 push	 edx
  00086	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  00091	52		 push	 edx
  00092	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 144  : 	FF (d, a, b, c, X[ 1], MD5_S12, MD5_T02); 

  0009e	68 56 b7 c7 e8	 push	 -389564586		; e8c7b756H
  000a3	6a 0c		 push	 12			; 0000000cH
  000a5	b8 04 00 00 00	 mov	 eax, 4
  000aa	c1 e0 00	 shl	 eax, 0
  000ad	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  000b1	51		 push	 ecx
  000b2	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  000b5	52		 push	 edx
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  000bd	51		 push	 ecx
  000be	8d 55 e8	 lea	 edx, DWORD PTR _d$[ebp]
  000c1	52		 push	 edx
  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c5	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 145  : 	FF (c, d, a, b, X[ 2], MD5_S13, MD5_T03); 

  000ca	68 db 70 20 24	 push	 606105819		; 242070dbH
  000cf	6a 11		 push	 17			; 00000011H
  000d1	b8 04 00 00 00	 mov	 eax, 4
  000d6	d1 e0		 shl	 eax, 1
  000d8	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  000dc	51		 push	 ecx
  000dd	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  000e0	52		 push	 edx
  000e1	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  000e4	50		 push	 eax
  000e5	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  000e8	51		 push	 ecx
  000e9	8d 55 ec	 lea	 edx, DWORD PTR _c$[ebp]
  000ec	52		 push	 edx
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 146  : 	FF (b, c, d, a, X[ 3], MD5_S14, MD5_T04); 

  000f5	68 ee ce bd c1	 push	 -1044525330		; c1bdceeeH
  000fa	6a 16		 push	 22			; 00000016H
  000fc	b8 04 00 00 00	 mov	 eax, 4
  00101	6b c8 03	 imul	 ecx, eax, 3
  00104	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00108	52		 push	 edx
  00109	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0010c	50		 push	 eax
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00110	51		 push	 ecx
  00111	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00114	52		 push	 edx
  00115	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00118	50		 push	 eax
  00119	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 147  : 	FF (a, b, c, d, X[ 4], MD5_S11, MD5_T05); 

  00121	68 af 0f 7c f5	 push	 -176418897		; f57c0fafH
  00126	6a 07		 push	 7
  00128	b8 04 00 00 00	 mov	 eax, 4
  0012d	c1 e0 02	 shl	 eax, 2
  00130	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00134	51		 push	 ecx
  00135	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00138	52		 push	 edx
  00139	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00140	51		 push	 ecx
  00141	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  00144	52		 push	 edx
  00145	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 148  : 	FF (d, a, b, c, X[ 5], MD5_S12, MD5_T06); 

  0014d	68 2a c6 87 47	 push	 1200080426		; 4787c62aH
  00152	6a 0c		 push	 12			; 0000000cH
  00154	b8 04 00 00 00	 mov	 eax, 4
  00159	6b c8 05	 imul	 ecx, eax, 5
  0015c	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00160	52		 push	 edx
  00161	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00164	50		 push	 eax
  00165	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00168	51		 push	 ecx
  00169	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0016c	52		 push	 edx
  0016d	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00170	50		 push	 eax
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 149  : 	FF (c, d, a, b, X[ 6], MD5_S13, MD5_T07); 

  00179	68 13 46 30 a8	 push	 -1473231341		; a8304613H
  0017e	6a 11		 push	 17			; 00000011H
  00180	b8 04 00 00 00	 mov	 eax, 4
  00185	6b c8 06	 imul	 ecx, eax, 6
  00188	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0018c	52		 push	 edx
  0018d	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00190	50		 push	 eax
  00191	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00194	51		 push	 ecx
  00195	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00198	52		 push	 edx
  00199	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0019c	50		 push	 eax
  0019d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 150  : 	FF (b, c, d, a, X[ 7], MD5_S14, MD5_T08); 

  001a5	68 01 95 46 fd	 push	 -45705983		; fd469501H
  001aa	6a 16		 push	 22			; 00000016H
  001ac	b8 04 00 00 00	 mov	 eax, 4
  001b1	6b c8 07	 imul	 ecx, eax, 7
  001b4	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  001b8	52		 push	 edx
  001b9	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  001bc	50		 push	 eax
  001bd	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  001c0	51		 push	 ecx
  001c1	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  001c4	52		 push	 edx
  001c5	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 151  : 	FF (a, b, c, d, X[ 8], MD5_S11, MD5_T09); 

  001d1	68 d8 98 80 69	 push	 1770035416		; 698098d8H
  001d6	6a 07		 push	 7
  001d8	b8 04 00 00 00	 mov	 eax, 4
  001dd	c1 e0 03	 shl	 eax, 3
  001e0	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  001e4	51		 push	 ecx
  001e5	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  001e8	52		 push	 edx
  001e9	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  001ec	50		 push	 eax
  001ed	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  001f0	51		 push	 ecx
  001f1	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  001f4	52		 push	 edx
  001f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 152  : 	FF (d, a, b, c, X[ 9], MD5_S12, MD5_T10); 

  001fd	68 af f7 44 8b	 push	 -1958414417		; 8b44f7afH
  00202	6a 0c		 push	 12			; 0000000cH
  00204	b8 04 00 00 00	 mov	 eax, 4
  00209	6b c8 09	 imul	 ecx, eax, 9
  0020c	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00210	52		 push	 edx
  00211	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00214	50		 push	 eax
  00215	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00218	51		 push	 ecx
  00219	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0021c	52		 push	 edx
  0021d	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00220	50		 push	 eax
  00221	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 153  : 	FF (c, d, a, b, X[10], MD5_S13, MD5_T11); 

  00229	68 b1 5b ff ff	 push	 -42063			; ffff5bb1H
  0022e	6a 11		 push	 17			; 00000011H
  00230	b8 04 00 00 00	 mov	 eax, 4
  00235	6b c8 0a	 imul	 ecx, eax, 10
  00238	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0023c	52		 push	 edx
  0023d	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00240	50		 push	 eax
  00241	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00244	51		 push	 ecx
  00245	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00248	52		 push	 edx
  00249	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0024c	50		 push	 eax
  0024d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00250	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 154  : 	FF (b, c, d, a, X[11], MD5_S14, MD5_T12); 

  00255	68 be d7 5c 89	 push	 -1990404162		; 895cd7beH
  0025a	6a 16		 push	 22			; 00000016H
  0025c	b8 04 00 00 00	 mov	 eax, 4
  00261	6b c8 0b	 imul	 ecx, eax, 11
  00264	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00268	52		 push	 edx
  00269	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0026c	50		 push	 eax
  0026d	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00270	51		 push	 ecx
  00271	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00274	52		 push	 edx
  00275	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00278	50		 push	 eax
  00279	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027c	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 155  : 	FF (a, b, c, d, X[12], MD5_S11, MD5_T13); 

  00281	68 22 11 90 6b	 push	 1804603682		; 6b901122H
  00286	6a 07		 push	 7
  00288	b8 04 00 00 00	 mov	 eax, 4
  0028d	6b c8 0c	 imul	 ecx, eax, 12
  00290	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00294	52		 push	 edx
  00295	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00298	50		 push	 eax
  00299	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0029c	51		 push	 ecx
  0029d	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  002a0	52		 push	 edx
  002a1	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  002a4	50		 push	 eax
  002a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a8	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 156  : 	FF (d, a, b, c, X[13], MD5_S12, MD5_T14); 

  002ad	68 93 71 98 fd	 push	 -40341101		; fd987193H
  002b2	6a 0c		 push	 12			; 0000000cH
  002b4	b8 04 00 00 00	 mov	 eax, 4
  002b9	6b c8 0d	 imul	 ecx, eax, 13
  002bc	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  002c0	52		 push	 edx
  002c1	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  002c4	50		 push	 eax
  002c5	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  002c8	51		 push	 ecx
  002c9	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  002cc	52		 push	 edx
  002cd	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  002d0	50		 push	 eax
  002d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002d4	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 157  : 	FF (c, d, a, b, X[14], MD5_S13, MD5_T15); 

  002d9	68 8e 43 79 a6	 push	 -1502002290		; a679438eH
  002de	6a 11		 push	 17			; 00000011H
  002e0	b8 04 00 00 00	 mov	 eax, 4
  002e5	6b c8 0e	 imul	 ecx, eax, 14
  002e8	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  002ec	52		 push	 edx
  002ed	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  002f0	50		 push	 eax
  002f1	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  002f4	51		 push	 ecx
  002f5	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  002f8	52		 push	 edx
  002f9	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  002fc	50		 push	 eax
  002fd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 158  : 	FF (b, c, d, a, X[15], MD5_S14, MD5_T16); 

  00305	68 21 08 b4 49	 push	 1236535329		; 49b40821H
  0030a	6a 16		 push	 22			; 00000016H
  0030c	b8 04 00 00 00	 mov	 eax, 4
  00311	6b c8 0f	 imul	 ecx, eax, 15
  00314	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00318	52		 push	 edx
  00319	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0031c	50		 push	 eax
  0031d	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00320	51		 push	 ecx
  00321	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00324	52		 push	 edx
  00325	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00328	50		 push	 eax
  00329	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0032c	e8 00 00 00 00	 call	 ?FF@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::FF

; 159  : 
; 160  : 	//2轮转换
; 161  : 	GG (a, b, c, d, X[ 1], MD5_S21, MD5_T17); 

  00331	68 62 25 1e f6	 push	 -165796510		; f61e2562H
  00336	6a 05		 push	 5
  00338	b8 04 00 00 00	 mov	 eax, 4
  0033d	c1 e0 00	 shl	 eax, 0
  00340	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00344	51		 push	 ecx
  00345	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00348	52		 push	 edx
  00349	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  0034c	50		 push	 eax
  0034d	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00350	51		 push	 ecx
  00351	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  00354	52		 push	 edx
  00355	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00358	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 162  : 	GG (d, a, b, c, X[ 6], MD5_S22, MD5_T18); 

  0035d	68 40 b3 40 c0	 push	 -1069501632		; c040b340H
  00362	6a 09		 push	 9
  00364	b8 04 00 00 00	 mov	 eax, 4
  00369	6b c8 06	 imul	 ecx, eax, 6
  0036c	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00370	52		 push	 edx
  00371	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00374	50		 push	 eax
  00375	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00378	51		 push	 ecx
  00379	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0037c	52		 push	 edx
  0037d	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00380	50		 push	 eax
  00381	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00384	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 163  : 	GG (c, d, a, b, X[11], MD5_S23, MD5_T19); 

  00389	68 51 5a 5e 26	 push	 643717713		; 265e5a51H
  0038e	6a 0e		 push	 14			; 0000000eH
  00390	b8 04 00 00 00	 mov	 eax, 4
  00395	6b c8 0b	 imul	 ecx, eax, 11
  00398	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0039c	52		 push	 edx
  0039d	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  003a0	50		 push	 eax
  003a1	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  003a4	51		 push	 ecx
  003a5	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  003a8	52		 push	 edx
  003a9	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  003ac	50		 push	 eax
  003ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003b0	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 164  : 	GG (b, c, d, a, X[ 0], MD5_S24, MD5_T20); 

  003b5	68 aa c7 b6 e9	 push	 -373897302		; e9b6c7aaH
  003ba	6a 14		 push	 20			; 00000014H
  003bc	b8 04 00 00 00	 mov	 eax, 4
  003c1	6b c8 00	 imul	 ecx, eax, 0
  003c4	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  003c8	52		 push	 edx
  003c9	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  003cc	50		 push	 eax
  003cd	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  003d0	51		 push	 ecx
  003d1	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  003d4	52		 push	 edx
  003d5	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  003d8	50		 push	 eax
  003d9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003dc	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 165  : 	GG (a, b, c, d, X[ 5], MD5_S21, MD5_T21); 

  003e1	68 5d 10 2f d6	 push	 -701558691		; d62f105dH
  003e6	6a 05		 push	 5
  003e8	b8 04 00 00 00	 mov	 eax, 4
  003ed	6b c8 05	 imul	 ecx, eax, 5
  003f0	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  003f4	52		 push	 edx
  003f5	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  003f8	50		 push	 eax
  003f9	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  003fc	51		 push	 ecx
  003fd	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  00400	52		 push	 edx
  00401	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00404	50		 push	 eax
  00405	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00408	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 166  : 	GG (d, a, b, c, X[10], MD5_S22, MD5_T22); 

  0040d	68 53 14 44 02	 push	 38016083		; 02441453H
  00412	6a 09		 push	 9
  00414	b8 04 00 00 00	 mov	 eax, 4
  00419	6b c8 0a	 imul	 ecx, eax, 10
  0041c	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00420	52		 push	 edx
  00421	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00424	50		 push	 eax
  00425	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00428	51		 push	 ecx
  00429	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0042c	52		 push	 edx
  0042d	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00430	50		 push	 eax
  00431	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00434	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 167  : 	GG (c, d, a, b, X[15], MD5_S23, MD5_T23); 

  00439	68 81 e6 a1 d8	 push	 -660478335		; d8a1e681H
  0043e	6a 0e		 push	 14			; 0000000eH
  00440	b8 04 00 00 00	 mov	 eax, 4
  00445	6b c8 0f	 imul	 ecx, eax, 15
  00448	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0044c	52		 push	 edx
  0044d	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00450	50		 push	 eax
  00451	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00454	51		 push	 ecx
  00455	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00458	52		 push	 edx
  00459	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0045c	50		 push	 eax
  0045d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00460	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 168  : 	GG (b, c, d, a, X[ 4], MD5_S24, MD5_T24); 

  00465	68 c8 fb d3 e7	 push	 -405537848		; e7d3fbc8H
  0046a	6a 14		 push	 20			; 00000014H
  0046c	b8 04 00 00 00	 mov	 eax, 4
  00471	c1 e0 02	 shl	 eax, 2
  00474	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00478	51		 push	 ecx
  00479	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0047c	52		 push	 edx
  0047d	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00480	50		 push	 eax
  00481	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00484	51		 push	 ecx
  00485	8d 55 f0	 lea	 edx, DWORD PTR _b$[ebp]
  00488	52		 push	 edx
  00489	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0048c	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 169  : 	GG (a, b, c, d, X[ 9], MD5_S21, MD5_T25); 

  00491	68 e6 cd e1 21	 push	 568446438		; 21e1cde6H
  00496	6a 05		 push	 5
  00498	b8 04 00 00 00	 mov	 eax, 4
  0049d	6b c8 09	 imul	 ecx, eax, 9
  004a0	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  004a4	52		 push	 edx
  004a5	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  004a8	50		 push	 eax
  004a9	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  004ac	51		 push	 ecx
  004ad	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  004b0	52		 push	 edx
  004b1	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  004b4	50		 push	 eax
  004b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004b8	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 170  : 	GG (d, a, b, c, X[14], MD5_S22, MD5_T26); 

  004bd	68 d6 07 37 c3	 push	 -1019803690		; c33707d6H
  004c2	6a 09		 push	 9
  004c4	b8 04 00 00 00	 mov	 eax, 4
  004c9	6b c8 0e	 imul	 ecx, eax, 14
  004cc	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  004d0	52		 push	 edx
  004d1	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  004d4	50		 push	 eax
  004d5	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  004d8	51		 push	 ecx
  004d9	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  004dc	52		 push	 edx
  004dd	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  004e0	50		 push	 eax
  004e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004e4	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 171  : 	GG (c, d, a, b, X[ 3], MD5_S23, MD5_T27); 

  004e9	68 87 0d d5 f4	 push	 -187363961		; f4d50d87H
  004ee	6a 0e		 push	 14			; 0000000eH
  004f0	b8 04 00 00 00	 mov	 eax, 4
  004f5	6b c8 03	 imul	 ecx, eax, 3
  004f8	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  004fc	52		 push	 edx
  004fd	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00500	50		 push	 eax
  00501	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00504	51		 push	 ecx
  00505	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00508	52		 push	 edx
  00509	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0050c	50		 push	 eax
  0050d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00510	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 172  : 	GG (b, c, d, a, X[ 8], MD5_S24, MD5_T28); 

  00515	68 ed 14 5a 45	 push	 1163531501		; 455a14edH
  0051a	6a 14		 push	 20			; 00000014H
  0051c	b8 04 00 00 00	 mov	 eax, 4
  00521	c1 e0 03	 shl	 eax, 3
  00524	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00528	51		 push	 ecx
  00529	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0052c	52		 push	 edx
  0052d	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00530	50		 push	 eax
  00531	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00534	51		 push	 ecx
  00535	8d 55 f0	 lea	 edx, DWORD PTR _b$[ebp]
  00538	52		 push	 edx
  00539	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0053c	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 173  : 	GG (a, b, c, d, X[13], MD5_S21, MD5_T29); 

  00541	68 05 e9 e3 a9	 push	 -1444681467		; a9e3e905H
  00546	6a 05		 push	 5
  00548	b8 04 00 00 00	 mov	 eax, 4
  0054d	6b c8 0d	 imul	 ecx, eax, 13
  00550	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00554	52		 push	 edx
  00555	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00558	50		 push	 eax
  00559	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0055c	51		 push	 ecx
  0055d	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  00560	52		 push	 edx
  00561	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00564	50		 push	 eax
  00565	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00568	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 174  : 	GG (d, a, b, c, X[ 2], MD5_S22, MD5_T30); 

  0056d	68 f8 a3 ef fc	 push	 -51403784		; fcefa3f8H
  00572	6a 09		 push	 9
  00574	b8 04 00 00 00	 mov	 eax, 4
  00579	d1 e0		 shl	 eax, 1
  0057b	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  0057f	51		 push	 ecx
  00580	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00583	52		 push	 edx
  00584	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00587	50		 push	 eax
  00588	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0058b	51		 push	 ecx
  0058c	8d 55 e8	 lea	 edx, DWORD PTR _d$[ebp]
  0058f	52		 push	 edx
  00590	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00593	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 175  : 	GG (c, d, a, b, X[ 7], MD5_S23, MD5_T31); 

  00598	68 d9 02 6f 67	 push	 1735328473		; 676f02d9H
  0059d	6a 0e		 push	 14			; 0000000eH
  0059f	b8 04 00 00 00	 mov	 eax, 4
  005a4	6b c8 07	 imul	 ecx, eax, 7
  005a7	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  005ab	52		 push	 edx
  005ac	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  005af	50		 push	 eax
  005b0	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  005b3	51		 push	 ecx
  005b4	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  005b7	52		 push	 edx
  005b8	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  005bb	50		 push	 eax
  005bc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005bf	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 176  : 	GG (b, c, d, a, X[12], MD5_S24, MD5_T32); 

  005c4	68 8a 4c 2a 8d	 push	 -1926607734		; 8d2a4c8aH
  005c9	6a 14		 push	 20			; 00000014H
  005cb	b8 04 00 00 00	 mov	 eax, 4
  005d0	6b c8 0c	 imul	 ecx, eax, 12
  005d3	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  005d7	52		 push	 edx
  005d8	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  005db	50		 push	 eax
  005dc	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  005df	51		 push	 ecx
  005e0	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  005e3	52		 push	 edx
  005e4	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  005e7	50		 push	 eax
  005e8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005eb	e8 00 00 00 00	 call	 ?GG@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::GG

; 177  : 
; 178  : 	//3轮转换
; 179  : 	HH (a, b, c, d, X[ 5], MD5_S31, MD5_T33); 

  005f0	68 42 39 fa ff	 push	 -378558			; fffa3942H
  005f5	6a 04		 push	 4
  005f7	b8 04 00 00 00	 mov	 eax, 4
  005fc	6b c8 05	 imul	 ecx, eax, 5
  005ff	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00603	52		 push	 edx
  00604	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00607	50		 push	 eax
  00608	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0060b	51		 push	 ecx
  0060c	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  0060f	52		 push	 edx
  00610	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00613	50		 push	 eax
  00614	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00617	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 180  : 	HH (d, a, b, c, X[ 8], MD5_S32, MD5_T34); 

  0061c	68 81 f6 71 87	 push	 -2022574463		; 8771f681H
  00621	6a 0b		 push	 11			; 0000000bH
  00623	b8 04 00 00 00	 mov	 eax, 4
  00628	c1 e0 03	 shl	 eax, 3
  0062b	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  0062f	51		 push	 ecx
  00630	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00633	52		 push	 edx
  00634	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00637	50		 push	 eax
  00638	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0063b	51		 push	 ecx
  0063c	8d 55 e8	 lea	 edx, DWORD PTR _d$[ebp]
  0063f	52		 push	 edx
  00640	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00643	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 181  : 	HH (c, d, a, b, X[11], MD5_S33, MD5_T35); 

  00648	68 22 61 9d 6d	 push	 1839030562		; 6d9d6122H
  0064d	6a 10		 push	 16			; 00000010H
  0064f	b8 04 00 00 00	 mov	 eax, 4
  00654	6b c8 0b	 imul	 ecx, eax, 11
  00657	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0065b	52		 push	 edx
  0065c	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  0065f	50		 push	 eax
  00660	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00663	51		 push	 ecx
  00664	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00667	52		 push	 edx
  00668	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0066b	50		 push	 eax
  0066c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0066f	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 182  : 	HH (b, c, d, a, X[14], MD5_S34, MD5_T36); 

  00674	68 0c 38 e5 fd	 push	 -35309556		; fde5380cH
  00679	6a 17		 push	 23			; 00000017H
  0067b	b8 04 00 00 00	 mov	 eax, 4
  00680	6b c8 0e	 imul	 ecx, eax, 14
  00683	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00687	52		 push	 edx
  00688	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0068b	50		 push	 eax
  0068c	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  0068f	51		 push	 ecx
  00690	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00693	52		 push	 edx
  00694	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00697	50		 push	 eax
  00698	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0069b	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 183  : 	HH (a, b, c, d, X[ 1], MD5_S31, MD5_T37); 

  006a0	68 44 ea be a4	 push	 -1530992060		; a4beea44H
  006a5	6a 04		 push	 4
  006a7	b8 04 00 00 00	 mov	 eax, 4
  006ac	c1 e0 00	 shl	 eax, 0
  006af	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  006b3	51		 push	 ecx
  006b4	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  006b7	52		 push	 edx
  006b8	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  006bb	50		 push	 eax
  006bc	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  006bf	51		 push	 ecx
  006c0	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  006c3	52		 push	 edx
  006c4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006c7	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 184  : 	HH (d, a, b, c, X[ 4], MD5_S32, MD5_T38); 

  006cc	68 a9 cf de 4b	 push	 1272893353		; 4bdecfa9H
  006d1	6a 0b		 push	 11			; 0000000bH
  006d3	b8 04 00 00 00	 mov	 eax, 4
  006d8	c1 e0 02	 shl	 eax, 2
  006db	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  006df	51		 push	 ecx
  006e0	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  006e3	52		 push	 edx
  006e4	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  006e7	50		 push	 eax
  006e8	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  006eb	51		 push	 ecx
  006ec	8d 55 e8	 lea	 edx, DWORD PTR _d$[ebp]
  006ef	52		 push	 edx
  006f0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006f3	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 185  : 	HH (c, d, a, b, X[ 7], MD5_S33, MD5_T39); 

  006f8	68 60 4b bb f6	 push	 -155497632		; f6bb4b60H
  006fd	6a 10		 push	 16			; 00000010H
  006ff	b8 04 00 00 00	 mov	 eax, 4
  00704	6b c8 07	 imul	 ecx, eax, 7
  00707	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0070b	52		 push	 edx
  0070c	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  0070f	50		 push	 eax
  00710	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00713	51		 push	 ecx
  00714	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00717	52		 push	 edx
  00718	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0071b	50		 push	 eax
  0071c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0071f	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 186  : 	HH (b, c, d, a, X[10], MD5_S34, MD5_T40); 

  00724	68 70 bc bf be	 push	 -1094730640		; bebfbc70H
  00729	6a 17		 push	 23			; 00000017H
  0072b	b8 04 00 00 00	 mov	 eax, 4
  00730	6b c8 0a	 imul	 ecx, eax, 10
  00733	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00737	52		 push	 edx
  00738	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0073b	50		 push	 eax
  0073c	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  0073f	51		 push	 ecx
  00740	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00743	52		 push	 edx
  00744	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00747	50		 push	 eax
  00748	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0074b	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 187  : 	HH (a, b, c, d, X[13], MD5_S31, MD5_T41); 

  00750	68 c6 7e 9b 28	 push	 681279174		; 289b7ec6H
  00755	6a 04		 push	 4
  00757	b8 04 00 00 00	 mov	 eax, 4
  0075c	6b c8 0d	 imul	 ecx, eax, 13
  0075f	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00763	52		 push	 edx
  00764	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00767	50		 push	 eax
  00768	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0076b	51		 push	 ecx
  0076c	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  0076f	52		 push	 edx
  00770	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00773	50		 push	 eax
  00774	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00777	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 188  : 	HH (d, a, b, c, X[ 0], MD5_S32, MD5_T42); 

  0077c	68 fa 27 a1 ea	 push	 -358537222		; eaa127faH
  00781	6a 0b		 push	 11			; 0000000bH
  00783	b8 04 00 00 00	 mov	 eax, 4
  00788	6b c8 00	 imul	 ecx, eax, 0
  0078b	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0078f	52		 push	 edx
  00790	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00793	50		 push	 eax
  00794	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00797	51		 push	 ecx
  00798	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0079b	52		 push	 edx
  0079c	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  0079f	50		 push	 eax
  007a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007a3	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 189  : 	HH (c, d, a, b, X[ 3], MD5_S33, MD5_T43); 

  007a8	68 85 30 ef d4	 push	 -722521979		; d4ef3085H
  007ad	6a 10		 push	 16			; 00000010H
  007af	b8 04 00 00 00	 mov	 eax, 4
  007b4	6b c8 03	 imul	 ecx, eax, 3
  007b7	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  007bb	52		 push	 edx
  007bc	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  007bf	50		 push	 eax
  007c0	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  007c3	51		 push	 ecx
  007c4	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  007c7	52		 push	 edx
  007c8	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  007cb	50		 push	 eax
  007cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007cf	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 190  : 	HH (b, c, d, a, X[ 6], MD5_S34, MD5_T44); 

  007d4	68 05 1d 88 04	 push	 76029189		; 04881d05H
  007d9	6a 17		 push	 23			; 00000017H
  007db	b8 04 00 00 00	 mov	 eax, 4
  007e0	6b c8 06	 imul	 ecx, eax, 6
  007e3	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  007e7	52		 push	 edx
  007e8	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  007eb	50		 push	 eax
  007ec	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  007ef	51		 push	 ecx
  007f0	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  007f3	52		 push	 edx
  007f4	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  007f7	50		 push	 eax
  007f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007fb	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 191  : 	HH (a, b, c, d, X[ 9], MD5_S31, MD5_T45); 

  00800	68 39 d0 d4 d9	 push	 -640364487		; d9d4d039H
  00805	6a 04		 push	 4
  00807	b8 04 00 00 00	 mov	 eax, 4
  0080c	6b c8 09	 imul	 ecx, eax, 9
  0080f	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00813	52		 push	 edx
  00814	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00817	50		 push	 eax
  00818	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0081b	51		 push	 ecx
  0081c	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  0081f	52		 push	 edx
  00820	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00823	50		 push	 eax
  00824	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00827	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 192  : 	HH (d, a, b, c, X[12], MD5_S32, MD5_T46); 

  0082c	68 e5 99 db e6	 push	 -421815835		; e6db99e5H
  00831	6a 0b		 push	 11			; 0000000bH
  00833	b8 04 00 00 00	 mov	 eax, 4
  00838	6b c8 0c	 imul	 ecx, eax, 12
  0083b	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0083f	52		 push	 edx
  00840	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00843	50		 push	 eax
  00844	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00847	51		 push	 ecx
  00848	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0084b	52		 push	 edx
  0084c	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  0084f	50		 push	 eax
  00850	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00853	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 193  : 	HH (c, d, a, b, X[15], MD5_S33, MD5_T47); 

  00858	68 f8 7c a2 1f	 push	 530742520		; 1fa27cf8H
  0085d	6a 10		 push	 16			; 00000010H
  0085f	b8 04 00 00 00	 mov	 eax, 4
  00864	6b c8 0f	 imul	 ecx, eax, 15
  00867	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0086b	52		 push	 edx
  0086c	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  0086f	50		 push	 eax
  00870	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00873	51		 push	 ecx
  00874	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00877	52		 push	 edx
  00878	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0087b	50		 push	 eax
  0087c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0087f	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 194  : 	HH (b, c, d, a, X[ 2], MD5_S34, MD5_T48); 

  00884	68 65 56 ac c4	 push	 -995338651		; c4ac5665H
  00889	6a 17		 push	 23			; 00000017H
  0088b	b8 04 00 00 00	 mov	 eax, 4
  00890	d1 e0		 shl	 eax, 1
  00892	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00896	51		 push	 ecx
  00897	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0089a	52		 push	 edx
  0089b	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  0089e	50		 push	 eax
  0089f	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  008a2	51		 push	 ecx
  008a3	8d 55 f0	 lea	 edx, DWORD PTR _b$[ebp]
  008a6	52		 push	 edx
  008a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008aa	e8 00 00 00 00	 call	 ?HH@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::HH

; 195  : 
; 196  : 	//4轮转换
; 197  : 	II (a, b, c, d, X[ 0], MD5_S41, MD5_T49); 

  008af	68 44 22 29 f4	 push	 -198630844		; f4292244H
  008b4	6a 06		 push	 6
  008b6	b8 04 00 00 00	 mov	 eax, 4
  008bb	6b c8 00	 imul	 ecx, eax, 0
  008be	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  008c2	52		 push	 edx
  008c3	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  008c6	50		 push	 eax
  008c7	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  008ca	51		 push	 ecx
  008cb	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  008ce	52		 push	 edx
  008cf	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  008d2	50		 push	 eax
  008d3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  008d6	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 198  : 	II (d, a, b, c, X[ 7], MD5_S42, MD5_T50); 

  008db	68 97 ff 2a 43	 push	 1126891415		; 432aff97H
  008e0	6a 0a		 push	 10			; 0000000aH
  008e2	b8 04 00 00 00	 mov	 eax, 4
  008e7	6b c8 07	 imul	 ecx, eax, 7
  008ea	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  008ee	52		 push	 edx
  008ef	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  008f2	50		 push	 eax
  008f3	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  008f6	51		 push	 ecx
  008f7	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  008fa	52		 push	 edx
  008fb	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  008fe	50		 push	 eax
  008ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00902	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 199  : 	II (c, d, a, b, X[14], MD5_S43, MD5_T51); 

  00907	68 a7 23 94 ab	 push	 -1416354905		; ab9423a7H
  0090c	6a 0f		 push	 15			; 0000000fH
  0090e	b8 04 00 00 00	 mov	 eax, 4
  00913	6b c8 0e	 imul	 ecx, eax, 14
  00916	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0091a	52		 push	 edx
  0091b	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  0091e	50		 push	 eax
  0091f	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00922	51		 push	 ecx
  00923	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00926	52		 push	 edx
  00927	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  0092a	50		 push	 eax
  0092b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0092e	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 200  : 	II (b, c, d, a, X[ 5], MD5_S44, MD5_T52); 

  00933	68 39 a0 93 fc	 push	 -57434055		; fc93a039H
  00938	6a 15		 push	 21			; 00000015H
  0093a	b8 04 00 00 00	 mov	 eax, 4
  0093f	6b c8 05	 imul	 ecx, eax, 5
  00942	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00946	52		 push	 edx
  00947	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0094a	50		 push	 eax
  0094b	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  0094e	51		 push	 ecx
  0094f	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00952	52		 push	 edx
  00953	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00956	50		 push	 eax
  00957	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0095a	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 201  : 	II (a, b, c, d, X[12], MD5_S41, MD5_T53); 

  0095f	68 c3 59 5b 65	 push	 1700485571		; 655b59c3H
  00964	6a 06		 push	 6
  00966	b8 04 00 00 00	 mov	 eax, 4
  0096b	6b c8 0c	 imul	 ecx, eax, 12
  0096e	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00972	52		 push	 edx
  00973	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  00976	50		 push	 eax
  00977	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  0097a	51		 push	 ecx
  0097b	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  0097e	52		 push	 edx
  0097f	8d 45 f4	 lea	 eax, DWORD PTR _a$[ebp]
  00982	50		 push	 eax
  00983	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00986	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 202  : 	II (d, a, b, c, X[ 3], MD5_S42, MD5_T54); 

  0098b	68 92 cc 0c 8f	 push	 -1894986606		; 8f0ccc92H
  00990	6a 0a		 push	 10			; 0000000aH
  00992	b8 04 00 00 00	 mov	 eax, 4
  00997	6b c8 03	 imul	 ecx, eax, 3
  0099a	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  0099e	52		 push	 edx
  0099f	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  009a2	50		 push	 eax
  009a3	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  009a6	51		 push	 ecx
  009a7	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  009aa	52		 push	 edx
  009ab	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  009ae	50		 push	 eax
  009af	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009b2	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 203  : 	II (c, d, a, b, X[10], MD5_S43, MD5_T55); 

  009b7	68 7d f4 ef ff	 push	 -1051523		; ffeff47dH
  009bc	6a 0f		 push	 15			; 0000000fH
  009be	b8 04 00 00 00	 mov	 eax, 4
  009c3	6b c8 0a	 imul	 ecx, eax, 10
  009c6	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  009ca	52		 push	 edx
  009cb	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  009ce	50		 push	 eax
  009cf	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  009d2	51		 push	 ecx
  009d3	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  009d6	52		 push	 edx
  009d7	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  009da	50		 push	 eax
  009db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  009de	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 204  : 	II (b, c, d, a, X[ 1], MD5_S44, MD5_T56); 

  009e3	68 d1 5d 84 85	 push	 -2054922799		; 85845dd1H
  009e8	6a 15		 push	 21			; 00000015H
  009ea	b8 04 00 00 00	 mov	 eax, 4
  009ef	c1 e0 00	 shl	 eax, 0
  009f2	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  009f6	51		 push	 ecx
  009f7	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  009fa	52		 push	 edx
  009fb	8b 45 e8	 mov	 eax, DWORD PTR _d$[ebp]
  009fe	50		 push	 eax
  009ff	8b 4d ec	 mov	 ecx, DWORD PTR _c$[ebp]
  00a02	51		 push	 ecx
  00a03	8d 55 f0	 lea	 edx, DWORD PTR _b$[ebp]
  00a06	52		 push	 edx
  00a07	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a0a	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 205  : 	II (a, b, c, d, X[ 8], MD5_S41, MD5_T57); 

  00a0f	68 4f 7e a8 6f	 push	 1873313359		; 6fa87e4fH
  00a14	6a 06		 push	 6
  00a16	b8 04 00 00 00	 mov	 eax, 4
  00a1b	c1 e0 03	 shl	 eax, 3
  00a1e	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00a22	51		 push	 ecx
  00a23	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00a26	52		 push	 edx
  00a27	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00a2a	50		 push	 eax
  00a2b	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00a2e	51		 push	 ecx
  00a2f	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  00a32	52		 push	 edx
  00a33	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a36	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 206  : 	II (d, a, b, c, X[15], MD5_S42, MD5_T58); 

  00a3b	68 e0 e6 2c fe	 push	 -30611744		; fe2ce6e0H
  00a40	6a 0a		 push	 10			; 0000000aH
  00a42	b8 04 00 00 00	 mov	 eax, 4
  00a47	6b c8 0f	 imul	 ecx, eax, 15
  00a4a	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00a4e	52		 push	 edx
  00a4f	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00a52	50		 push	 eax
  00a53	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00a56	51		 push	 ecx
  00a57	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  00a5a	52		 push	 edx
  00a5b	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00a5e	50		 push	 eax
  00a5f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a62	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 207  : 	II (c, d, a, b, X[ 6], MD5_S43, MD5_T59); 

  00a67	68 14 43 01 a3	 push	 -1560198380		; a3014314H
  00a6c	6a 0f		 push	 15			; 0000000fH
  00a6e	b8 04 00 00 00	 mov	 eax, 4
  00a73	6b c8 06	 imul	 ecx, eax, 6
  00a76	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00a7a	52		 push	 edx
  00a7b	8b 45 f0	 mov	 eax, DWORD PTR _b$[ebp]
  00a7e	50		 push	 eax
  00a7f	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00a82	51		 push	 ecx
  00a83	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00a86	52		 push	 edx
  00a87	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  00a8a	50		 push	 eax
  00a8b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a8e	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 208  : 	II (b, c, d, a, X[13], MD5_S44, MD5_T60); 

  00a93	68 a1 11 08 4e	 push	 1309151649		; 4e0811a1H
  00a98	6a 15		 push	 21			; 00000015H
  00a9a	b8 04 00 00 00	 mov	 eax, 4
  00a9f	6b c8 0d	 imul	 ecx, eax, 13
  00aa2	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00aa6	52		 push	 edx
  00aa7	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00aaa	50		 push	 eax
  00aab	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00aae	51		 push	 ecx
  00aaf	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00ab2	52		 push	 edx
  00ab3	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00ab6	50		 push	 eax
  00ab7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00aba	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 209  : 	II (a, b, c, d, X[ 4], MD5_S41, MD5_T61); 

  00abf	68 82 7e 53 f7	 push	 -145523070		; f7537e82H
  00ac4	6a 06		 push	 6
  00ac6	b8 04 00 00 00	 mov	 eax, 4
  00acb	c1 e0 02	 shl	 eax, 2
  00ace	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00ad2	51		 push	 ecx
  00ad3	8b 55 e8	 mov	 edx, DWORD PTR _d$[ebp]
  00ad6	52		 push	 edx
  00ad7	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00ada	50		 push	 eax
  00adb	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00ade	51		 push	 ecx
  00adf	8d 55 f4	 lea	 edx, DWORD PTR _a$[ebp]
  00ae2	52		 push	 edx
  00ae3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae6	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 210  : 	II (d, a, b, c, X[11], MD5_S42, MD5_T62); 

  00aeb	68 35 f2 3a bd	 push	 -1120210379		; bd3af235H
  00af0	6a 0a		 push	 10			; 0000000aH
  00af2	b8 04 00 00 00	 mov	 eax, 4
  00af7	6b c8 0b	 imul	 ecx, eax, 11
  00afa	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00afe	52		 push	 edx
  00aff	8b 45 ec	 mov	 eax, DWORD PTR _c$[ebp]
  00b02	50		 push	 eax
  00b03	8b 4d f0	 mov	 ecx, DWORD PTR _b$[ebp]
  00b06	51		 push	 ecx
  00b07	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  00b0a	52		 push	 edx
  00b0b	8d 45 e8	 lea	 eax, DWORD PTR _d$[ebp]
  00b0e	50		 push	 eax
  00b0f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b12	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 211  : 	II (c, d, a, b, X[ 2], MD5_S43, MD5_T63); 

  00b17	68 bb d2 d7 2a	 push	 718787259		; 2ad7d2bbH
  00b1c	6a 0f		 push	 15			; 0000000fH
  00b1e	b8 04 00 00 00	 mov	 eax, 4
  00b23	d1 e0		 shl	 eax, 1
  00b25	8b 4c 05 a8	 mov	 ecx, DWORD PTR _X$[ebp+eax]
  00b29	51		 push	 ecx
  00b2a	8b 55 f0	 mov	 edx, DWORD PTR _b$[ebp]
  00b2d	52		 push	 edx
  00b2e	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00b31	50		 push	 eax
  00b32	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00b35	51		 push	 ecx
  00b36	8d 55 ec	 lea	 edx, DWORD PTR _c$[ebp]
  00b39	52		 push	 edx
  00b3a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b3d	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 212  : 	II (b, c, d, a, X[ 9], MD5_S44, MD5_T64); 

  00b42	68 91 d3 86 eb	 push	 -343485551		; eb86d391H
  00b47	6a 15		 push	 21			; 00000015H
  00b49	b8 04 00 00 00	 mov	 eax, 4
  00b4e	6b c8 09	 imul	 ecx, eax, 9
  00b51	8b 54 0d a8	 mov	 edx, DWORD PTR _X$[ebp+ecx]
  00b55	52		 push	 edx
  00b56	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00b59	50		 push	 eax
  00b5a	8b 4d e8	 mov	 ecx, DWORD PTR _d$[ebp]
  00b5d	51		 push	 ecx
  00b5e	8b 55 ec	 mov	 edx, DWORD PTR _c$[ebp]
  00b61	52		 push	 edx
  00b62	8d 45 f0	 lea	 eax, DWORD PTR _b$[ebp]
  00b65	50		 push	 eax
  00b66	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b69	e8 00 00 00 00	 call	 ?II@CWHMD5Checksum@@IAEXAAKKKKKKK@Z ; CWHMD5Checksum::II

; 213  : 
; 214  : 	//设置校验和
; 215  : 	m_lMD5[0] += a;

  00b6e	b8 04 00 00 00	 mov	 eax, 4
  00b73	6b c8 00	 imul	 ecx, eax, 0
  00b76	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00b79	8b 44 0a 4c	 mov	 eax, DWORD PTR [edx+ecx+76]
  00b7d	03 45 f4	 add	 eax, DWORD PTR _a$[ebp]
  00b80	b9 04 00 00 00	 mov	 ecx, 4
  00b85	6b d1 00	 imul	 edx, ecx, 0
  00b88	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b8b	89 44 11 4c	 mov	 DWORD PTR [ecx+edx+76], eax

; 216  : 	m_lMD5[1] += b;

  00b8f	b8 04 00 00 00	 mov	 eax, 4
  00b94	c1 e0 00	 shl	 eax, 0
  00b97	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b9a	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  00b9e	03 55 f0	 add	 edx, DWORD PTR _b$[ebp]
  00ba1	b8 04 00 00 00	 mov	 eax, 4
  00ba6	c1 e0 00	 shl	 eax, 0
  00ba9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bac	89 54 01 4c	 mov	 DWORD PTR [ecx+eax+76], edx

; 217  : 	m_lMD5[2] += c;

  00bb0	b8 04 00 00 00	 mov	 eax, 4
  00bb5	d1 e0		 shl	 eax, 1
  00bb7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bba	8b 54 01 4c	 mov	 edx, DWORD PTR [ecx+eax+76]
  00bbe	03 55 ec	 add	 edx, DWORD PTR _c$[ebp]
  00bc1	b8 04 00 00 00	 mov	 eax, 4
  00bc6	d1 e0		 shl	 eax, 1
  00bc8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bcb	89 54 01 4c	 mov	 DWORD PTR [ecx+eax+76], edx

; 218  : 	m_lMD5[3] += d;

  00bcf	b8 04 00 00 00	 mov	 eax, 4
  00bd4	6b c8 03	 imul	 ecx, eax, 3
  00bd7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00bda	8b 44 0a 4c	 mov	 eax, DWORD PTR [edx+ecx+76]
  00bde	03 45 e8	 add	 eax, DWORD PTR _d$[ebp]
  00be1	b9 04 00 00 00	 mov	 ecx, 4
  00be6	6b d1 03	 imul	 edx, ecx, 3
  00be9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bec	89 44 11 4c	 mov	 DWORD PTR [ecx+edx+76], eax

; 219  : }

  00bf0	5f		 pop	 edi
  00bf1	5e		 pop	 esi
  00bf2	5b		 pop	 ebx
  00bf3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bf6	33 cd		 xor	 ecx, ebp
  00bf8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bfd	8b e5		 mov	 esp, ebp
  00bff	5d		 pop	 ebp
  00c00	c2 04 00	 ret	 4
?Transform@CWHMD5Checksum@@IAEXQAE@Z ENDP		; CWHMD5Checksum::Transform
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
tv195 = -148						; size = 4
tv95 = -144						; size = 4
tv77 = -144						; size = 4
$T2 = -140						; size = 4
$T3 = -136						; size = 4
_Str$4 = -68						; size = 4
_i$5 = -64						; size = 4
_strMD5$ = -60						; size = 4
_lpszMD5$ = -56						; size = 16
_nMD5Size$ = -40					; size = 4
_nPadLen$ = -36						; size = 4
_nIndex$ = -32						; size = 4
_Bits$ = -28						; size = 8
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC ; CWHMD5Checksum::Final, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00031	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0

; 83   : 	//变量定义
; 84   : 	BYTE Bits[8];
; 85   : 	DWordToByte( Bits, m_nCount, 8 );

  0003b	6a 08		 push	 8
  0003d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c0 44	 add	 eax, 68			; 00000044H
  00043	50		 push	 eax
  00044	8d 4d e4	 lea	 ecx, DWORD PTR _Bits$[ebp]
  00047	51		 push	 ecx
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z ; CWHMD5Checksum::ULongToUInt8

; 86   : 
; 87   : 	//变量定义
; 88   : 	UINT nIndex = (UINT)((m_nCount[0] >> 3) & 0x3f);

  00050	b8 04 00 00 00	 mov	 eax, 4
  00055	6b c8 00	 imul	 ecx, eax, 0
  00058	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 44 0a 44	 mov	 eax, DWORD PTR [edx+ecx+68]
  0005f	c1 e8 03	 shr	 eax, 3
  00062	83 e0 3f	 and	 eax, 63			; 0000003fH
  00065	89 45 e0	 mov	 DWORD PTR _nIndex$[ebp], eax

; 89   : 	UINT nPadLen = (nIndex < 56) ? (56 - nIndex) : (120 - nIndex);

  00068	83 7d e0 38	 cmp	 DWORD PTR _nIndex$[ebp], 56 ; 00000038H
  0006c	73 10		 jae	 SHORT $LN10@Final
  0006e	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00073	2b 45 e0	 sub	 eax, DWORD PTR _nIndex$[ebp]
  00076	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  0007c	eb 0e		 jmp	 SHORT $LN11@Final
$LN10@Final:
  0007e	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00083	2b 4d e0	 sub	 ecx, DWORD PTR _nIndex$[ebp]
  00086	89 8d 70 ff ff
	ff		 mov	 DWORD PTR tv77[ebp], ecx
$LN11@Final:
  0008c	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  00092	89 55 dc	 mov	 DWORD PTR _nPadLen$[ebp], edx

; 90   : 	Update( PADDING, nPadLen );

  00095	8b 45 dc	 mov	 eax, DWORD PTR _nPadLen$[ebp]
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ?PADDING@@3PAEA
  0009e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?Update@CWHMD5Checksum@@IAEXPAEK@Z ; CWHMD5Checksum::Update

; 91   : 
; 92   : 	//更新数据
; 93   : 	Update( Bits, 8 );

  000a6	6a 08		 push	 8
  000a8	8d 45 e4	 lea	 eax, DWORD PTR _Bits$[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?Update@CWHMD5Checksum@@IAEXPAEK@Z ; CWHMD5Checksum::Update

; 94   : 
; 95   : 	//变量定义
; 96   : 	const int nMD5Size = 16;

  000b4	c7 45 d8 10 00
	00 00		 mov	 DWORD PTR _nMD5Size$[ebp], 16 ; 00000010H

; 97   : 	unsigned char lpszMD5[ nMD5Size ];
; 98   : 	DWordToByte( lpszMD5, m_lMD5, nMD5Size );

  000bb	6a 10		 push	 16			; 00000010H
  000bd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 c0 4c	 add	 eax, 76			; 0000004cH
  000c3	50		 push	 eax
  000c4	8d 4d c8	 lea	 ecx, DWORD PTR _lpszMD5$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?ULongToUInt8@CWHMD5Checksum@@IAEXPAEPAKI@Z ; CWHMD5Checksum::ULongToUInt8

; 99   : 
; 100  : 	//转换类型
; 101  : 	CString strMD5;

  000d0	8d 4d c4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 102  : 	for ( int i=0; i < nMD5Size; i++) 

  000e0	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  000e7	eb 09		 jmp	 SHORT $LN4@Final
$LN2@Final:
  000e9	8b 45 c0	 mov	 eax, DWORD PTR _i$5[ebp]
  000ec	83 c0 01	 add	 eax, 1
  000ef	89 45 c0	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@Final:
  000f2	83 7d c0 10	 cmp	 DWORD PTR _i$5[ebp], 16	; 00000010H
  000f6	0f 8d ec 00 00
	00		 jge	 $LN3@Final

; 103  : 	{
; 104  : 		CString Str;

  000fc	8d 4d bc	 lea	 ecx, DWORD PTR _Str$4[ebp]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00105	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 105  : 		if (lpszMD5[i] == 0) 

  00109	8b 45 c0	 mov	 eax, DWORD PTR _i$5[ebp]
  0010c	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _lpszMD5$[ebp+eax]
  00111	85 c9		 test	 ecx, ecx
  00113	75 49		 jne	 SHORT $LN5@Final

; 106  : 		{
; 107  : 			Str = CString("00");

  00115	68 00 00 00 00	 push	 OFFSET ??_C@_02PLJDPFIO@00@
  0011a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00126	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], eax
  0012c	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv95[ebp]
  00132	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv195[ebp], eax
  00138	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013c	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv195[ebp]
  00142	51		 push	 ecx
  00143	8d 4d bc	 lea	 ecx, DWORD PTR _Str$4[ebp]
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0014c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00150	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0015c	eb 45		 jmp	 SHORT $LN6@Final
$LN5@Final:

; 108  : 		}
; 109  : 		else if (lpszMD5[i] <= 15)  

  0015e	8b 45 c0	 mov	 eax, DWORD PTR _i$5[ebp]
  00161	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _lpszMD5$[ebp+eax]
  00166	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00169	7f 1d		 jg	 SHORT $LN7@Final

; 110  : 		{
; 111  : 			Str.Format(TEXT("0%x"),lpszMD5[i]);

  0016b	8b 45 c0	 mov	 eax, DWORD PTR _i$5[ebp]
  0016e	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _lpszMD5$[ebp+eax]
  00173	51		 push	 ecx
  00174	68 00 00 00 00	 push	 OFFSET ??_C@_03PHPAKPLH@0?$CFx@
  00179	8d 55 bc	 lea	 edx, DWORD PTR _Str$4[ebp]
  0017c	52		 push	 edx
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00183	83 c4 0c	 add	 esp, 12			; 0000000cH

; 112  : 		}
; 113  : 		else 

  00186	eb 1b		 jmp	 SHORT $LN6@Final
$LN7@Final:

; 114  : 		{
; 115  : 			Str.Format(TEXT("%x"),lpszMD5[i]);

  00188	8b 45 c0	 mov	 eax, DWORD PTR _i$5[ebp]
  0018b	0f b6 4c 05 c8	 movzx	 ecx, BYTE PTR _lpszMD5$[ebp+eax]
  00190	51		 push	 ecx
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_02NJNOFBBI@?$CFx@
  00196	8d 55 bc	 lea	 edx, DWORD PTR _Str$4[ebp]
  00199	52		 push	 edx
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@Final:

; 116  : 		}
; 117  : 		
; 118  : 		ASSERT( Str.GetLength() == 2 );

  001a3	8d 4d bc	 lea	 ecx, DWORD PTR _Str$4[ebp]
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  001ac	83 f8 02	 cmp	 eax, 2
  001af	74 18		 je	 SHORT $LN12@Final
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ@4JA
  001b6	83 c0 24	 add	 eax, 36			; 00000024H
  001b9	50		 push	 eax
  001ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001bf	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001c4	85 c0		 test	 eax, eax
  001c6	74 01		 je	 SHORT $LN12@Final
  001c8	cc		 int	 3
$LN12@Final:

; 119  : 		strMD5 += Str;

  001c9	8d 45 bc	 lea	 eax, DWORD PTR _Str$4[ebp]
  001cc	50		 push	 eax
  001cd	8d 4d c4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV?$CSimpleStringT@D$00@1@@Z

; 120  : 	}

  001d6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001da	8d 4d bc	 lea	 ecx, DWORD PTR _Str$4[ebp]
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001e3	e9 01 ff ff ff	 jmp	 $LN2@Final
$LN3@Final:

; 121  : 
; 122  : 	//结果校验
; 123  : 	ASSERT( strMD5.GetLength() == 32 );

  001e8	8d 4d c4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
  001f1	83 f8 20	 cmp	 eax, 32			; 00000020H
  001f4	74 18		 je	 SHORT $LN13@Final
  001f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ@4JA
  001fb	83 c0 29	 add	 eax, 41			; 00000029H
  001fe	50		 push	 eax
  001ff	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00204	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00209	85 c0		 test	 eax, eax
  0020b	74 01		 je	 SHORT $LN13@Final
  0020d	cc		 int	 3
$LN13@Final:

; 124  : 	return strMD5;

  0020e	8d 45 c4	 lea	 eax, DWORD PTR _strMD5$[ebp]
  00211	50		 push	 eax
  00212	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0021b	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00221	83 c9 01	 or	 ecx, 1
  00224	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  0022a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00231	8d 4d c4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  00234	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0023a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 125  : }

  0023d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00240	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00247	59		 pop	 ecx
  00248	5f		 pop	 edi
  00249	5e		 pop	 esi
  0024a	5b		 pop	 ebx
  0024b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024e	33 cd		 xor	 ecx, ebp
  00250	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00255	8b e5		 mov	 esp, ebp
  00257	5d		 pop	 ebp
  00258	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _strMD5$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$1:
  00009	8d 4d bc	 lea	 ecx, DWORD PTR _Str$4[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__unwindfunclet$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ$2:
  00012	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00018	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; CWHMD5Checksum::Final
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
_File$ = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strFilePath$ = 12					; size = 4
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z PROC ; CWHMD5Checksum::GetMD5, COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 27   : 	//打开文件
; 28   : 	CFile File;

  0002f	8d 4d e0	 lea	 ecx, DWORD PTR _File$[ebp]
  00032	e8 00 00 00 00	 call	 ??0CFile@@QAE@XZ	; CFile::CFile
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 29   : 	if(File.Open(strFilePath, CFile::modeRead|CFile::shareDenyNone)==false)

  0003e	6a 00		 push	 0
  00040	6a 40		 push	 64			; 00000040H
  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _strFilePath$[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0004b	50		 push	 eax
  0004c	8d 4d e0	 lea	 ecx, DWORD PTR _File$[ebp]
  0004f	e8 00 00 00 00	 call	 ?Open@CFile@@UAEHPBDIPAVCFileException@@@Z ; CFile::Open
  00054	85 c0		 test	 eax, eax
  00056	75 2b		 jne	 SHORT $LN2@GetMD5

; 30   : 	{
; 31   : 		return TEXT("");

  00058	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00066	8b 45 9c	 mov	 eax, DWORD PTR $T2[ebp]
  00069	83 c8 01	 or	 eax, 1
  0006c	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
  0006f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00076	8d 4d e0	 lea	 ecx, DWORD PTR _File$[ebp]
  00079	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  0007e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00081	eb 2b		 jmp	 SHORT $LN1@GetMD5
$LN2@GetMD5:

; 32   : 	}
; 33   : 
; 34   : 	//返回校验和
; 35   : 	return GetMD5(File);

  00083	8d 45 e0	 lea	 eax, DWORD PTR _File$[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z ; CWHMD5Checksum::GetMD5
  00090	83 c4 08	 add	 esp, 8
  00093	8b 55 9c	 mov	 edx, DWORD PTR $T2[ebp]
  00096	83 ca 01	 or	 edx, 1
  00099	89 55 9c	 mov	 DWORD PTR $T2[ebp], edx
  0009c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a3	8d 4d e0	 lea	 ecx, DWORD PTR _File$[ebp]
  000a6	e8 00 00 00 00	 call	 ??1CFile@@UAE@XZ	; CFile::~CFile
  000ab	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@GetMD5:

; 36   : }

  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _File$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFile@@UAE@XZ	; CFile::~CFile
__ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@ABV23@@Z ENDP ; CWHMD5Checksum::GetMD5
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z
_TEXT	SEGMENT
tv130 = -1360						; size = 4
tv78 = -1360						; size = 4
$T2 = -1356						; size = 4
$T3 = -1352						; size = 4
$T4 = -1348						; size = 8
_e$5 = -1148						; size = 4
_Buffer$6 = -1144					; size = 1024
_nBufferSize$7 = -120					; size = 4
_nLength$8 = -116					; size = 4
_MD5Checksum$9 = -112					; size = 92
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_File$ = 12						; size = 4
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z PROC ; CWHMD5Checksum::GetMD5, COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 40 05 00
	00		 sub	 esp, 1344		; 00000540H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00029	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00032	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0

; 41   : 	try

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 42   : 	{
; 43   : 		//变量定义
; 44   : 		CWHMD5Checksum MD5Checksum;  

  00043	8d 4d 90	 lea	 ecx, DWORD PTR _MD5Checksum$9[ebp]
  00046	e8 00 00 00 00	 call	 ??0CWHMD5Checksum@@IAE@XZ ; CWHMD5Checksum::CWHMD5Checksum
  0004b	89 85 b0 fa ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00051	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 45   : 		int nLength = 0;  

  00055	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _nLength$8[ebp], 0

; 46   : 		const int nBufferSize = 1024; 

  0005c	c7 45 88 00 04
	00 00		 mov	 DWORD PTR _nBufferSize$7[ebp], 1024 ; 00000400H
$LN2@GetMD5:

; 47   : 		BYTE Buffer[nBufferSize];  
; 48   : 
; 49   : 		//校验文件
; 50   : 		while ((nLength = File.Read( Buffer, nBufferSize )) > 0 )

  00063	68 00 04 00 00	 push	 1024			; 00000400H
  00068	8d 85 88 fb ff
	ff		 lea	 eax, DWORD PTR _Buffer$6[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _File$[ebp]
  00072	8b 11		 mov	 edx, DWORD PTR [ecx]
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _File$[ebp]
  00077	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0007a	ff d0		 call	 eax
  0007c	89 85 b0 fa ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  00082	8b 8d b0 fa ff
	ff		 mov	 ecx, DWORD PTR tv130[ebp]
  00088	89 4d 8c	 mov	 DWORD PTR _nLength$8[ebp], ecx
  0008b	83 7d 8c 00	 cmp	 DWORD PTR _nLength$8[ebp], 0
  0008f	7e 15		 jle	 SHORT $LN3@GetMD5

; 51   : 		{
; 52   : 			MD5Checksum.Update( Buffer, nLength );

  00091	8b 45 8c	 mov	 eax, DWORD PTR _nLength$8[ebp]
  00094	50		 push	 eax
  00095	8d 8d 88 fb ff
	ff		 lea	 ecx, DWORD PTR _Buffer$6[ebp]
  0009b	51		 push	 ecx
  0009c	8d 4d 90	 lea	 ecx, DWORD PTR _MD5Checksum$9[ebp]
  0009f	e8 00 00 00 00	 call	 ?Update@CWHMD5Checksum@@IAEXPAEK@Z ; CWHMD5Checksum::Update

; 53   : 		}

  000a4	eb bd		 jmp	 SHORT $LN2@GetMD5
$LN3@GetMD5:

; 54   : 
; 55   : 		//完成校验
; 56   : 		return MD5Checksum.Final();

  000a6	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a9	50		 push	 eax
  000aa	8d 4d 90	 lea	 ecx, DWORD PTR _MD5Checksum$9[ebp]
  000ad	e8 00 00 00 00	 call	 ?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CWHMD5Checksum::Final
  000b2	8b 8d b4 fa ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  000b8	83 c9 01	 or	 ecx, 1
  000bb	89 8d b4 fa ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  000c1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000c5	8d 4d 90	 lea	 ecx, DWORD PTR _MD5Checksum$9[ebp]
  000c8	e8 00 00 00 00	 call	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
  000cd	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d0	eb 5f		 jmp	 SHORT $LN5@GetMD5
__catch$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$0:

; 57   : 	}
; 58   : 	catch (CFileException* e )
; 59   : 	{
; 60   : 		TRACE0("CWHMD5Checksum::GetMD5: CFileException caught"); 

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LNOLBCMM@CWHMD5Checksum?3?3GetMD5?3?5CFileEx@
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_03CGPANDLG@?$CFTs@
  000dc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z@4JA
  000e1	83 c0 14	 add	 eax, 20			; 00000014H
  000e4	50		 push	 eax
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@LHIPHMPE@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000ea	8d 8d bc fa ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000f0	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 		throw e;

  000fe	8b 85 84 fb ff
	ff		 mov	 eax, DWORD PTR _e$5[ebp]
  00104	89 85 b8 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0010a	68 00 00 00 00	 push	 OFFSET __TI4PAVCFileException@@
  0010f	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 __CxxThrowException@8

; 62   : 	}

  0011b	b8 00 00 00 00	 mov	 eax, $LN12@GetMD5
  00120	c3		 ret	 0
  00121	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00128	eb 07		 jmp	 SHORT $LN5@GetMD5
$LN12@GetMD5:
  0012a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN5@GetMD5:

; 63   : }

  00131	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00134	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013b	59		 pop	 ecx
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00142	33 cd		 xor	 ecx, ebp
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z$2:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR _MD5Checksum$9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
__ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a ac fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1364]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCFile@@@Z ENDP ; CWHMD5Checksum::GetMD5
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z
_TEXT	SEGMENT
$T2 = -176						; size = 4
_MD5Checksum$ = -108					; size = 92
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pBuf$ = 12						; size = 4
_nLength$ = 16						; size = 4
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z PROC ; CWHMD5Checksum::GetMD5, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0

; 68   : 	AfxIsValidAddress(pBuf,nLength,FALSE);

  00038	6a 00		 push	 0
  0003a	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ?AfxIsValidAddress@@YGHPBXIH@Z ; AfxIsValidAddress

; 69   : 
; 70   : 	//变量定义
; 71   : 	CWHMD5Checksum MD5Checksum;

  00047	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0CWHMD5Checksum@@IAE@XZ ; CWHMD5Checksum::CWHMD5Checksum
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 72   : 
; 73   : 	//计算校验和
; 74   : 	MD5Checksum.Update( pBuf, nLength );

  00056	8b 45 10	 mov	 eax, DWORD PTR _nLength$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _pBuf$[ebp]
  0005d	51		 push	 ecx
  0005e	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00061	e8 00 00 00 00	 call	 ?Update@CWHMD5Checksum@@IAEXPAEK@Z ; CWHMD5Checksum::Update

; 75   : 
; 76   : 	//完成校验
; 77   : 	return MD5Checksum.Final();

  00066	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00069	50		 push	 eax
  0006a	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  0006d	e8 00 00 00 00	 call	 ?Final@CWHMD5Checksum@@IAE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; CWHMD5Checksum::Final
  00072	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  00078	83 c9 01	 or	 ecx, 1
  0007b	89 8d 50 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
  00081	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00088	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  0008b	e8 00 00 00 00	 call	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
  00090	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 78   : }

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a4	33 cd		 xor	 ecx, ebp
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR _MD5Checksum$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CWHMD5Checksum@@MAE@XZ ; CWHMD5Checksum::~CWHMD5Checksum
__ehhandler$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 4c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-180]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetMD5@CWHMD5Checksum@@SA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PAEI@Z ENDP ; CWHMD5Checksum::GetMD5
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ??1CWHMD5Checksum@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CWHMD5Checksum@@MAE@XZ PROC				; CWHMD5Checksum::~CWHMD5Checksum, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWHMD5Checksum@@6B@

; 22   : }

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1CWHMD5Checksum@@MAE@XZ ENDP				; CWHMD5Checksum::~CWHMD5Checksum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ??0CWHMD5Checksum@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CWHMD5Checksum@@IAE@XZ PROC				; CWHMD5Checksum::CWHMD5Checksum, COMDAT
; _this$ = ecx

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CWHMD5Checksum@@6B@

; 8    : 	//初始成员
; 9    : 	memset( m_lpszBuffer, 0, 64 );

  00015	6a 40		 push	 64			; 00000040H
  00017	6a 00		 push	 0
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c0 04	 add	 eax, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _memset
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 10   : 	m_nCount[0] = m_nCount[1] = 0;

  00028	b8 04 00 00 00	 mov	 eax, 4
  0002d	c1 e0 00	 shl	 eax, 0
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 44 01 44 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+68], 0
  0003b	ba 04 00 00 00	 mov	 edx, 4
  00040	6b c2 00	 imul	 eax, edx, 0
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	c7 44 01 44 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+68], 0

; 11   : 
; 12   : 	//初始变量
; 13   : 	m_lMD5[0] = MD5_INIT_STATE_0;

  0004e	b8 04 00 00 00	 mov	 eax, 4
  00053	6b c8 00	 imul	 ecx, eax, 0
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c7 44 0a 4c 01
	23 45 67	 mov	 DWORD PTR [edx+ecx+76], 1732584193 ; 67452301H

; 14   : 	m_lMD5[1] = MD5_INIT_STATE_1;

  00061	b8 04 00 00 00	 mov	 eax, 4
  00066	c1 e0 00	 shl	 eax, 0
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	c7 44 01 4c 89
	ab cd ef	 mov	 DWORD PTR [ecx+eax+76], -271733879 ; efcdab89H

; 15   : 	m_lMD5[2] = MD5_INIT_STATE_2;

  00074	b8 04 00 00 00	 mov	 eax, 4
  00079	d1 e0		 shl	 eax, 1
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	c7 44 01 4c fe
	dc ba 98	 mov	 DWORD PTR [ecx+eax+76], -1732584194 ; 98badcfeH

; 16   : 	m_lMD5[3] = MD5_INIT_STATE_3;

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	6b c8 03	 imul	 ecx, eax, 3
  0008e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00091	c7 44 0a 4c 76
	54 32 10	 mov	 DWORD PTR [edx+ecx+76], 271733878 ; 10325476H

; 17   : }

  00099	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
??0CWHMD5Checksum@@IAE@XZ ENDP				; CWHMD5Checksum::CWHMD5Checksum
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
_TEXT	SEGMENT
_ptr$ = -20						; size = 4
_ple$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pszFmt$ = 12						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 449  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 450  : 		CPreserveLastError ple;

  00028	8d 4d f0	 lea	 ecx, DWORD PTR _ple$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CPreserveLastError@ATL@@QAE@XZ ; ATL::CPreserveLastError::CPreserveLastError
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 451  : 		va_list ptr; va_start(ptr, pszFmt);

  00037	8d 45 10	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  0003a	89 45 ec	 mov	 DWORD PTR _ptr$[ebp], eax

; 452  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, atlTraceGeneral, 0, pszFmt, ptr);

  0003d	8b 45 ec	 mov	 eax, DWORD PTR _ptr$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  00044	51		 push	 ecx
  00045	6a 00		 push	 0
  00047	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  0004c	e8 00 00 00 00	 call	 ??B?$CTraceCategoryEx@$00$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<1,0>::operator unsigned int
  00051	50		 push	 eax
  00052	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00055	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z ; ATL::CTrace::TraceV
  00064	83 c4 18	 add	 esp, 24			; 00000018H

; 453  : 		va_end(ptr);

  00067	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 454  : 	}

  0006e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00075	8d 4d f0	 lea	 ecx, DWORD PTR _ple$[ebp]
  00078	e8 00 00 00 00	 call	 ??1CPreserveLastError@ATL@@QAE@XZ ; ATL::CPreserveLastError::~CPreserveLastError
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ$0:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _ple$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CPreserveLastError@ATL@@QAE@XZ ; ATL::CPreserveLastError::~CPreserveLastError
__ehhandler$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??RCTraceFileAndLineInfo@ATL@@QBAXPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 411  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _nLineNo$[ebp]
  0001a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 412  : 	}

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??1CPreserveLastError@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CPreserveLastError@ATL@@QAE@XZ PROC			; ATL::CPreserveLastError::~CPreserveLastError, COMDAT
; _this$ = ecx

; 396  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 397  : 		SetLastError(m_dwLastError);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 398  : 	}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??1CPreserveLastError@ATL@@QAE@XZ ENDP			; ATL::CPreserveLastError::~CPreserveLastError
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0CPreserveLastError@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CPreserveLastError@ATL@@QAE@XZ PROC			; ATL::CPreserveLastError::CPreserveLastError, COMDAT
; _this$ = ecx

; 390  : 	CPreserveLastError()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	{
; 392  : 		m_dwLastError = GetLastError();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 393  : 	}

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0CPreserveLastError@ATL@@QAE@XZ ENDP			; ATL::CPreserveLastError::CPreserveLastError
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::~CHeapPtr<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::~CHeapPtr<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -8						; size = 4
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 456  : 		size_t nBytes=0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nBytes$[ebp], 0

; 457  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

  00013	6a 01		 push	 1
  00015	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00018	50		 push	 eax
  00019	8d 4d f8	 lea	 ecx, DWORD PTR _nBytes$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
  00025	85 c0		 test	 eax, eax
  00027	7d 04		 jge	 SHORT $LN2@Allocate

; 458  : 		{
; 459  : 			return false;

  00029	32 c0		 xor	 al, al
  0002b	eb 0c		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 460  : 		}
; 461  : 		return this->AllocateBytes(nBytes);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes
$LN1@Allocate:

; 462  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 434  : 	CHeapPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 435  : 	{

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>

; 436  : 	}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 407  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : 		Allocator::Free(m_pData);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00017	83 c4 04	 add	 esp, 4

; 409  : 		m_pData = NULL;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 410  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 381  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 382  : 		ATLASSERT(m_pData == NULL);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 27		 je	 SHORT $LN4@AllocateBy
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  0001e	6a 00		 push	 0
  00020	68 7e 01 00 00	 push	 382			; 0000017eH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_1OE@IAPLKPHI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 01		 jne	 SHORT $LN4@AllocateBy
  0003a	cc		 int	 3
$LN4@AllocateBy:

; 383  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0003b	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00044	83 c4 04	 add	 esp, 4
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 01		 mov	 DWORD PTR [ecx], eax

; 384  : 		if (m_pData == NULL)

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00052	75 04		 jne	 SHORT $LN2@AllocateBy

; 385  : 			return false;

  00054	32 c0		 xor	 al, al
  00056	eb 02		 jmp	 SHORT $LN1@AllocateBy
$LN2@AllocateBy:

; 386  : 
; 387  : 		return true;

  00058	b0 01		 mov	 al, 1
$LN1@AllocateBy:

; 388  : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 363  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 364  : 		return m_pData;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 365  : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 349  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 350  : 		Free();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free

; 351  : 	}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 336  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		m_pData(NULL)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 337  : 	}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -8						; size = 4
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 456  : 		size_t nBytes=0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _nBytes$[ebp], 0

; 457  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

  00013	6a 02		 push	 2
  00015	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00018	50		 push	 eax
  00019	8d 4d f8	 lea	 ecx, DWORD PTR _nBytes$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
  00025	85 c0		 test	 eax, eax
  00027	7d 04		 jge	 SHORT $LN2@Allocate

; 458  : 		{
; 459  : 			return false;

  00029	32 c0		 xor	 al, al
  0002b	eb 0c		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 460  : 		}
; 461  : 		return this->AllocateBytes(nBytes);

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00030	50		 push	 eax
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
$LN1@Allocate:

; 462  : 	}

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 434  : 	CHeapPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 435  : 	{

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>

; 436  : 	}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 407  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : 		Allocator::Free(m_pData);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  00017	83 c4 04	 add	 esp, 4

; 409  : 		m_pData = NULL;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 410  : 	}

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 381  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 382  : 		ATLASSERT(m_pData == NULL);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 27		 je	 SHORT $LN4@AllocateBy
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  0001e	6a 00		 push	 0
  00020	68 7e 01 00 00	 push	 382			; 0000017eH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_1OE@IAPLKPHI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 01		 jne	 SHORT $LN4@AllocateBy
  0003a	cc		 int	 3
$LN4@AllocateBy:

; 383  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0003b	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00044	83 c4 04	 add	 esp, 4
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 01		 mov	 DWORD PTR [ecx], eax

; 384  : 		if (m_pData == NULL)

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00052	75 04		 jne	 SHORT $LN2@AllocateBy

; 385  : 			return false;

  00054	32 c0		 xor	 al, al
  00056	eb 02		 jmp	 SHORT $LN1@AllocateBy
$LN2@AllocateBy:

; 386  : 
; 387  : 		return true;

  00058	b0 01		 mov	 al, 1
$LN1@AllocateBy:

; 388  : 	}

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 363  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 364  : 		return m_pData;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 365  : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 349  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 350  : 		Free();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free

; 351  : 	}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 336  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 		m_pData(NULL)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 337  : 	}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z
_TEXT	SEGMENT
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 329  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 330  : 		if (pszCategory == nullptr)

  00016	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  0001a	75 05		 jne	 SHORT $LN2@RegisterCa

; 331  : 		{
; 332  : 			return;

  0001c	e9 a9 00 00 00	 jmp	 $LN1@RegisterCa
$LN2@RegisterCa:

; 333  : 		}
; 334  : 
; 335  : 		if (m_nLastCategory >= MaxCategoryArray) 

  00021	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00028	72 2d		 jb	 SHORT $LN3@RegisterCa

; 336  : 		{
; 337  : 			ATLASSERT(false && "Too many categories defined");

  0002a	33 c0		 xor	 eax, eax
  0002c	75 27		 jne	 SHORT $LN5@RegisterCa
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  00038	6a 00		 push	 0
  0003a	68 51 01 00 00	 push	 337			; 00000151H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00044	6a 02		 push	 2
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0004c	83 c4 18	 add	 esp, 24			; 00000018H
  0004f	83 f8 01	 cmp	 eax, 1
  00052	75 01		 jne	 SHORT $LN5@RegisterCa
  00054	cc		 int	 3
$LN5@RegisterCa:

; 338  : 			return;

  00055	eb 73		 jmp	 SHORT $LN1@RegisterCa
$LN3@RegisterCa:

; 339  : 		}
; 340  : 
; 341  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00057	69 05 00 00 00
	00 04 01 00 00	 imul	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _nCategory$[ebp]
  00064	89 88 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax], ecx

; 342  : #ifdef _UNICODE
; 343  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);
; 344  : #else
; 345  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	

  0006a	68 00 01 00 00	 push	 256			; 00000100H
  0006f	6a 00		 push	 0
  00071	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _memset
  0007d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 346  : #if _MSC_VER < 1900
; 347  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 348  : #else
; 349  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%hs", pszCategory);

  00080	8b 45 08	 mov	 eax, DWORD PTR _pszCategory$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
  00089	6a 7f		 push	 127			; 0000007fH
  0008b	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _swprintf_s
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 350  : #endif
; 351  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);

  0009a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  000a0	50		 push	 eax
  000a1	6a 7f		 push	 127			; 0000007fH
  000a3	69 0d 00 00 00
	00 04 01 00 00	 imul	 ecx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  000ad	81 c1 04 00 00
	00		 add	 ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  000b3	51		 push	 ecx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 352  : #endif
; 353  : 	
; 354  : 		m_nLastCategory++;

  000bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000c2	83 c0 01	 add	 eax, 1
  000c5	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN1@RegisterCa:

; 355  : 	}

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d0	33 cd		 xor	 ecx, ebp
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c3		 ret	 0
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z
_TEXT	SEGMENT
_wszBuf$ = -24						; size = 4
_szBuf$ = -20						; size = 4
_cchNeeded$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 239  : 		int cchNeeded = _vscprintf(pszFmt, args);

  00028	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 18	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 __vscprintf
  00035	83 c4 08	 add	 esp, 8
  00038	89 45 f0	 mov	 DWORD PTR _cchNeeded$[ebp], eax

; 240  : 		if (cchNeeded < 0)

  0003b	83 7d f0 00	 cmp	 DWORD PTR _cchNeeded$[ebp], 0
  0003f	7d 05		 jge	 SHORT $LN2@TraceV

; 241  : 		{
; 242  : 			return;

  00041	e9 64 01 00 00	 jmp	 $LN1@TraceV
$LN2@TraceV:

; 243  : 		}
; 244  : 
; 245  : 		CHeapPtr<char> szBuf;

  00046	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00049	e8 00 00 00 00	 call	 ??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 246  : 		if (!szBuf.Allocate(cchNeeded + 1))

  00055	8b 45 f0	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	50		 push	 eax
  0005c	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  0005f	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate
  00064	0f b6 c8	 movzx	 ecx, al
  00067	85 c9		 test	 ecx, ecx
  00069	75 14		 jne	 SHORT $LN3@TraceV

; 247  : 		{
; 248  : 			return;

  0006b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00072	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00075	e8 00 00 00 00	 call	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0007a	e9 2b 01 00 00	 jmp	 $LN1@TraceV
$LN3@TraceV:

; 249  : 		}
; 250  : 
; 251  : 		szBuf[0] = '\0';

  0007f	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00082	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
  00087	b9 01 00 00 00	 mov	 ecx, 1
  0008c	6b d1 00	 imul	 edx, ecx, 0
  0008f	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 252  : 
; 253  : 		if (_vsnprintf_s(szBuf, cchNeeded + 1, cchNeeded, pszFmt, args) == -1)

  00093	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  00096	50		 push	 eax
  00097	8b 4d 18	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 f0	 mov	 edx, DWORD PTR _cchNeeded$[ebp]
  0009e	52		 push	 edx
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	50		 push	 eax
  000a6	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  000a9	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 __vsnprintf_s
  000b4	83 c4 14	 add	 esp, 20			; 00000014H
  000b7	83 f8 ff	 cmp	 eax, -1
  000ba	75 14		 jne	 SHORT $LN4@TraceV

; 254  : 		{
; 255  : 			return;

  000bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c3	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  000c6	e8 00 00 00 00	 call	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  000cb	e9 da 00 00 00	 jmp	 $LN1@TraceV
$LN4@TraceV:

; 256  : 		}
; 257  : 
; 258  : 		CHeapPtr<wchar_t> wszBuf;

  000d0	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000d3	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
  000d8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 259  : 		if (!wszBuf.Allocate(cchNeeded + 1))

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  000df	83 c0 01	 add	 eax, 1
  000e2	50		 push	 eax
  000e3	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000e6	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  000eb	0f b6 c8	 movzx	 ecx, al
  000ee	85 c9		 test	 ecx, ecx
  000f0	75 20		 jne	 SHORT $LN5@TraceV

; 260  : 		{
; 261  : 			return;

  000f2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f6	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000f9	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  000fe	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00105	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00108	e8 00 00 00 00	 call	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0010d	e9 98 00 00 00	 jmp	 $LN1@TraceV
$LN5@TraceV:

; 262  : 		}
; 263  : 
; 264  : 		wszBuf[0] = '\0';

  00112	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00115	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  0011a	b9 02 00 00 00	 mov	 ecx, 2
  0011f	6b d1 00	 imul	 edx, ecx, 0
  00122	33 c9		 xor	 ecx, ecx
  00124	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 265  : 
; 266  : 		if (::MultiByteToWideChar(CP_ACP, 0, szBuf, -1, wszBuf, cchNeeded + 1) == 0)

  00128	8b 45 f0	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  0012b	83 c0 01	 add	 eax, 1
  0012e	50		 push	 eax
  0012f	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00132	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  00137	50		 push	 eax
  00138	6a ff		 push	 -1
  0013a	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  0013d	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
  00142	50		 push	 eax
  00143	6a 00		 push	 0
  00145	6a 00		 push	 0
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  0014d	85 c0		 test	 eax, eax
  0014f	75 1d		 jne	 SHORT $LN6@TraceV

; 267  : 		{
; 268  : 			return;

  00151	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00155	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00158	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0015d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00164	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00167	e8 00 00 00 00	 call	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0016c	eb 3c		 jmp	 SHORT $LN1@TraceV
$LN6@TraceV:

; 269  : 		}
; 270  : 
; 271  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

  0016e	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00171	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  00176	50		 push	 eax
  00177	8b 45 14	 mov	 eax, DWORD PTR _nLevel$[ebp]
  0017a	50		 push	 eax
  0017b	8b 4d 10	 mov	 ecx, DWORD PTR _dwCategory$[ebp]
  0017e	51		 push	 ecx
  0017f	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00182	52		 push	 edx
  00183	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00186	50		 push	 eax
  00187	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ; ATL::CTrace::TraceV
  0018c	83 c4 14	 add	 esp, 20			; 00000014H

; 272  : 	}

  0018f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00193	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00196	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0019b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001a2	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  001a5	e8 00 00 00 00	 call	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN1@TraceV:
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b4	59		 pop	 ecx
  001b5	5f		 pop	 edi
  001b6	5e		 pop	 esi
  001b7	5b		 pop	 ebx
  001b8	8b e5		 mov	 esp, ebp
  001ba	5d		 pop	 ebp
  001bb	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z$0:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _szBuf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z$1:
  00008	8d 4d e8	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_fileName$ = -2588					; size = 520
_wszBuf$ = -2068					; size = 4
_chCount$ = -2064					; size = 4
_pwszCategoryName$ = -2060				; size = 4
_categoryLength$ = -2056				; size = 4
_wszCategory$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 150  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 9c 0b 00
	00		 sub	 esp, 2972		; 00000b9cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 151  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_nLevel@CTrace@ATL@@1IA, -1 ; ATL::CTrace::m_nLevel
  0001d	74 14		 je	 SHORT $LN3@TraceV
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
  00024	3b 45 14	 cmp	 eax, DWORD PTR _nLevel$[ebp]
  00027	72 0a		 jb	 SHORT $LN3@TraceV
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nCategory
  0002e	23 45 10	 and	 eax, DWORD PTR _dwCategory$[ebp]
  00031	75 05		 jne	 SHORT $LN2@TraceV
$LN3@TraceV:

; 152  : 		{
; 153  : 			return;

  00033	e9 c2 01 00 00	 jmp	 $LN1@TraceV
$LN2@TraceV:

; 154  : 		}
; 155  : 
; 156  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};

  00038	68 00 08 00 00	 push	 2048			; 00000800H
  0003d	6a 00		 push	 0
  0003f	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _memset
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 157  : 		int categoryLength = 0;

  0004e	c7 85 f8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _categoryLength$[ebp], 0

; 158  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

  00058	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ; ATL::CTrace::GetCategoryName
  00061	83 c4 04	 add	 esp, 4
  00064	89 85 f4 f7 ff
	ff		 mov	 DWORD PTR _pwszCategoryName$[ebp], eax

; 159  : 		if (pwszCategoryName != nullptr)

  0006a	83 bd f4 f7 ff
	ff 00		 cmp	 DWORD PTR _pwszCategoryName$[ebp], 0
  00071	74 36		 je	 SHORT $LN4@TraceV

; 160  : 		{
; 161  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%ls - ", pwszCategoryName)) == -1)

  00073	8b 85 f4 f7 ff
	ff		 mov	 eax, DWORD PTR _pwszCategoryName$[ebp]
  00079	50		 push	 eax
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5@
  0007f	68 00 04 00 00	 push	 1024			; 00000400H
  00084	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 _swprintf_s
  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  00099	83 bd f8 f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  000a0	75 05		 jne	 SHORT $LN6@TraceV

; 162  : 			{
; 163  : 				return;

  000a2	e9 53 01 00 00	 jmp	 $LN1@TraceV
$LN6@TraceV:

; 164  : 			}
; 165  : 		}
; 166  : 		else

  000a7	eb 31		 jmp	 SHORT $LN5@TraceV
$LN4@TraceV:

; 167  : 		{
; 168  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

  000a9	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  000ac	50		 push	 eax
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5@
  000b2	68 00 04 00 00	 push	 1024			; 00000400H
  000b7	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _swprintf_s
  000c3	83 c4 10	 add	 esp, 16			; 00000010H
  000c6	89 85 f8 f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  000cc	83 bd f8 f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  000d3	75 05		 jne	 SHORT $LN5@TraceV

; 169  : 			{
; 170  : 				return;

  000d5	e9 20 01 00 00	 jmp	 $LN1@TraceV
$LN5@TraceV:

; 171  : 			}
; 172  : 		}
; 173  : 
; 174  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

  000da	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  000dd	50		 push	 eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  000e4	83 c4 04	 add	 esp, 4
  000e7	8b 8d f8 f7 ff
	ff		 mov	 ecx, DWORD PTR _categoryLength$[ebp]
  000ed	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  000f1	89 95 f0 f7 ff
	ff		 mov	 DWORD PTR _chCount$[ebp], edx

; 175  : 		CHeapPtr<wchar_t> wszBuf;

  000f7	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000fd	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>

; 176  : 		if (!wszBuf.Allocate(chCount))

  00102	8b 85 f0 f7 ff
	ff		 mov	 eax, DWORD PTR _chCount$[ebp]
  00108	50		 push	 eax
  00109	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0010f	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  00114	0f b6 c8	 movzx	 ecx, al
  00117	85 c9		 test	 ecx, ecx
  00119	75 10		 jne	 SHORT $LN8@TraceV

; 177  : 		{
; 178  : 			return;

  0011b	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00121	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  00126	e9 cf 00 00 00	 jmp	 $LN1@TraceV
$LN8@TraceV:

; 179  : 		}
; 180  : 
; 181  : 		wszBuf[0] = '\0';

  0012b	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00131	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  00136	b9 02 00 00 00	 mov	 ecx, 2
  0013b	6b d1 00	 imul	 edx, ecx, 0
  0013e	33 c9		 xor	 ecx, ecx
  00140	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 182  : 
; 183  : 		if (swprintf_s(wszBuf, chCount, L"%ls%ls", wszCategory, pwszMessage) == -1)

  00144	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  00147	50		 push	 eax
  00148	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  0014e	51		 push	 ecx
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs@
  00154	8b 95 f0 f7 ff
	ff		 mov	 edx, DWORD PTR _chCount$[ebp]
  0015a	52		 push	 edx
  0015b	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00161	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  00166	50		 push	 eax
  00167	e8 00 00 00 00	 call	 _swprintf_s
  0016c	83 c4 14	 add	 esp, 20			; 00000014H
  0016f	83 f8 ff	 cmp	 eax, -1
  00172	75 0d		 jne	 SHORT $LN9@TraceV

; 184  : 		{
; 185  : 			return;

  00174	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0017f	eb 79		 jmp	 SHORT $LN1@TraceV
$LN9@TraceV:

; 186  : 		}
; 187  : 
; 188  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	

  00181	68 08 02 00 00	 push	 520			; 00000208H
  00186	6a 00		 push	 0
  00188	8d 85 e4 f5 ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  0018e	50		 push	 eax
  0018f	e8 00 00 00 00	 call	 _memset
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 189  : #if _MSC_VER < 1900
; 190  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)
; 191  : #else
; 192  : 		if (swprintf_s(fileName, _MAX_PATH, L"%hs", pszFileName) == -1)

  00197	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  0019a	50		 push	 eax
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
  001a0	68 04 01 00 00	 push	 260			; 00000104H
  001a5	8d 8d e4 f5 ff
	ff		 lea	 ecx, DWORD PTR _fileName$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 _swprintf_s
  001b1	83 c4 10	 add	 esp, 16			; 00000010H
  001b4	83 f8 ff	 cmp	 eax, -1
  001b7	75 0d		 jne	 SHORT $LN10@TraceV

; 193  : #endif
; 194  : 		{
; 195  : 			return;

  001b9	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001bf	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  001c4	eb 34		 jmp	 SHORT $LN1@TraceV
$LN10@TraceV:

; 196  : 		}
; 197  : 
; 198  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%ls", static_cast<const wchar_t*>(wszBuf));

  001c6	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001cc	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  001d1	50		 push	 eax
  001d2	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  001d7	6a 00		 push	 0
  001d9	8b 45 0c	 mov	 eax, DWORD PTR _nLine$[ebp]
  001dc	50		 push	 eax
  001dd	8d 8d e4 f5 ff
	ff		 lea	 ecx, DWORD PTR _fileName$[ebp]
  001e3	51		 push	 ecx
  001e4	6a 00		 push	 0
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  001ec	83 c4 18	 add	 esp, 24			; 00000018H

; 199  : 	}

  001ef	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001f5	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN1@TraceV:
  001fa	5f		 pop	 edi
  001fb	5e		 pop	 esi
  001fc	5b		 pop	 ebx
  001fd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00200	33 cd		 xor	 ecx, ebp
  00202	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c3		 ret	 0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 132  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 133  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN4@GetCategor
$LN2@GetCategor:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetCategor:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  00024	73 22		 jae	 SHORT $LN3@GetCategor

; 134  : 		{
; 135  : 			if (m_nMap[i].nCategory == nCategory)

  00026	69 45 fc 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  0002d	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax]
  00033	3b 4d 08	 cmp	 ecx, DWORD PTR _nCategory$[ebp]
  00036	75 0e		 jne	 SHORT $LN5@GetCategor

; 136  : 			{
; 137  : 				return m_nMap[i].categryName;

  00038	69 45 fc 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  0003f	05 04 00 00 00	 add	 eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  00044	eb 04		 jmp	 SHORT $LN1@GetCategor
$LN5@GetCategor:

; 138  : 			}
; 139  : 		}

  00046	eb ca		 jmp	 SHORT $LN2@GetCategor
$LN3@GetCategor:

; 140  : 
; 141  : 		return nullptr;

  00048	33 c0		 xor	 eax, eax
$LN1@GetCategor:

; 142  : 	}

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceString@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceString@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceString'', COMDAT

; 114  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceString> atlTraceString(_T("atlTraceString"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MBNHGHMI@atlTraceString@
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
  00013	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??__EatlTraceString@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceString''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000c	68 00 00 02 00	 push	 131072			; 00020000H
  00011	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  0001a	83 c4 08	 add	 esp, 8

; 482  : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PGMFNIFA@atlTraceException@
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  00013	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000c	68 00 20 00 00	 push	 8192			; 00002000H
  00011	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  0001a	83 c4 08	 add	 esp, 8

; 482  : }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceGeneral@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceGeneral@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceGeneral'', COMDAT

; 97   : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceGeneral> atlTraceGeneral(_T("atlTraceGeneral"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@MKMIKKJB@atlTraceGeneral@
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
  00013	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??__EatlTraceGeneral@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceGeneral''
text$di	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$00$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTraceCategoryEx@$00$0A@@ATL@@QAEIXZ PROC		; ATL::CTraceCategoryEx<1,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 79   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : #ifdef _DEBUG
; 81   : 		return traceCategory;

  0000c	b8 01 00 00 00	 mov	 eax, 1

; 82   : #else
; 83   : 		return 0;
; 84   : #endif
; 85   : 	}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??B?$CTraceCategoryEx@$00$0A@@ATL@@QAEIXZ ENDP		; ATL::CTraceCategoryEx<1,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  0000c	6a 01		 push	 1
  0000e	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  00017	83 c4 08	 add	 esp, 8

; 482  : }

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 266  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 267  : 		free(p);

  00009	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00013	83 c4 04	 add	 esp, 4

; 268  : 	}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 261  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 262  : 		return malloc(nBytes);

  00009	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00013	83 c4 04	 add	 esp, 4

; 263  : 	}

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -8					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 136  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  0000c	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _i64Result$[ebp], eax
  00012	89 55 fc	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 137  : 	if(i64Result>UINT_MAX)

  00015	83 7d fc 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  00019	77 06		 ja	 SHORT $LN4@AtlMultipl
  0001b	83 7d f8 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  0001f	76 0f		 jbe	 SHORT $LN2@AtlMultipl
$LN4@AtlMultipl:

; 138  : 	{
; 139  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00021	68 16 02 00 00	 push	 534			; 00000216H
  00026	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 0a		 jmp	 SHORT $LN1@AtlMultipl
$LN2@AtlMultipl:

; 140  : 	}
; 141  : 	*piResult=static_cast<unsigned int>(i64Result);

  00030	8b 45 f8	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 142  : 	return S_OK;

  00038	33 c0		 xor	 eax, eax
$LN1@AtlMultipl:

; 143  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_bResult$ = -36						; size = 4
_bQuit$ = -32						; size = 4
_msg$ = -28						; size = 28
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00009	6a 01		 push	 1
  0000b	6a 12		 push	 18			; 00000012H
  0000d	6a 12		 push	 18			; 00000012H
  0000f	6a 00		 push	 0
  00011	8d 45 e4	 lea	 eax, DWORD PTR _msg$[ebp]
  00014	50		 push	 eax
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  0001b	89 45 e0	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	8b 45 0c	 mov	 eax, DWORD PTR _nLine$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _lpszFileName$[ebp]
  00029	51		 push	 ecx
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00032	83 c4 14	 add	 esp, 20			; 00000014H
  00035	89 45 dc	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00038	83 7d e0 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  0003c	74 0a		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0003e	8b 45 ec	 mov	 eax, DWORD PTR _msg$[ebp+8]
  00041	50		 push	 eax
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00048	8b 45 dc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 08 00	 ret	 8
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vscprintf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__ArgList$ = 12						; size = 4
__vscprintf PROC					; COMDAT

; 1675 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1676 :         return _vscprintf_l(_Format, NULL, _ArgList);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __vscprintf_l
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1677 :     }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
__vscprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vscprintf_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
__Locale$ = 12						; size = 4
__ArgList$ = 16						; size = 4
__vscprintf_l PROC					; COMDAT

; 1658 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1659 :         int const _Result = __stdio_common_vsprintf(

  00009	8b 45 10	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	6a 00		 push	 0
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	83 c9 02	 or	 ecx, 2
  00023	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00026	52		 push	 edx
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0002e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00031	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1660 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1661 :             NULL, 0, _Format, _Locale, _ArgList);
; 1662 : 
; 1663 :         return _Result < 0 ? -1 : _Result;

  00034	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00038	7d 09		 jge	 SHORT $LN3@vscprintf_
  0003a	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00041	eb 06		 jmp	 SHORT $LN4@vscprintf_
$LN3@vscprintf_:
  00043	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00046	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vscprintf_:
  00049	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1664 :     }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
__vscprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__MaxCount$ = 16					; size = 4
__Format$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_s PROC					; COMDAT

; 1605 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1606 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	8b 4d 14	 mov	 ecx, DWORD PTR __Format$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 10	 mov	 edx, DWORD PTR __MaxCount$[ebp]
  00016	52		 push	 edx
  00017	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 __vsnprintf_s_l
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 1607 :     }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_s_l
_TEXT	SEGMENT
tv74 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__MaxCount$ = 16					; size = 4
__Format$ = 20						; size = 4
__Locale$ = 24						; size = 4
__ArgList$ = 28						; size = 4
__vsnprintf_s_l PROC					; COMDAT

; 1584 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1585 :         int const _Result = __stdio_common_vsnprintf_s(

  00009	8b 45 1c	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 18	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 14	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 10	 mov	 eax, DWORD PTR __MaxCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __BufferCount$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00026	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00029	51		 push	 ecx
  0002a	8b 10		 mov	 edx, DWORD PTR [eax]
  0002c	52		 push	 edx
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsnprintf_s
  00033	83 c4 20	 add	 esp, 32			; 00000020H
  00036	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1586 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1587 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1588 : 
; 1589 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0003d	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003f	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00046	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00048	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0004b	89 45 b8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf_:
  0004e	8b 45 b8	 mov	 eax, DWORD PTR tv74[ebp]

; 1590 :     }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
__vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1538 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1539 :             int _Result;
; 1540 :             va_list _ArgList;
; 1541 :             __crt_va_start(_ArgList, _Format);

  00009	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  0000c	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1542 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0001c	52		 push	 edx
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 __vswprintf_s_l
  00026	83 c4 14	 add	 esp, 20			; 00000014H
  00029	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1543 :             __crt_va_end(_ArgList);

  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1544 :             return _Result;

  00033	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1545 :         }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
tv73 = -72						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1264 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1265 :         int const _Result = __stdio_common_vswprintf_s(

  00009	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00014	52		 push	 edx
  00015	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00025	52		 push	 edx
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00032	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1266 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1267 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1268 : 
; 1269 :         return _Result < 0 ? -1 : _Result;

  00035	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00039	7d 09		 jge	 SHORT $LN3@vswprintf_
  0003b	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  00042	eb 06		 jmp	 SHORT $LN4@vswprintf_
$LN3@vswprintf_:
  00044	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  00047	89 45 b8	 mov	 DWORD PTR tv73[ebp], eax
$LN4@vswprintf_:
  0004a	8b 45 b8	 mov	 eax, DWORD PTR tv73[ebp]

; 1270 :     }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00009	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  0000e	5f		 pop	 edi
  0000f	5e		 pop	 esi
  00010	5b		 pop	 ebx
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -68						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 28640: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0000d	7f 08		 jg	 SHORT $LN3@HRESULT_FR
  0000f	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00012	89 45 bc	 mov	 DWORD PTR tv68[ebp], eax
  00015	eb 18		 jmp	 SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00020	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  00026	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  0002c	89 4d bc	 mov	 DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
  0002f	8b 45 bc	 mov	 eax, DWORD PTR tv68[ebp]
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
; File g:\网狐\happygamewh\服务端\系统模块\公共组件\服务核心\whmd5checksum.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /ZI
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -68						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@vector:
  00009	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000c	89 45 bc	 mov	 DWORD PTR tv66[ebp], eax
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  00012	83 e9 01	 sub	 ecx, 1
  00015	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00018	83 7d bc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001c	76 11		 jbe	 SHORT $LN1@vector
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  00021	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00027	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  0002a	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  0002d	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
