; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\服务器组件\内核引擎\TCPNetworkEngine.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ ; `string'
PUBLIC	??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::file_level_metadata
PUBLIC	?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
PUBLIC	?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
PUBLIC	?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_
PUBLIC	?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
PUBLIC	?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
PUBLIC	?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_
PUBLIC	?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_
PUBLIC	?offsets@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@2QBIB ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::offsets
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@		; `string'
PUBLIC	??_C@_0BC@PGMFNIFA@atlTraceException@		; `string'
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
_BSS	SEGMENT
?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A DQ 07H DUP (?) ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::file_level_metadata
?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A DB 028H DUP (?) ; NullPmd::_command_default_instance_
?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A DB 020H DUP (?) ; NullPmd::_head_default_instance_
?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A DB 018H DUP (?) ; NullPmd::_indication_default_instance_
?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A DB 030H DUP (?) ; NullPmd::_info_default_instance_
?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A DB 020H DUP (?) ; NullPmd::_message_default_instance_
?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A DB 018H DUP (?) ; NullPmd::_request_default_instance_
?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A DB 020H DUP (?) ; NullPmd::_response_default_instance_
_BSS	ENDS
;	COMDAT ??_C@_0BC@PGMFNIFA@atlTraceException@
CONST	SEGMENT
??_C@_0BC@PGMFNIFA@atlTraceException@ DB 'atlTraceException', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@ DB '%', 00H, 'l', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
CONST	SEGMENT
?kMinRepeatedFieldAllocationSize@internal@protobuf@google@@3HB DD 04H ; google::protobuf::internal::kMinRepeatedFieldAllocationSize
?IID_ITraceServiceManager@@3U_GUID@@B DD 08bfc36dbH	; IID_ITraceServiceManager
	DW	05ba2H
	DW	042baH
	DB	081H
	DB	0b0H
	DB	087H
	DB	0b0H
	DB	01cH
	DB	09eH
	DB	0afH
	DB	0feH
?IID_IServiceModule@@3U_GUID@@B DD 05980504H		; IID_IServiceModule
	DW	0a2f2H
	DW	04b0fH
	DB	09bH
	DB	054H
	DB	051H
	DB	054H
	DB	01eH
	DB	05H
	DB	05cH
	DB	0ffH
?IID_IAsynchronismEngine@@3U_GUID@@B DD 0c7a13074H	; IID_IAsynchronismEngine
	DW	075c5H
	DW	04b8eH
	DB	0b5H
	DB	04bH
	DB	0eeH
	DB	0eH
	DB	0ecH
	DB	0feH
	DB	0b9H
	DB	0ebH
?IID_IAsynchronismEngineSink@@3U_GUID@@B DD 02edf5c9eH	; IID_IAsynchronismEngineSink
	DW	02cacH
	DW	0461dH
	DB	0a7H
	DB	082H
	DB	02eH
	DB	02fH
	DB	0e1H
	DB	091H
	DB	080H
	DB	0f8H
?IID_IDataBase@@3U_GUID@@B DD 0a2e38a78H		; IID_IDataBase
	DW	01e4fH
	DW	04de4H
	DB	0a5H
	DB	0d1H
	DB	0b9H
	DB	019H
	DB	09bH
	DB	0ceH
	DB	041H
	DB	0aeH
?IID_IDataBaseEngine@@3U_GUID@@B DD 047b5a119H		; IID_IDataBaseEngine
	DW	01676H
	DW	049a3H
	DB	0beH
	DB	0aeH
	DB	0caH
	DB	027H
	DB	0ebH
	DB	059H
	DB	097H
	DB	022H
?IID_IUDPNetworkEngine@@3U_GUID@@B DD 08d138a9bH	; IID_IUDPNetworkEngine
	DW	0a97dH
	DW	04d51H
	DB	09dH
	DB	06cH
	DB	0d8H
	DB	06eH
	DB	0a1H
	DB	084H
	DB	045H
	DB	02eH
?IID_ITCPNetworkEngine@@3U_GUID@@B DD 07747f683H	; IID_ITCPNetworkEngine
	DW	0c0daH
	DW	04588H
	DB	089H
	DB	0ccH
	DB	015H
	DB	093H
	DB	0acH
	DB	0c0H
	DB	044H
	DB	0c8H
?IID_ITCPSocketService@@3U_GUID@@B DD 0709a4449H	; IID_ITCPSocketService
	DW	0ad77H
	DW	04b3dH
	DB	0b4H
	DB	0d6H
	DB	08dH
	DB	0bH
	DB	028H
	DB	065H
	DB	0ecH
	DB	0aeH
?IID_IWEBSocketService@@3U_GUID@@B DD 091052ff2H	; IID_IWEBSocketService
	DW	0eb29H
	DW	040b9H
	DB	0b2H
	DB	0a2H
	DB	08aH
	DB	0a2H
	DB	098H
	DB	036H
	DB	02cH
	DB	084H
?IID_ITimerEngine@@3U_GUID@@B DD 0496401aeH		; IID_ITimerEngine
	DW	06fb0H
	DW	04e9fH
	DB	090H
	DB	098H
	DB	044H
	DB	09dH
	DB	09cH
	DB	0b2H
	DB	0bdH
	DB	097H
?file_default_instances@protobuf_NullPmd_2eproto@NullPmd@@3QBQBVMessage@protobuf@google@@B DD FLAT:?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::protobuf_NullPmd_2eproto::file_default_instances
	DD	FLAT:?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A
	DD	FLAT:?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A
	DD	FLAT:?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A
	DD	FLAT:?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A
	DD	FLAT:?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A
	DD	FLAT:?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A
?schemas@protobuf_NullPmd_2eproto@NullPmd@@3QBUMigrationSchema@internal@protobuf@google@@B DD 00H ; NullPmd::protobuf_NullPmd_2eproto::schemas
	DD	0ffffffffH
	DD	0cH
	DD	04H
	DD	0ffffffffH
	DD	014H
	DD	0aH
	DD	0ffffffffH
	DD	0cH
	DD	0eH
	DD	0ffffffffH
	DD	020H
	DD	014H
	DD	0ffffffffH
	DD	028H
	DD	01bH
	DD	0ffffffffH
	DD	014H
	DD	021H
	DD	0ffffffffH
	DD	014H
?IID_ITCPNetworkEngineEvent@@3U_GUID@@B DD 0b7e6da53H	; IID_ITCPNetworkEngineEvent
	DW	0fca5H
	DW	04d90H
	DB	085H
	DB	048H
	DB	0feH
	DB	05H
	DB	0f6H
	DB	0b4H
	DB	0c0H
	DB	0efH
?IID_IAttemperEngine@@3U_GUID@@B DD 0b070b2cH		; IID_IAttemperEngine
	DW	09d72H
	DW	042d2H
	DB	0a5H
	DB	070H
	DB	0baH
	DB	02cH
	DB	0bfH
	DB	06fH
	DB	0bbH
	DB	01cH
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
	ORG $+3
?offsets@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@2QBIB DD 0ffffffffH ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::offsets
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0cH
	DD	08H
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	08H
	DD	010H
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	08H
	DD	010H
	DD	018H
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	08H
	DD	0cH
	DD	0ffffffffH
	DD	04H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0cH
	DD	08H
?IID_IUnknownEx@@3U_GUID@@B DD 05feec21eH		; IID_IUnknownEx
	DW	0dbf3H
	DW	046f0H
	DB	09fH
	DB	057H
	DB	0d1H
	DB	0cdH
	DB	071H
	DB	01cH
	DB	046H
	DB	0deH
CONST	ENDS
;	COMDAT ??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm'
	DB	00H, 'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't'
	DB	00H, 'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@ DB '%', 00H, 'h', 00H, 's', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	_swprintf_s
PUBLIC	__snprintf
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPBDI@Z		; ATL::CTrace::RegisterCategory
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z	; std::_Container_base12::_Swap_all
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??1_Ref_count_base@std@@UAE@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	?_Decref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	?InterfaceVersionCompare@@YA_NKK@Z		; InterfaceVersionCompare
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0ByteBuffer@net@zl@@QAE@XZ			; zl::net::ByteBuffer::ByteBuffer
PUBLIC	?write@ByteBuffer@net@zl@@QAEXPBDI@Z		; zl::net::ByteBuffer::write
PUBLIC	?ensureWritableBytes@ByteBuffer@net@zl@@QAEXI@Z	; zl::net::ByteBuffer::ensureWritableBytes
PUBLIC	?hasWritten@ByteBuffer@net@zl@@QAEXI@Z		; zl::net::ByteBuffer::hasWritten
PUBLIC	?begin@ByteBuffer@net@zl@@AAEPADXZ		; zl::net::ByteBuffer::begin
PUBLIC	?makeSpace@ByteBuffer@net@zl@@AAEXI@Z		; zl::net::ByteBuffer::makeSpace
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::~_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@ABEII@Z ; std::vector<char,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Buy@?$vector@DV?$allocator@D@std@@@std@@AAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC	?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AAEXQADII@Z ; std::vector<char,std::allocator<char> >::_Change_array
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Orphan_range
PUBLIC	??1ByteBuffer@net@zl@@QAE@XZ			; zl::net::ByteBuffer::~ByteBuffer
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
PUBLIC	??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; zl::base::string_cmp_nocase::operator()
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
PUBLIC	?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
PUBLIC	??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??0HttpRequest@net@zl@@QAE@XZ			; zl::net::HttpRequest::HttpRequest
PUBLIC	??1HttpRequest@net@zl@@QAE@XZ			; zl::net::HttpRequest::~HttpRequest
PUBLIC	?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ; zl::net::HttpRequest::getHeader
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Construct
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
PUBLIC	?_Alloc_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Free_proxy
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Freeheadnode
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Extract
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
PUBLIC	?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_ptr
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::operator++
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@ABV01@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
PUBLIC	??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1HttpContext@net@zl@@QAE@XZ			; zl::net::HttpContext::~HttpContext
PUBLIC	??0COverLapped@@QAE@W4enOperationType@@@Z	; COverLapped::COverLapped
PUBLIC	??1COverLapped@@UAE@XZ				; COverLapped::~COverLapped
PUBLIC	??_GCOverLapped@@UAEPAXI@Z			; COverLapped::`scalar deleting destructor'
PUBLIC	??0COverLappedSend@@QAE@XZ			; COverLappedSend::COverLappedSend
PUBLIC	??1COverLappedSend@@UAE@XZ			; COverLappedSend::~COverLappedSend
PUBLIC	??_GCOverLappedSend@@UAEPAXI@Z			; COverLappedSend::`scalar deleting destructor'
PUBLIC	??0COverLappedRecv@@QAE@XZ			; COverLappedRecv::COverLappedRecv
PUBLIC	??1COverLappedRecv@@UAE@XZ			; COverLappedRecv::~COverLappedRecv
PUBLIC	??_GCOverLappedRecv@@UAEPAXI@Z			; COverLappedRecv::`scalar deleting destructor'
PUBLIC	??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::CWHArray<COverLappedSend *,COverLappedSend * const &>
PUBLIC	??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
PUBLIC	?Append@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABV1@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Append
PUBLIC	?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
PUBLIC	?SetSize@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetSize
PUBLIC	?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow
PUBLIC	?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAt
PUBLIC	?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll
PUBLIC	?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::AllocMemory
PUBLIC	??_G?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`scalar deleting destructor'
PUBLIC	??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z ; CTCPNetworkItem::CTCPNetworkItem
PUBLIC	??1CTCPNetworkItem@@UAE@XZ			; CTCPNetworkItem::~CTCPNetworkItem
PUBLIC	?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z ; CTCPNetworkItem::handshake
PUBLIC	?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z	; CTCPNetworkItem::SendRawData
PUBLIC	?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ	; CTCPNetworkItem::CheckIsWinSocket
PUBLIC	?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ	; CTCPNetworkItem::HandleWebsocketRecv
PUBLIC	?isWebSocket@CTCPNetworkItem@@QAE_NXZ		; CTCPNetworkItem::isWebSocket
PUBLIC	?isWinSocket@CTCPNetworkItem@@QAE_NXZ		; CTCPNetworkItem::isWinSocket
PUBLIC	?sendPingFrame@CTCPNetworkItem@@QAE_NXZ		; CTCPNetworkItem::sendPingFrame
PUBLIC	?Attach@CTCPNetworkItem@@QAEKIK@Z		; CTCPNetworkItem::Attach
PUBLIC	?ResumeData@CTCPNetworkItem@@QAEKXZ		; CTCPNetworkItem::ResumeData
PUBLIC	?SendData@CTCPNetworkItem@@QAE_NGGG@Z		; CTCPNetworkItem::SendData
PUBLIC	?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z	; CTCPNetworkItem::SendData
PUBLIC	?RecvData@CTCPNetworkItem@@QAE_NXZ		; CTCPNetworkItem::RecvData
PUBLIC	?CloseSocket@CTCPNetworkItem@@QAE_NG@Z		; CTCPNetworkItem::CloseSocket
PUBLIC	?ShutDownSocket@CTCPNetworkItem@@QAE_NG@Z	; CTCPNetworkItem::ShutDownSocket
PUBLIC	?AllowBatchSend@CTCPNetworkItem@@QAE_NG_NE@Z	; CTCPNetworkItem::AllowBatchSend
PUBLIC	?OnSendCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedSend@@K@Z ; CTCPNetworkItem::OnSendCompleted
PUBLIC	?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z ; CTCPNetworkItem::OnRecvCompleted
PUBLIC	?OnCloseCompleted@CTCPNetworkItem@@QAE_NXZ	; CTCPNetworkItem::OnCloseCompleted
PUBLIC	?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z	; CTCPNetworkItem::EncryptBuffer
PUBLIC	?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z	; CTCPNetworkItem::CrevasseBuffer
PUBLIC	?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z ; CTCPNetworkItem::GetSendOverLapped
PUBLIC	??_GCTCPNetworkItem@@UAEPAXI@Z			; CTCPNetworkItem::`scalar deleting destructor'
PUBLIC	??0CTCPNetworkThreadReadWrite@@QAE@XZ		; CTCPNetworkThreadReadWrite::CTCPNetworkThreadReadWrite
PUBLIC	??1CTCPNetworkThreadReadWrite@@UAE@XZ		; CTCPNetworkThreadReadWrite::~CTCPNetworkThreadReadWrite
PUBLIC	?InitThread@CTCPNetworkThreadReadWrite@@QAE_NPAX@Z ; CTCPNetworkThreadReadWrite::InitThread
PUBLIC	?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ ; CTCPNetworkThreadReadWrite::OnEventThreadRun
PUBLIC	??_GCTCPNetworkThreadReadWrite@@UAEPAXI@Z	; CTCPNetworkThreadReadWrite::`scalar deleting destructor'
PUBLIC	??0CTCPNetworkThreadAccept@@QAE@XZ		; CTCPNetworkThreadAccept::CTCPNetworkThreadAccept
PUBLIC	??1CTCPNetworkThreadAccept@@UAE@XZ		; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept
PUBLIC	?InitThread@CTCPNetworkThreadAccept@@QAE_NPAXIPAVCTCPNetworkEngine@@@Z ; CTCPNetworkThreadAccept::InitThread
PUBLIC	?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ ; CTCPNetworkThreadAccept::OnEventThreadRun
PUBLIC	??_GCTCPNetworkThreadAccept@@UAEPAXI@Z		; CTCPNetworkThreadAccept::`scalar deleting destructor'
PUBLIC	??0CTCPNetworkThreadDetect@@QAE@XZ		; CTCPNetworkThreadDetect::CTCPNetworkThreadDetect
PUBLIC	??1CTCPNetworkThreadDetect@@UAE@XZ		; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect
PUBLIC	?InitThread@CTCPNetworkThreadDetect@@QAE_NPAVCTCPNetworkEngine@@K@Z ; CTCPNetworkThreadDetect::InitThread
PUBLIC	?OnEventThreadRun@CTCPNetworkThreadDetect@@EAE_NXZ ; CTCPNetworkThreadDetect::OnEventThreadRun
PUBLIC	??_GCTCPNetworkThreadDetect@@UAEPAXI@Z		; CTCPNetworkThreadDetect::`scalar deleting destructor'
PUBLIC	??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
PUBLIC	??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
PUBLIC	?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Copy
PUBLIC	?Append@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABV1@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Append
PUBLIC	?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
PUBLIC	?SetSize@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetSize
PUBLIC	?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
PUBLIC	?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAt
PUBLIC	?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAll
PUBLIC	?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory
PUBLIC	??_G?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`scalar deleting destructor'
PUBLIC	??0?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
PUBLIC	??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
PUBLIC	?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt
PUBLIC	?SetSize@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetSize
PUBLIC	?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetAtGrow
PUBLIC	?RemoveAll@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXXZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::RemoveAll
PUBLIC	?AllocMemory@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::AllocMemory
PUBLIC	??_G?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`scalar deleting destructor'
PUBLIC	??0CTCPNetworkEngine@@QAE@XZ			; CTCPNetworkEngine::CTCPNetworkEngine
PUBLIC	??1CTCPNetworkEngine@@UAE@XZ			; CTCPNetworkEngine::~CTCPNetworkEngine
PUBLIC	?Release@CTCPNetworkEngine@@UAEXXZ		; CTCPNetworkEngine::Release
PUBLIC	?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z ; CTCPNetworkEngine::QueryInterface
PUBLIC	?StartService@CTCPNetworkEngine@@UAE_NXZ	; CTCPNetworkEngine::StartService
PUBLIC	?ConcludeService@CTCPNetworkEngine@@UAE_NXZ	; CTCPNetworkEngine::ConcludeService
PUBLIC	?GetServicePort@CTCPNetworkEngine@@UAEGXZ	; CTCPNetworkEngine::GetServicePort
PUBLIC	?GetCurrentPort@CTCPNetworkEngine@@UAEGXZ	; CTCPNetworkEngine::GetCurrentPort
PUBLIC	?SetTCPNetworkEngineEvent@CTCPNetworkEngine@@UAE_NPAUIUnknownEx@@@Z ; CTCPNetworkEngine::SetTCPNetworkEngineEvent
PUBLIC	?SetServiceParameter@CTCPNetworkEngine@@UAE_NGGPBD@Z ; CTCPNetworkEngine::SetServiceParameter
PUBLIC	?SendData@CTCPNetworkEngine@@UAE_NKGG@Z		; CTCPNetworkEngine::SendData
PUBLIC	?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z	; CTCPNetworkEngine::SendData
PUBLIC	?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z ; CTCPNetworkEngine::SendDataBatch
PUBLIC	?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z	; CTCPNetworkEngine::CloseSocket
PUBLIC	?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z	; CTCPNetworkEngine::ShutDownSocket
PUBLIC	?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z	; CTCPNetworkEngine::AllowBatchSend
PUBLIC	?OnAsynchronismEngineStart@CTCPNetworkEngine@@UAE_NXZ ; CTCPNetworkEngine::OnAsynchronismEngineStart
PUBLIC	?OnAsynchronismEngineConclude@CTCPNetworkEngine@@UAE_NXZ ; CTCPNetworkEngine::OnAsynchronismEngineConclude
PUBLIC	?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z ; CTCPNetworkEngine::OnAsynchronismEngineData
PUBLIC	?OnEventSocketBind@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z ; CTCPNetworkEngine::OnEventSocketBind
PUBLIC	?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z ; CTCPNetworkEngine::OnEventSocketShut
PUBLIC	?OnEventSocketRead@CTCPNetworkEngine@@UAE_NUTCP_Command@@PAXGPAVCTCPNetworkItem@@@Z ; CTCPNetworkEngine::OnEventSocketRead
PUBLIC	?DetectSocket@CTCPNetworkEngine@@AAE_NXZ	; CTCPNetworkEngine::DetectSocket
PUBLIC	?WebAttestation@CTCPNetworkEngine@@AAE_NXZ	; CTCPNetworkEngine::WebAttestation
PUBLIC	?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z	; CTCPNetworkEngine::CreateSocket
PUBLIC	?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ ; CTCPNetworkEngine::ActiveNetworkItem
PUBLIC	?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ; CTCPNetworkEngine::GetNetworkItem
PUBLIC	?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z ; CTCPNetworkEngine::FreeNetworkItem
PUBLIC	??_GCTCPNetworkEngine@@UAEPAXI@Z		; CTCPNetworkEngine::`scalar deleting destructor'
PUBLIC	??_GClosure@protobuf@google@@UAEPAXI@Z		; google::protobuf::Closure::`scalar deleting destructor'
PUBLIC	?Run@FunctionClosure0@internal@protobuf@google@@UAEXXZ ; google::protobuf::internal::FunctionClosure0::Run
PUBLIC	??_GFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z ; google::protobuf::internal::FunctionClosure0::`scalar deleting destructor'
PUBLIC	?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z ; google::protobuf::io::CodedInputStream::ReadVarint32
PUBLIC	?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
PUBLIC	?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt
PUBLIC	??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
PUBLIC	?SetNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QAV56@@Z ; google::protobuf::internal::ArenaStringPtr::SetNoArena
PUBLIC	?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::DestroyNoArena
PUBLIC	?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
PUBLIC	?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z	; google::protobuf::GoogleOnceInit
PUBLIC	??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
PUBLIC	?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields
PUBLIC	?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
PUBLIC	?mutable_unknown_fields_slow@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@AAEPAVUnknownFieldSet@34@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields_slow
PUBLIC	??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArena::~InternalMetadataWithArena
PUBLIC	??1MessageLite@protobuf@google@@UAE@XZ		; google::protobuf::MessageLite::~MessageLite
PUBLIC	?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ ; google::protobuf::MessageLite::GetArena
PUBLIC	?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ ; google::protobuf::MessageLite::GetMaybeArenaPointer
PUBLIC	?ByteSize@MessageLite@protobuf@google@@QBEHXZ	; google::protobuf::MessageLite::ByteSize
PUBLIC	?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z ; google::protobuf::MessageLite::SerializeWithCachedSizesToArray
PUBLIC	??_GMessageLite@protobuf@google@@UAEPAXI@Z	; google::protobuf::MessageLite::`scalar deleting destructor'
PUBLIC	??1Message@protobuf@google@@UAE@XZ		; google::protobuf::Message::~Message
PUBLIC	?New@Message@protobuf@google@@UBEPAV123@PAVArena@23@@Z ; google::protobuf::Message::New
PUBLIC	?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ ; google::protobuf::Message::GetReflection
PUBLIC	??_GMessage@protobuf@google@@UAEPAXI@Z		; google::protobuf::Message::`scalar deleting destructor'
PUBLIC	??$Own@VMessage@protobuf@google@@@Arena@protobuf@google@@QAEXPAVMessage@12@@Z ; google::protobuf::Arena::Own<google::protobuf::Message>
PUBLIC	?InitDefaultsImpl@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::InitDefaultsImpl
PUBLIC	?Shutdown@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::Shutdown
PUBLIC	?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors
PUBLIC	?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
PUBLIC	??0request@NullPmd@@QAE@XZ			; NullPmd::request::request
PUBLIC	??1request@NullPmd@@UAE@XZ			; NullPmd::request::~request
PUBLIC	??0request@NullPmd@@QAE@ABV01@@Z		; NullPmd::request::request
PUBLIC	?descriptor@request@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::request::descriptor
PUBLIC	?default_instance@request@NullPmd@@SAABV12@XZ	; NullPmd::request::default_instance
PUBLIC	?Swap@request@NullPmd@@QAEXPAV12@@Z		; NullPmd::request::Swap
PUBLIC	?New@request@NullPmd@@UBEPAV12@XZ		; NullPmd::request::New
PUBLIC	?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::request::New
PUBLIC	?CopyFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::request::CopyFrom
PUBLIC	?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::request::MergeFrom
PUBLIC	?CopyFrom@request@NullPmd@@QAEXABV12@@Z		; NullPmd::request::CopyFrom
PUBLIC	?MergeFrom@request@NullPmd@@QAEXABV12@@Z	; NullPmd::request::MergeFrom
PUBLIC	?Clear@request@NullPmd@@UAEXXZ			; NullPmd::request::Clear
PUBLIC	?IsInitialized@request@NullPmd@@UBE_NXZ		; NullPmd::request::IsInitialized
PUBLIC	?ByteSizeLong@request@NullPmd@@UBEIXZ		; NullPmd::request::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@request@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::request::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@request@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::request::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::request::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@request@NullPmd@@UBEPAEPAE@Z ; NullPmd::request::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@request@NullPmd@@UBEHXZ		; NullPmd::request::GetCachedSize
PUBLIC	?SharedCtor@request@NullPmd@@AAEXXZ		; NullPmd::request::SharedCtor
PUBLIC	?SharedDtor@request@NullPmd@@AAEXXZ		; NullPmd::request::SharedDtor
PUBLIC	?SetCachedSize@request@NullPmd@@EBEXH@Z		; NullPmd::request::SetCachedSize
PUBLIC	?InternalSwap@request@NullPmd@@AAEXPAV12@@Z	; NullPmd::request::InternalSwap
PUBLIC	?GetMetadata@request@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::request::GetMetadata
PUBLIC	??_Grequest@NullPmd@@UAEPAXI@Z			; NullPmd::request::`scalar deleting destructor'
PUBLIC	??0response@NullPmd@@QAE@XZ			; NullPmd::response::response
PUBLIC	??1response@NullPmd@@UAE@XZ			; NullPmd::response::~response
PUBLIC	??0response@NullPmd@@QAE@ABV01@@Z		; NullPmd::response::response
PUBLIC	?descriptor@response@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::response::descriptor
PUBLIC	?default_instance@response@NullPmd@@SAABV12@XZ	; NullPmd::response::default_instance
PUBLIC	?Swap@response@NullPmd@@QAEXPAV12@@Z		; NullPmd::response::Swap
PUBLIC	?New@response@NullPmd@@UBEPAV12@XZ		; NullPmd::response::New
PUBLIC	?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::response::New
PUBLIC	?CopyFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::response::CopyFrom
PUBLIC	?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::response::MergeFrom
PUBLIC	?CopyFrom@response@NullPmd@@QAEXABV12@@Z	; NullPmd::response::CopyFrom
PUBLIC	?MergeFrom@response@NullPmd@@QAEXABV12@@Z	; NullPmd::response::MergeFrom
PUBLIC	?Clear@response@NullPmd@@UAEXXZ			; NullPmd::response::Clear
PUBLIC	?IsInitialized@response@NullPmd@@UBE_NXZ	; NullPmd::response::IsInitialized
PUBLIC	?ByteSizeLong@response@NullPmd@@UBEIXZ		; NullPmd::response::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::response::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@response@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::response::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::response::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@response@NullPmd@@UBEPAEPAE@Z ; NullPmd::response::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@response@NullPmd@@UBEHXZ		; NullPmd::response::GetCachedSize
PUBLIC	?SharedCtor@response@NullPmd@@AAEXXZ		; NullPmd::response::SharedCtor
PUBLIC	?SharedDtor@response@NullPmd@@AAEXXZ		; NullPmd::response::SharedDtor
PUBLIC	?SetCachedSize@response@NullPmd@@EBEXH@Z	; NullPmd::response::SetCachedSize
PUBLIC	?InternalSwap@response@NullPmd@@AAEXPAV12@@Z	; NullPmd::response::InternalSwap
PUBLIC	?GetMetadata@response@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::response::GetMetadata
PUBLIC	??_Gresponse@NullPmd@@UAEPAXI@Z			; NullPmd::response::`scalar deleting destructor'
PUBLIC	??0indication@NullPmd@@QAE@XZ			; NullPmd::indication::indication
PUBLIC	??1indication@NullPmd@@UAE@XZ			; NullPmd::indication::~indication
PUBLIC	??0indication@NullPmd@@QAE@ABV01@@Z		; NullPmd::indication::indication
PUBLIC	?descriptor@indication@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::indication::descriptor
PUBLIC	?default_instance@indication@NullPmd@@SAABV12@XZ ; NullPmd::indication::default_instance
PUBLIC	?Swap@indication@NullPmd@@QAEXPAV12@@Z		; NullPmd::indication::Swap
PUBLIC	?New@indication@NullPmd@@UBEPAV12@XZ		; NullPmd::indication::New
PUBLIC	?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::indication::New
PUBLIC	?CopyFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::indication::CopyFrom
PUBLIC	?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::indication::MergeFrom
PUBLIC	?CopyFrom@indication@NullPmd@@QAEXABV12@@Z	; NullPmd::indication::CopyFrom
PUBLIC	?MergeFrom@indication@NullPmd@@QAEXABV12@@Z	; NullPmd::indication::MergeFrom
PUBLIC	?Clear@indication@NullPmd@@UAEXXZ		; NullPmd::indication::Clear
PUBLIC	?IsInitialized@indication@NullPmd@@UBE_NXZ	; NullPmd::indication::IsInitialized
PUBLIC	?ByteSizeLong@indication@NullPmd@@UBEIXZ	; NullPmd::indication::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@indication@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::indication::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@indication@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::indication::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::indication::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAEPAE@Z ; NullPmd::indication::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@indication@NullPmd@@UBEHXZ	; NullPmd::indication::GetCachedSize
PUBLIC	?SharedCtor@indication@NullPmd@@AAEXXZ		; NullPmd::indication::SharedCtor
PUBLIC	?SharedDtor@indication@NullPmd@@AAEXXZ		; NullPmd::indication::SharedDtor
PUBLIC	?SetCachedSize@indication@NullPmd@@EBEXH@Z	; NullPmd::indication::SetCachedSize
PUBLIC	?InternalSwap@indication@NullPmd@@AAEXPAV12@@Z	; NullPmd::indication::InternalSwap
PUBLIC	?GetMetadata@indication@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::indication::GetMetadata
PUBLIC	??_Gindication@NullPmd@@UAEPAXI@Z		; NullPmd::indication::`scalar deleting destructor'
PUBLIC	??0command@NullPmd@@QAE@XZ			; NullPmd::command::command
PUBLIC	??1command@NullPmd@@UAE@XZ			; NullPmd::command::~command
PUBLIC	??0command@NullPmd@@QAE@ABV01@@Z		; NullPmd::command::command
PUBLIC	?descriptor@command@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::command::descriptor
PUBLIC	?default_instance@command@NullPmd@@SAABV12@XZ	; NullPmd::command::default_instance
PUBLIC	?Swap@command@NullPmd@@QAEXPAV12@@Z		; NullPmd::command::Swap
PUBLIC	?New@command@NullPmd@@UBEPAV12@XZ		; NullPmd::command::New
PUBLIC	?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::command::New
PUBLIC	?CopyFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::command::CopyFrom
PUBLIC	?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::command::MergeFrom
PUBLIC	?CopyFrom@command@NullPmd@@QAEXABV12@@Z		; NullPmd::command::CopyFrom
PUBLIC	?MergeFrom@command@NullPmd@@QAEXABV12@@Z	; NullPmd::command::MergeFrom
PUBLIC	?Clear@command@NullPmd@@UAEXXZ			; NullPmd::command::Clear
PUBLIC	?IsInitialized@command@NullPmd@@UBE_NXZ		; NullPmd::command::IsInitialized
PUBLIC	?ByteSizeLong@command@NullPmd@@UBEIXZ		; NullPmd::command::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::command::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@command@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::command::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::command::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@command@NullPmd@@UBEPAEPAE@Z ; NullPmd::command::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@command@NullPmd@@UBEHXZ		; NullPmd::command::GetCachedSize
PUBLIC	?SharedCtor@command@NullPmd@@AAEXXZ		; NullPmd::command::SharedCtor
PUBLIC	?SharedDtor@command@NullPmd@@AAEXXZ		; NullPmd::command::SharedDtor
PUBLIC	?SetCachedSize@command@NullPmd@@EBEXH@Z		; NullPmd::command::SetCachedSize
PUBLIC	?InternalSwap@command@NullPmd@@AAEXPAV12@@Z	; NullPmd::command::InternalSwap
PUBLIC	?GetMetadata@command@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::command::GetMetadata
PUBLIC	??_Gcommand@NullPmd@@UAEPAXI@Z			; NullPmd::command::`scalar deleting destructor'
PUBLIC	??0info@NullPmd@@QAE@XZ				; NullPmd::info::info
PUBLIC	??1info@NullPmd@@UAE@XZ				; NullPmd::info::~info
PUBLIC	??0info@NullPmd@@QAE@ABV01@@Z			; NullPmd::info::info
PUBLIC	?descriptor@info@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::info::descriptor
PUBLIC	?default_instance@info@NullPmd@@SAABV12@XZ	; NullPmd::info::default_instance
PUBLIC	?Swap@info@NullPmd@@QAEXPAV12@@Z		; NullPmd::info::Swap
PUBLIC	?New@info@NullPmd@@UBEPAV12@XZ			; NullPmd::info::New
PUBLIC	?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::info::New
PUBLIC	?CopyFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::info::CopyFrom
PUBLIC	?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::info::MergeFrom
PUBLIC	?CopyFrom@info@NullPmd@@QAEXABV12@@Z		; NullPmd::info::CopyFrom
PUBLIC	?MergeFrom@info@NullPmd@@QAEXABV12@@Z		; NullPmd::info::MergeFrom
PUBLIC	?Clear@info@NullPmd@@UAEXXZ			; NullPmd::info::Clear
PUBLIC	?IsInitialized@info@NullPmd@@UBE_NXZ		; NullPmd::info::IsInitialized
PUBLIC	?ByteSizeLong@info@NullPmd@@UBEIXZ		; NullPmd::info::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::info::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@info@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::info::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::info::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@info@NullPmd@@UBEPAEPAE@Z ; NullPmd::info::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@info@NullPmd@@UBEHXZ		; NullPmd::info::GetCachedSize
PUBLIC	?SharedCtor@info@NullPmd@@AAEXXZ		; NullPmd::info::SharedCtor
PUBLIC	?SharedDtor@info@NullPmd@@AAEXXZ		; NullPmd::info::SharedDtor
PUBLIC	?SetCachedSize@info@NullPmd@@EBEXH@Z		; NullPmd::info::SetCachedSize
PUBLIC	?InternalSwap@info@NullPmd@@AAEXPAV12@@Z	; NullPmd::info::InternalSwap
PUBLIC	?GetMetadata@info@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::info::GetMetadata
PUBLIC	?cbdatakind@info@NullPmd@@QBE_KXZ		; NullPmd::info::cbdatakind
PUBLIC	??_Ginfo@NullPmd@@UAEPAXI@Z			; NullPmd::info::`scalar deleting destructor'
PUBLIC	??0head@NullPmd@@QAE@XZ				; NullPmd::head::head
PUBLIC	??1head@NullPmd@@UAE@XZ				; NullPmd::head::~head
PUBLIC	??0head@NullPmd@@QAE@ABV01@@Z			; NullPmd::head::head
PUBLIC	?descriptor@head@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::head::descriptor
PUBLIC	?default_instance@head@NullPmd@@SAABV12@XZ	; NullPmd::head::default_instance
PUBLIC	?Swap@head@NullPmd@@QAEXPAV12@@Z		; NullPmd::head::Swap
PUBLIC	?New@head@NullPmd@@UBEPAV12@XZ			; NullPmd::head::New
PUBLIC	?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::head::New
PUBLIC	?CopyFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::head::CopyFrom
PUBLIC	?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::head::MergeFrom
PUBLIC	?CopyFrom@head@NullPmd@@QAEXABV12@@Z		; NullPmd::head::CopyFrom
PUBLIC	?MergeFrom@head@NullPmd@@QAEXABV12@@Z		; NullPmd::head::MergeFrom
PUBLIC	?Clear@head@NullPmd@@UAEXXZ			; NullPmd::head::Clear
PUBLIC	?IsInitialized@head@NullPmd@@UBE_NXZ		; NullPmd::head::IsInitialized
PUBLIC	?ByteSizeLong@head@NullPmd@@UBEIXZ		; NullPmd::head::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::head::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@head@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::head::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::head::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@head@NullPmd@@UBEPAEPAE@Z ; NullPmd::head::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@head@NullPmd@@UBEHXZ		; NullPmd::head::GetCachedSize
PUBLIC	?SharedCtor@head@NullPmd@@AAEXXZ		; NullPmd::head::SharedCtor
PUBLIC	?SharedDtor@head@NullPmd@@AAEXXZ		; NullPmd::head::SharedDtor
PUBLIC	?SetCachedSize@head@NullPmd@@EBEXH@Z		; NullPmd::head::SetCachedSize
PUBLIC	?InternalSwap@head@NullPmd@@AAEXPAV12@@Z	; NullPmd::head::InternalSwap
PUBLIC	?GetMetadata@head@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::head::GetMetadata
PUBLIC	?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ; NullPmd::head::mutable_command
PUBLIC	?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ	; NullPmd::head::mutable_info
PUBLIC	??_Ghead@NullPmd@@UAEPAXI@Z			; NullPmd::head::`scalar deleting destructor'
PUBLIC	??0message@NullPmd@@QAE@XZ			; NullPmd::message::message
PUBLIC	??1message@NullPmd@@UAE@XZ			; NullPmd::message::~message
PUBLIC	??0message@NullPmd@@QAE@ABV01@@Z		; NullPmd::message::message
PUBLIC	?descriptor@message@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ; NullPmd::message::descriptor
PUBLIC	?default_instance@message@NullPmd@@SAABV12@XZ	; NullPmd::message::default_instance
PUBLIC	?Swap@message@NullPmd@@QAEXPAV12@@Z		; NullPmd::message::Swap
PUBLIC	?New@message@NullPmd@@UBEPAV12@XZ		; NullPmd::message::New
PUBLIC	?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::message::New
PUBLIC	?CopyFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::message::CopyFrom
PUBLIC	?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::message::MergeFrom
PUBLIC	?CopyFrom@message@NullPmd@@QAEXABV12@@Z		; NullPmd::message::CopyFrom
PUBLIC	?MergeFrom@message@NullPmd@@QAEXABV12@@Z	; NullPmd::message::MergeFrom
PUBLIC	?Clear@message@NullPmd@@UAEXXZ			; NullPmd::message::Clear
PUBLIC	?IsInitialized@message@NullPmd@@UBE_NXZ		; NullPmd::message::IsInitialized
PUBLIC	?ByteSizeLong@message@NullPmd@@UBEIXZ		; NullPmd::message::ByteSizeLong
PUBLIC	?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::message::MergePartialFromCodedStream
PUBLIC	?SerializeWithCachedSizes@message@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ; NullPmd::message::SerializeWithCachedSizes
PUBLIC	?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::message::InternalSerializeWithCachedSizesToArray
PUBLIC	?SerializeWithCachedSizesToArray@message@NullPmd@@UBEPAEPAE@Z ; NullPmd::message::SerializeWithCachedSizesToArray
PUBLIC	?GetCachedSize@message@NullPmd@@UBEHXZ		; NullPmd::message::GetCachedSize
PUBLIC	?SharedCtor@message@NullPmd@@AAEXXZ		; NullPmd::message::SharedCtor
PUBLIC	?SharedDtor@message@NullPmd@@AAEXXZ		; NullPmd::message::SharedDtor
PUBLIC	?SetCachedSize@message@NullPmd@@EBEXH@Z		; NullPmd::message::SetCachedSize
PUBLIC	?InternalSwap@message@NullPmd@@AAEXPAV12@@Z	; NullPmd::message::InternalSwap
PUBLIC	?GetMetadata@message@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ; NullPmd::message::GetMetadata
PUBLIC	?set_data@message@NullPmd@@QAEXPBD@Z		; NullPmd::message::set_data
PUBLIC	?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ	; NullPmd::message::mutable_head
PUBLIC	??_Gmessage@NullPmd@@UAEPAXI@Z			; NullPmd::message::`scalar deleting destructor'
PUBLIC	?WriteInt32ToArray@WireFormatLite@internal@protobuf@google@@SAPAEHHPAE@Z ; google::protobuf::internal::WireFormatLite::WriteInt32ToArray
PUBLIC	?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
PUBLIC	?StringSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::StringSize
PUBLIC	?BytesSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::BytesSize
PUBLIC	?AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptorsImpl
PUBLIC	??$Own@Vrequest@NullPmd@@@Arena@protobuf@google@@QAEXPAVrequest@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::request>
PUBLIC	??$DynamicCastToGenerated@$$CBVrequest@NullPmd@@@internal@protobuf@google@@YAPBVrequest@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::request const >
PUBLIC	??$Own@Vresponse@NullPmd@@@Arena@protobuf@google@@QAEXPAVresponse@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::response>
PUBLIC	??$DynamicCastToGenerated@$$CBVresponse@NullPmd@@@internal@protobuf@google@@YAPBVresponse@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::response const >
PUBLIC	??$Own@Vindication@NullPmd@@@Arena@protobuf@google@@QAEXPAVindication@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::indication>
PUBLIC	??$DynamicCastToGenerated@$$CBVindication@NullPmd@@@internal@protobuf@google@@YAPBVindication@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::indication const >
PUBLIC	??$Own@Vcommand@NullPmd@@@Arena@protobuf@google@@QAEXPAVcommand@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::command>
PUBLIC	??$DynamicCastToGenerated@$$CBVcommand@NullPmd@@@internal@protobuf@google@@YAPBVcommand@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::command const >
PUBLIC	??$Own@Vinfo@NullPmd@@@Arena@protobuf@google@@QAEXPAVinfo@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::info>
PUBLIC	??$DynamicCastToGenerated@$$CBVinfo@NullPmd@@@internal@protobuf@google@@YAPBVinfo@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::info const >
PUBLIC	??$Own@Vhead@NullPmd@@@Arena@protobuf@google@@QAEXPAVhead@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::head>
PUBLIC	??$ReadMessageNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVcommand@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::command>
PUBLIC	??$ReadMessageNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVinfo@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::info>
PUBLIC	??$InternalWriteMessageNoVirtualToArray@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVcommand@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::command>
PUBLIC	??$InternalWriteMessageNoVirtualToArray@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVinfo@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::info>
PUBLIC	??$DynamicCastToGenerated@$$CBVhead@NullPmd@@@internal@protobuf@google@@YAPBVhead@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::head const >
PUBLIC	??$Own@Vmessage@NullPmd@@@Arena@protobuf@google@@QAEXPAVmessage@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::message>
PUBLIC	??$ReadMessageNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVhead@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::head>
PUBLIC	??$InternalWriteMessageNoVirtualToArray@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVhead@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::head>
PUBLIC	??$DynamicCastToGenerated@$$CBVmessage@NullPmd@@@internal@protobuf@google@@YAPBVmessage@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::message const >
PUBLIC	??1?$shared_ptr@D@std@@QAE@XZ			; std::shared_ptr<char>::~shared_ptr<char>
PUBLIC	_CreateTCPNetworkEngine
PUBLIC	??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z ; std::vector<char,std::allocator<char> >::_Resize<<lambda_c82d6fc6887df3275822341e5972f698> >
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$Create@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@SAPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@PAV012@@Z ; google::protobuf::Arena::Create<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
PUBLIC	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Verify_range@D@std@@YAXQBD0@Z		; std::_Verify_range<char>
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z ; std::shared_ptr<char>::_Setp<char>
PUBLIC	??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z ; std::search<char *,char const *,std::equal_to<void> >
PUBLIC	??$CreateInternal@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@AAEPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@_N@Z ; google::protobuf::Arena::CreateInternal<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,char *,std::allocator<char> >
PUBLIC	??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
PUBLIC	?_Destroy@?$_Ref_count@D@std@@EAEXXZ		; std::_Ref_count<char>::_Destroy
PUBLIC	?_Delete_this@?$_Ref_count@D@std@@EAEXXZ	; std::_Ref_count<char>::_Delete_this
PUBLIC	??_G?$_Ref_count@D@std@@UAEPAXI@Z		; std::_Ref_count<char>::`scalar deleting destructor'
PUBLIC	??$_Search_unchecked@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@Urandom_access_iterator_tag@0@4@Z ; std::_Search_unchecked<char *,char const *,std::equal_to<void> >
PUBLIC	??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
PUBLIC	??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z ; std::_Enable_shared_from_this<char,char>
PUBLIC	??$_Enable_shared_from_this1@DD@std@@YAXABV?$shared_ptr@D@0@PADU?$integral_constant@_N$0A@@0@@Z ; std::_Enable_shared_from_this1<char,char>
PUBLIC	?Release@CTCPNetworkEngine@@W3AEXXZ		; [thunk]:CTCPNetworkEngine::Release`adjustor{4}'
PUBLIC	?QueryInterface@CTCPNetworkEngine@@W3AEPAXABU_GUID@@K@Z ; [thunk]:CTCPNetworkEngine::QueryInterface`adjustor{4}'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_7IUnknownEx@@6B@				; IUnknownEx::`vftable'
PUBLIC	??_7IServiceModule@@6B@				; IServiceModule::`vftable'
PUBLIC	??_7IAsynchronismEngineSink@@6B@		; IAsynchronismEngineSink::`vftable'
PUBLIC	??_7ITCPNetworkEngine@@6B@			; ITCPNetworkEngine::`vftable'
PUBLIC	??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@		; `string'
PUBLIC	??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@	; `string'
PUBLIC	??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_1CK@HLKMELIP@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EA@MNNKLKHL@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EI@GKCFLMIJ@?$AAp?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe@ ; `string'
PUBLIC	??_C@_1CO@EOJCKDIM@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1CO@OAPHHNA@?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1DK@JBKPABMM@?$AAk?$AAC?$AAh?$AAe?$AAa?$AAp?$AAP?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DM@ ; `string'
PUBLIC	??_C@_1DI@FLADJBMA@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAa@ ; `string'
PUBLIC	??_7ITCPNetworkItemSink@@6B@			; ITCPNetworkItemSink::`vftable'
PUBLIC	??_7COverLapped@@6B@				; COverLapped::`vftable'
PUBLIC	??_7COverLappedSend@@6B@			; COverLappedSend::`vftable'
PUBLIC	??_7COverLappedRecv@@6B@			; COverLappedRecv::`vftable'
PUBLIC	??_7?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@	; CWHArray<COverLappedSend *,COverLappedSend * const &>::`vftable'
PUBLIC	??_7CTCPNetworkItem@@6B@			; CTCPNetworkItem::`vftable'
PUBLIC	??_7CTCPNetworkThreadReadWrite@@6B@		; CTCPNetworkThreadReadWrite::`vftable'
PUBLIC	??_7CTCPNetworkThreadAccept@@6B@		; CTCPNetworkThreadAccept::`vftable'
PUBLIC	??_7CTCPNetworkThreadDetect@@6B@		; CTCPNetworkThreadDetect::`vftable'
PUBLIC	??_7?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`vftable'
PUBLIC	??_7?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`vftable'
PUBLIC	??_7CTCPNetworkEngine@@6BITCPNetworkEngine@@@	; CTCPNetworkEngine::`vftable'
PUBLIC	??_7CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@ ; CTCPNetworkEngine::`vftable'
PUBLIC	??_7CTCPNetworkEngine@@6BITCPNetworkItemSink@@@	; CTCPNetworkEngine::`vftable'
PUBLIC	??_7Closure@protobuf@google@@6B@		; google::protobuf::Closure::`vftable'
PUBLIC	??_7FunctionClosure0@internal@protobuf@google@@6B@ ; google::protobuf::internal::FunctionClosure0::`vftable'
PUBLIC	??_C@_0FL@GKGAFMDK@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@ ; `string'
PUBLIC	??_C@_0CG@ENGJCHJ@CHECK?5failed?3?5initial_value?5?$CB?$DN?5@ ; `string'
PUBLIC	??_7MessageLite@protobuf@google@@6B@		; google::protobuf::MessageLite::`vftable'
PUBLIC	??_C@_0FM@MGPCODI@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@ ; `string'
PUBLIC	??_C@_0DO@HCOJOCJH@CHECK?5failed?3?5?$CIresult?$CJ?5?$DM?$DN?5?$CIstat@ ; `string'
PUBLIC	??_7Message@protobuf@google@@6B@		; google::protobuf::Message::`vftable'
PUBLIC	??_7request@NullPmd@@6B@			; NullPmd::request::`vftable'
PUBLIC	??_7response@NullPmd@@6B@			; NullPmd::response::`vftable'
PUBLIC	??_7indication@NullPmd@@6B@			; NullPmd::indication::`vftable'
PUBLIC	??_7command@NullPmd@@6B@			; NullPmd::command::`vftable'
PUBLIC	??_7info@NullPmd@@6B@				; NullPmd::info::`vftable'
PUBLIC	??_7head@NullPmd@@6B@				; NullPmd::head::`vftable'
PUBLIC	??_7message@NullPmd@@6B@			; NullPmd::message::`vftable'
PUBLIC	??_C@_0O@PBNICMEM@NullPmd?4proto@		; `string'
PUBLIC	??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	?static_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@3UStaticDescriptorInitializer@12@A ; NullPmd::protobuf_NullPmd_2eproto::static_descriptor_initializer
PUBLIC	??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@ ; `string'
PUBLIC	??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@ ; `string'
PUBLIC	??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	__TI2PAD
PUBLIC	__CTA2PAD
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAD@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_C@_0L@JNDINJCC@?$LH?$KC?K?M?$LA?$PM?L?$KL?$LE?s@ ; `string'
PUBLIC	??_C@_0BA@LDGEJDBI@Serialize?5error@		; `string'
PUBLIC	??_C@_0BB@OELGDMNI@SendData?5?R?l?$LD?$KD?3?$CFs@ ; `string'
PUBLIC	??_C@_0O@LEAMMJHF@SendData?5?R?l?$LD?$KD@	; `string'
PUBLIC	??_C@_0CE@NEGGEINK@?J?$PN?$LO?$NN?N?$KK?$LP?U?3wMainCmdID?3?$CFd?0wSubCmdI@ ; `string'
PUBLIC	??_C@_0CJ@PPIPIEAL@?$LH?$KC?K?M?O?$PL?O?$KCpData?3wMainCmdID?3?$CFd?0wSu@ ; `string'
PUBLIC	??_C@_0BH@NLJMDLEL@SendData?5pData?5?R?l?$LD?$KD?3?$CFs@ ; `string'
PUBLIC	??_C@_0BE@BFBPJPAH@SendData?5pData?5?R?l?$LD?$KD@ ; `string'
PUBLIC	??_C@_04FMMHFHOO@?$AN?6?$AN?6@			; `string'
PUBLIC	??_C@_0P@IFKIJFDN@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LD?$KE@ ; `string'
PUBLIC	??_C@_0CH@MKDFEHED@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CF@ ; `string'
PUBLIC	??_C@_0BM@LPKEJNLP@?$LA?$PM?$LD?$KE?5?$CFd?0?5?$LA?f?$LB?$LO?5?$CFd?0?5?P?$KH?Q?i?B?k?5?$CFd@ ; `string'
PUBLIC	??_C@_0P@COEHLGHJ@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L@ ; `string'
PUBLIC	??_C@_04OPBHEPOC@0x?$CFx@			; `string'
PUBLIC	??_C@_0BB@HMAHCNOL@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@ ; `string'
PUBLIC	??_C@_0EE@ONNHHJGK@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@ ; `string'
PUBLIC	??_C@_0EG@EEAELNCF@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@ ; `string'
PUBLIC	??_C@_0BD@DINLBKIB@?J?$PN?$LO?$NN?$LA?$PM?$LN?b?C?$NM?$LD?$KE?$LG?H?$LE?m?N?s@ ; `string'
PUBLIC	??_C@_0BB@GKKJNMOA@?J?$PN?$LO?$NN?$LA?$PM?P?$KH?Q?i?B?k?$LE?m?N?s@ ; `string'
PUBLIC	??_C@_0DE@HPGDGIOK@error?0receive?5data?5len?5?$DO?5SOCKET@ ; `string'
PUBLIC	??_C@_0M@BJIBBOFC@parse?5error@			; `string'
PUBLIC	??_C@_0L@HPNHKCLL@?$LH?G?$LH?$KI?C?$PM?A?n?B?k@	; `string'
PUBLIC	??_C@_0BM@EEHLBJJE@?J?U?$LF?$LN?O?$PL?O?$KC?3mainid?3?$CFd?0subid?3?$CFd@ ; `string'
PUBLIC	??_C@_0BG@KIEOHCJC@?J?U?$LF?$LNWS_PING_FRAME?O?$PL?O?$KC@ ; `string'
PUBLIC	??_C@_0BH@KPFBJOAM@?J?U?$LF?$LNWS_CLOSE_FRAME?O?$PL?O?$KC@ ; `string'
PUBLIC	??_C@_0BA@LDBHEJCC@?J?U?$LF?$LNdefault?O?$PL?O?$KC@ ; `string'
PUBLIC	??_C@_0BM@KAJJAILJ@HandleWebsocketRecv?5?R?l?$LD?$KD?3?$CFs@ ; `string'
PUBLIC	??_C@_0DF@DAAPGLPI@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMHandleW@ ; `string'
PUBLIC	??_C@_0L@DAPODOBD@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KM?$LD?$KE@ ; `string'
PUBLIC	??_C@_0L@ICOFAPAB@?J?$PN?$LO?$NN?$LA?$PM?$LH?G?$LH?$KI@ ; `string'
PUBLIC	??_C@_0P@BBEPCAEF@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LE?m?N?s@ ; `string'
PUBLIC	??_C@_0CB@BHAJGHNJ@CheckIsWinSocket?5?$LH?Gweebsocket?3?$CF@ ; `string'
PUBLIC	??_C@_0DC@OCAKDNJE@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMCheckIs@ ; `string'
PUBLIC	??_C@_0CI@GGFIIOME@parse?5handshake?5error?0send?5clos@ ; `string'
PUBLIC	??_C@_0BN@PJMBPKGC@HTTP?11?41?5400?5Bad?5Request?$AN?6?$AN?6@ ; `string'
PUBLIC	??_C@_1HG@EFDLDILG@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_1CC@MAPHGENJ@?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAg?$AAo?$AAt?$AAA?$AAl?$AAl?$AA?$CI@ ; `string'
PUBLIC	??_C@_0BA@HEMDDLEL@X?9Forwarded?9For@		; `string'
PUBLIC	??_C@_0CN@CFILDAFG@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMSendRaw@ ; `string'
PUBLIC	??_C@_0BB@GIIMFCKJ@?I?j?G?k?A?$KM?$LN?S?$LG?T?O?s?J?$KH?$LA?$NM@ ; `string'
PUBLIC	??_C@_0BL@FJOHAJKD@?N?$LE?V?$LI?$LG?$KI?M?x?B?g?$LG?K?$LP?Z?$KD?$KM?$LN?$KL?K?f?$LL?z?$LH?V?E?d@ ; `string'
PUBLIC	??_C@_0CB@DMDLLPEB@?$LD?$KC?J?T?A?K?V?Z?$LG?$OA?$LF?D?$LG?K?$LP?Z?$LK?E?$KD?$KM?$LM?$OA?L?$PN?$LC?Y?W?w?J?$KH?$LA@ ; `string'
PUBLIC	??_C@_0DD@KAEGCGFA@?O?$LF?M?$LD?W?J?T?$LE?$LC?$LL?W?c?$LL?r?U?$NP?5TCP?1IP?5?P?$KN?R?i?C?$LL?S@ ; `string'
PUBLIC	??_C@_0CD@FEECEEMH@?M?x?B?g?$LA?s?$LG?$KI?$LE?m?N?s?0?F?t?$LG?$KP?J?$KH?$LA?$NM?4?U?$LM?S?C?$LG?K?$LP?Z?$KD@ ; `string'
PUBLIC	??_C@_0CI@ELCMGMJI@?$LG?K?$LP?Z?U?$PN?$LB?$LL?F?d?K?$PL?$LH?$PO?N?q?U?$LM?S?C?$KD?$KM?$LM?$OA?L?$PN?5?$CFld?5@ ; `string'
PUBLIC	??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@ ; `string'
PUBLIC	??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@ ; `string'
PUBLIC	??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_0DE@DMNPKCGM@cannot?5increment?5value?9initiali@ ; `string'
PUBLIC	??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1CFG@PGGKMBNC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1GM@BJMCGEGI@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0CG@NLEHEOHN@cannot?5increment?5end?5map?1set?5it@ ; `string'
PUBLIC	??_C@_1FA@KLFCDGNE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@ ; `string'
PUBLIC	??_C@_1MG@DDPKBOFO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@ ; `string'
PUBLIC	??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0DD@LAECODHC@cannot?5increment?5value?9initiali@ ; `string'
PUBLIC	??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GK@MICKMFNF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0IA@BFMOHEDB@cannot?5increment?5string?5iterato@ ; `string'
PUBLIC	??_C@_1BAK@GBJMLMKM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0CK@IKJHPFKC@cannot?5increment?5string?5iterato@ ; `string'
PUBLIC	??_C@_1FI@JCCODAAD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0DF@IMIHIHOP@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GO@PNALIMBD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0IC@DGJDAAEM@cannot?5dereference?5string?5itera@ ; `string'
PUBLIC	??_C@_1BAO@BGLBIONH@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0FF@HJKEHIBC@cannot?5dereference?5string?5itera@ ; `string'
PUBLIC	??_C@_1KO@CMPBFHAM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0BP@OLDKBHLM@map?1set?5iterators?5incompatible@ ; `string'
PUBLIC	??_C@_1CFG@FGJHCIBH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1EC@JLIDLCDH@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_0DG@LCFNIIPB@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1CFE@PPLBLEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1HA@ILGCNILF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CI@OKFEHCEB@cannot?5dereference?5end?5map?1set?5@ ; `string'
PUBLIC	??_C@_1FE@NKHAAGMB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0EJ@NPIAEPMO@string?5iterators?5incompatible?5?$CI@ ; `string'
PUBLIC	??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1JM@EIPCMFMM@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_C@_0CF@JILFNJOL@map?1set?5erase?5iterator?5outside?5@ ; `string'
PUBLIC	??_C@_1DMG@NDMMDDDJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1EO@CEDAEPC@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5@ ; `string'
PUBLIC	??_C@_1CAM@NGLDEJOH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAv?$AAa?$AAl?$AA?$DM@ ; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	??_R0?AVMessage@protobuf@google@@@8		; google::protobuf::Message `RTTI Type Descriptor'
PUBLIC	??_R0?AVrequest@NullPmd@@@8			; NullPmd::request `RTTI Type Descriptor'
PUBLIC	??_R0?AVresponse@NullPmd@@@8			; NullPmd::response `RTTI Type Descriptor'
PUBLIC	??_R0?AVindication@NullPmd@@@8			; NullPmd::indication `RTTI Type Descriptor'
PUBLIC	??_R0?AVcommand@NullPmd@@@8			; NullPmd::command `RTTI Type Descriptor'
PUBLIC	??_R0?AVinfo@NullPmd@@@8			; NullPmd::info `RTTI Type Descriptor'
PUBLIC	??_R0?AVhead@NullPmd@@@8			; NullPmd::head `RTTI Type Descriptor'
PUBLIC	??_R0?AVmessage@NullPmd@@@8			; NullPmd::message `RTTI Type Descriptor'
PUBLIC	??_C@_0BD@FEEMDEPI@invalid?5comparator@		; `string'
PUBLIC	??_C@_1CI@JONCLBEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAb?$AAu?$AAg?$AA_?$AAl?$AAt?$AA_@ ; `string'
PUBLIC	??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7?$_Ref_count@D@std@@6B@			; std::_Ref_count<char>::`vftable'
PUBLIC	??_R0?AUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@8 ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container `RTTI Type Descriptor'
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
PUBLIC	??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@	; `string'
PUBLIC	??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ ; `string'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IUnknownEx@@6B@				; IUnknownEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIUnknownEx@@@8				; IUnknownEx `RTTI Type Descriptor'
PUBLIC	??_R3IUnknownEx@@8				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknownEx@@8				; IUnknownEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IServiceModule@@6B@			; IServiceModule::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIServiceModule@@@8			; IServiceModule `RTTI Type Descriptor'
PUBLIC	??_R3IServiceModule@@8				; IServiceModule::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IServiceModule@@8				; IServiceModule::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IServiceModule@@8			; IServiceModule::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IAsynchronismEngineSink@@6B@		; IAsynchronismEngineSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIAsynchronismEngineSink@@@8		; IAsynchronismEngineSink `RTTI Type Descriptor'
PUBLIC	??_R3IAsynchronismEngineSink@@8			; IAsynchronismEngineSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IAsynchronismEngineSink@@8			; IAsynchronismEngineSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IAsynchronismEngineSink@@8	; IAsynchronismEngineSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ITCPNetworkEngine@@6B@			; ITCPNetworkEngine::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUITCPNetworkEngine@@@8			; ITCPNetworkEngine `RTTI Type Descriptor'
PUBLIC	??_R3ITCPNetworkEngine@@8			; ITCPNetworkEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITCPNetworkEngine@@8			; ITCPNetworkEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITCPNetworkEngine@@8		; ITCPNetworkEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4COverLappedRecv@@6B@			; COverLappedRecv::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOverLappedRecv@@@8			; COverLappedRecv `RTTI Type Descriptor'
PUBLIC	??_R3COverLappedRecv@@8				; COverLappedRecv::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COverLappedRecv@@8				; COverLappedRecv::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COverLappedRecv@@8		; COverLappedRecv::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@COverLapped@@8			; COverLapped::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCOverLapped@@@8				; COverLapped `RTTI Type Descriptor'
PUBLIC	??_R3COverLapped@@8				; COverLapped::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COverLapped@@8				; COverLapped::`RTTI Base Class Array'
PUBLIC	??_R4COverLappedSend@@6B@			; COverLappedSend::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOverLappedSend@@@8			; COverLappedSend `RTTI Type Descriptor'
PUBLIC	??_R3COverLappedSend@@8				; COverLappedSend::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COverLappedSend@@8				; COverLappedSend::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COverLappedSend@@8		; COverLappedSend::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTCPNetworkItem@@6B@			; CTCPNetworkItem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTCPNetworkItem@@@8			; CTCPNetworkItem `RTTI Type Descriptor'
PUBLIC	??_R3CTCPNetworkItem@@8				; CTCPNetworkItem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTCPNetworkItem@@8				; CTCPNetworkItem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTCPNetworkItem@@8		; CTCPNetworkItem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTCPNetworkEngine@@6BITCPNetworkEngine@@@	; CTCPNetworkEngine::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTCPNetworkEngine@@@8			; CTCPNetworkEngine `RTTI Type Descriptor'
PUBLIC	??_R3CTCPNetworkEngine@@8			; CTCPNetworkEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTCPNetworkEngine@@8			; CTCPNetworkEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTCPNetworkEngine@@8		; CTCPNetworkEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EC@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R13?0A@EA@IAsynchronismEngineSink@@8		; IAsynchronismEngineSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EC@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R17?0A@EA@ITCPNetworkItemSink@@8		; ITCPNetworkItemSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AUITCPNetworkItemSink@@@8			; ITCPNetworkItemSink `RTTI Type Descriptor'
PUBLIC	??_R3ITCPNetworkItemSink@@8			; ITCPNetworkItemSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITCPNetworkItemSink@@8			; ITCPNetworkItemSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITCPNetworkItemSink@@8		; ITCPNetworkItemSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@ ; CTCPNetworkEngine::`RTTI Complete Object Locator'
PUBLIC	??_R4CTCPNetworkEngine@@6BITCPNetworkItemSink@@@ ; CTCPNetworkEngine::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@@8 ; CWHArray<COverLappedSend *,COverLappedSend * const &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8	; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8	; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8 ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ITCPNetworkItemSink@@6B@			; ITCPNetworkItemSink::`RTTI Complete Object Locator'
PUBLIC	??_R4COverLapped@@6B@				; COverLapped::`RTTI Complete Object Locator'
PUBLIC	??_R4CTCPNetworkThreadReadWrite@@6B@		; CTCPNetworkThreadReadWrite::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTCPNetworkThreadReadWrite@@@8		; CTCPNetworkThreadReadWrite `RTTI Type Descriptor'
PUBLIC	??_R3CTCPNetworkThreadReadWrite@@8		; CTCPNetworkThreadReadWrite::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTCPNetworkThreadReadWrite@@8		; CTCPNetworkThreadReadWrite::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTCPNetworkThreadReadWrite@@8	; CTCPNetworkThreadReadWrite::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CWHThread@@8			; CWHThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWHThread@@@8				; CWHThread `RTTI Type Descriptor'
PUBLIC	??_R3CWHThread@@8				; CWHThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWHThread@@8				; CWHThread::`RTTI Base Class Array'
PUBLIC	??_R4CTCPNetworkThreadAccept@@6B@		; CTCPNetworkThreadAccept::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTCPNetworkThreadAccept@@@8		; CTCPNetworkThreadAccept `RTTI Type Descriptor'
PUBLIC	??_R3CTCPNetworkThreadAccept@@8			; CTCPNetworkThreadAccept::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTCPNetworkThreadAccept@@8			; CTCPNetworkThreadAccept::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTCPNetworkThreadAccept@@8	; CTCPNetworkThreadAccept::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTCPNetworkThreadDetect@@6B@		; CTCPNetworkThreadDetect::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTCPNetworkThreadDetect@@@8		; CTCPNetworkThreadDetect `RTTI Type Descriptor'
PUBLIC	??_R3CTCPNetworkThreadDetect@@8			; CTCPNetworkThreadDetect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTCPNetworkThreadDetect@@8			; CTCPNetworkThreadDetect::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTCPNetworkThreadDetect@@8	; CTCPNetworkThreadDetect::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@@8 ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8 ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Closure@protobuf@google@@6B@		; google::protobuf::Closure::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVClosure@protobuf@google@@@8		; google::protobuf::Closure `RTTI Type Descriptor'
PUBLIC	??_R3Closure@protobuf@google@@8			; google::protobuf::Closure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Closure@protobuf@google@@8			; google::protobuf::Closure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Closure@protobuf@google@@8	; google::protobuf::Closure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4FunctionClosure0@internal@protobuf@google@@6B@ ; google::protobuf::internal::FunctionClosure0::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFunctionClosure0@internal@protobuf@google@@@8 ; google::protobuf::internal::FunctionClosure0 `RTTI Type Descriptor'
PUBLIC	??_R3FunctionClosure0@internal@protobuf@google@@8 ; google::protobuf::internal::FunctionClosure0::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FunctionClosure0@internal@protobuf@google@@8 ; google::protobuf::internal::FunctionClosure0::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FunctionClosure0@internal@protobuf@google@@8 ; google::protobuf::internal::FunctionClosure0::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Message@protobuf@google@@6B@		; google::protobuf::Message::`RTTI Complete Object Locator'
PUBLIC	??_R3Message@protobuf@google@@8			; google::protobuf::Message::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Message@protobuf@google@@8			; google::protobuf::Message::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Message@protobuf@google@@8	; google::protobuf::Message::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@MessageLite@protobuf@google@@8	; google::protobuf::MessageLite::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVMessageLite@protobuf@google@@@8		; google::protobuf::MessageLite `RTTI Type Descriptor'
PUBLIC	??_R3MessageLite@protobuf@google@@8		; google::protobuf::MessageLite::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MessageLite@protobuf@google@@8		; google::protobuf::MessageLite::`RTTI Base Class Array'
PUBLIC	??_R4MessageLite@protobuf@google@@6B@		; google::protobuf::MessageLite::`RTTI Complete Object Locator'
PUBLIC	??_R4command@NullPmd@@6B@			; NullPmd::command::`RTTI Complete Object Locator'
PUBLIC	??_R3command@NullPmd@@8				; NullPmd::command::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2command@NullPmd@@8				; NullPmd::command::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@command@NullPmd@@8		; NullPmd::command::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4head@NullPmd@@6B@				; NullPmd::head::`RTTI Complete Object Locator'
PUBLIC	??_R3head@NullPmd@@8				; NullPmd::head::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2head@NullPmd@@8				; NullPmd::head::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@head@NullPmd@@8			; NullPmd::head::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4indication@NullPmd@@6B@			; NullPmd::indication::`RTTI Complete Object Locator'
PUBLIC	??_R3indication@NullPmd@@8			; NullPmd::indication::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2indication@NullPmd@@8			; NullPmd::indication::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@indication@NullPmd@@8		; NullPmd::indication::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4info@NullPmd@@6B@				; NullPmd::info::`RTTI Complete Object Locator'
PUBLIC	??_R3info@NullPmd@@8				; NullPmd::info::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2info@NullPmd@@8				; NullPmd::info::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@info@NullPmd@@8			; NullPmd::info::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4message@NullPmd@@6B@			; NullPmd::message::`RTTI Complete Object Locator'
PUBLIC	??_R3message@NullPmd@@8				; NullPmd::message::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2message@NullPmd@@8				; NullPmd::message::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@message@NullPmd@@8		; NullPmd::message::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4request@NullPmd@@6B@			; NullPmd::request::`RTTI Complete Object Locator'
PUBLIC	??_R3request@NullPmd@@8				; NullPmd::request::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2request@NullPmd@@8				; NullPmd::request::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@request@NullPmd@@8		; NullPmd::request::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4response@NullPmd@@6B@			; NullPmd::response::`RTTI Complete Object Locator'
PUBLIC	??_R3response@NullPmd@@8			; NullPmd::response::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2response@NullPmd@@8			; NullPmd::response::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@response@NullPmd@@8		; NullPmd::response::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_Ref_count@D@std@@6B@			; std::_Ref_count<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@D@std@@@8			; std::_Ref_count<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Ref_count@D@std@@8			; std::_Ref_count<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@D@std@@8			; std::_Ref_count<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@D@std@@8		; std::_Ref_count<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__wcscpy_s:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__CreateIoCompletionPort@16:PROC
EXTRN	__imp__GetQueuedCompletionStatus@20:PROC
EXTRN	__imp__PostQueuedCompletionStatus@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetSystemInfo@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp____stdio_common_vswprintf_s:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__WSAAccept@20:PROC
EXTRN	__imp__WSARecv@28:PROC
EXTRN	__imp__WSASend@28:PROC
EXTRN	__imp__WSASocketA@24:PROC
EXTRN	__imp__CoCreateGuid@4:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	__imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ:PROC
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:PROC
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:PROC
EXTRN	??0CCriticalSection@@QAE@XZ:PROC		; CCriticalSection::CCriticalSection
EXTRN	??1CCriticalSection@@UAE@XZ:PROC		; CCriticalSection::~CCriticalSection
EXTRN	__imp___wassert:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_??0CWHThread@@IAE@XZ:PROC
EXTRN	__imp_??1CWHThread@@MAE@XZ:PROC
EXTRN	__imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z:PROC
EXTRN	__imp_??1CWHDataLocker@@UAE@XZ:PROC
EXTRN	__imp_?UnLock@CWHDataLocker@@QAEXXZ:PROC
EXTRN	??0CAsynchronismEngine@@QAE@XZ:PROC		; CAsynchronismEngine::CAsynchronismEngine
EXTRN	??1CAsynchronismEngine@@UAE@XZ:PROC		; CAsynchronismEngine::~CAsynchronismEngine
EXTRN	?makeHandshakeResponse@ws@net@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDV45@@Z:PROC ; zl::net::ws::makeHandshakeResponse
EXTRN	?decodeFrame@ws@net@zl@@YA?AW4WsFrameType@123@PBDHPADPAH2@Z:PROC ; zl::net::ws::decodeFrame
EXTRN	?encodeFrame@ws@net@zl@@YAHW4WsFrameType@123@PBDHPADH@Z:PROC ; zl::net::ws::encodeFrame
EXTRN	?parseRequest@HttpContext@net@zl@@QAE_NPAVByteBuffer@23@@Z:PROC ; zl::net::HttpContext::parseRequest
EXTRN	??_ECOverLapped@@UAEPAXI@Z:PROC			; COverLapped::`vector deleting destructor'
EXTRN	??_ECOverLappedSend@@UAEPAXI@Z:PROC		; COverLappedSend::`vector deleting destructor'
EXTRN	??_ECOverLappedRecv@@UAEPAXI@Z:PROC		; COverLappedRecv::`vector deleting destructor'
EXTRN	??_E?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z:PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`vector deleting destructor'
EXTRN	??_ECTCPNetworkItem@@UAEPAXI@Z:PROC		; CTCPNetworkItem::`vector deleting destructor'
EXTRN	??_ECTCPNetworkThreadReadWrite@@UAEPAXI@Z:PROC	; CTCPNetworkThreadReadWrite::`vector deleting destructor'
EXTRN	??_ECTCPNetworkThreadAccept@@UAEPAXI@Z:PROC	; CTCPNetworkThreadAccept::`vector deleting destructor'
EXTRN	??_ECTCPNetworkThreadDetect@@UAEPAXI@Z:PROC	; CTCPNetworkThreadDetect::`vector deleting destructor'
EXTRN	??_E?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z:PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`vector deleting destructor'
EXTRN	??_E?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z:PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`vector deleting destructor'
EXTRN	??_ECTCPNetworkEngine@@UAEPAXI@Z:PROC		; CTCPNetworkEngine::`vector deleting destructor'
EXTRN	?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z:PROC ; CTraceServiceManager::TraceString
EXTRN	??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z:PROC ; google::protobuf::internal::LogMessage::LogMessage
EXTRN	??1LogMessage@internal@protobuf@google@@QAE@XZ:PROC ; google::protobuf::internal::LogMessage::~LogMessage
EXTRN	??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z:PROC ; google::protobuf::internal::LogMessage::operator<<
EXTRN	??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z:PROC ; google::protobuf::internal::LogFinisher::operator=
EXTRN	??1Closure@protobuf@google@@UAE@XZ:PROC		; google::protobuf::Closure::~Closure
EXTRN	??_EClosure@protobuf@google@@UAEPAXI@Z:PROC	; google::protobuf::Closure::`vector deleting destructor'
EXTRN	??1FunctionClosure0@internal@protobuf@google@@UAE@XZ:PROC ; google::protobuf::internal::FunctionClosure0::~FunctionClosure0
EXTRN	??_EFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z:PROC ; google::protobuf::internal::FunctionClosure0::`vector deleting destructor'
EXTRN	?VerifyVersion@internal@protobuf@google@@YAXHHPBD@Z:PROC ; google::protobuf::internal::VerifyVersion
EXTRN	?ShutdownProtobufLibrary@protobuf@google@@YAXXZ:PROC ; google::protobuf::ShutdownProtobufLibrary
EXTRN	?OnShutdown@internal@protobuf@google@@YAXP6AXXZ@Z:PROC ; google::protobuf::internal::OnShutdown
EXTRN	?IncrementRecursionDepthAndPushLimit@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@HH@std@@H@Z:PROC ; google::protobuf::io::CodedInputStream::IncrementRecursionDepthAndPushLimit
EXTRN	?DecrementRecursionDepthAndPopLimit@CodedInputStream@io@protobuf@google@@QAE_NH@Z:PROC ; google::protobuf::io::CodedInputStream::DecrementRecursionDepthAndPopLimit
EXTRN	?ReadVarint32Fallback@CodedInputStream@io@protobuf@google@@AAE_JI@Z:PROC ; google::protobuf::io::CodedInputStream::ReadVarint32Fallback
EXTRN	?ReadVarintSizeAsIntFallback@CodedInputStream@io@protobuf@google@@AAEHXZ:PROC ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsIntFallback
EXTRN	?ReadVarint64Fallback@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@_K_N@std@@XZ:PROC ; google::protobuf::io::CodedInputStream::ReadVarint64Fallback
EXTRN	?ReadTagFallback@CodedInputStream@io@protobuf@google@@AAEII@Z:PROC ; google::protobuf::io::CodedInputStream::ReadTagFallback
EXTRN	?WriteStringWithSizeToArray@CodedOutputStream@io@protobuf@google@@SAPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z:PROC ; google::protobuf::io::CodedOutputStream::WriteStringWithSizeToArray
EXTRN	?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z:PROC ; google::protobuf::io::CodedOutputStream::VarintSize64
EXTRN	?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z:PROC ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
EXTRN	?AllocateAligned@Arena@protobuf@google@@AAEPAXPBVtype_info@@I@Z:PROC ; google::protobuf::Arena::AllocateAligned
EXTRN	?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z:PROC ; google::protobuf::Arena::AddListNode
EXTRN	?AssignWithDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U1234@@Z:PROC ; google::protobuf::internal::ArenaStringPtr::AssignWithDefault
EXTRN	?GoogleOnceInitImpl@protobuf@google@@YAXPAHPAVClosure@12@@Z:PROC ; google::protobuf::GoogleOnceInitImpl
EXTRN	?InitProtobufDefaults@internal@protobuf@google@@YAXXZ:PROC ; google::protobuf::internal::InitProtobufDefaults
EXTRN	?MergeFrom@UnknownFieldSet@protobuf@google@@QAEXABV123@@Z:PROC ; google::protobuf::UnknownFieldSet::MergeFrom
EXTRN	?default_instance@UnknownFieldSet@protobuf@google@@SAPBV123@XZ:PROC ; google::protobuf::UnknownFieldSet::default_instance
EXTRN	?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ:PROC ; google::protobuf::UnknownFieldSet::ClearFallback
EXTRN	?New@MessageLite@protobuf@google@@UBEPAV123@PAVArena@23@@Z:PROC ; google::protobuf::MessageLite::New
EXTRN	?InitializationErrorString@MessageLite@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; google::protobuf::MessageLite::InitializationErrorString
EXTRN	?ParseFromArray@MessageLite@protobuf@google@@QAE_NPBXH@Z:PROC ; google::protobuf::MessageLite::ParseFromArray
EXTRN	?SerializeToArray@MessageLite@protobuf@google@@QBE_NPAXH@Z:PROC ; google::protobuf::MessageLite::SerializeToArray
EXTRN	?InternalSerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAE_NPAE@Z:PROC ; google::protobuf::MessageLite::InternalSerializeWithCachedSizesToArray
EXTRN	??_EMessageLite@protobuf@google@@UAEPAXI@Z:PROC	; google::protobuf::MessageLite::`vector deleting destructor'
EXTRN	?InternalAddGeneratedFile@DescriptorPool@protobuf@google@@SAXPBXH@Z:PROC ; google::protobuf::DescriptorPool::InternalAddGeneratedFile
EXTRN	?CopyFrom@Message@protobuf@google@@UAEXABV123@@Z:PROC ; google::protobuf::Message::CopyFrom
EXTRN	?MergeFrom@Message@protobuf@google@@UAEXABV123@@Z:PROC ; google::protobuf::Message::MergeFrom
EXTRN	?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; google::protobuf::Message::InitializationErrorString
EXTRN	?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ:PROC ; google::protobuf::Message::DiscardUnknownFields
EXTRN	?SpaceUsed@Message@protobuf@google@@UBEHXZ:PROC	; google::protobuf::Message::SpaceUsed
EXTRN	?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; google::protobuf::Message::GetTypeName
EXTRN	?Clear@Message@protobuf@google@@UAEXXZ:PROC	; google::protobuf::Message::Clear
EXTRN	?IsInitialized@Message@protobuf@google@@UBE_NXZ:PROC ; google::protobuf::Message::IsInitialized
EXTRN	?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z:PROC ; google::protobuf::Message::CheckTypeAndMergeFrom
EXTRN	?MergePartialFromCodedStream@Message@protobuf@google@@UAE_NPAVCodedInputStream@io@23@@Z:PROC ; google::protobuf::Message::MergePartialFromCodedStream
EXTRN	?ByteSizeLong@Message@protobuf@google@@UBEIXZ:PROC ; google::protobuf::Message::ByteSizeLong
EXTRN	?SerializeWithCachedSizes@Message@protobuf@google@@UBEXPAVCodedOutputStream@io@23@@Z:PROC ; google::protobuf::Message::SerializeWithCachedSizes
EXTRN	?SetCachedSize@Message@protobuf@google@@EBEXH@Z:PROC ; google::protobuf::Message::SetCachedSize
EXTRN	??_EMessage@protobuf@google@@UAEPAXI@Z:PROC	; google::protobuf::Message::`vector deleting destructor'
EXTRN	?InternalRegisterGeneratedFile@MessageFactory@protobuf@google@@SAXPBDP6AXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@Z:PROC ; google::protobuf::MessageFactory::InternalRegisterGeneratedFile
EXTRN	??_Erequest@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::request::`vector deleting destructor'
EXTRN	??_Eresponse@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::response::`vector deleting destructor'
EXTRN	??_Eindication@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::indication::`vector deleting destructor'
EXTRN	??_Ecommand@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::command::`vector deleting destructor'
EXTRN	??_Einfo@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::info::`vector deleting destructor'
EXTRN	??_Ehead@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::head::`vector deleting destructor'
EXTRN	??_Emessage@NullPmd@@UAEPAXI@Z:PROC		; NullPmd::message::`vector deleting destructor'
EXTRN	?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z:PROC ; google::protobuf::internal::WireFormatLite::SkipField
EXTRN	?ReadBytes@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; google::protobuf::internal::WireFormatLite::ReadBytes
EXTRN	?VerifyUtf8String@WireFormatLite@internal@protobuf@google@@SA_NPBDHW4Operation@1234@0@Z:PROC ; google::protobuf::internal::WireFormatLite::VerifyUtf8String
EXTRN	?WriteInt32@WireFormatLite@internal@protobuf@google@@SAXHHPAVCodedOutputStream@io@34@@Z:PROC ; google::protobuf::internal::WireFormatLite::WriteInt32
EXTRN	?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z:PROC ; google::protobuf::internal::WireFormatLite::WriteUInt64
EXTRN	?WriteStringMaybeAliased@WireFormatLite@internal@protobuf@google@@SAXHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVCodedOutputStream@io@34@@Z:PROC ; google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased
EXTRN	?WriteBytesMaybeAliased@WireFormatLite@internal@protobuf@google@@SAXHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVCodedOutputStream@io@34@@Z:PROC ; google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased
EXTRN	?WriteMessageMaybeToArray@WireFormatLite@internal@protobuf@google@@SAXHABVMessageLite@34@PAVCodedOutputStream@io@34@@Z:PROC ; google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray
EXTRN	?AssignDescriptors@internal@protobuf@google@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBUMigrationSchema@123@PBQBVMessage@23@PBIPAVMessageFactory@23@PAUMetadata@23@PAPBVEnumDescriptor@23@PAPBVServiceDescriptor@23@@Z:PROC ; google::protobuf::internal::AssignDescriptors
EXTRN	?RegisterAllTypes@internal@protobuf@google@@YAXPBUMetadata@23@H@Z:PROC ; google::protobuf::internal::RegisterAllTypes
EXTRN	?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z:PROC ; google::protobuf::internal::ReflectionOps::Merge
EXTRN	??_E?$_Ref_count@D@std@@UAEPAXI@Z:PROC		; std::_Ref_count<char>::`vector deleting destructor'
EXTRN	?ConcludeThread@CWHThread@@UAE_NK@Z:PROC	; CWHThread::ConcludeThread
EXTRN	?IsRuning@CWHThread@@UAE_NXZ:PROC		; CWHThread::IsRuning
EXTRN	?OnEventThreadConclude@CWHThread@@MAE_NXZ:PROC	; CWHThread::OnEventThreadConclude
EXTRN	?OnEventThreadStrat@CWHThread@@MAE_NXZ:PROC	; CWHThread::OnEventThreadStrat
EXTRN	?StartThread@CWHThread@@UAE_NXZ:PROC		; CWHThread::StartThread
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	__aullshr:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_TraceServiceManager@@3VCTraceServiceManager@@A:BYTE ; g_TraceServiceManager
EXTRN	?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA:BYTE ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
EXTRN	?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A:BYTE ; google::protobuf::internal::fixed_address_empty_string
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?once@?1??protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
_BSS	SEGMENT
?once@?1??protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA DD 01H DUP (?) ; `NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce'::`2'::once
_BSS	ENDS
;	COMDAT ?once@?1??InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
_BSS	SEGMENT
?once@?1??InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA DD 01H DUP (?) ; `NullPmd::protobuf_NullPmd_2eproto::InitDefaults'::`2'::once
_BSS	ENDS
;	COMDAT ?once@?1??AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
_BSS	SEGMENT
?once@?1??AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA DD 01H DUP (?) ; `NullPmd::protobuf_NullPmd_2eproto::AddDescriptors'::`2'::once
_BSS	ENDS
_BSS	SEGMENT
?static_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@3UStaticDescriptorInitializer@12@A DB 01H DUP (?) ; NullPmd::protobuf_NullPmd_2eproto::static_descriptor_initializer
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?atlTraceException$initializer$@ATL@@3P6AXXZA DD FLAT:??__EatlTraceException@ATL@@YAXXZ ; ATL::atlTraceException$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@D@std@@8 DD FLAT:??_R0?AV?$_Ref_count@D@std@@@8 ; std::_Ref_count<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Ref_count@D@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count@D@std@@8 ; std::_Ref_count<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@D@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@D@std@@8 DD 00H			; std::_Ref_count<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@D@std@@@8
data$r	SEGMENT
??_R0?AV?$_Ref_count@D@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count@D@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$_Ref_count@D@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@D@std@@6B@ DD 00H			; std::_Ref_count<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count@D@std@@@8
	DD	FLAT:??_R3?$_Ref_count@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@response@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@response@NullPmd@@8 DD FLAT:??_R0?AVresponse@NullPmd@@@8 ; NullPmd::response::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3response@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2response@NullPmd@@8
rdata$r	SEGMENT
??_R2response@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@response@NullPmd@@8 ; NullPmd::response::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3response@NullPmd@@8
rdata$r	SEGMENT
??_R3response@NullPmd@@8 DD 00H				; NullPmd::response::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2response@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4response@NullPmd@@6B@
rdata$r	SEGMENT
??_R4response@NullPmd@@6B@ DD 00H			; NullPmd::response::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVresponse@NullPmd@@@8
	DD	FLAT:??_R3response@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@request@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@request@NullPmd@@8 DD FLAT:??_R0?AVrequest@NullPmd@@@8 ; NullPmd::request::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3request@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2request@NullPmd@@8
rdata$r	SEGMENT
??_R2request@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@request@NullPmd@@8 ; NullPmd::request::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3request@NullPmd@@8
rdata$r	SEGMENT
??_R3request@NullPmd@@8 DD 00H				; NullPmd::request::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2request@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4request@NullPmd@@6B@
rdata$r	SEGMENT
??_R4request@NullPmd@@6B@ DD 00H			; NullPmd::request::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVrequest@NullPmd@@@8
	DD	FLAT:??_R3request@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@message@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@message@NullPmd@@8 DD FLAT:??_R0?AVmessage@NullPmd@@@8 ; NullPmd::message::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3message@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2message@NullPmd@@8
rdata$r	SEGMENT
??_R2message@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@message@NullPmd@@8 ; NullPmd::message::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3message@NullPmd@@8
rdata$r	SEGMENT
??_R3message@NullPmd@@8 DD 00H				; NullPmd::message::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2message@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4message@NullPmd@@6B@
rdata$r	SEGMENT
??_R4message@NullPmd@@6B@ DD 00H			; NullPmd::message::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVmessage@NullPmd@@@8
	DD	FLAT:??_R3message@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@info@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@info@NullPmd@@8 DD FLAT:??_R0?AVinfo@NullPmd@@@8 ; NullPmd::info::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3info@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2info@NullPmd@@8
rdata$r	SEGMENT
??_R2info@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@info@NullPmd@@8 ; NullPmd::info::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3info@NullPmd@@8
rdata$r	SEGMENT
??_R3info@NullPmd@@8 DD 00H				; NullPmd::info::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2info@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4info@NullPmd@@6B@
rdata$r	SEGMENT
??_R4info@NullPmd@@6B@ DD 00H				; NullPmd::info::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVinfo@NullPmd@@@8
	DD	FLAT:??_R3info@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@indication@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@indication@NullPmd@@8 DD FLAT:??_R0?AVindication@NullPmd@@@8 ; NullPmd::indication::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3indication@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2indication@NullPmd@@8
rdata$r	SEGMENT
??_R2indication@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@indication@NullPmd@@8 ; NullPmd::indication::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3indication@NullPmd@@8
rdata$r	SEGMENT
??_R3indication@NullPmd@@8 DD 00H			; NullPmd::indication::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2indication@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4indication@NullPmd@@6B@
rdata$r	SEGMENT
??_R4indication@NullPmd@@6B@ DD 00H			; NullPmd::indication::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVindication@NullPmd@@@8
	DD	FLAT:??_R3indication@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@head@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@head@NullPmd@@8 DD FLAT:??_R0?AVhead@NullPmd@@@8 ; NullPmd::head::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3head@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2head@NullPmd@@8
rdata$r	SEGMENT
??_R2head@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@head@NullPmd@@8 ; NullPmd::head::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3head@NullPmd@@8
rdata$r	SEGMENT
??_R3head@NullPmd@@8 DD 00H				; NullPmd::head::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2head@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4head@NullPmd@@6B@
rdata$r	SEGMENT
??_R4head@NullPmd@@6B@ DD 00H				; NullPmd::head::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVhead@NullPmd@@@8
	DD	FLAT:??_R3head@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@command@NullPmd@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@command@NullPmd@@8 DD FLAT:??_R0?AVcommand@NullPmd@@@8 ; NullPmd::command::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3command@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R2command@NullPmd@@8
rdata$r	SEGMENT
??_R2command@NullPmd@@8 DD FLAT:??_R1A@?0A@EA@command@NullPmd@@8 ; NullPmd::command::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3command@NullPmd@@8
rdata$r	SEGMENT
??_R3command@NullPmd@@8 DD 00H				; NullPmd::command::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2command@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4command@NullPmd@@6B@
rdata$r	SEGMENT
??_R4command@NullPmd@@6B@ DD 00H			; NullPmd::command::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcommand@NullPmd@@@8
	DD	FLAT:??_R3command@NullPmd@@8
rdata$r	ENDS
;	COMDAT ??_R4MessageLite@protobuf@google@@6B@
rdata$r	SEGMENT
??_R4MessageLite@protobuf@google@@6B@ DD 00H		; google::protobuf::MessageLite::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMessageLite@protobuf@google@@@8
	DD	FLAT:??_R3MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R2MessageLite@protobuf@google@@8
rdata$r	SEGMENT
??_R2MessageLite@protobuf@google@@8 DD FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8 ; google::protobuf::MessageLite::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MessageLite@protobuf@google@@8
rdata$r	SEGMENT
??_R3MessageLite@protobuf@google@@8 DD 00H		; google::protobuf::MessageLite::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMessageLite@protobuf@google@@@8
data$r	SEGMENT
??_R0?AVMessageLite@protobuf@google@@@8 DD FLAT:??_7type_info@@6B@ ; google::protobuf::MessageLite `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMessageLite@protobuf@google@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MessageLite@protobuf@google@@8 DD FLAT:??_R0?AVMessageLite@protobuf@google@@@8 ; google::protobuf::MessageLite::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Message@protobuf@google@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Message@protobuf@google@@8 DD FLAT:??_R0?AVMessage@protobuf@google@@@8 ; google::protobuf::Message::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Message@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R2Message@protobuf@google@@8
rdata$r	SEGMENT
??_R2Message@protobuf@google@@8 DD FLAT:??_R1A@?0A@EA@Message@protobuf@google@@8 ; google::protobuf::Message::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MessageLite@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3Message@protobuf@google@@8
rdata$r	SEGMENT
??_R3Message@protobuf@google@@8 DD 00H			; google::protobuf::Message::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Message@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R4Message@protobuf@google@@6B@
rdata$r	SEGMENT
??_R4Message@protobuf@google@@6B@ DD 00H		; google::protobuf::Message::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMessage@protobuf@google@@@8
	DD	FLAT:??_R3Message@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@FunctionClosure0@internal@protobuf@google@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FunctionClosure0@internal@protobuf@google@@8 DD FLAT:??_R0?AVFunctionClosure0@internal@protobuf@google@@@8 ; google::protobuf::internal::FunctionClosure0::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FunctionClosure0@internal@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R2FunctionClosure0@internal@protobuf@google@@8
rdata$r	SEGMENT
??_R2FunctionClosure0@internal@protobuf@google@@8 DD FLAT:??_R1A@?0A@EA@FunctionClosure0@internal@protobuf@google@@8 ; google::protobuf::internal::FunctionClosure0::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Closure@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R3FunctionClosure0@internal@protobuf@google@@8
rdata$r	SEGMENT
??_R3FunctionClosure0@internal@protobuf@google@@8 DD 00H ; google::protobuf::internal::FunctionClosure0::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FunctionClosure0@internal@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFunctionClosure0@internal@protobuf@google@@@8
data$r	SEGMENT
??_R0?AVFunctionClosure0@internal@protobuf@google@@@8 DD FLAT:??_7type_info@@6B@ ; google::protobuf::internal::FunctionClosure0 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFunctionClosure0@internal@protobuf@google@@', 00H
data$r	ENDS
;	COMDAT ??_R4FunctionClosure0@internal@protobuf@google@@6B@
rdata$r	SEGMENT
??_R4FunctionClosure0@internal@protobuf@google@@6B@ DD 00H ; google::protobuf::internal::FunctionClosure0::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFunctionClosure0@internal@protobuf@google@@@8
	DD	FLAT:??_R3FunctionClosure0@internal@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Closure@protobuf@google@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Closure@protobuf@google@@8 DD FLAT:??_R0?AVClosure@protobuf@google@@@8 ; google::protobuf::Closure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Closure@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R2Closure@protobuf@google@@8
rdata$r	SEGMENT
??_R2Closure@protobuf@google@@8 DD FLAT:??_R1A@?0A@EA@Closure@protobuf@google@@8 ; google::protobuf::Closure::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Closure@protobuf@google@@8
rdata$r	SEGMENT
??_R3Closure@protobuf@google@@8 DD 00H			; google::protobuf::Closure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Closure@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVClosure@protobuf@google@@@8
data$r	SEGMENT
??_R0?AVClosure@protobuf@google@@@8 DD FLAT:??_7type_info@@6B@ ; google::protobuf::Closure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVClosure@protobuf@google@@', 00H
data$r	ENDS
;	COMDAT ??_R4Closure@protobuf@google@@6B@
rdata$r	SEGMENT
??_R4Closure@protobuf@google@@6B@ DD 00H		; google::protobuf::Closure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVClosure@protobuf@google@@@8
	DD	FLAT:??_R3Closure@protobuf@google@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 DD FLAT:??_R0?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	SEGMENT
??_R2?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	SEGMENT
??_R3?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8 DD 00H ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@@8
data$r	SEGMENT
??_R0?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@ DD 00H ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@@8
	DD	FLAT:??_R3?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8 DD FLAT:??_R0?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@@8 ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	SEGMENT
??_R2?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8 ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	SEGMENT
??_R3?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8 DD 00H	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@@8
data$r	SEGMENT
??_R0?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@ DD 00H	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@@8
	DD	FLAT:??_R3?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTCPNetworkThreadDetect@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTCPNetworkThreadDetect@@8 DD FLAT:??_R0?AVCTCPNetworkThreadDetect@@@8 ; CTCPNetworkThreadDetect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTCPNetworkThreadDetect@@8
rdata$r	ENDS
;	COMDAT ??_R2CTCPNetworkThreadDetect@@8
rdata$r	SEGMENT
??_R2CTCPNetworkThreadDetect@@8 DD FLAT:??_R1A@?0A@EA@CTCPNetworkThreadDetect@@8 ; CTCPNetworkThreadDetect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R3CTCPNetworkThreadDetect@@8
rdata$r	SEGMENT
??_R3CTCPNetworkThreadDetect@@8 DD 00H			; CTCPNetworkThreadDetect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTCPNetworkThreadDetect@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTCPNetworkThreadDetect@@@8
data$r	SEGMENT
??_R0?AVCTCPNetworkThreadDetect@@@8 DD FLAT:??_7type_info@@6B@ ; CTCPNetworkThreadDetect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTCPNetworkThreadDetect@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTCPNetworkThreadDetect@@6B@
rdata$r	SEGMENT
??_R4CTCPNetworkThreadDetect@@6B@ DD 00H		; CTCPNetworkThreadDetect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkThreadDetect@@@8
	DD	FLAT:??_R3CTCPNetworkThreadDetect@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTCPNetworkThreadAccept@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTCPNetworkThreadAccept@@8 DD FLAT:??_R0?AVCTCPNetworkThreadAccept@@@8 ; CTCPNetworkThreadAccept::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTCPNetworkThreadAccept@@8
rdata$r	ENDS
;	COMDAT ??_R2CTCPNetworkThreadAccept@@8
rdata$r	SEGMENT
??_R2CTCPNetworkThreadAccept@@8 DD FLAT:??_R1A@?0A@EA@CTCPNetworkThreadAccept@@8 ; CTCPNetworkThreadAccept::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R3CTCPNetworkThreadAccept@@8
rdata$r	SEGMENT
??_R3CTCPNetworkThreadAccept@@8 DD 00H			; CTCPNetworkThreadAccept::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTCPNetworkThreadAccept@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTCPNetworkThreadAccept@@@8
data$r	SEGMENT
??_R0?AVCTCPNetworkThreadAccept@@@8 DD FLAT:??_7type_info@@6B@ ; CTCPNetworkThreadAccept `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTCPNetworkThreadAccept@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTCPNetworkThreadAccept@@6B@
rdata$r	SEGMENT
??_R4CTCPNetworkThreadAccept@@6B@ DD 00H		; CTCPNetworkThreadAccept::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkThreadAccept@@@8
	DD	FLAT:??_R3CTCPNetworkThreadAccept@@8
rdata$r	ENDS
;	COMDAT ??_R2CWHThread@@8
rdata$r	SEGMENT
??_R2CWHThread@@8 DD FLAT:??_R1A@?0A@EA@CWHThread@@8	; CWHThread::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWHThread@@8
rdata$r	SEGMENT
??_R3CWHThread@@8 DD 00H				; CWHThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWHThread@@@8
data$r	SEGMENT
??_R0?AVCWHThread@@@8 DD FLAT:??_7type_info@@6B@	; CWHThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWHThread@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWHThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWHThread@@8 DD FLAT:??_R0?AVCWHThread@@@8 ; CWHThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTCPNetworkThreadReadWrite@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTCPNetworkThreadReadWrite@@8 DD FLAT:??_R0?AVCTCPNetworkThreadReadWrite@@@8 ; CTCPNetworkThreadReadWrite::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTCPNetworkThreadReadWrite@@8
rdata$r	ENDS
;	COMDAT ??_R2CTCPNetworkThreadReadWrite@@8
rdata$r	SEGMENT
??_R2CTCPNetworkThreadReadWrite@@8 DD FLAT:??_R1A@?0A@EA@CTCPNetworkThreadReadWrite@@8 ; CTCPNetworkThreadReadWrite::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R3CTCPNetworkThreadReadWrite@@8
rdata$r	SEGMENT
??_R3CTCPNetworkThreadReadWrite@@8 DD 00H		; CTCPNetworkThreadReadWrite::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTCPNetworkThreadReadWrite@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTCPNetworkThreadReadWrite@@@8
data$r	SEGMENT
??_R0?AVCTCPNetworkThreadReadWrite@@@8 DD FLAT:??_7type_info@@6B@ ; CTCPNetworkThreadReadWrite `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTCPNetworkThreadReadWrite@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTCPNetworkThreadReadWrite@@6B@
rdata$r	SEGMENT
??_R4CTCPNetworkThreadReadWrite@@6B@ DD 00H		; CTCPNetworkThreadReadWrite::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkThreadReadWrite@@@8
	DD	FLAT:??_R3CTCPNetworkThreadReadWrite@@8
rdata$r	ENDS
;	COMDAT ??_R4COverLapped@@6B@
rdata$r	SEGMENT
??_R4COverLapped@@6B@ DD 00H				; COverLapped::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOverLapped@@@8
	DD	FLAT:??_R3COverLapped@@8
rdata$r	ENDS
;	COMDAT ??_R4ITCPNetworkItemSink@@6B@
rdata$r	SEGMENT
??_R4ITCPNetworkItemSink@@6B@ DD 00H			; ITCPNetworkItemSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUITCPNetworkItemSink@@@8
	DD	FLAT:??_R3ITCPNetworkItemSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8 DD FLAT:??_R0?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@@8 ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	SEGMENT
??_R2?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8 DD FLAT:??_R1A@?0A@EA@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8 ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	SEGMENT
??_R3?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8 DD 00H	; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@@8
data$r	SEGMENT
??_R0?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@@8 DD FLAT:??_7type_info@@6B@ ; CWHArray<COverLappedSend *,COverLappedSend * const &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@
rdata$r	SEGMENT
??_R4?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@ DD 00H	; CWHArray<COverLappedSend *,COverLappedSend * const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@@8
	DD	FLAT:??_R3?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@8
rdata$r	ENDS
;	COMDAT ??_R4CTCPNetworkEngine@@6BITCPNetworkItemSink@@@
rdata$r	SEGMENT
??_R4CTCPNetworkEngine@@6BITCPNetworkItemSink@@@ DD 00H	; CTCPNetworkEngine::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkEngine@@@8
	DD	FLAT:??_R3CTCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R4CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@
rdata$r	SEGMENT
??_R4CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@ DD 00H ; CTCPNetworkEngine::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkEngine@@@8
	DD	FLAT:??_R3CTCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITCPNetworkItemSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITCPNetworkItemSink@@8 DD FLAT:??_R0?AUITCPNetworkItemSink@@@8 ; ITCPNetworkItemSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITCPNetworkItemSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITCPNetworkItemSink@@8
rdata$r	SEGMENT
??_R2ITCPNetworkItemSink@@8 DD FLAT:??_R1A@?0A@EA@ITCPNetworkItemSink@@8 ; ITCPNetworkItemSink::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ITCPNetworkItemSink@@8
rdata$r	SEGMENT
??_R3ITCPNetworkItemSink@@8 DD 00H			; ITCPNetworkItemSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ITCPNetworkItemSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITCPNetworkItemSink@@@8
data$r	SEGMENT
??_R0?AUITCPNetworkItemSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITCPNetworkItemSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITCPNetworkItemSink@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@ITCPNetworkItemSink@@8
rdata$r	SEGMENT
??_R17?0A@EA@ITCPNetworkItemSink@@8 DD FLAT:??_R0?AUITCPNetworkItemSink@@@8 ; ITCPNetworkItemSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITCPNetworkItemSink@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknownEx@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@IAsynchronismEngineSink@@8
rdata$r	SEGMENT
??_R13?0A@EA@IAsynchronismEngineSink@@8 DD FLAT:??_R0?AUIAsynchronismEngineSink@@@8 ; IAsynchronismEngineSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAsynchronismEngineSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknownEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTCPNetworkEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTCPNetworkEngine@@8 DD FLAT:??_R0?AVCTCPNetworkEngine@@@8 ; CTCPNetworkEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2CTCPNetworkEngine@@8
rdata$r	SEGMENT
??_R2CTCPNetworkEngine@@8 DD FLAT:??_R1A@?0A@EA@CTCPNetworkEngine@@8 ; CTCPNetworkEngine::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITCPNetworkEngine@@8
	DD	FLAT:??_R1A@?0A@EA@IServiceModule@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknownEx@@8
	DD	FLAT:??_R13?0A@EA@IAsynchronismEngineSink@@8
	DD	FLAT:??_R13?0A@EC@IUnknownEx@@8
	DD	FLAT:??_R17?0A@EA@ITCPNetworkItemSink@@8
rdata$r	ENDS
;	COMDAT ??_R3CTCPNetworkEngine@@8
rdata$r	SEGMENT
??_R3CTCPNetworkEngine@@8 DD 00H			; CTCPNetworkEngine::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	07H
	DD	FLAT:??_R2CTCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTCPNetworkEngine@@@8
data$r	SEGMENT
??_R0?AVCTCPNetworkEngine@@@8 DD FLAT:??_7type_info@@6B@ ; CTCPNetworkEngine `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTCPNetworkEngine@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTCPNetworkEngine@@6BITCPNetworkEngine@@@
rdata$r	SEGMENT
??_R4CTCPNetworkEngine@@6BITCPNetworkEngine@@@ DD 00H	; CTCPNetworkEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkEngine@@@8
	DD	FLAT:??_R3CTCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTCPNetworkItem@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTCPNetworkItem@@8 DD FLAT:??_R0?AVCTCPNetworkItem@@@8 ; CTCPNetworkItem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTCPNetworkItem@@8
rdata$r	ENDS
;	COMDAT ??_R2CTCPNetworkItem@@8
rdata$r	SEGMENT
??_R2CTCPNetworkItem@@8 DD FLAT:??_R1A@?0A@EA@CTCPNetworkItem@@8 ; CTCPNetworkItem::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CTCPNetworkItem@@8
rdata$r	SEGMENT
??_R3CTCPNetworkItem@@8 DD 00H				; CTCPNetworkItem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTCPNetworkItem@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTCPNetworkItem@@@8
data$r	SEGMENT
??_R0?AVCTCPNetworkItem@@@8 DD FLAT:??_7type_info@@6B@	; CTCPNetworkItem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTCPNetworkItem@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTCPNetworkItem@@6B@
rdata$r	SEGMENT
??_R4CTCPNetworkItem@@6B@ DD 00H			; CTCPNetworkItem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTCPNetworkItem@@@8
	DD	FLAT:??_R3CTCPNetworkItem@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COverLappedSend@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COverLappedSend@@8 DD FLAT:??_R0?AVCOverLappedSend@@@8 ; COverLappedSend::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COverLappedSend@@8
rdata$r	ENDS
;	COMDAT ??_R2COverLappedSend@@8
rdata$r	SEGMENT
??_R2COverLappedSend@@8 DD FLAT:??_R1A@?0A@EA@COverLappedSend@@8 ; COverLappedSend::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@COverLapped@@8
rdata$r	ENDS
;	COMDAT ??_R3COverLappedSend@@8
rdata$r	SEGMENT
??_R3COverLappedSend@@8 DD 00H				; COverLappedSend::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2COverLappedSend@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOverLappedSend@@@8
data$r	SEGMENT
??_R0?AVCOverLappedSend@@@8 DD FLAT:??_7type_info@@6B@	; COverLappedSend `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOverLappedSend@@', 00H
data$r	ENDS
;	COMDAT ??_R4COverLappedSend@@6B@
rdata$r	SEGMENT
??_R4COverLappedSend@@6B@ DD 00H			; COverLappedSend::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOverLappedSend@@@8
	DD	FLAT:??_R3COverLappedSend@@8
rdata$r	ENDS
;	COMDAT ??_R2COverLapped@@8
rdata$r	SEGMENT
??_R2COverLapped@@8 DD FLAT:??_R1A@?0A@EA@COverLapped@@8 ; COverLapped::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3COverLapped@@8
rdata$r	SEGMENT
??_R3COverLapped@@8 DD 00H				; COverLapped::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2COverLapped@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOverLapped@@@8
data$r	SEGMENT
??_R0?AVCOverLapped@@@8 DD FLAT:??_7type_info@@6B@	; COverLapped `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOverLapped@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COverLapped@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COverLapped@@8 DD FLAT:??_R0?AVCOverLapped@@@8 ; COverLapped::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COverLapped@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COverLappedRecv@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COverLappedRecv@@8 DD FLAT:??_R0?AVCOverLappedRecv@@@8 ; COverLappedRecv::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COverLappedRecv@@8
rdata$r	ENDS
;	COMDAT ??_R2COverLappedRecv@@8
rdata$r	SEGMENT
??_R2COverLappedRecv@@8 DD FLAT:??_R1A@?0A@EA@COverLappedRecv@@8 ; COverLappedRecv::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@COverLapped@@8
rdata$r	ENDS
;	COMDAT ??_R3COverLappedRecv@@8
rdata$r	SEGMENT
??_R3COverLappedRecv@@8 DD 00H				; COverLappedRecv::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2COverLappedRecv@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOverLappedRecv@@@8
data$r	SEGMENT
??_R0?AVCOverLappedRecv@@@8 DD FLAT:??_7type_info@@6B@	; COverLappedRecv `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOverLappedRecv@@', 00H
data$r	ENDS
;	COMDAT ??_R4COverLappedRecv@@6B@
rdata$r	SEGMENT
??_R4COverLappedRecv@@6B@ DD 00H			; COverLappedRecv::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOverLappedRecv@@@8
	DD	FLAT:??_R3COverLappedRecv@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITCPNetworkEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITCPNetworkEngine@@8 DD FLAT:??_R0?AUITCPNetworkEngine@@@8 ; ITCPNetworkEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2ITCPNetworkEngine@@8
rdata$r	SEGMENT
??_R2ITCPNetworkEngine@@8 DD FLAT:??_R1A@?0A@EA@ITCPNetworkEngine@@8 ; ITCPNetworkEngine::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IServiceModule@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3ITCPNetworkEngine@@8
rdata$r	SEGMENT
??_R3ITCPNetworkEngine@@8 DD 00H			; ITCPNetworkEngine::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ITCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITCPNetworkEngine@@@8
data$r	SEGMENT
??_R0?AUITCPNetworkEngine@@@8 DD FLAT:??_7type_info@@6B@ ; ITCPNetworkEngine `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITCPNetworkEngine@@', 00H
data$r	ENDS
;	COMDAT ??_R4ITCPNetworkEngine@@6B@
rdata$r	SEGMENT
??_R4ITCPNetworkEngine@@6B@ DD 00H			; ITCPNetworkEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUITCPNetworkEngine@@@8
	DD	FLAT:??_R3ITCPNetworkEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IAsynchronismEngineSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IAsynchronismEngineSink@@8 DD FLAT:??_R0?AUIAsynchronismEngineSink@@@8 ; IAsynchronismEngineSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IAsynchronismEngineSink@@8
rdata$r	ENDS
;	COMDAT ??_R2IAsynchronismEngineSink@@8
rdata$r	SEGMENT
??_R2IAsynchronismEngineSink@@8 DD FLAT:??_R1A@?0A@EA@IAsynchronismEngineSink@@8 ; IAsynchronismEngineSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3IAsynchronismEngineSink@@8
rdata$r	SEGMENT
??_R3IAsynchronismEngineSink@@8 DD 00H			; IAsynchronismEngineSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IAsynchronismEngineSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIAsynchronismEngineSink@@@8
data$r	SEGMENT
??_R0?AUIAsynchronismEngineSink@@@8 DD FLAT:??_7type_info@@6B@ ; IAsynchronismEngineSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIAsynchronismEngineSink@@', 00H
data$r	ENDS
;	COMDAT ??_R4IAsynchronismEngineSink@@6B@
rdata$r	SEGMENT
??_R4IAsynchronismEngineSink@@6B@ DD 00H		; IAsynchronismEngineSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIAsynchronismEngineSink@@@8
	DD	FLAT:??_R3IAsynchronismEngineSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IServiceModule@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IServiceModule@@8 DD FLAT:??_R0?AUIServiceModule@@@8 ; IServiceModule::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R2IServiceModule@@8
rdata$r	SEGMENT
??_R2IServiceModule@@8 DD FLAT:??_R1A@?0A@EA@IServiceModule@@8 ; IServiceModule::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3IServiceModule@@8
rdata$r	SEGMENT
??_R3IServiceModule@@8 DD 00H				; IServiceModule::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIServiceModule@@@8
data$r	SEGMENT
??_R0?AUIServiceModule@@@8 DD FLAT:??_7type_info@@6B@	; IServiceModule `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIServiceModule@@', 00H
data$r	ENDS
;	COMDAT ??_R4IServiceModule@@6B@
rdata$r	SEGMENT
??_R4IServiceModule@@6B@ DD 00H				; IServiceModule::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIServiceModule@@@8
	DD	FLAT:??_R3IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknownEx@@8
rdata$r	SEGMENT
??_R2IUnknownEx@@8 DD FLAT:??_R1A@?0A@EA@IUnknownEx@@8	; IUnknownEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknownEx@@8
rdata$r	SEGMENT
??_R3IUnknownEx@@8 DD 00H				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknownEx@@@8
data$r	SEGMENT
??_R0?AUIUnknownEx@@@8 DD FLAT:??_7type_info@@6B@	; IUnknownEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknownEx@@', 00H
data$r	ENDS
;	COMDAT ??_R4IUnknownEx@@6B@
rdata$r	SEGMENT
??_R4IUnknownEx@@6B@ DD 00H				; IUnknownEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIUnknownEx@@@8
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD FLAT:??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
data$r	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Ref_count_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
CONST	SEGMENT
??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@ DB '"'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 's', 00H, 'p', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'o'
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
CONST	SEGMENT
??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@ DB 'transposed pointer ran'
	DB	'ge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
CONST	SEGMENT
??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@8
data$r	SEGMENT
??_R0?AUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@8 DD FLAT:??_7type_info@@6B@ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUContainer@?$InternalMetadataWithArenaBase@VUnknownFi'
	DB	'eldSet@protobuf@google@@VInternalMetadataWithArena@internal@2'
	DB	'3@@internal@protobuf@google@@', 00H
data$r	ENDS
;	COMDAT ??_7?$_Ref_count@D@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@D@std@@6B@ DD FLAT:??_R4?$_Ref_count@D@std@@6B@ ; std::_Ref_count<char>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count@D@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count@D@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count@D@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
CONST	SEGMENT
??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@JONCLBEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAb?$AAu?$AAg?$AA_?$AAl?$AAt?$AA_@
CONST	SEGMENT
??_C@_1CI@JONCLBEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAb?$AAu?$AAg?$AA_?$AAl?$AAt?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'b', 00H, 'u', 00H, 'g', 00H, '_', 00H, 'l', 00H, 't'
	DB	00H, '_', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FEEMDEPI@invalid?5comparator@
CONST	SEGMENT
??_C@_0BD@FEEMDEPI@invalid?5comparator@ DB 'invalid comparator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AVmessage@NullPmd@@@8
data$r	SEGMENT
??_R0?AVmessage@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::message `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVmessage@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVhead@NullPmd@@@8
data$r	SEGMENT
??_R0?AVhead@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::head `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVhead@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVinfo@NullPmd@@@8
data$r	SEGMENT
??_R0?AVinfo@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::info `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVinfo@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVcommand@NullPmd@@@8
data$r	SEGMENT
??_R0?AVcommand@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::command `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcommand@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVindication@NullPmd@@@8
data$r	SEGMENT
??_R0?AVindication@NullPmd@@@8 DD FLAT:??_7type_info@@6B@ ; NullPmd::indication `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVindication@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVresponse@NullPmd@@@8
data$r	SEGMENT
??_R0?AVresponse@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::response `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVresponse@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVrequest@NullPmd@@@8
data$r	SEGMENT
??_R0?AVrequest@NullPmd@@@8 DD FLAT:??_7type_info@@6B@	; NullPmd::request `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVrequest@NullPmd@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVMessage@protobuf@google@@@8
data$r	SEGMENT
??_R0?AVMessage@protobuf@google@@@8 DD FLAT:??_7type_info@@6B@ ; google::protobuf::Message `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMessage@protobuf@google@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0c8H, 0abH, 0beH, 0d6H, 0b6H, 0a8H, 0d2H, 0e5H, '\a'
	DB	'rray.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CAM@NGLDEJOH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAv?$AAa?$AAl?$AA?$DM@
CONST	SEGMENT
??_C@_1CAM@NGLDEJOH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAv?$AAa?$AAl?$AA?$DM@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, '<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H
	DB	't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, '_', 00H, 'T', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '_', 00H
	DB	's', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_'
	DB	00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H
	DB	'a', 00H, 'i', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c'
	DB	00H, '_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ','
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H
	DB	'a', 00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd'
	DB	00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' '
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b'
	DB	00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H
	DB	'>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'E', 00H, 'x', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@CEDAEPC@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5@
CONST	SEGMENT
??_C@_1EO@CEDAEPC@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5@ DB '"'
	DB	00H, 'm', 00H, 'a', 00H, 'p', 00H, '/', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, 's', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DMG@NDMMDDDJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1DMG@NDMMDDDJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'T', 00H, 'm', 00H, 'a', 00H, 'p'
	DB	00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a'
	DB	00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H
	DB	't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a'
	DB	00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ',', 00H, 'c', 00H
	DB	'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H
	DB	'i', 00H, 'c', 00H, '_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c'
	DB	00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H
	DB	':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H
	DB	'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ',', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H
	DB	'c', 00H, 't', 00H, ' ', 00H, 'z', 00H, 'l', 00H, ':', 00H, ':'
	DB	00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, ':', 00H, ':', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 'c', 00H, 'm', 00H, 'p', 00H, '_', 00H, 'n', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 's', 00H, 'e', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H
	DB	'a', 00H, 'i', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c'
	DB	00H, '_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ','
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H
	DB	'a', 00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H
	DB	'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd'
	DB	00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' '
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b'
	DB	00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't'
	DB	00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H
	DB	'>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H
	DB	'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ',', 00H, '0', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	':', 00H, ':', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JILFNJOL@map?1set?5erase?5iterator?5outside?5@
CONST	SEGMENT
??_C@_0CF@JILFNJOL@map?1set?5erase?5iterator?5outside?5@ DB 'map/set eras'
	DB	'e iterator outside range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1JM@EIPCMFMM@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
CONST	SEGMENT
??_C@_1JM@EIPCMFMM@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@ DB '"'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '(', 00H, 'e', 00H
	DB	'.', 00H, 'g', 00H, '.', 00H, '"', 00H, ' ', 00H, '"', 00H, ' '
	DB	00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'd', 00H, 'i', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H
	DB	'c', 00H, 'e', 00H, 's', 00H, ')', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@NPIAEPMO@string?5iterators?5incompatible?5?$CI@
CONST	SEGMENT
??_C@_0EJ@NPIAEPMO@string?5iterators?5incompatible?5?$CI@ DB 'string iter'
	DB	'ators incompatible (e.g. point to different string instances)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@NKHAAGMB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1FE@NKHAAGMB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'p'
	DB	00H, '/', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OKFEHCEB@cannot?5dereference?5end?5map?1set?5@
CONST	SEGMENT
??_C@_0CI@OKFEHCEB@cannot?5dereference?5end?5map?1set?5@ DB 'cannot deref'
	DB	'erence end map/set iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@ILGCNILF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HA@ILGCNILF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'a'
	DB	00H, 'p', 00H, '/', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CFE@PPLBLEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
CONST	SEGMENT
??_C@_1CFE@PPLBLEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'T', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a'
	DB	00H, 'i', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b', 00H
	DB	'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LCFNIIPB@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DG@LCFNIIPB@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized map/set iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@JLIDLCDH@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
CONST	SEGMENT
??_C@_1EC@JLIDLCDH@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DB '"'
	DB	00H, 'm', 00H, 'a', 00H, 'p', 00H, '/', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H
	DB	'n', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CFG@FGJHCIBH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
CONST	SEGMENT
??_C@_1CFG@FGJHCIBH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'T', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a'
	DB	00H, 'i', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b', 00H
	DB	'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '=', 00H, '=', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLDKBHLM@map?1set?5iterators?5incompatible@
CONST	SEGMENT
??_C@_0BP@OLDKBHLM@map?1set?5iterators?5incompatible@ DB 'map/set iterato'
	DB	'rs incompatible', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1KO@CMPBFHAM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1KO@CMPBFHAM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'c', 00H, 'a'
	DB	00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 's', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, '(', 00H, 'e', 00H, '.'
	DB	00H, 'g', 00H, '.', 00H, ' ', 00H, 'a', 00H, 'n', 00H, ' ', 00H
	DB	'e', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ')', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@HJKEHIBC@cannot?5dereference?5string?5itera@
CONST	SEGMENT
??_C@_0FF@HJKEHIBC@cannot?5dereference?5string?5itera@ DB 'cannot derefer'
	DB	'ence string iterator because it is out of range (e.g. an end '
	DB	'iterator)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAO@BGLBIONH@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1BAO@BGLBIONH@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'c', 00H, 'a'
	DB	00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'w', 00H, 'a', 00H
	DB	's', 00H, '"', 00H, ' ', 00H, '"', 00H, ' ', 00H, 'i', 00H, 'n'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '(', 00H, 'e', 00H, '.'
	DB	00H, 'g', 00H, '.', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'c', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, ' ', 00H, 'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'd', 00H
	DB	'e', 00H, 's', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'y', 00H, 'e'
	DB	00H, 'd', 00H, ')', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0IC@DGJDAAEM@cannot?5dereference?5string?5itera@
CONST	SEGMENT
??_C@_0IC@DGJDAAEM@cannot?5dereference?5string?5itera@ DB 'cannot derefer'
	DB	'ence string iterator because the iterator was invalidated (e.'
	DB	'g. reallocation occurred, or the string was destroyed)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GO@PNALIMBD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1GO@PNALIMBD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IMIHIHOP@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DF@IMIHIHOP@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized string iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@JCCODAAD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
CONST	SEGMENT
??_C@_1FI@JCCODAAD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'p', 00H, 'a', 00H, 's', 00H, 't', 00H, ' ', 00H, 'e'
	DB	00H, 'n', 00H, 'd', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IKJHPFKC@cannot?5increment?5string?5iterato@
CONST	SEGMENT
??_C@_0CK@IKJHPFKC@cannot?5increment?5string?5iterato@ DB 'cannot increme'
	DB	'nt string iterator past end', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAK@GBJMLMKM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
CONST	SEGMENT
??_C@_1BAK@GBJMLMKM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'b', 00H, 'e', 00H, 'c', 00H, 'a', 00H, 'u', 00H, 's'
	DB	00H, 'e', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'w', 00H, 'a', 00H, 's', 00H, '"', 00H
	DB	' ', 00H, '"', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a'
	DB	00H, 'l', 00H, 'i', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '(', 00H, 'e', 00H, '.', 00H, 'g', 00H, '.'
	DB	00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, 'o', 00H, 'c', 00H, 'c', 00H, 'u', 00H, 'r', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'w'
	DB	00H, 'a', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'o', 00H, 'y', 00H, 'e', 00H, 'd', 00H, ')'
	DB	00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0IA@BFMOHEDB@cannot?5increment?5string?5iterato@
CONST	SEGMENT
??_C@_0IA@BFMOHEDB@cannot?5increment?5string?5iterato@ DB 'cannot increme'
	DB	'nt string iterator because the iterator was invalidated (e.g.'
	DB	' reallocation occurred, or the string was destroyed)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@MICKMFNF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
CONST	SEGMENT
??_C@_1GK@MICKMFNF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H
	DB	'+', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xstring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LAECODHC@cannot?5increment?5value?9initiali@
CONST	SEGMENT
??_C@_0DD@LAECODHC@cannot?5increment?5value?9initiali@ DB 'cannot increme'
	DB	'nt value-initialized string iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'o', 00H
	DB	'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r'
	DB	00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'v', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, '"', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@
CONST	SEGMENT
??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@ DB 'can''t dere'
	DB	'ference out of range vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@DDPKBOFO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1MG@DDPKBOFO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@
CONST	SEGMENT
??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@ DB 'can''t derefe'
	DB	'rence value-initialized vector iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@KLFCDGNE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
CONST	SEGMENT
??_C@_1FA@KLFCDGNE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'e', 00H, 'n', 00H
	DB	'd', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'p', 00H, '/', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NLEHEOHN@cannot?5increment?5end?5map?1set?5it@
CONST	SEGMENT
??_C@_0CG@NLEHEOHN@cannot?5increment?5end?5map?1set?5it@ DB 'cannot incre'
	DB	'ment end map/set iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@BJMCGEGI@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
CONST	SEGMENT
??_C@_1GM@BJMCGEGI@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'p', 00H, '/'
	DB	00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CFG@PGGKMBNC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
CONST	SEGMENT
??_C@_1CFG@PGGKMBNC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'n'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'T', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, '_', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'<', 00H, 's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't'
	DB	00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'T', 00H, 'r', 00H, 'e', 00H, 'e', 00H, '_', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'p', 00H, 'a'
	DB	00H, 'i', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'i', 00H, 'c', 00H
	DB	'_', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ',', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a'
	DB	00H, 'i', 00H, 't', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h', 00H
	DB	'a', 00H, 'r', 00H, '>', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H
	DB	':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'b', 00H
	DB	'a', 00H, 's', 00H, 'i', 00H, 'c', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '<', 00H, 'c', 00H
	DB	'h', 00H, 'a', 00H, 'r', 00H, ',', 00H, 's', 00H, 't', 00H, 'r'
	DB	00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, '>'
	DB	00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a'
	DB	00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':'
	DB	00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 't', 00H
	DB	'r', 00H, 'e', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xtree', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DMNPKCGM@cannot?5increment?5value?9initiali@
CONST	SEGMENT
??_C@_0DE@DMNPKCGM@cannot?5increment?5value?9initiali@ DB 'cannot increme'
	DB	'nt value-initialized map/set iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\vector', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@ DB 0bdH, 0d3H, 0bfH
	DB	0daH, 0b2H, 0e9H, 0d1H, 0afH, 0caH, 0a7H, 0b0H, 0dcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@ DB 0b4H, 0b4H, 0bdH, 0a8H
	DB	0caH, 0a7H, 0b0H, 0dcH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ELCMGMJI@?$LG?K?$LP?Z?U?$PN?$LB?$LL?F?d?K?$PL?$LH?$PO?N?q?U?$LM?S?C?$KD?$KM?$LM?$OA?L?$PN?5?$CFld?5@
CONST	SEGMENT
??_C@_0CI@ELCMGMJI@?$LG?K?$LP?Z?U?$PN?$LB?$LL?F?d?K?$PL?$LH?$PO?N?q?U?$LM?S?C?$KD?$KM?$LM?$OA?L?$PN?5?$CFld?5@ DB 0b6H
	DB	0cbH, 0bfH, 0daH, 0d5H, 0fdH, 0b1H, 0bbH, 0c6H, 0e4H, 0cbH, 0fbH
	DB	0b7H, 0feH, 0ceH, 0f1H, 0d5H, 0bcH, 0d3H, 0c3H, 0a3H, 0acH, 0bcH
	DB	0e0H, 0ccH, 0fdH, ' %ld ', 0b6H, 0cbH, 0bfH, 0daH, 0caH, 0a7H, 0b0H
	DB	0dcH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FEECEEMH@?M?x?B?g?$LA?s?$LG?$KI?$LE?m?N?s?0?F?t?$LG?$KP?J?$KH?$LA?$NM?4?U?$LM?S?C?$LG?K?$LP?Z?$KD@
CONST	SEGMENT
??_C@_0CD@FEECEEMH@?M?x?B?g?$LA?s?$LG?$KI?$LE?m?N?s?0?F?t?$LG?$KP?J?$KH?$LA?$NM?4?U?$LM?S?C?$LG?K?$LP?Z?$KD@ DB 0cdH
	DB	0f8H, 0c2H, 0e7H, 0b0H, 0f3H, 0b6H, 0a8H, 0b4H, 0edH, 0ceH, 0f3H
	DB	',', 0c6H, 0f4H, 0b6H, 0afH, 0caH, 0a7H, 0b0H, 0dcH, '.', 0d5H
	DB	0bcH, 0d3H, 0c3H, 0b6H, 0cbH, 0bfH, 0daH, 0a3H, 0baH, '%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KAEGCGFA@?O?$LF?M?$LD?W?J?T?$LE?$LC?$LL?W?c?$LL?r?U?$NP?5TCP?1IP?5?P?$KN?R?i?C?$LL?S@
CONST	SEGMENT
??_C@_0DD@KAEGCGFA@?O?$LF?M?$LD?W?J?T?$LE?$LC?$LL?W?c?$LL?r?U?$NP?5TCP?1IP?5?P?$KN?R?i?C?$LL?S@ DB 0cfH
	DB	0b5H, 0cdH, 0b3H, 0d7H, 0caH, 0d4H, 0b4H, 0b2H, 0bbH, 0d7H, 0e3H
	DB	0bbH, 0f2H, 0d5H, 0dfH, ' TCP/IP ', 0d0H, 0adH, 0d2H, 0e9H, 0c3H
	DB	0bbH, 0d3H, 0d0H, 0b0H, 0b2H, 0d7H, 0b0H, 0a3H, 0acH, 0cdH, 0f8H
	DB	0c2H, 0e7H, 0c6H, 0f4H, 0b6H, 0afH, 0caH, 0a7H, 0b0H, 0dcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DMDLLPEB@?$LD?$KC?J?T?A?K?V?Z?$LG?$OA?$LF?D?$LG?K?$LP?Z?$LK?E?$KD?$KM?$LM?$OA?L?$PN?$LC?Y?W?w?J?$KH?$LA@
CONST	SEGMENT
??_C@_0CB@DMDLLPEB@?$LD?$KC?J?T?A?K?V?Z?$LG?$OA?$LF?D?$LG?K?$LP?Z?$LK?E?$KD?$KM?$LM?$OA?L?$PN?$LC?Y?W?w?J?$KH?$LA@ DB 0b3H
	DB	0a2H, 0caH, 0d4H, 0c1H, 0cbH, 0d6H, 0daH, 0b6H, 0e0H, 0b5H, 0c4H
	DB	0b6H, 0cbH, 0bfH, 0daH, 0baH, 0c5H, 0a3H, 0acH, 0bcH, 0e0H, 0ccH
	DB	0fdH, 0b2H, 0d9H, 0d7H, 0f7H, 0caH, 0a7H, 0b0H, 0dcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FJOHAJKD@?N?$LE?V?$LI?$LG?$KI?M?x?B?g?$LG?K?$LP?Z?$KD?$KM?$LN?$KL?K?f?$LL?z?$LH?V?E?d@
CONST	SEGMENT
??_C@_0BL@FJOHAJKD@?N?$LE?V?$LI?$LG?$KI?M?x?B?g?$LG?K?$LP?Z?$KD?$KM?$LN?$KL?K?f?$LL?z?$LH?V?E?d@ DB 0ceH
	DB	0b4H, 0d6H, 0b8H, 0b6H, 0a8H, 0cdH, 0f8H, 0c2H, 0e7H, 0b6H, 0cbH
	DB	0bfH, 0daH, 0a3H, 0acH, 0bdH, 0abH, 0cbH, 0e6H, 0bbH, 0faH, 0b7H
	DB	0d6H, 0c5H, 0e4H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GIIMFCKJ@?I?j?G?k?A?$KM?$LN?S?$LG?T?O?s?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_0BB@GIIMFCKJ@?I?j?G?k?A?$KM?$LN?S?$LG?T?O?s?J?$KH?$LA?$NM@ DB 0c9H, 0eaH
	DB	0c7H, 0ebH, 0c1H, 0acH, 0bdH, 0d3H, 0b6H, 0d4H, 0cfH, 0f3H, 0caH
	DB	0a7H, 0b0H, 0dcH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CFILDAFG@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMSendRaw@
CONST	SEGMENT
??_C@_0CN@CFILDAFG@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMSendRaw@ DB 'I'
	DB	'ndex=%ld', 0a3H, 0acH, 'RountID=%ld', 0a3H, 0acH, 'SendRawDat'
	DB	'a ', 0b7H, 0a2H, 0c9H, 0faH, 0d2H, 0ecH, 0b3H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For@
CONST	SEGMENT
??_C@_0BA@HEMDDLEL@X?9Forwarded?9For@ DB 'X-Forwarded-For', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MAPHGENJ@?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAg?$AAo?$AAt?$AAA?$AAl?$AAl?$AA?$CI@
CONST	SEGMENT
??_C@_1CC@MAPHGENJ@?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAg?$AAo?$AAt?$AAA?$AAl?$AAl?$AA?$CI@ DB 'c'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'.', 00H, 'g', 00H, 'o', 00H, 't', 00H, 'A', 00H, 'l', 00H, 'l'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@EFDLDILG@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
CONST	SEGMENT
??_C@_1HG@EFDLDILG@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@ DB 'g'
	DB	00H, ':', 00H, '\', 00H, 'Q', 07fH, 0d0H, 'r\', 00H, 'h', 00H, 'a'
	DB	00H, 'p', 00H, 'p', 00H, 'y', 00H, 'g', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 'w', 00H, 'h', 00H, '\', 00H, 0dH, 'g', 0a1H, 'R', 0efH
	DB	'z\', 00H, 0fbH, '|', 0dfH, '~!jWW\', 00H, 0dH, 'g', 0a1H, 'Rh'
	DB	'V', 0c4H, '~', 0f6H, 'N\', 00H, 085H, 'Q8h', 015H, '_', 0ceH, 'd'
	DB	'\', 00H, 't', 00H, 'c', 00H, 'p', 00H, 'n', 00H, 'e', 00H, 't'
	DB	00H, 'w', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'e', 00H, 'n', 00H
	DB	'g', 00H, 'i', 00H, 'n', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'p'
	DB	00H, 'p', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PJMBPKGC@HTTP?11?41?5400?5Bad?5Request?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_0BN@PJMBPKGC@HTTP?11?41?5400?5Bad?5Request?$AN?6?$AN?6@ DB 'HTTP/1.'
	DB	'1 400 Bad Request', 0dH, 0aH, 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GGFIIOME@parse?5handshake?5error?0send?5clos@
CONST	SEGMENT
??_C@_0CI@GGFIIOME@parse?5handshake?5error?0send?5clos@ DB 'parse handsha'
	DB	'ke error,send close header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OCAKDNJE@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMCheckIs@
CONST	SEGMENT
??_C@_0DC@OCAKDNJE@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMCheckIs@ DB 'I'
	DB	'ndex=%ld', 0a3H, 0acH, 'RountID=%ld', 0a3H, 0acH, 'CheckIsWin'
	DB	'Socket ', 0b7H, 0a2H, 0c9H, 0faH, 0d2H, 0ecH, 0b3H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BHAJGHNJ@CheckIsWinSocket?5?$LH?Gweebsocket?3?$CF@
CONST	SEGMENT
??_C@_0CB@BHAJGHNJ@CheckIsWinSocket?5?$LH?Gweebsocket?3?$CF@ DB 'CheckIsW'
	DB	'inSocket ', 0b7H, 0c7H, 'weebsocket:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BBEPCAEF@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LE?m?N?s@
CONST	SEGMENT
??_C@_0P@BBEPCAEF@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LE?m?N?s@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0b0H, 0e6H, 0b1H, 0beH, 0b4H, 0edH
	DB	0ceH, 0f3H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICOFAPAB@?J?$PN?$LO?$NN?$LA?$PM?$LH?G?$LH?$KI@
CONST	SEGMENT
??_C@_0L@ICOFAPAB@?J?$PN?$LO?$NN?$LA?$PM?$LH?G?$LH?$KI@ DB 0caH, 0fdH, 0beH
	DB	0ddH, 0b0H, 0fcH, 0b7H, 0c7H, 0b7H, 0a8H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAPODOBD@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KM?$LD?$KE@
CONST	SEGMENT
??_C@_0L@DAPODOBD@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KM?$LD?$KE@ DB 0caH, 0fdH, 0beH
	DB	0ddH, 0b0H, 0fcH, 0b3H, 0acH, 0b3H, 0a4H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DAAPGLPI@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMHandleW@
CONST	SEGMENT
??_C@_0DF@DAAPGLPI@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMHandleW@ DB 'I'
	DB	'ndex=%ld', 0a3H, 0acH, 'RountID=%ld', 0a3H, 0acH, 'HandleWebs'
	DB	'ocketRecv ', 0b7H, 0a2H, 0c9H, 0faH, 0d2H, 0ecH, 0b3H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KAJJAILJ@HandleWebsocketRecv?5?R?l?$LD?$KD?3?$CFs@
CONST	SEGMENT
??_C@_0BM@KAJJAILJ@HandleWebsocketRecv?5?R?l?$LD?$KD?3?$CFs@ DB 'HandleWe'
	DB	'bsocketRecv ', 0d2H, 0ecH, 0b3H, 0a3H, ':%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LDBHEJCC@?J?U?$LF?$LNdefault?O?$PL?O?$KC@
CONST	SEGMENT
??_C@_0BA@LDBHEJCC@?J?U?$LF?$LNdefault?O?$PL?O?$KC@ DB 0caH, 0d5H, 0b5H, 0bdH
	DB	'default', 0cfH, 0fbH, 0cfH, 0a2H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KPFBJOAM@?J?U?$LF?$LNWS_CLOSE_FRAME?O?$PL?O?$KC@
CONST	SEGMENT
??_C@_0BH@KPFBJOAM@?J?U?$LF?$LNWS_CLOSE_FRAME?O?$PL?O?$KC@ DB 0caH, 0d5H, 0b5H
	DB	0bdH, 'WS_CLOSE_FRAME', 0cfH, 0fbH, 0cfH, 0a2H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KIEOHCJC@?J?U?$LF?$LNWS_PING_FRAME?O?$PL?O?$KC@
CONST	SEGMENT
??_C@_0BG@KIEOHCJC@?J?U?$LF?$LNWS_PING_FRAME?O?$PL?O?$KC@ DB 0caH, 0d5H, 0b5H
	DB	0bdH, 'WS_PING_FRAME', 0cfH, 0fbH, 0cfH, 0a2H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EEHLBJJE@?J?U?$LF?$LN?O?$PL?O?$KC?3mainid?3?$CFd?0subid?3?$CFd@
CONST	SEGMENT
??_C@_0BM@EEHLBJJE@?J?U?$LF?$LN?O?$PL?O?$KC?3mainid?3?$CFd?0subid?3?$CFd@ DB 0caH
	DB	0d5H, 0b5H, 0bdH, 0cfH, 0fbH, 0cfH, 0a2H, ':mainid:%d,subid:%d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPNHKCLL@?$LH?G?$LH?$KI?C?$PM?A?n?B?k@
CONST	SEGMENT
??_C@_0L@HPNHKCLL@?$LH?G?$LH?$KI?C?$PM?A?n?B?k@ DB 0b7H, 0c7H, 0b7H, 0a8H
	DB	0c3H, 0fcH, 0c1H, 0eeH, 0c2H, 0ebH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BJIBBOFC@parse?5error@
CONST	SEGMENT
??_C@_0M@BJIBBOFC@parse?5error@ DB 'parse error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HPGDGIOK@error?0receive?5data?5len?5?$DO?5SOCKET@
CONST	SEGMENT
??_C@_0DE@HPGDGIOK@error?0receive?5data?5len?5?$DO?5SOCKET@ DB 'error,rec'
	DB	'eive data len > SOCKET_TCP_BUFFER,%d>32768', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKKJNMOA@?J?$PN?$LO?$NN?$LA?$PM?P?$KH?Q?i?B?k?$LE?m?N?s@
CONST	SEGMENT
??_C@_0BB@GKKJNMOA@?J?$PN?$LO?$NN?$LA?$PM?P?$KH?Q?i?B?k?$LE?m?N?s@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0d0H, 0a7H, 0d1H, 0e9H, 0c2H, 0ebH
	DB	0b4H, 0edH, 0ceH, 0f3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DINLBKIB@?J?$PN?$LO?$NN?$LA?$PM?$LN?b?C?$NM?$LD?$KE?$LG?H?$LE?m?N?s@
CONST	SEGMENT
??_C@_0BD@DINLBKIB@?J?$PN?$LO?$NN?$LA?$PM?$LN?b?C?$NM?$LD?$KE?$LG?H?$LE?m?N?s@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0bdH, 0e2H, 0c3H, 0dcH, 0b3H, 0a4H
	DB	0b6H, 0c8H, 0b4H, 0edH, 0ceH, 0f3H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@EEAELNCF@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@
CONST	SEGMENT
??_C@_0EG@EEAELNCF@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@ DB 'Sock'
	DB	'etEngine Index=%ld', 0a3H, 0acH, 'RountID=%ld', 0a3H, 0acH, 'O'
	DB	'nRecvCompleted ', 0b7H, 0a2H, 0c9H, 0faH, 0a1H, 0b0H, 0b7H, 0c7H
	DB	0b7H, 0a8H, 0a1H, 0b1H, 0d2H, 0ecH, 0b3H, 0a3H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@ONNHHJGK@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@
CONST	SEGMENT
??_C@_0EE@ONNHHJGK@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@ DB 'Sock'
	DB	'etEngine Index=%ld', 0a3H, 0acH, 'RountID=%ld', 0a3H, 0acH, 'O'
	DB	'nRecvCompleted ', 0b7H, 0a2H, 0c9H, 0faH, 0a1H, 0b0H, '%s', 0a1H
	DB	0b1H, 0d2H, 0ecH, 0b3H, 0a3H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HMAHCNOL@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
CONST	SEGMENT
??_C@_0BB@HMAHCNOL@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0b0H, 0e6H, 0b1H, 0beH, 0b2H, 0bbH
	DB	0c6H, 0a5H, 0c5H, 0e4H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OPBHEPOC@0x?$CFx@
CONST	SEGMENT
??_C@_04OPBHEPOC@0x?$CFx@ DB '0x%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@COEHLGHJ@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L@
CONST	SEGMENT
??_C@_0P@COEHLGHJ@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0b3H, 0a4H, 0b6H, 0c8H, 0ccH, 0abH
	DB	0b6H, 0ccH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LPKEJNLP@?$LA?$PM?$LD?$KE?5?$CFd?0?5?$LA?f?$LB?$LO?5?$CFd?0?5?P?$KH?Q?i?B?k?5?$CFd@
CONST	SEGMENT
??_C@_0BM@LPKEJNLP@?$LA?$PM?$LD?$KE?5?$CFd?0?5?$LA?f?$LB?$LO?5?$CFd?0?5?P?$KH?Q?i?B?k?5?$CFd@ DB 0b0H
	DB	0fcH, 0b3H, 0a4H, ' %d, ', 0b0H, 0e6H, 0b1H, 0beH, ' %d, ', 0d0H
	DB	0a7H, 0d1H, 0e9H, 0c2H, 0ebH, ' %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MKDFEHED@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CF@
CONST	SEGMENT
??_C@_0CH@MKDFEHED@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CF@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0b3H, 0a4H, 0b6H, 0c8H, 0ccH, 0abH
	DB	0b6H, 0ccH, ' %d,%d,%d,%d,%d,%d,%d,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IFKIJFDN@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LD?$KE@
CONST	SEGMENT
??_C@_0P@IFKIJFDN@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LD?$KE@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0b0H, 0fcH, 0b3H, 0a4H, 0b6H, 0c8H, 0ccH, 0abH
	DB	0b3H, 0a4H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMMHFHOO@?$AN?6?$AN?6@
CONST	SEGMENT
??_C@_04FMMHFHOO@?$AN?6?$AN?6@ DB 0dH, 0aH, 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BFBPJPAH@SendData?5pData?5?R?l?$LD?$KD@
CONST	SEGMENT
??_C@_0BE@BFBPJPAH@SendData?5pData?5?R?l?$LD?$KD@ DB 'SendData pData ', 0d2H
	DB	0ecH, 0b3H, 0a3H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NLJMDLEL@SendData?5pData?5?R?l?$LD?$KD?3?$CFs@
CONST	SEGMENT
??_C@_0BH@NLJMDLEL@SendData?5pData?5?R?l?$LD?$KD?3?$CFs@ DB 'SendData pDa'
	DB	'ta ', 0d2H, 0ecH, 0b3H, 0a3H, ':%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PPIPIEAL@?$LH?$KC?K?M?O?$PL?O?$KCpData?3wMainCmdID?3?$CFd?0wSu@
CONST	SEGMENT
??_C@_0CJ@PPIPIEAL@?$LH?$KC?K?M?O?$PL?O?$KCpData?3wMainCmdID?3?$CFd?0wSu@ DB 0b7H
	DB	0a2H, 0cbH, 0cdH, 0cfH, 0fbH, 0cfH, 0a2H, 'pData:wMainCmdID:%d'
	DB	',wSubCmdID:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEGGEINK@?J?$PN?$LO?$NN?N?$KK?$LP?U?3wMainCmdID?3?$CFd?0wSubCmdI@
CONST	SEGMENT
??_C@_0CE@NEGGEINK@?J?$PN?$LO?$NN?N?$KK?$LP?U?3wMainCmdID?3?$CFd?0wSubCmdI@ DB 0caH
	DB	0fdH, 0beH, 0ddH, 0ceH, 0aaH, 0bfH, 0d5H, ':wMainCmdID:%d,wSub'
	DB	'CmdID:%d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEAMMJHF@SendData?5?R?l?$LD?$KD@
CONST	SEGMENT
??_C@_0O@LEAMMJHF@SendData?5?R?l?$LD?$KD@ DB 'SendData ', 0d2H, 0ecH, 0b3H
	DB	0a3H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OELGDMNI@SendData?5?R?l?$LD?$KD?3?$CFs@
CONST	SEGMENT
??_C@_0BB@OELGDMNI@SendData?5?R?l?$LD?$KD?3?$CFs@ DB 'SendData ', 0d2H, 0ecH
	DB	0b3H, 0a3H, ':%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LDGEJDBI@Serialize?5error@
CONST	SEGMENT
??_C@_0BA@LDGEJDBI@Serialize?5error@ DB 'Serialize error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNDINJCC@?$LH?$KC?K?M?$LA?$PM?L?$KL?$LE?s@
CONST	SEGMENT
??_C@_0L@JNDINJCC@?$LH?$KC?K?M?$LA?$PM?L?$KL?$LE?s@ DB 0b7H, 0a2H, 0cbH, 0cdH
	DB	0b0H, 0fcH, 0ccH, 0abH, 0b4H, 0f3H, 00H	; `string'
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
data$r	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
data$r	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0b7H, 0feH, 0ceH, 0f1H, 0c6H, 0f7H, 0d7H, 0e9H, 0bcH
	DB	0feH, '\', 0c4H, 0daH, 0baH, 0cbH, 0d2H, 0fdH, 0c7H, 0e6H, '\t'
	DB	'cpnetworkengine.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@
CONST	SEGMENT
??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@ DB 'NullPmd.respons'
	DB	'e.errordescription', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
CONST	SEGMENT
??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@ DB 'C'
	DB	'HECK failed: (&from) != (this): ', 00H	; `string'
CONST	ENDS
;	COMDAT ?descriptor@?1??AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4QBDB
CONST	SEGMENT
?descriptor@?1??AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4QBDB DB 0aH
	DB	0dH, 'NullPmd.proto', 012H, 07H, 'NullPmd"', 09H, 0aH, 07H, 'r'
	DB	'equest"4', 0aH, 08H, 'response', 012H, 0eH, 0aH, 06H, 'result'
	DB	018H, 01H, ' ', 01H, '(', 05H, 012H, 018H, 0aH, 010H, 'errorde'
	DB	'scription', 018H, 02H, ' ', 01H, '(', 09H, '"', 0cH, 0aH, 0aH
	DB	'indication"(', 0aH, 07H, 'command', 012H, 0eH, 0aH, 06H, 'mai'
	DB	'nid', 018H, 01H, ' ', 01H, '(', 04H, 012H, 0dH, 0aH, 05H, 'su'
	DB	'bid', 018H, 02H, ' ', 01H, '(', 04H, '"D', 0aH, 04H, 'info', 012H
	DB	012H, 0aH, 0aH, 'cbdatakind', 018H, 01H, ' ', 01H, '(', 04H, 012H
	DB	013H, 0aH, 0bH, 'cbcheckcode', 018H, 02H, ' ', 01H, '(', 04H, 012H
	DB	013H, 0aH, 0bH, 'wpacketsize', 018H, 03H, ' ', 01H, '(', 04H, '"'
	DB	'F', 0aH, 04H, 'head', 012H, '!', 0aH, 07H, 'command', 018H, 01H
	DB	' ', 01H, '(', 0bH, '2', 010H, '.NullPmd.command', 012H, 01bH, 0aH
	DB	04H, 'info', 018H, 02H, ' ', 01H, '(', 0bH, '2', 0dH, '.NullPm'
	DB	'd.info"4', 0aH, 07H, 'message', 012H, 01bH, 0aH, 04H, 'head', 018H
	DB	01H, ' ', 01H, '(', 0bH, '2', 0dH, '.NullPmd.head', 012H, 0cH, 0aH
	DB	04H, 'data', 018H, 02H, ' ', 01H, '(', 0cH, 'b', 06H, 'proto3', 00H ; `NullPmd::protobuf_NullPmd_2eproto::AddDescriptorsImpl'::`2'::descriptor
CONST	ENDS
;	COMDAT ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0cfH, 0fbH, 0cfH, 0a2H, 0b6H, 0a8H, 0d2H, 0e5H, '\p'
	DB	'b\nullpmd.pb.cc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PBNICMEM@NullPmd?4proto@
CONST	SEGMENT
??_C@_0O@PBNICMEM@NullPmd?4proto@ DB 'NullPmd.proto', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7message@NullPmd@@6B@
CONST	SEGMENT
??_7message@NullPmd@@6B@ DD FLAT:??_R4message@NullPmd@@6B@ ; NullPmd::message::`vftable'
	DD	FLAT:??_Emessage@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@message@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@message@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@message@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@message@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@message@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@message@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@message@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@message@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@message@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7head@NullPmd@@6B@
CONST	SEGMENT
??_7head@NullPmd@@6B@ DD FLAT:??_R4head@NullPmd@@6B@	; NullPmd::head::`vftable'
	DD	FLAT:??_Ehead@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@head@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@head@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@head@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@head@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@head@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@head@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@head@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@head@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@head@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7info@NullPmd@@6B@
CONST	SEGMENT
??_7info@NullPmd@@6B@ DD FLAT:??_R4info@NullPmd@@6B@	; NullPmd::info::`vftable'
	DD	FLAT:??_Einfo@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@info@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@info@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@info@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@info@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@info@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@info@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@info@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@info@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@info@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7command@NullPmd@@6B@
CONST	SEGMENT
??_7command@NullPmd@@6B@ DD FLAT:??_R4command@NullPmd@@6B@ ; NullPmd::command::`vftable'
	DD	FLAT:??_Ecommand@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@command@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@command@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@command@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@command@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@command@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@command@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@command@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@command@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@command@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7indication@NullPmd@@6B@
CONST	SEGMENT
??_7indication@NullPmd@@6B@ DD FLAT:??_R4indication@NullPmd@@6B@ ; NullPmd::indication::`vftable'
	DD	FLAT:??_Eindication@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@indication@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@indication@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@indication@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@indication@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@indication@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@indication@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@indication@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@indication@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@indication@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7response@NullPmd@@6B@
CONST	SEGMENT
??_7response@NullPmd@@6B@ DD FLAT:??_R4response@NullPmd@@6B@ ; NullPmd::response::`vftable'
	DD	FLAT:??_Eresponse@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@response@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@response@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@response@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@response@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@response@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@response@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@response@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@response@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@response@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7request@NullPmd@@6B@
CONST	SEGMENT
??_7request@NullPmd@@6B@ DD FLAT:??_R4request@NullPmd@@6B@ ; NullPmd::request::`vftable'
	DD	FLAT:??_Erequest@NullPmd@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	FLAT:?New@request@NullPmd@@UBEPAV12@XZ
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@request@NullPmd@@UAEXXZ
	DD	FLAT:?IsInitialized@request@NullPmd@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@request@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
	DD	FLAT:?ByteSizeLong@request@NullPmd@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@request@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@request@NullPmd@@UBEPAEPAE@Z
	DD	FLAT:?GetCachedSize@request@NullPmd@@UBEHXZ
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@request@NullPmd@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:?GetMetadata@request@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
CONST	ENDS
;	COMDAT ??_7Message@protobuf@google@@6B@
CONST	SEGMENT
??_7Message@protobuf@google@@6B@ DD FLAT:??_R4Message@protobuf@google@@6B@ ; google::protobuf::Message::`vftable'
	DD	FLAT:??_EMessage@protobuf@google@@UAEPAXI@Z
	DD	FLAT:?GetTypeName@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?New@Message@protobuf@google@@UBEPAV123@PAVArena@23@@Z
	DD	FLAT:__purecall
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:?Clear@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?IsInitialized@Message@protobuf@google@@UBE_NXZ
	DD	FLAT:?InitializationErrorString@Message@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CheckTypeAndMergeFrom@Message@protobuf@google@@UAEXABVMessageLite@23@@Z
	DD	FLAT:?MergePartialFromCodedStream@Message@protobuf@google@@UAE_NPAVCodedInputStream@io@23@@Z
	DD	FLAT:?ByteSizeLong@Message@protobuf@google@@UBEIXZ
	DD	FLAT:?SerializeWithCachedSizes@Message@protobuf@google@@UBEXPAVCodedOutputStream@io@23@@Z
	DD	FLAT:?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z
	DD	FLAT:__purecall
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAE_NPAE@Z
	DD	FLAT:?CopyFrom@Message@protobuf@google@@UAEXABV123@@Z
	DD	FLAT:?MergeFrom@Message@protobuf@google@@UAEXABV123@@Z
	DD	FLAT:?DiscardUnknownFields@Message@protobuf@google@@UAEXXZ
	DD	FLAT:?SpaceUsed@Message@protobuf@google@@UBEHXZ
	DD	FLAT:?SetCachedSize@Message@protobuf@google@@EBEXH@Z
	DD	FLAT:?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_0DO@HCOJOCJH@CHECK?5failed?3?5?$CIresult?$CJ?5?$DM?$DN?5?$CIstat@
CONST	SEGMENT
??_C@_0DO@HCOJOCJH@CHECK?5failed?3?5?$CIresult?$CJ?5?$DM?$DN?5?$CIstat@ DB 'C'
	DB	'HECK failed: (result) <= (static_cast<size_t>(2147483647)): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@MGPCODI@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@
CONST	SEGMENT
??_C@_0FM@MGPCODI@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\', 0bfH, 0aaH, 0b7H, 0a2H, 0b5H
	DB	0c4H, 0c4H, 0a3H, 0bfH, 0e9H, '\', 0b7H, 0feH, 0ceH, 0f1H, 0b6H
	DB	0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH, 0e9H, '\', 0b5H
	DB	0daH, 0c8H, 0fdH, 0b7H, 0bdH, 0bfH, 0e2H, '\protobuf\include\g'
	DB	'oogle\protobuf\message_lite.h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7MessageLite@protobuf@google@@6B@
CONST	SEGMENT
??_7MessageLite@protobuf@google@@6B@ DD FLAT:??_R4MessageLite@protobuf@google@@6B@ ; google::protobuf::MessageLite::`vftable'
	DD	FLAT:??_EMessageLite@protobuf@google@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?New@MessageLite@protobuf@google@@UBEPAV123@PAVArena@23@@Z
	DD	FLAT:__purecall
	DD	FLAT:?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
	DD	FLAT:?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?InitializationErrorString@MessageLite@protobuf@google@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z
	DD	FLAT:__purecall
	DD	FLAT:?InternalSerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAE_NPAE@Z
CONST	ENDS
;	COMDAT ??_C@_0CG@ENGJCHJ@CHECK?5failed?3?5initial_value?5?$CB?$DN?5@
CONST	SEGMENT
??_C@_0CG@ENGJCHJ@CHECK?5failed?3?5initial_value?5?$CB?$DN?5@ DB 'CHECK f'
	DB	'ailed: initial_value != NULL: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FL@GKGAFMDK@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@
CONST	SEGMENT
??_C@_0FL@GKGAFMDK@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\', 0bfH, 0aaH, 0b7H, 0a2H, 0b5H
	DB	0c4H, 0c4H, 0a3H, 0bfH, 0e9H, '\', 0b7H, 0feH, 0ceH, 0f1H, 0b6H
	DB	0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH, 0e9H, '\', 0b5H
	DB	0daH, 0c8H, 0fdH, 0b7H, 0bdH, 0bfH, 0e2H, '\protobuf\include\g'
	DB	'oogle\protobuf\arenastring.h', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7FunctionClosure0@internal@protobuf@google@@6B@
CONST	SEGMENT
??_7FunctionClosure0@internal@protobuf@google@@6B@ DD FLAT:??_R4FunctionClosure0@internal@protobuf@google@@6B@ ; google::protobuf::internal::FunctionClosure0::`vftable'
	DD	FLAT:??_EFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z
	DD	FLAT:?Run@FunctionClosure0@internal@protobuf@google@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7Closure@protobuf@google@@6B@
CONST	SEGMENT
??_7Closure@protobuf@google@@6B@ DD FLAT:??_R4Closure@protobuf@google@@6B@ ; google::protobuf::Closure::`vftable'
	DD	FLAT:??_EClosure@protobuf@google@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7CTCPNetworkEngine@@6BITCPNetworkItemSink@@@
CONST	SEGMENT
??_7CTCPNetworkEngine@@6BITCPNetworkItemSink@@@ DD FLAT:??_R4CTCPNetworkEngine@@6BITCPNetworkItemSink@@@ ; CTCPNetworkEngine::`vftable'
	DD	FLAT:?OnEventSocketBind@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
	DD	FLAT:?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
	DD	FLAT:?OnEventSocketRead@CTCPNetworkEngine@@UAE_NUTCP_Command@@PAXGPAVCTCPNetworkItem@@@Z
CONST	ENDS
;	COMDAT ??_7CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@
CONST	SEGMENT
??_7CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@ DD FLAT:??_R4CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@ ; CTCPNetworkEngine::`vftable'
	DD	FLAT:?Release@CTCPNetworkEngine@@W3AEXXZ
	DD	FLAT:?QueryInterface@CTCPNetworkEngine@@W3AEPAXABU_GUID@@K@Z
	DD	FLAT:?OnAsynchronismEngineStart@CTCPNetworkEngine@@UAE_NXZ
	DD	FLAT:?OnAsynchronismEngineConclude@CTCPNetworkEngine@@UAE_NXZ
	DD	FLAT:?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z
CONST	ENDS
;	COMDAT ??_7CTCPNetworkEngine@@6BITCPNetworkEngine@@@
CONST	SEGMENT
??_7CTCPNetworkEngine@@6BITCPNetworkEngine@@@ DD FLAT:??_R4CTCPNetworkEngine@@6BITCPNetworkEngine@@@ ; CTCPNetworkEngine::`vftable'
	DD	FLAT:?Release@CTCPNetworkEngine@@UAEXXZ
	DD	FLAT:?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z
	DD	FLAT:?StartService@CTCPNetworkEngine@@UAE_NXZ
	DD	FLAT:?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
	DD	FLAT:?GetServicePort@CTCPNetworkEngine@@UAEGXZ
	DD	FLAT:?GetCurrentPort@CTCPNetworkEngine@@UAEGXZ
	DD	FLAT:?SetTCPNetworkEngineEvent@CTCPNetworkEngine@@UAE_NPAUIUnknownEx@@@Z
	DD	FLAT:?SetServiceParameter@CTCPNetworkEngine@@UAE_NGGPBD@Z
	DD	FLAT:?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z
	DD	FLAT:?SendData@CTCPNetworkEngine@@UAE_NKGG@Z
	DD	FLAT:?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z
	DD	FLAT:?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z
	DD	FLAT:?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z
	DD	FLAT:?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z
	DD	FLAT:??_ECTCPNetworkEngine@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@
CONST	SEGMENT
??_7?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@ DD FLAT:??_R4?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`vftable'
	DD	FLAT:??_E?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@
CONST	SEGMENT
??_7?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@ DD FLAT:??_R4?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`vftable'
	DD	FLAT:??_E?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CTCPNetworkThreadDetect@@6B@
CONST	SEGMENT
??_7CTCPNetworkThreadDetect@@6B@ DD FLAT:??_R4CTCPNetworkThreadDetect@@6B@ ; CTCPNetworkThreadDetect::`vftable'
	DD	FLAT:??_ECTCPNetworkThreadDetect@@UAEPAXI@Z
	DD	FLAT:?IsRuning@CWHThread@@UAE_NXZ
	DD	FLAT:?StartThread@CWHThread@@UAE_NXZ
	DD	FLAT:?ConcludeThread@CWHThread@@UAE_NK@Z
	DD	FLAT:?OnEventThreadRun@CTCPNetworkThreadDetect@@EAE_NXZ
	DD	FLAT:?OnEventThreadStrat@CWHThread@@MAE_NXZ
	DD	FLAT:?OnEventThreadConclude@CWHThread@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7CTCPNetworkThreadAccept@@6B@
CONST	SEGMENT
??_7CTCPNetworkThreadAccept@@6B@ DD FLAT:??_R4CTCPNetworkThreadAccept@@6B@ ; CTCPNetworkThreadAccept::`vftable'
	DD	FLAT:??_ECTCPNetworkThreadAccept@@UAEPAXI@Z
	DD	FLAT:?IsRuning@CWHThread@@UAE_NXZ
	DD	FLAT:?StartThread@CWHThread@@UAE_NXZ
	DD	FLAT:?ConcludeThread@CWHThread@@UAE_NK@Z
	DD	FLAT:?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
	DD	FLAT:?OnEventThreadStrat@CWHThread@@MAE_NXZ
	DD	FLAT:?OnEventThreadConclude@CWHThread@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7CTCPNetworkThreadReadWrite@@6B@
CONST	SEGMENT
??_7CTCPNetworkThreadReadWrite@@6B@ DD FLAT:??_R4CTCPNetworkThreadReadWrite@@6B@ ; CTCPNetworkThreadReadWrite::`vftable'
	DD	FLAT:??_ECTCPNetworkThreadReadWrite@@UAEPAXI@Z
	DD	FLAT:?IsRuning@CWHThread@@UAE_NXZ
	DD	FLAT:?StartThread@CWHThread@@UAE_NXZ
	DD	FLAT:?ConcludeThread@CWHThread@@UAE_NK@Z
	DD	FLAT:?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ
	DD	FLAT:?OnEventThreadStrat@CWHThread@@MAE_NXZ
	DD	FLAT:?OnEventThreadConclude@CWHThread@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7CTCPNetworkItem@@6B@
CONST	SEGMENT
??_7CTCPNetworkItem@@6B@ DD FLAT:??_R4CTCPNetworkItem@@6B@ ; CTCPNetworkItem::`vftable'
	DD	FLAT:??_ECTCPNetworkItem@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@
CONST	SEGMENT
??_7?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@ DD FLAT:??_R4?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`vftable'
	DD	FLAT:??_E?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7COverLappedRecv@@6B@
CONST	SEGMENT
??_7COverLappedRecv@@6B@ DD FLAT:??_R4COverLappedRecv@@6B@ ; COverLappedRecv::`vftable'
	DD	FLAT:??_ECOverLappedRecv@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7COverLappedSend@@6B@
CONST	SEGMENT
??_7COverLappedSend@@6B@ DD FLAT:??_R4COverLappedSend@@6B@ ; COverLappedSend::`vftable'
	DD	FLAT:??_ECOverLappedSend@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7COverLapped@@6B@
CONST	SEGMENT
??_7COverLapped@@6B@ DD FLAT:??_R4COverLapped@@6B@	; COverLapped::`vftable'
	DD	FLAT:??_ECOverLapped@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7ITCPNetworkItemSink@@6B@
CONST	SEGMENT
??_7ITCPNetworkItemSink@@6B@ DD FLAT:??_R4ITCPNetworkItemSink@@6B@ ; ITCPNetworkItemSink::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_1DI@FLADJBMA@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAa@
CONST	SEGMENT
??_C@_1DI@FLADJBMA@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAa@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '(', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@JBKPABMM@?$AAk?$AAC?$AAh?$AAe?$AAa?$AAp?$AAP?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DM@
CONST	SEGMENT
??_C@_1DK@JBKPABMM@?$AAk?$AAC?$AAh?$AAe?$AAa?$AAp?$AAP?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DM@ DB 'k'
	DB	00H, 'C', 00H, 'h', 00H, 'e', 00H, 'a', 00H, 'p', 00H, 'P', 00H
	DB	'r', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x'
	DB	00H, '_', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@OAPHHNA@?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe@
CONST	SEGMENT
??_C@_1CO@OAPHHNA@?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	'w', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'(', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@EOJCKDIM@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1CO@EOJCKDIM@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '('
	DB	00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, 'l', 00H
	DB	'e', 00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@GKCFLMIJ@?$AAp?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe@
CONST	SEGMENT
??_C@_1EI@GKCFLMIJ@?$AAp?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe@ DB 'p'
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'd', 00H
	DB	'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't'
	DB	00H, 'e', 00H, 's', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, 'k', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'a'
	DB	00H, 'p', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@MNNKLKHL@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1EA@MNNKLKHL@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ DB 'w'
	DB	00H, 'r', 00H, 'i', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '('
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'k', 00H
	DB	'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HLKMELIP@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
CONST	SEGMENT
??_C@_1CK@HLKMELIP@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@ DB 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, '('
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
CONST	SEGMENT
??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@ DB 'g'
	DB	00H, ':', 00H, '\', 00H, 'Q', 07fH, 0d0H, 'r\', 00H, 'h', 00H, 'a'
	DB	00H, 'p', 00H, 'p', 00H, 'y', 00H, 'g', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 'w', 00H, 'h', 00H, '\', 00H, 0dH, 'g', 0a1H, 'R', 0efH
	DB	'z\', 00H, 0fbH, '|', 0dfH, '~!jWW\', 00H, 0dH, 'g', 0a1H, 'Rh'
	DB	'V', 0c4H, '~', 0f6H, 'N\', 00H, 085H, 'Q8h', 015H, '_', 0ceH, 'd'
	DB	'\', 00H, 'z', 00H, 'l', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '\', 00H, 'b', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@
CONST	SEGMENT
??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@ DB 'Sec-WebSocket-Protocol', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@
CONST	SEGMENT
??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@ DB 'Sec-WebSocket-Key', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ITCPNetworkEngine@@6B@
CONST	SEGMENT
??_7ITCPNetworkEngine@@6B@ DD FLAT:??_R4ITCPNetworkEngine@@6B@ ; ITCPNetworkEngine::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IAsynchronismEngineSink@@6B@
CONST	SEGMENT
??_7IAsynchronismEngineSink@@6B@ DD FLAT:??_R4IAsynchronismEngineSink@@6B@ ; IAsynchronismEngineSink::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IServiceModule@@6B@
CONST	SEGMENT
??_7IServiceModule@@6B@ DD FLAT:??_R4IServiceModule@@6B@ ; IServiceModule::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IUnknownEx@@6B@
CONST	SEGMENT
??_7IUnknownEx@@6B@ DD FLAT:??_R4IUnknownEx@@6B@	; IUnknownEx::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
CONST	SEGMENT
?kSecWebSocketKeyHeader@ws@net@zl@@3QBDB DD FLAT:??_C@_0BC@DFHBMDHG@Sec?9WebSocket?9Key@ ; zl::net::ws::kSecWebSocketKeyHeader
?g_SendByteMap@@3QBEB DB 070H				; g_SendByteMap
	DB	02fH
	DB	040H
	DB	05fH
	DB	044H
	DB	08eH
	DB	06eH
	DB	045H
	DB	07eH
	DB	0abH
	DB	02cH
	DB	01fH
	DB	0b4H
	DB	0acH
	DB	09dH
	DB	091H
	DB	0dH
	DB	036H
	DB	09bH
	DB	0bH
	DB	0d4H
	DB	0c4H
	DB	039H
	DB	074H
	DB	0bfH
	DB	023H
	DB	016H
	DB	014H
	DB	06H
	DB	0ebH
	DB	04H
	DB	03eH
	DB	012H
	DB	05cH
	DB	08bH
	DB	0bcH
	DB	061H
	DB	063H
	DB	0f6H
	DB	0a5H
	DB	0e1H
	DB	065H
	DB	0d8H
	DB	0f5H
	DB	05aH
	DB	07H
	DB	0f0H
	DB	013H
	DB	0f2H
	DB	020H
	DB	06bH
	DB	04aH
	DB	024H
	DB	059H
	DB	089H
	DB	064H
	DB	0d7H
	DB	042H
	DB	06aH
	DB	05eH
	DB	03dH
	DB	0aH
	DB	077H
	DB	0e0H
	DB	080H
	DB	027H
	DB	0b8H
	DB	0c5H
	DB	08cH
	DB	0eH
	DB	0faH
	DB	08aH
	DB	0d5H
	DB	029H
	DB	056H
	DB	057H
	DB	06cH
	DB	053H
	DB	067H
	DB	041H
	DB	0e8H
	DB	00H
	DB	01aH
	DB	0ceH
	DB	086H
	DB	083H
	DB	0b0H
	DB	022H
	DB	028H
	DB	04dH
	DB	03fH
	DB	026H
	DB	046H
	DB	04fH
	DB	06fH
	DB	02bH
	DB	072H
	DB	03aH
	DB	0f1H
	DB	08dH
	DB	097H
	DB	095H
	DB	049H
	DB	084H
	DB	0e5H
	DB	0e3H
	DB	079H
	DB	08fH
	DB	051H
	DB	010H
	DB	0a8H
	DB	082H
	DB	0c6H
	DB	0ddH
	DB	0ffH
	DB	0fcH
	DB	0e4H
	DB	0cfH
	DB	0b3H
	DB	09H
	DB	05dH
	DB	0eaH
	DB	09cH
	DB	034H
	DB	0f9H
	DB	017H
	DB	09fH
	DB	0daH
	DB	087H
	DB	0f8H
	DB	015H
	DB	05H
	DB	03cH
	DB	0d3H
	DB	0a4H
	DB	085H
	DB	02eH
	DB	0fbH
	DB	0eeH
	DB	047H
	DB	03bH
	DB	0efH
	DB	037H
	DB	07fH
	DB	093H
	DB	0afH
	DB	069H
	DB	0cH
	DB	071H
	DB	031H
	DB	0deH
	DB	021H
	DB	075H
	DB	0a0H
	DB	0aaH
	DB	0baH
	DB	07cH
	DB	038H
	DB	02H
	DB	0b7H
	DB	081H
	DB	01H
	DB	0fdH
	DB	0e7H
	DB	01dH
	DB	0ccH
	DB	0cdH
	DB	0bdH
	DB	01bH
	DB	07aH
	DB	02aH
	DB	0adH
	DB	066H
	DB	0beH
	DB	055H
	DB	033H
	DB	03H
	DB	0dbH
	DB	088H
	DB	0b2H
	DB	01eH
	DB	04eH
	DB	0b9H
	DB	0e6H
	DB	0c2H
	DB	0f7H
	DB	0cbH
	DB	07dH
	DB	0c9H
	DB	062H
	DB	0c3H
	DB	0a6H
	DB	0dcH
	DB	0a7H
	DB	050H
	DB	0b5H
	DB	04bH
	DB	094H
	DB	0c0H
	DB	092H
	DB	04cH
	DB	011H
	DB	05bH
	DB	078H
	DB	0d9H
	DB	0b1H
	DB	0edH
	DB	019H
	DB	0e9H
	DB	0a1H
	DB	01cH
	DB	0b6H
	DB	032H
	DB	099H
	DB	0a3H
	DB	076H
	DB	09eH
	DB	07bH
	DB	06dH
	DB	09aH
	DB	030H
	DB	0d6H
	DB	0a9H
	DB	025H
	DB	0c7H
	DB	0aeH
	DB	096H
	DB	035H
	DB	0d0H
	DB	0bbH
	DB	0d2H
	DB	0c8H
	DB	0a2H
	DB	08H
	DB	0f3H
	DB	0d1H
	DB	073H
	DB	0f4H
	DB	048H
	DB	02dH
	DB	090H
	DB	0caH
	DB	0e2H
	DB	058H
	DB	0c1H
	DB	018H
	DB	052H
	DB	0feH
	DB	0dfH
	DB	068H
	DB	098H
	DB	054H
	DB	0ecH
	DB	060H
	DB	043H
	DB	0fH
?g_RecvByteMap@@3QBEB DB 051H				; g_RecvByteMap
	DB	0a1H
	DB	09eH
	DB	0b0H
	DB	01eH
	DB	083H
	DB	01cH
	DB	02dH
	DB	0e9H
	DB	077H
	DB	03dH
	DB	013H
	DB	093H
	DB	010H
	DB	045H
	DB	0ffH
	DB	06dH
	DB	0c9H
	DB	020H
	DB	02fH
	DB	01bH
	DB	082H
	DB	01aH
	DB	07dH
	DB	0f5H
	DB	0cfH
	DB	052H
	DB	0a8H
	DB	0d2H
	DB	0a4H
	DB	0b4H
	DB	0bH
	DB	031H
	DB	097H
	DB	057H
	DB	019H
	DB	034H
	DB	0dfH
	DB	05bH
	DB	041H
	DB	058H
	DB	049H
	DB	0aaH
	DB	05fH
	DB	0aH
	DB	0efH
	DB	088H
	DB	01H
	DB	0dcH
	DB	095H
	DB	0d4H
	DB	0afH
	DB	07bH
	DB	0e3H
	DB	011H
	DB	08eH
	DB	09dH
	DB	016H
	DB	061H
	DB	08cH
	DB	084H
	DB	03cH
	DB	01fH
	DB	05aH
	DB	02H
	DB	04fH
	DB	039H
	DB	0feH
	DB	04H
	DB	07H
	DB	05cH
	DB	08bH
	DB	0eeH
	DB	066H
	DB	033H
	DB	0c4H
	DB	0c8H
	DB	059H
	DB	0b5H
	DB	05dH
	DB	0c2H
	DB	06cH
	DB	0f6H
	DB	04dH
	DB	0fbH
	DB	0aeH
	DB	04aH
	DB	04bH
	DB	0f3H
	DB	035H
	DB	02cH
	DB	0caH
	DB	021H
	DB	078H
	DB	03bH
	DB	03H
	DB	0fdH
	DB	024H
	DB	0bdH
	DB	025H
	DB	037H
	DB	029H
	DB	0acH
	DB	04eH
	DB	0f9H
	DB	092H
	DB	03aH
	DB	032H
	DB	04cH
	DB	0daH
	DB	06H
	DB	05eH
	DB	00H
	DB	094H
	DB	060H
	DB	0ecH
	DB	017H
	DB	098H
	DB	0d7H
	DB	03eH
	DB	0cbH
	DB	06aH
	DB	0a9H
	DB	0d9H
	DB	09cH
	DB	0bbH
	DB	08H
	DB	08fH
	DB	040H
	DB	0a0H
	DB	06fH
	DB	055H
	DB	067H
	DB	087H
	DB	054H
	DB	080H
	DB	0b2H
	DB	036H
	DB	047H
	DB	022H
	DB	044H
	DB	063H
	DB	05H
	DB	06bH
	DB	0f0H
	DB	0fH
	DB	0c7H
	DB	090H
	DB	0c5H
	DB	065H
	DB	0e2H
	DB	064H
	DB	0faH
	DB	0d5H
	DB	0dbH
	DB	012H
	DB	07aH
	DB	0eH
	DB	0d8H
	DB	07eH
	DB	099H
	DB	0d1H
	DB	0e8H
	DB	0d6H
	DB	086H
	DB	027H
	DB	0bfH
	DB	0c1H
	DB	06eH
	DB	0deH
	DB	09aH
	DB	09H
	DB	0dH
	DB	0abH
	DB	0e1H
	DB	091H
	DB	056H
	DB	0cdH
	DB	0b3H
	DB	076H
	DB	0cH
	DB	0c3H
	DB	0d3H
	DB	09fH
	DB	042H
	DB	0b6H
	DB	09bH
	DB	0e5H
	DB	023H
	DB	0a7H
	DB	0adH
	DB	018H
	DB	0c6H
	DB	0f4H
	DB	0b8H
	DB	0beH
	DB	015H
	DB	043H
	DB	070H
	DB	0e0H
	DB	0e7H
	DB	0bcH
	DB	0f1H
	DB	0baH
	DB	0a5H
	DB	0a6H
	DB	053H
	DB	075H
	DB	0e4H
	DB	0ebH
	DB	0e6H
	DB	085H
	DB	014H
	DB	048H
	DB	0ddH
	DB	038H
	DB	02aH
	DB	0ccH
	DB	07fH
	DB	0b1H
	DB	0c0H
	DB	071H
	DB	096H
	DB	0f8H
	DB	03fH
	DB	028H
	DB	0f2H
	DB	069H
	DB	074H
	DB	068H
	DB	0b7H
	DB	0a3H
	DB	050H
	DB	0d0H
	DB	079H
	DB	01dH
	DB	0fcH
	DB	0ceH
	DB	08aH
	DB	08dH
	DB	02eH
	DB	062H
	DB	030H
	DB	0eaH
	DB	0edH
	DB	02bH
	DB	026H
	DB	0b9H
	DB	081H
	DB	07cH
	DB	046H
	DB	089H
	DB	073H
	DB	0a2H
	DB	0f7H
	DB	072H
?kSecWebSocketProtocolHeader@ws@net@zl@@3QBDB DD FLAT:??_C@_0BH@JBAMIGCM@Sec?9WebSocket?9Protocol@ ; zl::net::ws::kSecWebSocketProtocolHeader
CONST	ENDS
;	COMDAT ??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xlocnum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xlocale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xmemory0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
CONST	SEGMENT
??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'I', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '_', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '1', 00H
	DB	'2', 00H, ':', 00H, ':', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'p'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H
	DB	't', 00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xutility', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z$0
__unwindtable$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z$4
__ehfuncinfo$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
__ehfuncinfo$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z$0
__ehfuncinfo$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$0
__unwindtable$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$111
__ehfuncinfo$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_CreateTCPNetworkEngine$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_CreateTCPNetworkEngine$2
__catchsym$_CreateTCPNetworkEngine$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_CreateTCPNetworkEngine$0
__ehfuncinfo$_CreateTCPNetworkEngine DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$_CreateTCPNetworkEngine
	DD	02H
	DD	FLAT:__tryblocktable$_CreateTCPNetworkEngine
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_CreateTCPNetworkEngine DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_CreateTCPNetworkEngine$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$_CreateTCPNetworkEngine$6
__unwindtable$_CreateTCPNetworkEngine DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_CreateTCPNetworkEngine$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$shared_ptr@D@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
__ehfuncinfo$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ$0
__ehfuncinfo$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?set_data@message@NullPmd@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?set_data@message@NullPmd@@QAEXPBD@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
__ehfuncinfo$?set_data@message@NullPmd@@QAEXPBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?set_data@message@NullPmd@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?clear_data@message@NullPmd@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?clear_data@message@NullPmd@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?clear_data@message@NullPmd@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clear@message@NullPmd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?Clear@message@NullPmd@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clear@message@NullPmd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@message@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@message@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@message@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@message@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0message@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$2
__ehfuncinfo$??0message@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0message@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1message@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0message@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0message@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0message@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0message@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0message@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ$0
__ehfuncinfo$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ$0
__ehfuncinfo$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@head@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@head@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@head@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@head@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0head@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$3
__ehfuncinfo$??0head@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0head@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1head@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0head@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0head@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0head@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0head@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@info@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@info@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@info@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@info@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0info@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0info@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0info@NullPmd@@QAE@ABV01@@Z$1
__ehfuncinfo$??0info@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0info@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1info@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0info@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0info@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0info@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0info@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0info@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@command@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@command@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@command@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@command@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0command@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0command@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0command@NullPmd@@QAE@ABV01@@Z$1
__ehfuncinfo$??0command@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0command@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1command@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0command@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0command@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0command@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0command@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0command@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0indication@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0indication@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0indication@NullPmd@@QAE@ABV01@@Z$1
__ehfuncinfo$??0indication@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0indication@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1indication@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0indication@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0indication@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0indication@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0indication@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0indication@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clear@response@NullPmd@@UAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?Clear@response@NullPmd@@UAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clear@response@NullPmd@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@response@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@response@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@response@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@response@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0response@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0response@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0response@NullPmd@@QAE@ABV01@@Z$1
__ehfuncinfo$??0response@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0response@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1response@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0response@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0response@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0response@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0response@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0response@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@request@NullPmd@@QAEXABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@request@NullPmd@@QAEXABV12@@Z$0
__ehfuncinfo$?MergeFrom@request@NullPmd@@QAEXABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@request@NullPmd@@QAEXABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0
__ehfuncinfo$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0
__ehfuncinfo$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0request@NullPmd@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0request@NullPmd@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0request@NullPmd@@QAE@ABV01@@Z$1
__ehfuncinfo$??0request@NullPmd@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0request@NullPmd@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1request@NullPmd@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0request@NullPmd@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0request@NullPmd@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0request@NullPmd@@QAE@XZ$1
__ehfuncinfo$??0request@NullPmd@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0request@NullPmd@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ByteSize@MessageLite@protobuf@google@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ByteSize@MessageLite@protobuf@google@@QBEHXZ$0
__ehfuncinfo$?ByteSize@MessageLite@protobuf@google@@QBEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ByteSize@MessageLite@protobuf@google@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1UnknownFieldSet@protobuf@google@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z$0
__ehfuncinfo$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
__ehfuncinfo$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
__ehfuncinfo$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z$0
__ehfuncinfo$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z$0
__ehfuncinfo$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$0
__tryblocktable$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ DD 01H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$4
__unwindtable$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$2
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$3
	DD	00H
	DD	00H
__ehfuncinfo$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$0
__unwindtable$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$2
__ehfuncinfo$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z$0
__ehfuncinfo$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z$0
__ehfuncinfo$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z$0
__ehfuncinfo$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z$0
__ehfuncinfo$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z$0
__ehfuncinfo$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z$0
__ehfuncinfo$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$0
__unwindtable$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$2
__ehfuncinfo$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
	DD	01H
	DD	FLAT:__tryblocktable$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?StartService@CTCPNetworkEngine@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartService@CTCPNetworkEngine@@UAE_NXZ$0
__ehfuncinfo$?StartService@CTCPNetworkEngine@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?StartService@CTCPNetworkEngine@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CTCPNetworkEngine@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CTCPNetworkEngine@@QAE@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??0CTCPNetworkEngine@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CTCPNetworkEngine@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$0
__tryblocktable$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$3
__unwindtable$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
	DD	01H
	DD	FLAT:__tryblocktable$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ$1
__ehfuncinfo$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$0
__tryblocktable$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$3
__unwindtable$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z DD 0aH
	DD	0bH
	DD	0cH
	DD	02H
	DD	FLAT:__catchsym$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$232
__catchsym$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$232 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffb960H
	DD	FLAT:__catch$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$1
__ehfuncinfo$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z
	DD	01H
	DD	FLAT:__tryblocktable$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$3
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$4
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	06H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	08H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	00H
	DD	0aH
	DD	FLAT:__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$5
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z DD 00H
	DD	04H
	DD	05H
	DD	02H
	DD	FLAT:__catchsym$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$39
__catchsym$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$39 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffb948H
	DD	FLAT:__catch$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$1
__ehfuncinfo$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$4
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?SendData@CTCPNetworkItem@@QAE_NGGG@Z DD 00H
	DD	05H
	DD	06H
	DD	02H
	DD	FLAT:__catchsym$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$18
__catchsym$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$18 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffbd48H
	DD	FLAT:__catch$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$1
__ehfuncinfo$?SendData@CTCPNetworkItem@@QAE_NGGG@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?SendData@CTCPNetworkItem@@QAE_NGGG@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SendData@CTCPNetworkItem@@QAE_NGGG@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?SendData@CTCPNetworkItem@@QAE_NGGG@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$3
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$4
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__tryblocktable$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ DD 00H
	DD	05H
	DD	06H
	DD	02H
	DD	FLAT:__catchsym$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$14
__catchsym$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$14 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffb720H
	DD	FLAT:__catch$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$1
__ehfuncinfo$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ
	DD	01H
	DD	FLAT:__tryblocktable$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$6
	DD	04H
	DD	FLAT:__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$7
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ DD 00H
	DD	00H
	DD	01H
	DD	02H
	DD	FLAT:__catchsym$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$3
__catchsym$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$3 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	0ffffbbacH
	DD	FLAT:__catch$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$0
	DD	040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$1
__ehfuncinfo$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ
	DD	01H
	DD	FLAT:__tryblocktable$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z$0
__unwindtable$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z$2
__ehfuncinfo$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z DD 019930522H
	DD	01fH
	DD	FLAT:__unwindtable$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$1
	DD	00H
	DD	FLAT:___std_terminate
	DD	02H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$29
	DD	00H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$2
	DD	05H
	DD	FLAT:___std_terminate
	DD	06H
	DD	FLAT:___std_terminate
	DD	05H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$4
	DD	08H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$5
	DD	0aH
	DD	FLAT:___std_terminate
	DD	0bH
	DD	FLAT:___std_terminate
	DD	0aH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$6
	DD	0dH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$7
	DD	0aH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$7
	DD	0fH
	DD	FLAT:___std_terminate
	DD	010H
	DD	FLAT:___std_terminate
	DD	0fH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$8
	DD	012H
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$10
	DD	0fH
	DD	FLAT:__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$10
	DD	014H
	DD	FLAT:___std_terminate
	DD	015H
	DD	FLAT:___std_terminate
	DD	0fH
	DD	FLAT:___std_terminate
	DD	017H
	DD	FLAT:___std_terminate
	DD	0aH
	DD	FLAT:___std_terminate
	DD	019H
	DD	FLAT:___std_terminate
	DD	05H
	DD	FLAT:___std_terminate
	DD	01bH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	01dH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CTCPNetworkItem@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$3
__ehfuncinfo$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	02H
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ$2
	DD	02H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:__unwindfunclet$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	02H
	DD	FLAT:___std_terminate
	DD	02H
	DD	FLAT:___std_terminate
	DD	02H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$2
	DD	02H
	DD	FLAT:___std_terminate
	DD	02H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$3
	DD	02H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$1
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$0
__unwindtable$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$14
__ehfuncinfo$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ$28 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ$0
__unwindtable$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ$28
__ehfuncinfo$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$1
	DD	01H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$2
	DD	01H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	06H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1HttpRequest@net@zl@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1HttpRequest@net@zl@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1HttpRequest@net@zl@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	03H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	05H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HttpRequest@net@zl@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$2
__ehfuncinfo$??0HttpRequest@net@zl@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0HttpRequest@net@zl@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$3
	DD	02H
	DD	FLAT:___std_terminate
	DD	01H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ByteBuffer@net@zl@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ByteBuffer@net@zl@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ByteBuffer@net@zl@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$63 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$0
__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$63
__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?begin@ByteBuffer@net@zl@@AAEPADXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?begin@ByteBuffer@net@zl@@AAEPADXZ$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?begin@ByteBuffer@net@zl@@AAEPADXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?begin@ByteBuffer@net@zl@@AAEPADXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?static_descriptor_initializer$initializer$@protobuf_NullPmd_2eproto@NullPmd@@3P6AXXZA DD FLAT:??__Estatic_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::static_descriptor_initializer$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CTCPNetworkEngine@@W3AEPAXABU_GUID@@K@Z
_TEXT	SEGMENT
?QueryInterface@CTCPNetworkEngine@@W3AEPAXABU_GUID@@K@Z PROC ; [thunk]:CTCPNetworkEngine::QueryInterface`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z ; CTCPNetworkEngine::QueryInterface
?QueryInterface@CTCPNetworkEngine@@W3AEPAXABU_GUID@@K@Z ENDP ; [thunk]:CTCPNetworkEngine::QueryInterface`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CTCPNetworkEngine@@W3AEXXZ
_TEXT	SEGMENT
?Release@CTCPNetworkEngine@@W3AEXXZ PROC		; [thunk]:CTCPNetworkEngine::Release`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?Release@CTCPNetworkEngine@@UAEXXZ ; CTCPNetworkEngine::Release
?Release@CTCPNetworkEngine@@W3AEXXZ ENDP		; [thunk]:CTCPNetworkEngine::Release`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$_Equal_rev_pred_unchecked1@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
tv69 = -20						; size = 4
__First1_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
tv71 = -8						; size = 4
__First2_ch$ = -4					; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Equal_rev_pred_unchecked1@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Equal_rev_pred_unchecked1<char *,char const *,std::equal_to<void> >, COMDAT

; 885  : 	{	// compare [_First1, ...) to [_First2, _Last2), memcmp optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 886  : 	const auto _First1_ch = reinterpret_cast<const char *>(_First1);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR __First1_ch$[ebp], eax

; 887  : 	const auto _First2_ch = reinterpret_cast<const char *>(_First2);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR __First2_ch$[ebp], ecx

; 888  : 	const auto _Count = static_cast<size_t>(reinterpret_cast<const char *>(_Last2) - _First2_ch);

  00012	8b 55 10	 mov	 edx, DWORD PTR __Last2$[ebp]
  00015	2b 55 fc	 sub	 edx, DWORD PTR __First2_ch$[ebp]
  00018	89 55 f4	 mov	 DWORD PTR __Count$[ebp], edx

; 889  : 	return (_CSTD memcmp(_First1_ch, _First2_ch, _Count) == 0);

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Count$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __First2_ch$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 f0	 mov	 edx, DWORD PTR __First1_ch$[ebp]
  00026	52		 push	 edx
  00027	e8 00 00 00 00	 call	 _memcmp
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  00032	83 7d ec 00	 cmp	 DWORD PTR tv69[ebp], 0
  00036	75 09		 jne	 SHORT $LN3@Equal_rev_
  00038	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0003f	eb 07		 jmp	 SHORT $LN4@Equal_rev_
$LN3@Equal_rev_:
  00041	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@Equal_rev_:
  00048	8a 45 f8	 mov	 al, BYTE PTR tv71[ebp]

; 890  : 	}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Equal_rev_pred_unchecked1@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Equal_rev_pred_unchecked1<char *,char const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Equal_memcmp_is_safe@D$$CBDU?$equal_to@X@std@@@std@@YA?AU?$integral_constant@_N$00@0@ABQADABQBDABU?$equal_to@X@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Equal_memcmp_is_safe@D$$CBDU?$equal_to@X@std@@@std@@YA?AU?$integral_constant@_N$00@0@ABQADABQBDABU?$equal_to@X@0@@Z PROC ; std::_Equal_memcmp_is_safe<char,char const ,std::equal_to<void> >, COMDAT

; 3072 : 	{	// return equal optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3073 : 	return {};

  00004	33 c0		 xor	 eax, eax
  00006	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00009	8a 45 ff	 mov	 al, BYTE PTR $T1[ebp]

; 3074 : 	}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Equal_memcmp_is_safe@D$$CBDU?$equal_to@X@std@@@std@@YA?AU?$integral_constant@_N$00@0@ABQADABQBDABU?$equal_to@X@0@@Z ENDP ; std::_Equal_memcmp_is_safe<char,char const ,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$_Enable_shared_from_this1@DD@std@@YAXABV?$shared_ptr@D@0@PADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Enable_shared_from_this1@DD@std@@YAXABV?$shared_ptr@D@0@PADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Enable_shared_from_this1<char,char>, COMDAT

; 1022 : 	{	// don't enable shared_from_this

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1023 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Enable_shared_from_this1@DD@std@@YAXABV?$shared_ptr@D@0@PADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Enable_shared_from_this1<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z PROC		; std::_Copy_memmove<char *,char *>, COMDAT

; 2398 : 	{	// implement copy-like function as memmove

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

  00012	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00015	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00028	52		 push	 edx
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _memmove
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00035	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00038	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 2405 : 	}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Copy_memmove@PADPAD@std@@YAPADPAD00@Z ENDP		; std::_Copy_memmove<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$_Equal_rev_pred_unchecked@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@@Z
_TEXT	SEGMENT
tv79 = -36						; size = 4
__First1_ch$1 = -32					; size = 4
__Count$2 = -28						; size = 4
__First2$ = -24						; size = 4
__First1$ = -20						; size = 4
tv81 = -16						; size = 4
__First2_ch$3 = -12					; size = 4
___formal$ = -8						; size = 1
$T4 = -2						; size = 1
$T5 = -1						; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Equal_rev_pred_unchecked@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@@Z PROC ; std::_Equal_rev_pred_unchecked<char *,char const *,std::equal_to<void> >, COMDAT

; 896  : 	{	// compare [_First1, ...) to [_First2, _Last2) using _Pred, choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 3073 : 	return {};

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T5[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 897  : 	return (_Equal_rev_pred_unchecked1(_First1, _First2, _Last2, _Pred,

  0000b	8a 4d ff	 mov	 cl, BYTE PTR $T5[ebp]
  0000e	88 4d fe	 mov	 BYTE PTR $T4[ebp], cl
  00011	8a 55 14	 mov	 dl, BYTE PTR __Pred$[ebp]
  00014	88 55 f8	 mov	 BYTE PTR ___formal$[ebp], dl
  00017	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR __First2$[ebp], eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00020	89 4d ec	 mov	 DWORD PTR __First1$[ebp], ecx

; 886  : 	const auto _First1_ch = reinterpret_cast<const char *>(_First1);

  00023	8b 55 ec	 mov	 edx, DWORD PTR __First1$[ebp]
  00026	89 55 e0	 mov	 DWORD PTR __First1_ch$1[ebp], edx

; 887  : 	const auto _First2_ch = reinterpret_cast<const char *>(_First2);

  00029	8b 45 e8	 mov	 eax, DWORD PTR __First2$[ebp]
  0002c	89 45 f4	 mov	 DWORD PTR __First2_ch$3[ebp], eax

; 888  : 	const auto _Count = static_cast<size_t>(reinterpret_cast<const char *>(_Last2) - _First2_ch);

  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Last2$[ebp]
  00032	2b 4d f4	 sub	 ecx, DWORD PTR __First2_ch$3[ebp]
  00035	89 4d e4	 mov	 DWORD PTR __Count$2[ebp], ecx

; 889  : 	return (_CSTD memcmp(_First1_ch, _First2_ch, _Count) == 0);

  00038	8b 55 e4	 mov	 edx, DWORD PTR __Count$2[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 f4	 mov	 eax, DWORD PTR __First2_ch$3[ebp]
  0003f	50		 push	 eax
  00040	8b 4d e0	 mov	 ecx, DWORD PTR __First1_ch$1[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _memcmp
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	89 45 dc	 mov	 DWORD PTR tv79[ebp], eax
  0004f	83 7d dc 00	 cmp	 DWORD PTR tv79[ebp], 0
  00053	75 09		 jne	 SHORT $LN7@Equal_rev_
  00055	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN5@Equal_rev_
$LN7@Equal_rev_:
  0005e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN5@Equal_rev_:

; 897  : 	return (_Equal_rev_pred_unchecked1(_First1, _First2, _Last2, _Pred,

  00065	8a 45 f0	 mov	 al, BYTE PTR tv81[ebp]

; 898  : 		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
; 899  : 	}

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Equal_rev_pred_unchecked@PADPBDU?$equal_to@X@std@@@std@@YA_NQADQBD1U?$equal_to@X@0@@Z ENDP ; std::_Equal_rev_pred_unchecked<char *,char const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__This$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z PROC ; std::_Enable_shared_from_this<char,char>, COMDAT

; 1028 : 	{	// possibly enable shared_from_this

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1029 : 	_Enable_shared_from_this1(_This, _Ptr, bool_constant<conjunction_v<

  00004	33 c0		 xor	 eax, eax
  00006	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00009	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00011	52		 push	 edx
  00012	8b 45 08	 mov	 eax, DWORD PTR __This$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Enable_shared_from_this1@DD@std@@YAXABV?$shared_ptr@D@0@PADU?$integral_constant@_N$0A@@0@@Z ; std::_Enable_shared_from_this1<char,char>
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1030 : 		negation<is_array<_Other>>,
; 1031 : 		negation<is_volatile<_Yty>>,
; 1032 : 		_Can_enable_shared<_Yty>>>{});
; 1033 : 	}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z ENDP ; std::_Enable_shared_from_this<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@DDV?$allocator@D@std@@@std@@YAPADQAD00AAV?$allocator@D@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Last_ch$1 = -16					; size = 4
__Count$2 = -12						; size = 4
__Dest_ch$3 = -8					; size = 4
__First_ch$4 = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@DDV?$allocator@D@std@@@std@@YAPADQAD00AAV?$allocator@D@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<char,char,std::allocator<char> >, COMDAT

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$4[ebp], eax

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR __Last_ch$1[ebp], ecx

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

  00012	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00015	89 55 f8	 mov	 DWORD PTR __Dest_ch$3[ebp], edx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$1[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$4[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$2[ebp], eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Count$2[ebp]
  00024	51		 push	 ecx
  00025	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$4[ebp]
  00028	52		 push	 edx
  00029	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$3[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _memmove
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00035	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$3[ebp]
  00038	03 45 f4	 add	 eax, DWORD PTR __Count$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 245  : 	}

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@DDV?$allocator@D@std@@@std@@YAPADQAD00AAV?$allocator@D@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<char,char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Ptr_move_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z PROC ; std::_Ptr_move_cat<char,char>, COMDAT

; 1086 : 	{	// return pointer move optimization category for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1087 : 	return {};

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1088 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Ptr_move_cat@DD@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAD0@Z ENDP ; std::_Ptr_move_cat<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped_n@DH$0A@@std@@YAPADQADH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@DH$0A@@std@@YAPADQADH@Z PROC	; std::_Get_unwrapped_n<char,int,0>, COMDAT

; 808  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 809  : 	return (_Src);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Src$[ebp]

; 810  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped_n@DH$0A@@std@@YAPADQADH@Z ENDP	; std::_Get_unwrapped_n<char,int,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Zero_range@PAD@std@@YAPADQAD0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAD@std@@YAPADQAD0@Z PROC		; std::_Zero_range<char *>, COMDAT

; 310  : 	{	// fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00012	8b 55 f8	 mov	 edx, DWORD PTR __Last_ch$[ebp]
  00015	2b 55 fc	 sub	 edx, DWORD PTR __First_ch$[ebp]
  00018	52		 push	 edx
  00019	6a 00		 push	 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR __First_ch$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _memset
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 314  : 	return (_Last);

  00027	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 315  : 	}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Zero_range@PAD@std@@YAPADQAD0@Z ENDP		; std::_Zero_range<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z
_TEXT	SEGMENT
_this$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_object$ = 8						; size = 4
??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z PROC ; google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>, COMDAT

; 76   : template<typename T> void arena_destruct_object(void* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 259  :   if (fields_ != NULL) {

  00030	8b 4d f0	 mov	 ecx, DWORD PTR _this$2[ebp]
  00033	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00036	74 08		 je	 SHORT $LN10@arena_dest

; 260  :     ClearFallback();

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$2[ebp]
  0003b	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN10@arena_dest:

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00040	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00047	33 d2		 xor	 edx, edx
  00049	83 e2 01	 and	 edx, 1
  0004c	74 0e		 je	 SHORT $LN1@arena_dest
  0004e	6a 08		 push	 8
  00050	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00059	83 c4 08	 add	 esp, 8
$LN1@arena_dest:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h

; 78   : }

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ENDP ; google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$_Search_unchecked@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@Urandom_access_iterator_tag@0@4@Z
_TEXT	SEGMENT
__Last_possible$1 = -60					; size = 4
tv92 = -56						; size = 4
__First1_ch$2 = -52					; size = 4
__Count$3 = -48						; size = 4
__First2$ = -44						; size = 4
__First1$ = -40						; size = 4
__First1$ = -36						; size = 4
__First2$ = -32						; size = 4
tv94 = -28						; size = 4
__First2_ch$4 = -24					; size = 4
__Count2$ = -20						; size = 4
___formal$ = -16					; size = 1
$T5 = -9						; size = 1
__Pred$ = -8						; size = 1
$T6 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Search_unchecked@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@Urandom_access_iterator_tag@0@4@Z PROC ; std::_Search_unchecked<char *,char const *,std::equal_to<void> >, COMDAT

; 936  : 	{	// find first [_First2, _Last2) satisfying _Pred, random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 937  : 	_Iter_diff_t<_FwdItPat> _Count2 = _Last2 - _First2;

  00006	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  00009	2b 45 10	 sub	 eax, DWORD PTR __First2$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Count2$[ebp], eax

; 938  : 	if (_Last1 - _First1 >= _Count2)

  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Last1$[ebp]
  00012	2b 4d 08	 sub	 ecx, DWORD PTR __First1$[ebp]
  00015	3b 4d ec	 cmp	 ecx, DWORD PTR __Count2$[ebp]
  00018	0f 8c a1 00 00
	00		 jl	 $LN5@Search_unc

; 939  : 		{
; 940  : 		const auto _Last_possible = _Last1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);

  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Last1$[ebp]
  00021	2b 55 ec	 sub	 edx, DWORD PTR __Count2$[ebp]
  00024	89 55 c4	 mov	 DWORD PTR __Last_possible$1[ebp], edx
  00027	eb 09		 jmp	 SHORT $LN4@Search_unc
$LN2@Search_unc:

; 941  : 		for (;; ++_First1)

  00029	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 08	 mov	 DWORD PTR __First1$[ebp], eax
$LN4@Search_unc:

; 942  : 			{
; 943  : 			if (_Equal_rev_pred_unchecked(_First1, _First2, _Last2, _Pred))

  00032	8a 4d 18	 mov	 cl, BYTE PTR __Pred$[ebp]
  00035	88 4d f8	 mov	 BYTE PTR __Pred$[ebp], cl
  00038	8b 55 10	 mov	 edx, DWORD PTR __First2$[ebp]
  0003b	89 55 e0	 mov	 DWORD PTR __First2$[ebp], edx
  0003e	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00041	89 45 dc	 mov	 DWORD PTR __First1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 3073 : 	return {};

  00044	33 c9		 xor	 ecx, ecx
  00046	88 4d ff	 mov	 BYTE PTR $T6[ebp], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 897  : 	return (_Equal_rev_pred_unchecked1(_First1, _First2, _Last2, _Pred,

  00049	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  0004c	88 55 f7	 mov	 BYTE PTR $T5[ebp], dl
  0004f	8a 45 f8	 mov	 al, BYTE PTR __Pred$[ebp]
  00052	88 45 f0	 mov	 BYTE PTR ___formal$[ebp], al
  00055	8b 4d e0	 mov	 ecx, DWORD PTR __First2$[ebp]
  00058	89 4d d4	 mov	 DWORD PTR __First2$[ebp], ecx
  0005b	8b 55 dc	 mov	 edx, DWORD PTR __First1$[ebp]
  0005e	89 55 d8	 mov	 DWORD PTR __First1$[ebp], edx

; 886  : 	const auto _First1_ch = reinterpret_cast<const char *>(_First1);

  00061	8b 45 d8	 mov	 eax, DWORD PTR __First1$[ebp]
  00064	89 45 cc	 mov	 DWORD PTR __First1_ch$2[ebp], eax

; 887  : 	const auto _First2_ch = reinterpret_cast<const char *>(_First2);

  00067	8b 4d d4	 mov	 ecx, DWORD PTR __First2$[ebp]
  0006a	89 4d e8	 mov	 DWORD PTR __First2_ch$4[ebp], ecx

; 888  : 	const auto _Count = static_cast<size_t>(reinterpret_cast<const char *>(_Last2) - _First2_ch);

  0006d	8b 55 14	 mov	 edx, DWORD PTR __Last2$[ebp]
  00070	2b 55 e8	 sub	 edx, DWORD PTR __First2_ch$4[ebp]
  00073	89 55 d0	 mov	 DWORD PTR __Count$3[ebp], edx

; 889  : 	return (_CSTD memcmp(_First1_ch, _First2_ch, _Count) == 0);

  00076	8b 45 d0	 mov	 eax, DWORD PTR __Count$3[ebp]
  00079	50		 push	 eax
  0007a	8b 4d e8	 mov	 ecx, DWORD PTR __First2_ch$4[ebp]
  0007d	51		 push	 ecx
  0007e	8b 55 cc	 mov	 edx, DWORD PTR __First1_ch$2[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _memcmp
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008a	89 45 c8	 mov	 DWORD PTR tv92[ebp], eax
  0008d	83 7d c8 00	 cmp	 DWORD PTR tv92[ebp], 0
  00091	75 09		 jne	 SHORT $LN15@Search_unc
  00093	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  0009a	eb 07		 jmp	 SHORT $LN9@Search_unc
$LN15@Search_unc:
  0009c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
$LN9@Search_unc:

; 942  : 			{
; 943  : 			if (_Equal_rev_pred_unchecked(_First1, _First2, _Last2, _Pred))

  000a3	0f b6 45 e4	 movzx	 eax, BYTE PTR tv94[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 05		 je	 SHORT $LN6@Search_unc

; 944  : 				{
; 945  : 				return (_First1);

  000ab	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  000ae	eb 12		 jmp	 SHORT $LN1@Search_unc
$LN6@Search_unc:

; 946  : 				}
; 947  : 
; 948  : 			if (_First1 == _Last_possible)

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  000b3	3b 4d c4	 cmp	 ecx, DWORD PTR __Last_possible$1[ebp]
  000b6	75 02		 jne	 SHORT $LN7@Search_unc

; 949  : 				{
; 950  : 				break;

  000b8	eb 05		 jmp	 SHORT $LN5@Search_unc
$LN7@Search_unc:

; 951  : 				}
; 952  : 			}

  000ba	e9 6a ff ff ff	 jmp	 $LN2@Search_unc
$LN5@Search_unc:

; 953  : 		}
; 954  : 
; 955  : 	return (_Last1);

  000bf	8b 45 0c	 mov	 eax, DWORD PTR __Last1$[ebp]
$LN1@Search_unc:

; 956  : 	}

  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
??$_Search_unchecked@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@Urandom_access_iterator_tag@0@4@Z ENDP ; std::_Search_unchecked<char *,char const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$_Set_ptr_rep_and_enable_shared@D@?$shared_ptr@D@std@@AAEXPADPAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Px$ = 8						; size = 4
__Rx$ = 12						; size = 4
??$_Set_ptr_rep_and_enable_shared@D@?$shared_ptr@D@std@@AAEXPADPAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<char>::_Set_ptr_rep_and_enable_shared<char>, COMDAT
; _this$ = ecx

; 1581 : 		{	// take ownership of _Px

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1132 : 		_Ptr = _Other_ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1133 : 		_Rep = _Other_rep;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1582 : 		this->_Set_ptr_rep(_Px, _Rx);
; 1583 : 		_Enable_shared_from_this(*this, _Px);

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z ; std::_Enable_shared_from_this<char,char>
  00025	83 c4 08	 add	 esp, 8

; 1584 : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$_Set_ptr_rep_and_enable_shared@D@?$shared_ptr@D@std@@AAEXPADPAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<char>::_Set_ptr_rep_and_enable_shared<char>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Ref_count@D@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Ref_count@D@std@@UAEPAXI@Z PROC			; std::_Ref_count<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000a	83 e0 01	 and	 eax, 1
  0000d	74 0e		 je	 SHORT $LN2@scalar
  0000f	6a 10		 push	 16			; 00000010H
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001a	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_G?$_Ref_count@D@std@@UAEPAXI@Z ENDP			; std::_Ref_count<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Ref_count@D@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Ref_count@D@std@@UAE@XZ PROC			; std::_Ref_count<char>::~_Ref_count<char>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$_Ref_count@D@std@@UAE@XZ ENDP			; std::_Ref_count<char>::~_Ref_count<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@D@std@@EAEXXZ
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?_Delete_this@?$_Ref_count@D@std@@EAEXXZ PROC		; std::_Ref_count<char>::_Delete_this, COMDAT
; _this$ = ecx

; 889  : 		{	// destroy self

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 890  : 		delete this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
  00015	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00019	74 14		 je	 SHORT $LN3@Delete_thi
  0001b	6a 01		 push	 1
  0001d	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00025	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00028	ff d2		 call	 edx
  0002a	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  0002d	eb 07		 jmp	 SHORT $LN2@Delete_thi
$LN3@Delete_thi:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN2@Delete_thi:

; 891  : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?_Delete_this@?$_Ref_count@D@std@@EAEXXZ ENDP		; std::_Ref_count<char>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@D@std@@EAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Destroy@?$_Ref_count@D@std@@EAEXXZ PROC		; std::_Ref_count<char>::_Destroy, COMDAT
; _this$ = ecx

; 884  : 		{	// destroy managed resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 885  : 		delete _Ptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  00012	6a 01		 push	 1
  00014	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001d	83 c4 08	 add	 esp, 8

; 886  : 		}

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?_Destroy@?$_Ref_count@D@std@@EAEXXZ ENDP		; std::_Ref_count<char>::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??0?$_Ref_count@D@std@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Px$ = 8						; size = 4
??0?$_Ref_count@D@std@@QAE@PAD@Z PROC			; std::_Ref_count<char>::_Ref_count<char>, COMDAT
; _this$ = ecx

; 879  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 795  : 		: _Uses(1), _Weaks(1)	// non-atomic initializations

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1

; 879  : 		{	// construct

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7?$_Ref_count@D@std@@6B@

; 796  : 		{	// construct
; 797  : 		}
; 798  : 
; 799  : public:
; 800  : 	virtual ~_Ref_count_base() noexcept
; 801  : 		{	// TRANSITION, should be non-virtual
; 802  : 		}
; 803  : 
; 804  : 	bool _Incref_nz()
; 805  : 		{	// increment use count if not zero, return true if successful
; 806  : 		for (;;)
; 807  : 			{	// loop until state is known
; 808  :  #if _USE_INTERLOCKED_REFCOUNTING
; 809  : 			const _Atomic_integral_t _Count =
; 810  : 				static_cast<volatile _Atomic_counter_t&>(_Uses);
; 811  : 
; 812  : 			if (_Count == 0)
; 813  : 				return (false);
; 814  : 
; 815  : 			if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
; 816  : 					reinterpret_cast<volatile long *>(&_Uses),
; 817  : 					static_cast<long>(_Count + 1), static_cast<long>(_Count))) == _Count)
; 818  : 				return (true);
; 819  : 
; 820  :  #else /* _USE_INTERLOCKED_REFCOUNTING */
; 821  : 			const _Atomic_integral_t _Count =
; 822  : 				_Load_atomic_counter(_Uses);
; 823  : 
; 824  : 			if (_Count == 0)
; 825  : 				return (false);
; 826  : 
; 827  : 			if (_Compare_increment_atomic_counter(_Uses, _Count))
; 828  : 				return (true);
; 829  :  #endif /* _USE_INTERLOCKED_REFCOUNTING */
; 830  : 			}
; 831  : 		}
; 832  : 
; 833  : 	void _Incref()
; 834  : 		{	// increment use count
; 835  : 		_MT_INCR(_Uses);
; 836  : 		}
; 837  : 
; 838  : 	void _Incwref()
; 839  : 		{	// increment weak reference count
; 840  : 		_MT_INCR(_Weaks);
; 841  : 		}
; 842  : 
; 843  : 	void _Decref()
; 844  : 		{	// decrement use count
; 845  : 		if (_MT_DECR(_Uses) == 0)
; 846  : 			{	// destroy managed resource, decrement weak reference count
; 847  : 			_Destroy();
; 848  : 			_Decwref();
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void _Decwref()
; 853  : 		{	// decrement weak reference count
; 854  : 		if (_MT_DECR(_Weaks) == 0)
; 855  : 			{
; 856  : 			_Delete_this();
; 857  : 			}
; 858  : 		}
; 859  : 
; 860  : 	long _Use_count() const noexcept
; 861  : 		{	// return use count
; 862  : 		return (static_cast<long>(_Get_atomic_count(_Uses)));
; 863  : 		}
; 864  : 
; 865  : 	virtual void * _Get_deleter(const type_info&) const noexcept
; 866  : 		{	// return address of deleter object
; 867  : 		return (nullptr);
; 868  : 		}
; 869  : 	};
; 870  : 
; 871  : 	// CLASS TEMPLATE _Ref_count
; 872  : template<class _Ty>
; 873  : 	class _Ref_count
; 874  : 		: public _Ref_count_base
; 875  : 	{	// handle reference counting for pointer without deleter
; 876  : public:
; 877  : 	explicit _Ref_count(_Ty * _Px)
; 878  : 		: _Ref_count_base(), _Ptr(_Px)

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  0002a	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 880  : 		}

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0?$_Ref_count@D@std@@QAE@PAD@Z ENDP			; std::_Ref_count<char>::_Ref_count<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_object$ = 8						; size = 4
??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z PROC ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>, COMDAT

; 79   : template<typename T> void arena_delete_object(void* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 80   :   delete reinterpret_cast<T*>(object);

  00006	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
  00012	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00016	74 13		 je	 SHORT $LN3@arena_dele
  00018	6a 01		 push	 1
  0001a	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  0001d	8b 02		 mov	 eax, DWORD PTR [edx]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00022	8b 10		 mov	 edx, DWORD PTR [eax]
  00024	ff d2		 call	 edx
  00026	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00029	eb 07		 jmp	 SHORT $LN1@arena_dele
$LN3@arena_dele:
  0002b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN1@arena_dele:

; 81   : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ENDP ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$?0ABI_N$0A@@?$pair@I_N@std@@QAE@ABI$$QA_N@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABI_N$0A@@?$pair@I_N@std@@QAE@ABI$$QA_N@Z PROC	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int const &,bool,0>, COMDAT
; _this$ = ecx

; 174  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00025	8a 08		 mov	 cl, BYTE PTR [eax]
  00027	88 4a 04	 mov	 BYTE PTR [edx+4], cl

; 175  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??$?0ABI_N$0A@@?$pair@I_N@std@@QAE@ABI$$QA_N@Z ENDP	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int const &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$?0AAIAA_N$0A@@?$pair@I_N@std@@QAE@AAIAA_N@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAIAA_N$0A@@?$pair@I_N@std@@QAE@AAIAA_N@Z PROC	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int &,bool &,0>, COMDAT
; _this$ = ecx

; 174  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00025	8a 08		 mov	 cl, BYTE PTR [eax]
  00027	88 4a 04	 mov	 BYTE PTR [edx+4], cl

; 175  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??$?0AAIAA_N$0A@@?$pair@I_N@std@@QAE@AAIAA_N@Z ENDP	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int &,bool &,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AA_N@std@@YAAA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AA_N@std@@YAAA_NAA_N@Z PROC			; std::forward<bool &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AA_N@std@@YAAA_NAA_N@Z ENDP			; std::forward<bool &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$?0AAI_N$0A@@?$pair@I_N@std@@QAE@AAI$$QA_N@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAI_N$0A@@?$pair@I_N@std@@QAE@AAI$$QA_N@Z PROC	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int &,bool,0>, COMDAT
; _this$ = ecx

; 174  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00025	8a 08		 mov	 cl, BYTE PTR [eax]
  00027	88 4a 04	 mov	 BYTE PTR [edx+4], cl

; 175  : 		}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??$?0AAI_N$0A@@?$pair@I_N@std@@QAE@AAI$$QA_N@Z ENDP	; std::pair<unsigned int,bool>::pair<unsigned int,bool><unsigned int &,bool,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Seek_wrapped@D@std@@YAXAAPADQAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@D@std@@YAXAAPADQAD@Z PROC		; std::_Seek_wrapped<char>, COMDAT

; 871  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 872  : 	_It = _UIt;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __UIt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 873  : 	}

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Seek_wrapped@D@std@@YAXAAPADQAD@Z ENDP		; std::_Seek_wrapped<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Pass_fn@U?$equal_to@X@std@@$0A@@std@@YA?AU?$equal_to@X@0@U10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 1
??$_Pass_fn@U?$equal_to@X@std@@$0A@@std@@YA?AU?$equal_to@X@0@U10@@Z PROC ; std::_Pass_fn<std::equal_to<void>,0>, COMDAT

; 380  : 	{	// pass functor by value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 381  : 	return (_Val);

  00003	8a 45 08	 mov	 al, BYTE PTR __Val$[ebp]

; 382  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Pass_fn@U?$equal_to@X@std@@$0A@@std@@YA?AU?$equal_to@X@0@U10@@Z ENDP ; std::_Pass_fn<std::equal_to<void>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@$$CBD@std@@YAPBDQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@$$CBD@std@@YAPBDQBD@Z PROC		; std::_Get_unwrapped<char const >, COMDAT

; 662  : 	{	// special case already-unwrapped pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 663  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 664  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped@$$CBD@std@@YAPBDQBD@Z ENDP		; std::_Get_unwrapped<char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Last_ch$2 = -48					; size = 4
__Dest$ = -44						; size = 4
__Last$ = -40						; size = 4
__First$ = -36						; size = 4
__UDest$ = -32						; size = 4
__Count$3 = -28						; size = 4
__Dest_ch$4 = -24					; size = 4
__First_ch$5 = -20					; size = 4
__UFirst$ = -16						; size = 4
__ULast$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z PROC ; std::_Uninitialized_move<char *,char *,std::allocator<char> >, COMDAT

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 252  : 		// note: only called internally from elsewhere in the STL
; 253  : 	const auto _UFirst = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 254  : 	const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000f	89 4d f4	 mov	 DWORD PTR __ULast$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00012	8b 55 f4	 mov	 edx, DWORD PTR __ULast$[ebp]
  00015	2b 55 f0	 sub	 edx, DWORD PTR __UFirst$[ebp]

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));

  00018	89 55 cc	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  0001b	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001e	89 45 e0	 mov	 DWORD PTR __UDest$[ebp], eax

; 256  : 	_Seek_wrapped(_Dest,

  00021	8a 4d ff	 mov	 cl, BYTE PTR $T6[ebp]
  00024	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl
  00027	8b 55 e0	 mov	 edx, DWORD PTR __UDest$[ebp]
  0002a	89 55 d4	 mov	 DWORD PTR __Dest$[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __ULast$[ebp]
  00030	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax
  00033	8b 4d f0	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00036	89 4d dc	 mov	 DWORD PTR __First$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

  00039	8b 55 dc	 mov	 edx, DWORD PTR __First$[ebp]
  0003c	89 55 ec	 mov	 DWORD PTR __First_ch$5[ebp], edx

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

  0003f	8b 45 d8	 mov	 eax, DWORD PTR __Last$[ebp]
  00042	89 45 d0	 mov	 DWORD PTR __Last_ch$2[ebp], eax

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

  00045	8b 4d d4	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00048	89 4d e8	 mov	 DWORD PTR __Dest_ch$4[ebp], ecx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0004b	8b 55 d0	 mov	 edx, DWORD PTR __Last_ch$2[ebp]
  0004e	2b 55 ec	 sub	 edx, DWORD PTR __First_ch$5[ebp]
  00051	89 55 e4	 mov	 DWORD PTR __Count$3[ebp], edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00054	8b 45 e4	 mov	 eax, DWORD PTR __Count$3[ebp]
  00057	50		 push	 eax
  00058	8b 4d ec	 mov	 ecx, DWORD PTR __First_ch$5[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR __Dest_ch$4[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 _memmove
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  00068	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$4[ebp]
  0006b	03 45 e4	 add	 eax, DWORD PTR __Count$3[ebp]

; 872  : 	_It = _UIt;

  0006e	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 260  : 	return (_Dest);

  00071	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 261  : 	}

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z ENDP ; std::_Uninitialized_move<char *,char *,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<char> >, COMDAT

; 1145 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1146 : 		// nothing to do
; 1147 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range1@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		{	// construct childless container
; 82   : 		}
; 83   : 
; 84   : 	_Container_base12(const _Container_base12&) noexcept
; 85   : 		: _Myproxy(nullptr)
; 86   : 		{	// copy a container
; 87   : 		}
; 88   : 
; 89   : 	_Container_base12& operator=(const _Container_base12&) noexcept
; 90   : 		{	// assign a container
; 91   : 		return (*this);
; 92   : 		}
; 93   : 
; 94   : 	_Iterator_base12 **_Getpfirst() const noexcept
; 95   : 		{	// get address of iterator chain
; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
; 97   : 		}
; 98   : 
; 99   : 	void _Orphan_all() noexcept;	// orphan all iterators
; 100  : 	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators
; 101  : 
; 102  : 	_Container_proxy *_Myproxy;
; 103  : 	};
; 104  : 
; 105  : struct _Iterator_base12
; 106  : 	{	// store links to container proxy, next iterator
; 107  : 	_Iterator_base12() noexcept
; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 109  : 		{	// construct orphaned iterator
; 110  : 		}
; 111  : 
; 112  : 	_Iterator_base12(const _Iterator_base12& _Right) noexcept
; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;
; 116  : 		}
; 117  : 
; 118  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
; 119  : 		{	// assign an iterator
; 120  : 		if (_Myproxy != _Right._Myproxy)
; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);
; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);
; 136  : 		}
; 137  : 
; 138  : 	~_Iterator_base12() noexcept
; 139  : 		{	// destroy the iterator
; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);
; 142  : 		_Orphan_me();
; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}
; 145  : 
; 146  : 	void _Adopt(const _Container_base12 *_Parent) noexcept
; 147  : 		{	// adopt this iterator by parent
; 148  : 		if (_Parent == nullptr)
; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}
; 174  : 
; 175  : 	void _Clrcont() noexcept
; 176  : 		{	// disown owning container
; 177  : 		_Myproxy = nullptr;
; 178  : 		}
; 179  : 
; 180  : 	const _Container_base12 *_Getcont() const noexcept
; 181  : 		{	// get owning container
; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
; 183  : 		}
; 184  : 
; 185  : 	_Iterator_base12 **_Getpnext() noexcept
; 186  : 		{	// get address of remaining iterator chain
; 187  : 		return (&_Mynextiter);
; 188  : 		}
; 189  : 
; 190  : 	void _Orphan_me() noexcept
; 191  : 		{	// cut ties with parent
; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)
; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)
; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
; 200  : 			*_Pnext = _Mynextiter;
; 201  : 			_Myproxy = nullptr;
; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}
; 205  : 
; 206  : 	static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 207  : 
; 208  : 	_Container_proxy *_Myproxy;
; 209  : 	_Iterator_base12 *_Mynextiter;
; 210  : 	};
; 211  : 
; 212  : 		// MEMBER FUNCTIONS FOR _Container_base12
; 213  : inline void _Container_base12::_Orphan_all() noexcept
; 214  : 	{	// orphan all iterators
; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = nullptr;
; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}
; 227  : 
; 228  : inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
; 229  : 	{	// swap all iterators
; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);
; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;
; 236  : 	_Right._Myproxy = _Temp;
; 237  : 
; 238  : 	if (_Myproxy != nullptr)
; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;
; 240  : 	if (_Right._Myproxy != nullptr)
; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
; 242  : 	}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 245  : using _Container_base = _Container_base0;
; 246  : using _Iterator_base = _Iterator_base0;
; 247  : 
; 248  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 249  : using _Container_base = _Container_base12;
; 250  : using _Iterator_base = _Iterator_base12;
; 251  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 252  : 
; 253  : 	// CLASS TEMPLATE _Compressed_pair
; 254  : struct _Zero_then_variadic_args_t
; 255  : 	{	// tag type for value-initializing first,
; 256  : 	};	// constructing second from remaining args
; 257  : 
; 258  : struct _One_then_variadic_args_t
; 259  : 	{	// tag type for constructing first from one arg,
; 260  : 	};	// constructing second from remaining args
; 261  : 
; 262  : template<class _Ty1,
; 263  : 	class _Ty2,
; 264  : 	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
; 265  : 	class _Compressed_pair final
; 266  : 		: private _Ty1
; 267  : 	{	// store a pair of values, deriving from empty first
; 268  : private:
; 269  : 	_Ty2 _Myval2;
; 270  : 
; 271  : 	using _Mybase = _Ty1;	// for visualization
; 272  : 
; 273  : public:
; 274  : 	template<class... _Other2>
; 275  : 		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
; 276  : 			_Other2&&... _Val2)
; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 80   : 		: _Myproxy(nullptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 468  : 		: _Myhead(),

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 469  : 		_Mysize(0)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABUstring_cmp_nocase@base@zl@@@std@@YAABUstring_cmp_nocase@base@zl@@ABU123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUstring_cmp_nocase@base@zl@@@std@@YAABUstring_cmp_nocase@base@zl@@ABU123@@Z PROC ; std::forward<zl::base::string_cmp_nocase const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABUstring_cmp_nocase@base@zl@@@std@@YAABUstring_cmp_nocase@base@zl@@ABU123@@Z ENDP ; std::forward<zl::base::string_cmp_nocase const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 886  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 92   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 27	 add	 eax, 39			; 00000027H
  0000c	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 94   : 	if (_Block_size <= _Bytes)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  00015	77 07		 ja	 SHORT $LN13@Allocate_m

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);

  00017	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Block_size$[ebp], -1
$LN13@Allocate_m:

; 52   : 		return (::operator new(_Bytes));

  0001e	8b 55 fc	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00027	83 c4 04	 add	 esp, 4

; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0002a	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0002d	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00031	74 02		 je	 SHORT $LN7@Allocate_m
  00033	eb 44		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0003f	6a 00		 push	 0
  00041	6a 65		 push	 101			; 00000065H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00048	6a 02		 push	 2
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 01		 jne	 SHORT $LN12@Allocate_m
  00058	cc		 int	 3
$LN12@Allocate_m:
  00059	6a 00		 push	 0
  0005b	6a 65		 push	 101			; 00000065H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00072	83 c4 14	 add	 esp, 20			; 00000014H
  00075	33 c9		 xor	 ecx, ecx
  00077	75 bc		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00079	33 d2		 xor	 edx, edx
  0007b	75 b0		 jne	 SHORT $LN4@Allocate_m

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0007d	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00080	83 c0 27	 add	 eax, 39			; 00000027H
  00083	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00086	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00089	b9 04 00 00 00	 mov	 ecx, 4
  0008e	6b d1 ff	 imul	 edx, ecx, -1
  00091	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00094	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00097	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

  0009a	ba 04 00 00 00	 mov	 edx, 4
  0009f	6b c2 fe	 imul	 eax, edx, -2
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000a5	c7 04 01 fa fa
	fa fa		 mov	 DWORD PTR [ecx+eax], -84215046 ; fafafafaH

; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);

  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 110  : 	}

  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 287  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		{	// construct childless container
; 82   : 		}
; 83   : 
; 84   : 	_Container_base12(const _Container_base12&) noexcept
; 85   : 		: _Myproxy(nullptr)
; 86   : 		{	// copy a container
; 87   : 		}
; 88   : 
; 89   : 	_Container_base12& operator=(const _Container_base12&) noexcept
; 90   : 		{	// assign a container
; 91   : 		return (*this);
; 92   : 		}
; 93   : 
; 94   : 	_Iterator_base12 **_Getpfirst() const noexcept
; 95   : 		{	// get address of iterator chain
; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
; 97   : 		}
; 98   : 
; 99   : 	void _Orphan_all() noexcept;	// orphan all iterators
; 100  : 	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators
; 101  : 
; 102  : 	_Container_proxy *_Myproxy;
; 103  : 	};
; 104  : 
; 105  : struct _Iterator_base12
; 106  : 	{	// store links to container proxy, next iterator
; 107  : 	_Iterator_base12() noexcept
; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 109  : 		{	// construct orphaned iterator
; 110  : 		}
; 111  : 
; 112  : 	_Iterator_base12(const _Iterator_base12& _Right) noexcept
; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;
; 116  : 		}
; 117  : 
; 118  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
; 119  : 		{	// assign an iterator
; 120  : 		if (_Myproxy != _Right._Myproxy)
; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);
; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);
; 136  : 		}
; 137  : 
; 138  : 	~_Iterator_base12() noexcept
; 139  : 		{	// destroy the iterator
; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);
; 142  : 		_Orphan_me();
; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}
; 145  : 
; 146  : 	void _Adopt(const _Container_base12 *_Parent) noexcept
; 147  : 		{	// adopt this iterator by parent
; 148  : 		if (_Parent == nullptr)
; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}
; 174  : 
; 175  : 	void _Clrcont() noexcept
; 176  : 		{	// disown owning container
; 177  : 		_Myproxy = nullptr;
; 178  : 		}
; 179  : 
; 180  : 	const _Container_base12 *_Getcont() const noexcept
; 181  : 		{	// get owning container
; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
; 183  : 		}
; 184  : 
; 185  : 	_Iterator_base12 **_Getpnext() noexcept
; 186  : 		{	// get address of remaining iterator chain
; 187  : 		return (&_Mynextiter);
; 188  : 		}
; 189  : 
; 190  : 	void _Orphan_me() noexcept
; 191  : 		{	// cut ties with parent
; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)
; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)
; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
; 200  : 			*_Pnext = _Mynextiter;
; 201  : 			_Myproxy = nullptr;
; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}
; 205  : 
; 206  : 	static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 207  : 
; 208  : 	_Container_proxy *_Myproxy;
; 209  : 	_Iterator_base12 *_Mynextiter;
; 210  : 	};
; 211  : 
; 212  : 		// MEMBER FUNCTIONS FOR _Container_base12
; 213  : inline void _Container_base12::_Orphan_all() noexcept
; 214  : 	{	// orphan all iterators
; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = nullptr;
; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}
; 227  : 
; 228  : inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
; 229  : 	{	// swap all iterators
; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);
; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;
; 236  : 	_Right._Myproxy = _Temp;
; 237  : 
; 238  : 	if (_Myproxy != nullptr)
; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;
; 240  : 	if (_Right._Myproxy != nullptr)
; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
; 242  : 	}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 245  : using _Container_base = _Container_base0;
; 246  : using _Iterator_base = _Iterator_base0;
; 247  : 
; 248  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 249  : using _Container_base = _Container_base12;
; 250  : using _Iterator_base = _Iterator_base12;
; 251  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 252  : 
; 253  : 	// CLASS TEMPLATE _Compressed_pair
; 254  : struct _Zero_then_variadic_args_t
; 255  : 	{	// tag type for value-initializing first,
; 256  : 	};	// constructing second from remaining args
; 257  : 
; 258  : struct _One_then_variadic_args_t
; 259  : 	{	// tag type for constructing first from one arg,
; 260  : 	};	// constructing second from remaining args
; 261  : 
; 262  : template<class _Ty1,
; 263  : 	class _Ty2,
; 264  : 	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
; 265  : 	class _Compressed_pair final
; 266  : 		: private _Ty1
; 267  : 	{	// store a pair of values, deriving from empty first
; 268  : private:
; 269  : 	_Ty2 _Myval2;
; 270  : 
; 271  : 	using _Mybase = _Ty1;	// for visualization
; 272  : 
; 273  : public:
; 274  : 	template<class... _Other2>
; 275  : 		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
; 276  : 			_Other2&&... _Val2)
; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)
; 278  : 		{	// construct from forwarded values
; 279  : 		}
; 280  : 
; 281  : 	template<class _Other1,
; 282  : 		class... _Other2>
; 283  : 		_Compressed_pair(_One_then_variadic_args_t,
; 284  : 			_Other1&& _Val1, _Other2&&... _Val2)
; 285  : 		: _Ty1(_STD forward<_Other1>(_Val1)),
; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 80   : 		: _Myproxy(nullptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 1785 : 		_Myres(0)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1075 : 	{	// (don't) propagate on container copy assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1076 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1088 : 	{	// propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1089 : 	_Left = _STD move(_Right);
; 1090 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Last_ch$1 = -12					; size = 4
__Last$ = -8						; size = 4
__First_ch$2 = -4					; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_value_construct_n1@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<char *,unsigned int,std::allocator<char> >, COMDAT

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Last$[ebp], eax

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00012	89 4d fc	 mov	 DWORD PTR __First_ch$2[ebp], ecx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  00015	8b 55 f8	 mov	 edx, DWORD PTR __Last$[ebp]
  00018	89 55 f4	 mov	 DWORD PTR __Last_ch$1[ebp], edx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0001b	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$1[ebp]
  0001e	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$2[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d fc	 mov	 ecx, DWORD PTR __First_ch$2[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Last$[ebp]

; 337  : 	}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<char *,unsigned int,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$CreateInternal@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@AAEPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Where$ = -16						; size = 4
_t$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_skip_explicit_ownership$ = 8				; size = 1
??$CreateInternal@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@AAEPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@_N@Z PROC ; google::protobuf::Arena::CreateInternal<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>, COMDAT
; _this$ = ecx

; 648  :   T* CreateInternal(bool skip_explicit_ownership) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 649  :     T* t = new (AllocateAligned(RTTI_TYPE_ID(T), sizeof(T))) T();

  00009	6a 08		 push	 8
  0000b	68 00 00 00 00	 push	 OFFSET ??_R0?AUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@8
  00010	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?AllocateAligned@Arena@protobuf@google@@AAEPAXPBVtype_info@@I@Z ; google::protobuf::Arena::AllocateAligned
  00018	89 45 f0	 mov	 DWORD PTR __Where$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR __Where$[ebp]
  0001e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h

; 649  :     T* t = new (AllocateAligned(RTTI_TYPE_ID(T), sizeof(T))) T();

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00026	89 0a		 mov	 DWORD PTR [edx], ecx
  00028	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0002b	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h

; 252  : inline UnknownFieldSet::UnknownFieldSet() : fields_(NULL) {}

  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h

; 649  :     T* t = new (AllocateAligned(RTTI_TYPE_ID(T), sizeof(T))) T();

  0003a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003d	89 55 f4	 mov	 DWORD PTR _t$[ebp], edx

; 650  :     if (!skip_explicit_ownership) {

  00040	0f b6 45 08	 movzx	 eax, BYTE PTR _skip_explicit_ownership$[ebp]
  00044	85 c0		 test	 eax, eax
  00046	75 11		 jne	 SHORT $LN2@CreateInte

; 651  :       AddListNode(t, &internal::arena_destruct_object<T>);

  00048	68 00 00 00 00	 push	 OFFSET ??$arena_destruct_object@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_destruct_object<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _t$[ebp]
  00050	51		 push	 ecx
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN2@CreateInte:

; 652  :     }
; 653  :     return t;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _t$[ebp]

; 654  :   }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??$CreateInternal@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@AAEPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@_N@Z ENDP ; google::protobuf::Arena::CreateInternal<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 287  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		{	// construct childless container
; 82   : 		}
; 83   : 
; 84   : 	_Container_base12(const _Container_base12&) noexcept
; 85   : 		: _Myproxy(nullptr)
; 86   : 		{	// copy a container
; 87   : 		}
; 88   : 
; 89   : 	_Container_base12& operator=(const _Container_base12&) noexcept
; 90   : 		{	// assign a container
; 91   : 		return (*this);
; 92   : 		}
; 93   : 
; 94   : 	_Iterator_base12 **_Getpfirst() const noexcept
; 95   : 		{	// get address of iterator chain
; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
; 97   : 		}
; 98   : 
; 99   : 	void _Orphan_all() noexcept;	// orphan all iterators
; 100  : 	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators
; 101  : 
; 102  : 	_Container_proxy *_Myproxy;
; 103  : 	};
; 104  : 
; 105  : struct _Iterator_base12
; 106  : 	{	// store links to container proxy, next iterator
; 107  : 	_Iterator_base12() noexcept
; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 109  : 		{	// construct orphaned iterator
; 110  : 		}
; 111  : 
; 112  : 	_Iterator_base12(const _Iterator_base12& _Right) noexcept
; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;
; 116  : 		}
; 117  : 
; 118  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
; 119  : 		{	// assign an iterator
; 120  : 		if (_Myproxy != _Right._Myproxy)
; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);
; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);
; 136  : 		}
; 137  : 
; 138  : 	~_Iterator_base12() noexcept
; 139  : 		{	// destroy the iterator
; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);
; 142  : 		_Orphan_me();
; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}
; 145  : 
; 146  : 	void _Adopt(const _Container_base12 *_Parent) noexcept
; 147  : 		{	// adopt this iterator by parent
; 148  : 		if (_Parent == nullptr)
; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}
; 174  : 
; 175  : 	void _Clrcont() noexcept
; 176  : 		{	// disown owning container
; 177  : 		_Myproxy = nullptr;
; 178  : 		}
; 179  : 
; 180  : 	const _Container_base12 *_Getcont() const noexcept
; 181  : 		{	// get owning container
; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
; 183  : 		}
; 184  : 
; 185  : 	_Iterator_base12 **_Getpnext() noexcept
; 186  : 		{	// get address of remaining iterator chain
; 187  : 		return (&_Mynextiter);
; 188  : 		}
; 189  : 
; 190  : 	void _Orphan_me() noexcept
; 191  : 		{	// cut ties with parent
; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)
; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)
; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
; 200  : 			*_Pnext = _Mynextiter;
; 201  : 			_Myproxy = nullptr;
; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}
; 205  : 
; 206  : 	static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 207  : 
; 208  : 	_Container_proxy *_Myproxy;
; 209  : 	_Iterator_base12 *_Mynextiter;
; 210  : 	};
; 211  : 
; 212  : 		// MEMBER FUNCTIONS FOR _Container_base12
; 213  : inline void _Container_base12::_Orphan_all() noexcept
; 214  : 	{	// orphan all iterators
; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = nullptr;
; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}
; 227  : 
; 228  : inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
; 229  : 	{	// swap all iterators
; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);
; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;
; 236  : 	_Right._Myproxy = _Temp;
; 237  : 
; 238  : 	if (_Myproxy != nullptr)
; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;
; 240  : 	if (_Right._Myproxy != nullptr)
; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
; 242  : 	}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 245  : using _Container_base = _Container_base0;
; 246  : using _Iterator_base = _Iterator_base0;
; 247  : 
; 248  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 249  : using _Container_base = _Container_base12;
; 250  : using _Iterator_base = _Iterator_base12;
; 251  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 252  : 
; 253  : 	// CLASS TEMPLATE _Compressed_pair
; 254  : struct _Zero_then_variadic_args_t
; 255  : 	{	// tag type for value-initializing first,
; 256  : 	};	// constructing second from remaining args
; 257  : 
; 258  : struct _One_then_variadic_args_t
; 259  : 	{	// tag type for constructing first from one arg,
; 260  : 	};	// constructing second from remaining args
; 261  : 
; 262  : template<class _Ty1,
; 263  : 	class _Ty2,
; 264  : 	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
; 265  : 	class _Compressed_pair final
; 266  : 		: private _Ty1
; 267  : 	{	// store a pair of values, deriving from empty first
; 268  : private:
; 269  : 	_Ty2 _Myval2;
; 270  : 
; 271  : 	using _Mybase = _Ty1;	// for visualization
; 272  : 
; 273  : public:
; 274  : 	template<class... _Other2>
; 275  : 		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
; 276  : 			_Other2&&... _Val2)
; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)
; 278  : 		{	// construct from forwarded values
; 279  : 		}
; 280  : 
; 281  : 	template<class _Other1,
; 282  : 		class... _Other2>
; 283  : 		_Compressed_pair(_One_then_variadic_args_t,
; 284  : 			_Other1&& _Val1, _Other2&&... _Val2)
; 285  : 		: _Ty1(_STD forward<_Other1>(_Val1)),
; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 80   : 		: _Myproxy(nullptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 1785 : 		_Myres(0)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance1@PADPAD@std@@YAHABQAD0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@PADPAD@std@@YAHABQAD0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<char *,char *>, COMDAT

; 967  : 	{	// _Idl_distance for random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	2b 01		 sub	 eax, DWORD PTR [ecx]

; 969  : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Idl_distance1@PADPAD@std@@YAHABQAD0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Idl_distance@PADPAD@std@@YAHABQAD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PADPAD@std@@YAHABQAD0@Z PROC		; std::_Idl_distance<char *,char *>, COMDAT

; 974  : 	{	// tries to get the distance between _First and _Last if they are random-access iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	2b 01		 sub	 eax, DWORD PTR [ecx]

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Idl_distance@PADPAD@std@@YAHABQAD0@Z ENDP		; std::_Idl_distance<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Get_unwrapped@D@std@@YAPADQAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@D@std@@YAPADQAD@Z PROC		; std::_Get_unwrapped<char>, COMDAT

; 662  : 	{	// special case already-unwrapped pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 663  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 664  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped@D@std@@YAPADQAD@Z ENDP		; std::_Get_unwrapped<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 287  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		{	// construct childless container
; 82   : 		}
; 83   : 
; 84   : 	_Container_base12(const _Container_base12&) noexcept
; 85   : 		: _Myproxy(nullptr)
; 86   : 		{	// copy a container
; 87   : 		}
; 88   : 
; 89   : 	_Container_base12& operator=(const _Container_base12&) noexcept
; 90   : 		{	// assign a container
; 91   : 		return (*this);
; 92   : 		}
; 93   : 
; 94   : 	_Iterator_base12 **_Getpfirst() const noexcept
; 95   : 		{	// get address of iterator chain
; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
; 97   : 		}
; 98   : 
; 99   : 	void _Orphan_all() noexcept;	// orphan all iterators
; 100  : 	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators
; 101  : 
; 102  : 	_Container_proxy *_Myproxy;
; 103  : 	};
; 104  : 
; 105  : struct _Iterator_base12
; 106  : 	{	// store links to container proxy, next iterator
; 107  : 	_Iterator_base12() noexcept
; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 109  : 		{	// construct orphaned iterator
; 110  : 		}
; 111  : 
; 112  : 	_Iterator_base12(const _Iterator_base12& _Right) noexcept
; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;
; 116  : 		}
; 117  : 
; 118  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
; 119  : 		{	// assign an iterator
; 120  : 		if (_Myproxy != _Right._Myproxy)
; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);
; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);
; 136  : 		}
; 137  : 
; 138  : 	~_Iterator_base12() noexcept
; 139  : 		{	// destroy the iterator
; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);
; 142  : 		_Orphan_me();
; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}
; 145  : 
; 146  : 	void _Adopt(const _Container_base12 *_Parent) noexcept
; 147  : 		{	// adopt this iterator by parent
; 148  : 		if (_Parent == nullptr)
; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}
; 174  : 
; 175  : 	void _Clrcont() noexcept
; 176  : 		{	// disown owning container
; 177  : 		_Myproxy = nullptr;
; 178  : 		}
; 179  : 
; 180  : 	const _Container_base12 *_Getcont() const noexcept
; 181  : 		{	// get owning container
; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
; 183  : 		}
; 184  : 
; 185  : 	_Iterator_base12 **_Getpnext() noexcept
; 186  : 		{	// get address of remaining iterator chain
; 187  : 		return (&_Mynextiter);
; 188  : 		}
; 189  : 
; 190  : 	void _Orphan_me() noexcept
; 191  : 		{	// cut ties with parent
; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)
; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)
; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
; 200  : 			*_Pnext = _Mynextiter;
; 201  : 			_Myproxy = nullptr;
; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}
; 205  : 
; 206  : 	static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 207  : 
; 208  : 	_Container_proxy *_Myproxy;
; 209  : 	_Iterator_base12 *_Mynextiter;
; 210  : 	};
; 211  : 
; 212  : 		// MEMBER FUNCTIONS FOR _Container_base12
; 213  : inline void _Container_base12::_Orphan_all() noexcept
; 214  : 	{	// orphan all iterators
; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = nullptr;
; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}
; 227  : 
; 228  : inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
; 229  : 	{	// swap all iterators
; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);
; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;
; 236  : 	_Right._Myproxy = _Temp;
; 237  : 
; 238  : 	if (_Myproxy != nullptr)
; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;
; 240  : 	if (_Right._Myproxy != nullptr)
; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
; 242  : 	}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 245  : using _Container_base = _Container_base0;
; 246  : using _Iterator_base = _Iterator_base0;
; 247  : 
; 248  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 249  : using _Container_base = _Container_base12;
; 250  : using _Iterator_base = _Iterator_base12;
; 251  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 252  : 
; 253  : 	// CLASS TEMPLATE _Compressed_pair
; 254  : struct _Zero_then_variadic_args_t
; 255  : 	{	// tag type for value-initializing first,
; 256  : 	};	// constructing second from remaining args
; 257  : 
; 258  : struct _One_then_variadic_args_t
; 259  : 	{	// tag type for constructing first from one arg,
; 260  : 	};	// constructing second from remaining args
; 261  : 
; 262  : template<class _Ty1,
; 263  : 	class _Ty2,
; 264  : 	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
; 265  : 	class _Compressed_pair final
; 266  : 		: private _Ty1
; 267  : 	{	// store a pair of values, deriving from empty first
; 268  : private:
; 269  : 	_Ty2 _Myval2;
; 270  : 
; 271  : 	using _Mybase = _Ty1;	// for visualization
; 272  : 
; 273  : public:
; 274  : 	template<class... _Other2>
; 275  : 		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
; 276  : 			_Other2&&... _Val2)
; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)
; 278  : 		{	// construct from forwarded values
; 279  : 		}
; 280  : 
; 281  : 	template<class _Other1,
; 282  : 		class... _Other2>
; 283  : 		_Compressed_pair(_One_then_variadic_args_t,
; 284  : 			_Other1&& _Val1, _Other2&&... _Val2)
; 285  : 		: _Ty1(_STD forward<_Other1>(_Val1)),
; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 80   : 		: _Myproxy(nullptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 390  : 		_Mylast(),

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 391  : 		_Myend()

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z
_TEXT	SEGMENT
__UIt$ = -36						; size = 4
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -14						; size = 1
$T6 = -13						; size = 1
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T7 = -3						; size = 1
$T8 = -2						; size = 1
$T9 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z PROC ; std::search<char *,char const *,std::equal_to<void> >, COMDAT

; 963  : 	{	// find first [_First2, _Last2) satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T9[ebp], al
  0000b	8a 4d ff	 mov	 cl, BYTE PTR $T9[ebp]
  0000e	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl

; 603  : 	_Verify_range(_First, _Last);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Last1$[ebp]
  00014	52		 push	 edx
  00015	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  0001e	83 c4 08	 add	 esp, 8

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

  00021	33 c9		 xor	 ecx, ecx
  00023	88 4d fe	 mov	 BYTE PTR $T8[ebp], cl
  00026	8a 55 fe	 mov	 dl, BYTE PTR $T8[ebp]
  00029	88 55 f4	 mov	 BYTE PTR ___formal$[ebp], dl

; 603  : 	_Verify_range(_First, _Last);

  0002c	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 10	 mov	 ecx, DWORD PTR __First2$[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  00039	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 966  : 	_Seek_wrapped(_First1,

  0003c	8a 55 18	 mov	 dl, BYTE PTR __Pred$[ebp]
  0003f	88 55 fd	 mov	 BYTE PTR $T7[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 663  : 	return (_Ptr);

  00042	8b 45 14	 mov	 eax, DWORD PTR __Last2$[ebp]
  00045	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  00048	8b 4d 10	 mov	 ecx, DWORD PTR __First2$[ebp]
  0004b	89 4d e8	 mov	 DWORD PTR $T3[ebp], ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR __Last1$[ebp]
  00051	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  00054	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00057	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 966  : 	_Seek_wrapped(_First1,

  0005a	0f b6 4d f3	 movzx	 ecx, BYTE PTR $T6[ebp]
  0005e	51		 push	 ecx
  0005f	0f b6 55 f2	 movzx	 edx, BYTE PTR $T5[ebp]
  00063	52		 push	 edx
  00064	0f b6 45 fd	 movzx	 eax, BYTE PTR $T7[ebp]
  00068	50		 push	 eax
  00069	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  0006c	51		 push	 ecx
  0006d	8b 55 e8	 mov	 edx, DWORD PTR $T3[ebp]
  00070	52		 push	 edx
  00071	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00074	50		 push	 eax
  00075	8b 4d e0	 mov	 ecx, DWORD PTR $T1[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ??$_Search_unchecked@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@Urandom_access_iterator_tag@0@4@Z ; std::_Search_unchecked<char *,char const *,std::equal_to<void> >
  0007e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00081	89 45 dc	 mov	 DWORD PTR __UIt$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 872  : 	_It = _UIt;

  00084	8b 55 dc	 mov	 edx, DWORD PTR __UIt$[ebp]
  00087	89 55 08	 mov	 DWORD PTR __First1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 970  : 	return (_First1);

  0008a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 971  : 	}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z ENDP ; std::search<char *,char const *,std::equal_to<void> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 4
tv81 = -32						; size = 4
tv80 = -28						; size = 4
_this$ = -24						; size = 4
$T4 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Px$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z PROC ; std::shared_ptr<char>::_Setp<char>, COMDAT
; _this$ = ecx

; 1523 : 		{	// take ownership of _Px

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 18	 sub	 esp, 24			; 00000018H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1524 : 		_TRY_BEGIN	// allocate control block and set

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1525 : 		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));

  00036	6a 10		 push	 16			; 00000010H
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 e0	 mov	 DWORD PTR tv81[ebp], eax
  00043	8b 45 e0	 mov	 eax, DWORD PTR tv81[ebp]
  00046	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  00049	83 7d ec 00	 cmp	 DWORD PTR $T4[ebp], 0
  0004d	74 2e		 je	 SHORT $LN4@Setp

; 795  : 		: _Uses(1), _Weaks(1)	// non-atomic initializations

  0004f	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  00052	c7 41 04 01 00
	00 00		 mov	 DWORD PTR [ecx+4], 1
  00059	8b 55 ec	 mov	 edx, DWORD PTR $T4[ebp]
  0005c	c7 42 08 01 00
	00 00		 mov	 DWORD PTR [edx+8], 1

; 879  : 		{	// construct

  00063	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00066	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$_Ref_count@D@std@@6B@

; 796  : 		{	// construct
; 797  : 		}
; 798  : 
; 799  : public:
; 800  : 	virtual ~_Ref_count_base() noexcept
; 801  : 		{	// TRANSITION, should be non-virtual
; 802  : 		}
; 803  : 
; 804  : 	bool _Incref_nz()
; 805  : 		{	// increment use count if not zero, return true if successful
; 806  : 		for (;;)
; 807  : 			{	// loop until state is known
; 808  :  #if _USE_INTERLOCKED_REFCOUNTING
; 809  : 			const _Atomic_integral_t _Count =
; 810  : 				static_cast<volatile _Atomic_counter_t&>(_Uses);
; 811  : 
; 812  : 			if (_Count == 0)
; 813  : 				return (false);
; 814  : 
; 815  : 			if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
; 816  : 					reinterpret_cast<volatile long *>(&_Uses),
; 817  : 					static_cast<long>(_Count + 1), static_cast<long>(_Count))) == _Count)
; 818  : 				return (true);
; 819  : 
; 820  :  #else /* _USE_INTERLOCKED_REFCOUNTING */
; 821  : 			const _Atomic_integral_t _Count =
; 822  : 				_Load_atomic_counter(_Uses);
; 823  : 
; 824  : 			if (_Count == 0)
; 825  : 				return (false);
; 826  : 
; 827  : 			if (_Compare_increment_atomic_counter(_Uses, _Count))
; 828  : 				return (true);
; 829  :  #endif /* _USE_INTERLOCKED_REFCOUNTING */
; 830  : 			}
; 831  : 		}
; 832  : 
; 833  : 	void _Incref()
; 834  : 		{	// increment use count
; 835  : 		_MT_INCR(_Uses);
; 836  : 		}
; 837  : 
; 838  : 	void _Incwref()
; 839  : 		{	// increment weak reference count
; 840  : 		_MT_INCR(_Weaks);
; 841  : 		}
; 842  : 
; 843  : 	void _Decref()
; 844  : 		{	// decrement use count
; 845  : 		if (_MT_DECR(_Uses) == 0)
; 846  : 			{	// destroy managed resource, decrement weak reference count
; 847  : 			_Destroy();
; 848  : 			_Decwref();
; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 	void _Decwref()
; 853  : 		{	// decrement weak reference count
; 854  : 		if (_MT_DECR(_Weaks) == 0)
; 855  : 			{
; 856  : 			_Delete_this();
; 857  : 			}
; 858  : 		}
; 859  : 
; 860  : 	long _Use_count() const noexcept
; 861  : 		{	// return use count
; 862  : 		return (static_cast<long>(_Get_atomic_count(_Uses)));
; 863  : 		}
; 864  : 
; 865  : 	virtual void * _Get_deleter(const type_info&) const noexcept
; 866  : 		{	// return address of deleter object
; 867  : 		return (nullptr);
; 868  : 		}
; 869  : 	};
; 870  : 
; 871  : 	// CLASS TEMPLATE _Ref_count
; 872  : template<class _Ty>
; 873  : 	class _Ref_count
; 874  : 		: public _Ref_count_base
; 875  : 	{	// handle reference counting for pointer without deleter
; 876  : public:
; 877  : 	explicit _Ref_count(_Ty * _Px)
; 878  : 		: _Ref_count_base(), _Ptr(_Px)

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  0006f	8b 55 08	 mov	 edx, DWORD PTR __Px$[ebp]
  00072	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1525 : 		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));

  00075	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00078	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  0007b	eb 07		 jmp	 SHORT $LN5@Setp
$LN4@Setp:
  0007d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN5@Setp:
  00084	8b 4d e4	 mov	 ecx, DWORD PTR tv80[ebp]
  00087	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx

; 1132 : 		_Ptr = _Other_ptr;

  0008a	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  00090	89 02		 mov	 DWORD PTR [edx], eax

; 1133 : 		_Rep = _Other_rep;

  00092	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8b 55 dc	 mov	 edx, DWORD PTR $T3[ebp]
  00098	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1583 : 		_Enable_shared_from_this(*this, _Px);

  0009b	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  0009e	50		 push	 eax
  0009f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ??$_Enable_shared_from_this@DD@std@@YAXABV?$shared_ptr@D@0@PAD@Z ; std::_Enable_shared_from_this<char,char>
  000a8	83 c4 08	 add	 esp, 8

; 1525 : 		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));

  000ab	eb 23		 jmp	 SHORT $LN6@Setp
__catch$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z$0:

; 1526 : 		_CATCH_ALL	// allocation failed, delete resource
; 1527 : 		delete _Px;

  000ad	8b 55 08	 mov	 edx, DWORD PTR __Px$[ebp]
  000b0	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  000b3	6a 01		 push	 1
  000b5	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000be	83 c4 08	 add	 esp, 8

; 1528 : 		_RERAISE;

  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1529 : 		_CATCH_END

  000ca	b8 00 00 00 00	 mov	 eax, $LN10@Setp
  000cf	c3		 ret	 0
$LN6@Setp:
  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000d7	eb 07		 jmp	 SHORT $LN3@Setp
$LN10@Setp:
  000d9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Setp:

; 1530 : 		}

  000e0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ea	59		 pop	 ecx
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z ENDP ; std::shared_ptr<char>::_Setp<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAPAVhead@NullPmd@@@std@@YA$$QAPAVhead@NullPmd@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVhead@NullPmd@@@std@@YA$$QAPAVhead@NullPmd@@AAPAV12@@Z PROC ; std::move<NullPmd::head * &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVhead@NullPmd@@@std@@YA$$QAPAVhead@NullPmd@@AAPAV12@@Z ENDP ; std::move<NullPmd::head * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vmessage@NullPmd@@@Arena@protobuf@google@@AAEXPAVmessage@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vmessage@NullPmd@@@Arena@protobuf@google@@AAEXPAVmessage@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::message>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vmessage@NullPmd@@@Arena@protobuf@google@@AAEXPAVmessage@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::message>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAPAVinfo@NullPmd@@@std@@YA$$QAPAVinfo@NullPmd@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVinfo@NullPmd@@@std@@YA$$QAPAVinfo@NullPmd@@AAPAV12@@Z PROC ; std::move<NullPmd::info * &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVinfo@NullPmd@@@std@@YA$$QAPAVinfo@NullPmd@@AAPAV12@@Z ENDP ; std::move<NullPmd::info * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAPAVcommand@NullPmd@@@std@@YA$$QAPAVcommand@NullPmd@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVcommand@NullPmd@@@std@@YA$$QAPAVcommand@NullPmd@@AAPAV12@@Z PROC ; std::move<NullPmd::command * &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAVcommand@NullPmd@@@std@@YA$$QAPAVcommand@NullPmd@@AAPAV12@@Z ENDP ; std::move<NullPmd::command * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vhead@NullPmd@@@Arena@protobuf@google@@AAEXPAVhead@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vhead@NullPmd@@@Arena@protobuf@google@@AAEXPAVhead@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::head>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vhead@NullPmd@@@Arena@protobuf@google@@AAEXPAVhead@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::head>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vinfo@NullPmd@@@Arena@protobuf@google@@AAEXPAVinfo@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vinfo@NullPmd@@@Arena@protobuf@google@@AAEXPAVinfo@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::info>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vinfo@NullPmd@@@Arena@protobuf@google@@AAEXPAVinfo@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AA_K@std@@YA$$QA_KAA_K@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_K@std@@YA$$QA_KAA_K@Z PROC			; std::move<unsigned __int64 &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_K@std@@YA$$QA_KAA_K@Z ENDP			; std::move<unsigned __int64 &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vcommand@NullPmd@@@Arena@protobuf@google@@AAEXPAVcommand@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vcommand@NullPmd@@@Arena@protobuf@google@@AAEXPAVcommand@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::command>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vcommand@NullPmd@@@Arena@protobuf@google@@AAEXPAVcommand@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::command>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vindication@NullPmd@@@Arena@protobuf@google@@AAEXPAVindication@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vindication@NullPmd@@@Arena@protobuf@google@@AAEXPAVindication@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::indication>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vindication@NullPmd@@@Arena@protobuf@google@@AAEXPAVindication@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::indication>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vresponse@NullPmd@@@Arena@protobuf@google@@AAEXPAVresponse@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vresponse@NullPmd@@@Arena@protobuf@google@@AAEXPAVresponse@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::response>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vresponse@NullPmd@@@Arena@protobuf@google@@AAEXPAVresponse@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::response>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@Vrequest@NullPmd@@@Arena@protobuf@google@@AAEXPAVrequest@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@Vrequest@NullPmd@@@Arena@protobuf@google@@AAEXPAVrequest@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<NullPmd::request>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@Vrequest@NullPmd@@@Arena@protobuf@google@@AAEXPAVrequest@NullPmd@@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<NullPmd::request>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$OwnInternal@VMessage@protobuf@google@@@Arena@protobuf@google@@AAEXPAVMessage@12@U?$integral_constant@_N$00@internal@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
___formal$ = 12						; size = 1
??$OwnInternal@VMessage@protobuf@google@@@Arena@protobuf@google@@AAEXPAVMessage@12@U?$integral_constant@_N$00@internal@12@@Z PROC ; google::protobuf::Arena::OwnInternal<google::protobuf::Message>, COMDAT
; _this$ = ecx

; 831  :   void OwnInternal(T* object, google::protobuf::internal::true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@OwnInterna

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@OwnInterna:

; 834  :     }
; 835  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$OwnInternal@VMessage@protobuf@google@@@Arena@protobuf@google@@AAEXPAVMessage@12@U?$integral_constant@_N$00@internal@12@@Z ENDP ; google::protobuf::Arena::OwnInternal<google::protobuf::Message>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$make_pair@ABI_N@std@@YA?AU?$pair@I_N@0@ABI$$QA_N@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@ABI_N@std@@YA?AU?$pair@I_N@0@ABI$$QA_N@Z PROC ; std::make_pair<unsigned int const &,bool>, COMDAT

; 403  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00006	8b 45 10	 mov	 eax, DWORD PTR __Val2$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR $T4[ebp], ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR $T4[ebp]
  00015	89 55 f8	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00022	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	8a 02		 mov	 al, BYTE PTR [edx]
  00030	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 404  : 	using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 405  : 	return (_Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2)));

  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 406  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$make_pair@ABI_N@std@@YA?AU?$pair@I_N@0@ABI$$QA_N@Z ENDP ; std::make_pair<unsigned int const &,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$make_pair@AAIAA_N@std@@YA?AU?$pair@I_N@0@AAIAA_N@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAIAA_N@std@@YA?AU?$pair@I_N@0@AAIAA_N@Z PROC ; std::make_pair<unsigned int &,bool &>, COMDAT

; 403  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00006	8b 45 10	 mov	 eax, DWORD PTR __Val2$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR $T4[ebp], ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR $T4[ebp]
  00015	89 55 f8	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00022	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	8a 02		 mov	 al, BYTE PTR [edx]
  00030	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 404  : 	using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 405  : 	return (_Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2)));

  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 406  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$make_pair@AAIAA_N@std@@YA?AU?$pair@I_N@0@AAIAA_N@Z ENDP ; std::make_pair<unsigned int &,bool &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$make_pair@AAI_N@std@@YA?AU?$pair@I_N@0@AAI$$QA_N@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAI_N@std@@YA?AU?$pair@I_N@0@AAI$$QA_N@Z PROC ; std::make_pair<unsigned int &,bool>, COMDAT

; 403  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00006	8b 45 10	 mov	 eax, DWORD PTR __Val2$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Val1$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR $T4[ebp], ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR $T4[ebp]
  00015	89 55 f8	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00022	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00025	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	8a 02		 mov	 al, BYTE PTR [edx]
  00030	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 404  : 	using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
; 405  : 	return (_Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2)));

  00033	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 406  : 	}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
??$make_pair@AAI_N@std@@YA?AU?$pair@I_N@0@AAI$$QA_N@Z ENDP ; std::make_pair<unsigned int &,bool>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv66 = -28						; size = 4
tv86 = -24						; size = 4
__Ptrdest$ = -20					; size = 4
__Ptrnext$1 = -16					; size = 4
__Count$ = -12						; size = 4
tv83 = -8						; size = 4
tv89 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 664  : 	{	// convert C string to _Elem sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 665  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0000f	83 c1 01	 add	 ecx, 1
  00012	89 4d e8	 mov	 DWORD PTR tv86[ebp], ecx
$LL7@Maklocstr:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0001d	83 45 f8 01	 add	 DWORD PTR tv83[ebp], 1
  00021	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00025	75 ee		 jne	 SHORT $LL7@Maklocstr
  00027	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0002a	2b 4d e8	 sub	 ecx, DWORD PTR tv86[ebp]
  0002d	89 4d e4	 mov	 DWORD PTR tv66[ebp], ecx
  00030	8b 55 e4	 mov	 edx, DWORD PTR tv66[ebp]
  00033	83 c2 01	 add	 edx, 1
  00036	89 55 f4	 mov	 DWORD PTR __Count$[ebp], edx

; 666  : 
; 667  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

  00039	68 9c 02 00 00	 push	 668			; 0000029cH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00043	6a 02		 push	 2
  00045	6a 01		 push	 1
  00047	8b 45 f4	 mov	 eax, DWORD PTR __Count$[ebp]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	89 45 ec	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 668  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 669  : 
; 670  : 	if (!_Ptrdest)

  00057	83 7d ec 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  0005b	75 05		 jne	 SHORT $LN5@Maklocstr

; 671  : 		_Xbad_alloc();

  0005d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 672  : 
; 673  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

  00062	8b 4d ec	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00065	89 4d f0	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00068	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  0006a	8b 55 f4	 mov	 edx, DWORD PTR __Count$[ebp]
  0006d	83 ea 01	 sub	 edx, 1
  00070	89 55 f4	 mov	 DWORD PTR __Count$[ebp], edx
  00073	8b 45 f0	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 f0	 mov	 DWORD PTR __Ptrnext$1[ebp], eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
$LN4@Maklocstr:
  00085	83 7d f4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00089	76 0c		 jbe	 SHORT $LN3@Maklocstr

; 674  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

  0008b	8b 55 f0	 mov	 edx, DWORD PTR __Ptrnext$1[ebp]
  0008e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00091	8a 08		 mov	 cl, BYTE PTR [eax]
  00093	88 0a		 mov	 BYTE PTR [edx], cl
  00095	eb d3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 675  : 
; 676  : 	return (_Ptrdest);

  00097	8b 45 ec	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 677  : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range1@PADPAD@std@@YAXABQAD0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@PADPAD@std@@YAXABQAD0U?$integral_constant@_N$00@0@@Z PROC ; std::_Adl_verify_range1<char *,char *>, COMDAT

; 602  : 	{	// check that [_First, _Last) forms an iterator range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 	_Verify_range(_First, _Last);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  00014	83 c4 08	 add	 esp, 8

; 604  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Adl_verify_range1@PADPAD@std@@YAXABQAD0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Adl_verify_range1<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z PROC ; std::_Adl_verify_range1<char const *,char const *>, COMDAT

; 602  : 	{	// check that [_First, _Last) forms an iterator range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 	_Verify_range(_First, _Last);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000c	8b 02		 mov	 eax, DWORD PTR [edx]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  00014	83 c4 08	 add	 esp, 8

; 604  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Adl_verify_range1@PBDPBD@std@@YAXABQBD0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Adl_verify_range1<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Verify_range@D@std@@YAXQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Verify_range@D@std@@YAXQBD0@Z PROC			; std::_Verify_range<char>, COMDAT

; 558  : 	{	// special case range verification for pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN4@Verify_ran:

; 559  : 	_STL_VERIFY(_First <= _Last, "transposed pointer range");

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00009	77 02		 ja	 SHORT $LN7@Verify_ran
  0000b	eb 4a		 jmp	 SHORT $LN2@Verify_ran
$LN7@Verify_ran:
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@HAJGEHKO@transposed?5pointer?5range@
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00017	6a 00		 push	 0
  00019	68 2f 02 00 00	 push	 559			; 0000022fH
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00023	6a 02		 push	 2
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0002b	83 c4 18	 add	 esp, 24			; 00000018H
  0002e	83 f8 01	 cmp	 eax, 1
  00031	75 01		 jne	 SHORT $LN11@Verify_ran
  00033	cc		 int	 3
$LN11@Verify_ran:
  00034	6a 00		 push	 0
  00036	68 2f 02 00 00	 push	 559			; 0000022fH
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@LJCPDKEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAr?$AAi?$AAf?$AAy?$AA_?$AAr?$AAa@
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@FJIKMGFD@?$AA?$CC?$AAt?$AAr?$AAa?$AAn?$AAs?$AAp?$AAo?$AAs?$AAe?$AAd?$AA?5?$AAp?$AAo?$AAi@
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00050	83 c4 14	 add	 esp, 20			; 00000014H
  00053	33 d2		 xor	 edx, edx
  00055	75 b6		 jne	 SHORT $LN7@Verify_ran
$LN2@Verify_ran:
  00057	33 c0		 xor	 eax, eax
  00059	75 a8		 jne	 SHORT $LN4@Verify_ran

; 560  : 	}

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??$_Verify_range@D@std@@YAXQBD0@Z ENDP			; std::_Verify_range<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$0EI@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$ = -8					; size = 4
__Result$ = -4						; size = 4
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0EI@@std@@YAII@Z PROC		; std::_Get_size_of_n<72>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00006	c7 45 f8 e3 38
	8e 03		 mov	 DWORD PTR __Max_possible$[ebp], 59652323 ; 038e38e3H

; 25   : 	size_t _Result = _Count * _Ty_size;

  0000d	6b 45 08 48	 imul	 eax, DWORD PTR __Count$[ebp], 72
  00011	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 26   : 	if (_Max_possible < _Count)

  00014	81 7d 08 e3 38
	8e 03		 cmp	 DWORD PTR __Count$[ebp], 59652323 ; 038e38e3H
  0001b	76 07		 jbe	 SHORT $LN2@Get_size_o

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  0001d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Result$[ebp], -1
$LN2@Get_size_o:

; 30   : 		}
; 31   : 
; 32   : 	return (_Result);

  00024	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 33   : 	}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Get_size_of_n@$0EI@@std@@YAII@Z ENDP		; std::_Get_size_of_n<72>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@AAPAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00012	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@AAPAU12@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@AAPAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@YAPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@DX@std@@YAXAAD0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YAXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 55 ff	 mov	 BYTE PTR __Tmp$[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f4	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8a 02		 mov	 al, BYTE PTR [edx]
  00022	88 01		 mov	 BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d ff	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	88 0a		 mov	 BYTE PTR [edx], cl

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@DX@std@@YAXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$ = -8					; size = 4
__Result$ = -4						; size = 4
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00006	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$[ebp], 536870911 ; 1fffffffH

; 25   : 	size_t _Result = _Count * _Ty_size;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00010	c1 e0 03	 shl	 eax, 3
  00013	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 26   : 	if (_Max_possible < _Count)

  00016	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  0001d	76 07		 jbe	 SHORT $LN2@Get_size_o

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  0001f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Result$[ebp], -1
$LN2@Get_size_o:

; 30   : 		}
; 31   : 
; 32   : 	return (_Result);

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 33   : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 886  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  0000b	33 c0		 xor	 eax, eax
  0000d	83 e0 01	 and	 eax, 1
  00010	74 0e		 je	 SHORT $LN1@destroy
  00012	6a 38		 push	 56			; 00000038H
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001d	83 c4 08	 add	 esp, 8
$LN1@destroy:

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00012	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001a	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  0001d	89 02		 mov	 DWORD PTR [edx], eax
  0001f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 1154 : 	{	// destroy [_First, _Last), choose optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

  00004	33 c0		 xor	 eax, eax
  00006	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 70   : 		{	// extract key from element value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 72   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@SAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0ABUstring_cmp_nocase@base@zl@@U_Zero_then_variadic_args_t@std@@@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABUstring_cmp_nocase@base@zl@@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
___formal$ = -4						; size = 1
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABUstring_cmp_nocase@base@zl@@U_Zero_then_variadic_args_t@std@@@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABUstring_cmp_nocase@base@zl@@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1><zl::base::string_cmp_nocase const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx

; 287  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00009	8b 45 10	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	8a 11		 mov	 dl, BYTE PTR [ecx]
  00014	88 55 fc	 mov	 BYTE PTR ___formal$[ebp], dl
  00017	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  0001d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 		: _Myproxy(nullptr)

  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 468  : 		: _Myhead(),

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 469  : 		_Mysize(0)

  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABUstring_cmp_nocase@base@zl@@U_Zero_then_variadic_args_t@std@@@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAE@U_One_then_variadic_args_t@1@ABUstring_cmp_nocase@base@zl@@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1><zl::base::string_cmp_nocase const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Bytes$ = -4						; size = 4
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>, COMDAT

; 1212 : 	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	c1 e0 03	 shl	 eax, 3
  0000e	89 45 fc	 mov	 DWORD PTR __Bytes$[ebp], eax
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00014	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00017	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0001e	72 10		 jb	 SHORT $LN6@Deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00020	8d 55 fc	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00023	52		 push	 edx
  00024	8d 45 f8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0002d	83 c4 08	 add	 esp, 8
$LN6@Deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8

; 1213 : 	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 1214 : 	}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 886  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Bytes$ = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 871  : 		{	// deallocate _Count elements at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 872  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	c1 e0 03	 shl	 eax, 3
  0000c	89 45 fc	 mov	 DWORD PTR __Bytes$[ebp], eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00015	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0001c	72 10		 jb	 SHORT $LN4@deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0001e	8d 55 fc	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00021	52		 push	 edx
  00022	8d 45 f8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0002b	83 c4 08	 add	 esp, 8
$LN4@deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8

; 874  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >, COMDAT
; _this$ = ecx

; 986  : 		{	// construct from a related allocator (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 987  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
??$?0U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Max_possible$1 = -16					; size = 4
_this$ = -12						; size = 4
$T2 = -8						; size = 4
__Result$3 = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00009	c7 45 f0 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 25   : 	size_t _Result = _Count * _Ty_size;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00013	c1 e0 03	 shl	 eax, 3
  00016	89 45 fc	 mov	 DWORD PTR __Result$3[ebp], eax

; 26   : 	if (_Max_possible < _Count)

  00019	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00020	76 07		 jbe	 SHORT $LN3@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00022	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Result$3[ebp], -1
$LN3@allocate:

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00029	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Result$3[ebp], 4096 ; 00001000H
  00030	72 11		 jb	 SHORT $LN7@allocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00032	8b 4d fc	 mov	 ecx, DWORD PTR __Result$3[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00041	eb 1e		 jmp	 SHORT $LN6@allocate
$LN7@allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00043	83 7d fc 00	 cmp	 DWORD PTR __Result$3[ebp], 0
  00047	74 11		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  00049	8b 55 fc	 mov	 edx, DWORD PTR __Result$3[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00052	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00055	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00058	eb 07		 jmp	 SHORT $LN6@allocate
$LN8@allocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
$LN6@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00061	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]

; 998  : 		}

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Ptr$ = -20						; size = 4
__Bytes$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >, COMDAT

; 407  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 408  : 			using _Alnode = _Rebind_alloc_t<_Alloc, _Tree_node>;
; 409  : 			using _Alnode_traits = allocator_traits<_Alnode>;
; 410  : 			_Alnode _Node_alloc(_Al);
; 411  : 			_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00028	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 412  : 			_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Parent));

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00031	89 4d e4	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 413  : 			_Alnode_traits::destroy(_Node_alloc, _STD addressof(_Ptr->_Right));

  00034	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00037	83 c2 08	 add	 edx, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0003a	89 55 e0	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	6b c8 48	 imul	 ecx, eax, 72
  00045	89 4d f0	 mov	 DWORD PTR __Bytes$[ebp], ecx
  00048	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0004b	89 55 ec	 mov	 DWORD PTR __Ptr$[ebp], edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0004e	81 7d f0 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00055	72 10		 jb	 SHORT $LN21@Freenode0

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00057	8d 45 f0	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d ec	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00064	83 c4 08	 add	 esp, 8
$LN21@Freenode0:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  00067	8b 55 f0	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00074	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 415  : 			}

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 199  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 10		 jb	 SHORT $LN2@Deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0000c	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00019	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8

; 208  : 	}

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 180  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0e		 jb	 SHORT $LN2@Allocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00015	83 c4 04	 add	 esp, 4
  00018	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  0001a	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001e	74 0e		 je	 SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00029	83 c4 04	 add	 esp, 4

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));

  0002c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  0002e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 194  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 1943 : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00028	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00034	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	89 55 f0	 mov	 DWORD PTR _this$[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0004d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00050	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1944 : 		_Alloc_proxy();

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 1945 : 		}

  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00012	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@Max_value
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@Max_value
$LN3@Max_value:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@Max_value:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 34   : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 886  : 		{	// destroy object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 278  : 		{	// construct from forwarded values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   : 		{	// construct childless container
; 82   : 		}
; 83   : 
; 84   : 	_Container_base12(const _Container_base12&) noexcept
; 85   : 		: _Myproxy(nullptr)
; 86   : 		{	// copy a container
; 87   : 		}
; 88   : 
; 89   : 	_Container_base12& operator=(const _Container_base12&) noexcept
; 90   : 		{	// assign a container
; 91   : 		return (*this);
; 92   : 		}
; 93   : 
; 94   : 	_Iterator_base12 **_Getpfirst() const noexcept
; 95   : 		{	// get address of iterator chain
; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);
; 97   : 		}
; 98   : 
; 99   : 	void _Orphan_all() noexcept;	// orphan all iterators
; 100  : 	void _Swap_all(_Container_base12&) noexcept;	// swap all iterators
; 101  : 
; 102  : 	_Container_proxy *_Myproxy;
; 103  : 	};
; 104  : 
; 105  : struct _Iterator_base12
; 106  : 	{	// store links to container proxy, next iterator
; 107  : 	_Iterator_base12() noexcept
; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 109  : 		{	// construct orphaned iterator
; 110  : 		}
; 111  : 
; 112  : 	_Iterator_base12(const _Iterator_base12& _Right) noexcept
; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)
; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;
; 116  : 		}
; 117  : 
; 118  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
; 119  : 		{	// assign an iterator
; 120  : 		if (_Myproxy != _Right._Myproxy)
; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)
; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);
; 126  : 				_Orphan_me();
; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}
; 129  : 			else
; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);
; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);
; 136  : 		}
; 137  : 
; 138  : 	~_Iterator_base12() noexcept
; 139  : 		{	// destroy the iterator
; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);
; 142  : 		_Orphan_me();
; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}
; 145  : 
; 146  : 	void _Adopt(const _Container_base12 *_Parent) noexcept
; 147  : 		{	// adopt this iterator by parent
; 148  : 		if (_Parent == nullptr)
; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);
; 152  : 			_Orphan_me();
; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}
; 155  : 		else
; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)
; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);
; 163  : 				_Orphan_me();
; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 165  : 				_Parent_proxy->_Myfirstiter = this;
; 166  : 				_Myproxy = _Parent_proxy;
; 167  : 				}
; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}
; 174  : 
; 175  : 	void _Clrcont() noexcept
; 176  : 		{	// disown owning container
; 177  : 		_Myproxy = nullptr;
; 178  : 		}
; 179  : 
; 180  : 	const _Container_base12 *_Getcont() const noexcept
; 181  : 		{	// get owning container
; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);
; 183  : 		}
; 184  : 
; 185  : 	_Iterator_base12 **_Getpnext() noexcept
; 186  : 		{	// get address of remaining iterator chain
; 187  : 		return (&_Mynextiter);
; 188  : 		}
; 189  : 
; 190  : 	void _Orphan_me() noexcept
; 191  : 		{	// cut ties with parent
; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)
; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)
; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
; 200  : 			*_Pnext = _Mynextiter;
; 201  : 			_Myproxy = nullptr;
; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}
; 205  : 
; 206  : 	static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 207  : 
; 208  : 	_Container_proxy *_Myproxy;
; 209  : 	_Iterator_base12 *_Mynextiter;
; 210  : 	};
; 211  : 
; 212  : 		// MEMBER FUNCTIONS FOR _Container_base12
; 213  : inline void _Container_base12::_Orphan_all() noexcept
; 214  : 	{	// orphan all iterators
; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)
; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);
; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)
; 222  : 			(*_Pnext)->_Myproxy = nullptr;
; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}
; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}
; 227  : 
; 228  : inline void _Container_base12::_Swap_all(_Container_base12& _Right) noexcept
; 229  : 	{	// swap all iterators
; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);
; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;
; 236  : 	_Right._Myproxy = _Temp;
; 237  : 
; 238  : 	if (_Myproxy != nullptr)
; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;
; 240  : 	if (_Right._Myproxy != nullptr)
; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
; 242  : 	}
; 243  : 
; 244  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 245  : using _Container_base = _Container_base0;
; 246  : using _Iterator_base = _Iterator_base0;
; 247  : 
; 248  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 249  : using _Container_base = _Container_base12;
; 250  : using _Iterator_base = _Iterator_base12;
; 251  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 252  : 
; 253  : 	// CLASS TEMPLATE _Compressed_pair
; 254  : struct _Zero_then_variadic_args_t
; 255  : 	{	// tag type for value-initializing first,
; 256  : 	};	// constructing second from remaining args
; 257  : 
; 258  : struct _One_then_variadic_args_t
; 259  : 	{	// tag type for constructing first from one arg,
; 260  : 	};	// constructing second from remaining args
; 261  : 
; 262  : template<class _Ty1,
; 263  : 	class _Ty2,
; 264  : 	bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
; 265  : 	class _Compressed_pair final
; 266  : 		: private _Ty1
; 267  : 	{	// store a pair of values, deriving from empty first
; 268  : private:
; 269  : 	_Ty2 _Myval2;
; 270  : 
; 271  : 	using _Mybase = _Ty1;	// for visualization
; 272  : 
; 273  : public:
; 274  : 	template<class... _Other2>
; 275  : 		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
; 276  : 			_Other2&&... _Val2)
; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 80   : 		: _Myproxy(nullptr)

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 1785 : 		_Myres(0)

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1080 : 	{	// (maybe) propagate on container copy assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1081 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1082 : 	_Pocca(_Left, _Right, _Tag);
; 1083 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1099 : 	{	// (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1100 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1101 : 	_Pocma(_Left, _Right, _Tag);
; 1102 : 	}

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@@Z
_TEXT	SEGMENT
__Last_ch$1 = -20					; size = 4
__Last$ = -16						; size = 4
__First_ch$2 = -12					; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@@Z PROC ; std::_Uninitialized_value_construct_n<char *,unsigned int,std::allocator<char> >, COMDAT

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
  0000b	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  0000e	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00011	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00014	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  00017	89 55 f0	 mov	 DWORD PTR __Last$[ebp], edx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  0001a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR __First_ch$2[ebp], eax

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  00020	8b 4d f0	 mov	 ecx, DWORD PTR __Last$[ebp]
  00023	89 4d ec	 mov	 DWORD PTR __Last_ch$1[ebp], ecx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00026	8b 55 ec	 mov	 edx, DWORD PTR __Last_ch$1[ebp]
  00029	2b 55 f4	 sub	 edx, DWORD PTR __First_ch$2[ebp]
  0002c	52		 push	 edx
  0002d	6a 00		 push	 0
  0002f	8b 45 f4	 mov	 eax, DWORD PTR __First_ch$2[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _memset
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0003b	8b 45 f0	 mov	 eax, DWORD PTR __Last$[ebp]

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??$_Uninitialized_value_construct_n@PADIV?$allocator@D@std@@@std@@YAPADPADIAAV?$allocator@D@0@@Z ENDP ; std::_Uninitialized_value_construct_n<char *,unsigned int,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
__Wherenode$ = -8					; size = 4
__Pnode$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 2044 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
  00016	8b 4d f0	 mov	 ecx, DWORD PTR $T6[ebp]
  00019	89 4d ec	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  0001c	8b 55 ec	 mov	 edx, DWORD PTR $T5[ebp]
  0001f	89 55 e8	 mov	 DWORD PTR $T4[ebp], edx

; 2045 : 		_Nodeptr _Wherenode = this->_Get_data()._Myhead;	// end() if search fails

  00022	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00025	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00028	89 4d f8	 mov	 DWORD PTR __Wherenode$[ebp], ecx

; 2046 : 		_Nodeptr _Pnode = _Wherenode->_Parent;

  0002b	8b 55 f8	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0002e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00031	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN2@Lbound:

; 2047 : 
; 2048 : 		while (!_Pnode->_Isnil)

  00034	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00037	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  0003b	85 d2		 test	 edx, edx
  0003d	75 45		 jne	 SHORT $LN3@Lbound

; 1000 : 		return (_Mypair._Get_first());

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1000 : 		return (_Mypair._Get_first());

  00045	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00048	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx

; 2032 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

  0004b	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  0004e	52		 push	 edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map

; 71   : 		return (_Val.first);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00052	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2032 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

  00055	50		 push	 eax
  00056	8b 4d e0	 mov	 ecx, DWORD PTR $T2[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2049 : 			{
; 2050 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

  00062	0f b6 d0	 movzx	 edx, al
  00065	85 d2		 test	 edx, edx
  00067	74 0b		 je	 SHORT $LN4@Lbound

; 2051 : 				{
; 2052 : 				_Pnode = _Pnode->_Right;	// descend right subtree

  00069	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006f	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 2053 : 				}
; 2054 : 			else

  00072	eb 0e		 jmp	 SHORT $LN5@Lbound
$LN4@Lbound:

; 2055 : 				{	// _Pnode not less than _Keyval, remember it
; 2056 : 				_Wherenode = _Pnode;

  00074	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00077	89 55 f8	 mov	 DWORD PTR __Wherenode$[ebp], edx

; 2057 : 				_Pnode = _Pnode->_Left;	// descend left subtree

  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN5@Lbound:

; 2058 : 				}
; 2059 : 			}

  00082	eb b0		 jmp	 SHORT $LN2@Lbound
$LN3@Lbound:

; 2060 : 
; 2061 : 		return (_Wherenode);	// return best remembered candidate

  00084	8b 45 f8	 mov	 eax, DWORD PTR __Wherenode$[ebp]

; 2062 : 		}

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ??$PtrValue@VArena@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAVArena@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PtrValue@VArena@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAVArena@23@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrValue<google::protobuf::Arena>, COMDAT
; _this$ = ecx

; 148  :   template<typename U> U* PtrValue() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  :     return reinterpret_cast<U*>(

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	83 e0 fe	 and	 eax, -2			; fffffffeH

; 150  :         reinterpret_cast<intptr_t>(ptr_) & kPtrValueMask);
; 151  :   }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$PtrValue@VArena@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAVArena@23@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrValue<google::protobuf::Arena>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Create@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@SAPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@PAV012@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
$T2 = -4						; size = 4
_arena$ = 8						; size = 4
??$Create@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@SAPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@PAV012@@Z PROC ; google::protobuf::Arena::Create<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>, COMDAT

; 307  :   static T* Create(::google::protobuf::Arena* arena) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 308  :     if (arena == NULL) {

  00006	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0000a	75 48		 jne	 SHORT $LN2@Create

; 309  :       return new T();

  0000c	6a 08		 push	 8
  0000e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00013	83 c4 04	 add	 esp, 4
  00016	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00019	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  0001d	74 21		 je	 SHORT $LN5@Create
  0001f	33 c0		 xor	 eax, eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00024	89 01		 mov	 DWORD PTR [ecx], eax
  00026	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00029	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  0002c	89 55 f4	 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h

; 252  : inline UnknownFieldSet::UnknownFieldSet() : fields_(NULL) {}

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h

; 309  :       return new T();

  00038	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
  0003e	eb 07		 jmp	 SHORT $LN6@Create
$LN5@Create:
  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN6@Create:
  00047	8b 55 f8	 mov	 edx, DWORD PTR tv74[ebp]
  0004a	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  0004d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00050	eb 0c		 jmp	 SHORT $LN1@Create

; 310  :     } else {

  00052	eb 0a		 jmp	 SHORT $LN1@Create
$LN2@Create:

; 311  :       return arena->CreateInternal<T>(google::protobuf::internal::has_trivial_destructor<T>::value);

  00054	6a 00		 push	 0
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00059	e8 00 00 00 00	 call	 ??$CreateInternal@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@AAEPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@_N@Z ; google::protobuf::Arena::CreateInternal<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
$LN1@Create:

; 312  :     }
; 313  :   }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$Create@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@SAPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@PAV012@@Z ENDP ; google::protobuf::Arena::Create<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@ABU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@ABU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@YAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@0@ABU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1943 : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00028	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00034	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	89 55 f0	 mov	 DWORD PTR _this$[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0004d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00050	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1944 : 		_Alloc_proxy();

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 1945 : 		}

  00066	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator!=<char,char>, COMDAT

; 1054 : 	{	// test for allocator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1055 : 	return (false);

  00003	32 c0		 xor	 al, al

; 1056 : 	}

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
??$?9DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator!=<char,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
__Ptr$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__Ptr$ = -44						; size = 4
__Old_capacity$ = -40					; size = 4
__New_ptr$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_ptr$ = -28					; size = 4
__Bytes$ = -24						; size = 4
$T6 = -20						; size = 4
__Count$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T7 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 3887 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3888 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3889 : 		if (_New_size > max_size())

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 3890 : 			{
; 3891 : 			_Xlen();	// result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN2@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00021	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  00024	89 4d f8	 mov	 DWORD PTR __My_data$[ebp], ecx

; 3892 : 			}
; 3893 : 
; 3894 : 		auto& _My_data = this->_Get_data();
; 3895 : 		const size_type _Old_capacity = _My_data._Myres;

  00027	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0002d	89 45 d8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 3896 : 		const size_type _New_capacity = _Calculate_growth(_New_size);

  00030	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00033	51		 push	 ecx
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0003c	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2033 : 		return (_Mypair._Get_first());

  0003f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00042	89 55 cc	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00045	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0004b	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0004e	83 c1 01	 add	 ecx, 1
  00051	89 4d f0	 mov	 DWORD PTR __Count$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00054	81 7d f0 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  0005b	72 11		 jb	 SHORT $LN88@Reallocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  0005d	8b 55 f0	 mov	 edx, DWORD PTR __Count$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00066	83 c4 04	 add	 esp, 4
  00069	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
  0006c	eb 1e		 jmp	 SHORT $LN83@Reallocate
$LN88@Reallocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  0006e	83 7d f0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	74 11		 je	 SHORT $LN89@Reallocate

; 52   : 		return (::operator new(_Bytes));

  00074	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007d	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00080	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
  00083	eb 07		 jmp	 SHORT $LN83@Reallocate
$LN89@Reallocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00085	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3898 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0008c	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  0008f	89 4d e4	 mov	 DWORD PTR __New_ptr$[ebp], ecx

; 3899 : 		_My_data._Orphan_all();

  00092	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3900 : 		_My_data._Mysize = _New_size;

  0009a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009d	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  000a0	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3901 : 		_My_data._Myres = _New_capacity;

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000a6	8b 55 e0	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  000a9	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 3902 : 		_Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000ac	8b 45 e4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000af	89 45 dc	 mov	 DWORD PTR __New_ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000b5	51		 push	 ecx
  000b6	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000b9	52		 push	 edx
  000ba	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _memcpy
  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());

  000c6	c6 45 ff 00	 mov	 BYTE PTR $T7[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000cd	03 4d 08	 add	 ecx, DWORD PTR __New_size$[ebp]
  000d0	8a 55 ff	 mov	 dl, BYTE PTR $T7[ebp]
  000d3	88 11		 mov	 BYTE PTR [ecx], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3903 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000d5	83 7d d8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  000d9	72 4c		 jb	 SHORT $LN3@Reallocate

; 3904 : 			{
; 3905 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000db	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000de	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000e1	89 4d c8	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000e4	8b 55 d8	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000e7	83 c2 01	 add	 edx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ea	89 55 e8	 mov	 DWORD PTR __Bytes$[ebp], edx
  000ed	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f0	89 45 d4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000f3	81 7d e8 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  000fa	72 10		 jb	 SHORT $LN127@Reallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  000fc	8d 4d e8	 lea	 ecx, DWORD PTR __Bytes$[ebp]
  000ff	51		 push	 ecx
  00100	8d 55 d4	 lea	 edx, DWORD PTR __Ptr$[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00109	83 c4 08	 add	 esp, 8
$LN127@Reallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0010c	8b 45 e8	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0010f	50		 push	 eax
  00110	8b 4d d4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00113	51		 push	 ecx
  00114	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00119	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3906 : 			_My_data._Bx._Ptr = _New_ptr;

  0011c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0011f	8b 45 e4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00122	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 3907 : 			}
; 3908 : 		else

  00125	eb 1f		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3909 : 			{
; 3910 : 			_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);

  00127	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0012a	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0012d	89 4d c4	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00130	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00133	89 55 c0	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00136	8d 45 e4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00139	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0013c	8b 4d c0	 mov	 ecx, DWORD PTR $T2[ebp]
  0013f	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  00142	8b 02		 mov	 eax, DWORD PTR [edx]
  00144	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3913 : 		return (*this);

  00146	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 3914 : 		}

  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z PROC ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator(), COMDAT
; _this$ = ecx

; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());

  0001d	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00021	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00024	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00027	8a 4d ff	 mov	 cl, BYTE PTR $T1[ebp]
  0002a	88 08		 mov	 BYTE PTR [eax], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2671 : 			}, _Ptr));

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_9366063389c5f42a00a5088cf24e69de>@@QBEXQADIQBD@Z ENDP ; <lambda_9366063389c5f42a00a5088cf24e69de>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z PROC		; std::_Refancy<char const *,0>, COMDAT

; 362  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 363  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 364  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z ENDP		; std::_Refancy<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > const >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPBV?$_String_val@U?$_Simple_types@D@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@$$CBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z PROC			; std::_Unfancy<char const >, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@$$CBD@std@@YAPBDPBD@Z ENDP			; std::_Unfancy<char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 455  : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Al$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 453  : 		: _Mypair(_One_then_variadic_args_t(),

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00015	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 55 fc	 mov	 DWORD PTR _this$[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 390  : 		_Mylast(),

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 391  : 		_Myend()

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 456  : 		_Alloc_proxy();

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 457  : 		}

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
??$?0ABV?$allocator@D@std@@X@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z
_TEXT	SEGMENT
$T2 = -340						; size = 4
__Last$ = -336						; size = 4
$T3 = -332						; size = 4
$T4 = -328						; size = 4
$T5 = -324						; size = 4
$T6 = -320						; size = 4
$T7 = -316						; size = 4
$T8 = -312						; size = 4
$T9 = -308						; size = 4
$T10 = -304						; size = 4
$T11 = -300						; size = 4
$T12 = -296						; size = 4
$T13 = -292						; size = 4
$T14 = -288						; size = 4
$T15 = -284						; size = 4
$T16 = -280						; size = 4
$T17 = -276						; size = 4
$T18 = -272						; size = 4
$T19 = -268						; size = 4
$T20 = -264						; size = 4
$T21 = -260						; size = 4
$T22 = -256						; size = 4
__Last_ch$23 = -252					; size = 4
$T24 = -248						; size = 4
_this$ = -244						; size = 4
$T25 = -240						; size = 4
$T26 = -236						; size = 4
$T27 = -232						; size = 4
__First$ = -228						; size = 4
__Last$ = -224						; size = 4
$T28 = -220						; size = 4
$T29 = -216						; size = 4
$T30 = -212						; size = 4
$T31 = -208						; size = 4
$T32 = -204						; size = 4
$T33 = -200						; size = 4
$T34 = -196						; size = 4
$T35 = -192						; size = 4
__Last_ch$36 = -188					; size = 4
$T37 = -184						; size = 4
_this$ = -180						; size = 4
$T38 = -176						; size = 4
$T39 = -172						; size = 4
$T40 = -168						; size = 4
$T41 = -164						; size = 4
$T42 = -160						; size = 4
$T43 = -156						; size = 4
__Oldcapacity$ = -152					; size = 4
$T44 = -148						; size = 4
$T45 = -144						; size = 4
$T46 = -140						; size = 4
$T47 = -136						; size = 4
$T48 = -132						; size = 4
$T49 = -128						; size = 4
$T50 = -124						; size = 4
$T51 = -120						; size = 4
$T52 = -116						; size = 4
$T53 = -112						; size = 4
$T54 = -108						; size = 4
$T55 = -104						; size = 4
__Newlast$56 = -100					; size = 4
__Last$57 = -96						; size = 4
__First_ch$58 = -92					; size = 4
__Appended_last$59 = -88				; size = 4
__Last$60 = -84						; size = 4
__First_ch$61 = -80					; size = 4
tv259 = -76						; size = 4
$T62 = -72						; size = 4
$T63 = -68						; size = 4
$T64 = -64						; size = 4
$T65 = -57						; size = 1
___formal$66 = -56					; size = 1
___formal$ = -52					; size = 1
___formal$67 = -48					; size = 1
__Oldlast$68 = -44					; size = 4
__Newvec$69 = -40					; size = 4
__Appended_first$70 = -36				; size = 4
__Oldsize$ = -32					; size = 4
__Newcapacity$71 = -28					; size = 4
$T72 = -23						; size = 1
$T73 = -22						; size = 1
$T74 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z PROC ; std::vector<char,std::allocator<char> >::_Resize<<lambda_c82d6fc6887df3275822341e5972f698> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 98	 mov	 DWORD PTR $T55[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00038	8b 4d 98	 mov	 ecx, DWORD PTR $T55[ebp]
  0003b	89 4d 94	 mov	 DWORD PTR $T54[ebp], ecx

; 591  : 		return (_Get_data()._Mylast);

  0003e	8b 55 94	 mov	 edx, DWORD PTR $T54[ebp]
  00041	83 c2 08	 add	 edx, 8
  00044	89 55 88	 mov	 DWORD PTR $T51[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 90	 mov	 DWORD PTR $T53[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0004d	8b 4d 90	 mov	 ecx, DWORD PTR $T53[ebp]
  00050	89 4d 8c	 mov	 DWORD PTR $T52[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  00053	8b 55 8c	 mov	 edx, DWORD PTR $T52[ebp]
  00056	83 c2 04	 add	 edx, 4
  00059	89 55 84	 mov	 DWORD PTR $T50[ebp], edx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  0005c	8b 45 88	 mov	 eax, DWORD PTR $T51[ebp]
  0005f	8b 4d 84	 mov	 ecx, DWORD PTR $T50[ebp]
  00062	8b 10		 mov	 edx, DWORD PTR [eax]
  00064	2b 11		 sub	 edx, DWORD PTR [ecx]
  00066	89 55 e0	 mov	 DWORD PTR __Oldsize$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00069	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	89 45 80	 mov	 DWORD PTR $T49[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0006f	8b 4d 80	 mov	 ecx, DWORD PTR $T49[ebp]
  00072	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T48[ebp], ecx

; 601  : 		return (_Get_data()._Myend);

  00078	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T48[ebp]
  0007e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00081	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T45[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00087	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T47[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00090	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T47[ebp]
  00096	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T46[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  0009c	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T46[ebp]
  000a2	83 c2 04	 add	 edx, 4
  000a5	89 95 6c ff ff
	ff		 mov	 DWORD PTR $T44[ebp], edx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  000ab	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T45[ebp]
  000b1	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T44[ebp]
  000b7	8b 10		 mov	 edx, DWORD PTR [eax]
  000b9	2b 11		 sub	 edx, DWORD PTR [ecx]
  000bb	89 95 68 ff ff
	ff		 mov	 DWORD PTR __Oldcapacity$[ebp], edx

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  000c1	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c4	3b 85 68 ff ff
	ff		 cmp	 eax, DWORD PTR __Oldcapacity$[ebp]
  000ca	0f 86 5b 02 00
	00		 jbe	 $LN2@Resize

; 550  : 		return (_Mypair._Get_first());

  000d0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  000d3	89 8d 64 ff ff
	ff		 mov	 DWORD PTR $T43[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 550  : 		return (_Mypair._Get_first());

  000d9	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR $T43[ebp]
  000df	89 95 c0 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  000e5	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR $T63[ebp], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits

; 617  : 		return (INT_MAX);

  000ec	c7 85 60 ff ff
	ff ff ff ff 7f	 mov	 DWORD PTR $T42[ebp], 2147483647 ; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  000f6	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T42[ebp]
  000fc	89 45 b8	 mov	 DWORD PTR $T62[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  000ff	8b 4d bc	 mov	 ecx, DWORD PTR $T63[ebp]
  00102	3b 4d b8	 cmp	 ecx, DWORD PTR $T62[ebp]
  00105	73 08		 jae	 SHORT $LN74@Resize
  00107	8d 55 bc	 lea	 edx, DWORD PTR $T63[ebp]
  0010a	89 55 b4	 mov	 DWORD PTR tv259[ebp], edx
  0010d	eb 06		 jmp	 SHORT $LN75@Resize
$LN74@Resize:
  0010f	8d 45 b8	 lea	 eax, DWORD PTR $T62[ebp]
  00112	89 45 b4	 mov	 DWORD PTR tv259[ebp], eax
$LN75@Resize:
  00115	8b 4d b4	 mov	 ecx, DWORD PTR tv259[ebp]
  00118	89 8d 5c ff ff
	ff		 mov	 DWORD PTR $T41[ebp], ecx
  0011e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR $T41[ebp]
  00124	89 95 58 ff ff
	ff		 mov	 DWORD PTR $T40[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0012a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T40[ebp]
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	89 8d 54 ff ff
	ff		 mov	 DWORD PTR $T39[ebp], ecx

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00138	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0013b	3b 95 54 ff ff
	ff		 cmp	 edx, DWORD PTR $T39[ebp]
  00141	76 05		 jbe	 SHORT $LN4@Resize

; 1435 : 				{
; 1436 : 				_Xlength();

  00143	e8 00 00 00 00	 call	 ?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
$LN4@Resize:

; 1437 : 				}
; 1438 : 
; 1439 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00148	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@ABEII@Z ; std::vector<char,std::allocator<char> >::_Calculate_growth
  00154	89 45 e4	 mov	 DWORD PTR __Newcapacity$71[ebp], eax

; 545  : 		return (_Mypair._Get_first());

  00157	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0015a	89 8d 50 ff ff
	ff		 mov	 DWORD PTR $T38[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  00160	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR $T38[ebp]
  00166	89 95 bc fe ff
	ff		 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  0016c	81 7d e4 00 10
	00 00		 cmp	 DWORD PTR __Newcapacity$71[ebp], 4096 ; 00001000H
  00173	72 11		 jb	 SHORT $LN113@Resize

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00175	8b 45 e4	 mov	 eax, DWORD PTR __Newcapacity$71[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0017e	83 c4 04	 add	 esp, 4
  00181	89 45 c0	 mov	 DWORD PTR $T64[ebp], eax
  00184	eb 1e		 jmp	 SHORT $LN108@Resize
$LN113@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00186	83 7d e4 00	 cmp	 DWORD PTR __Newcapacity$71[ebp], 0
  0018a	74 11		 je	 SHORT $LN114@Resize

; 52   : 		return (::operator new(_Bytes));

  0018c	8b 4d e4	 mov	 ecx, DWORD PTR __Newcapacity$71[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00195	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00198	89 45 c0	 mov	 DWORD PTR $T64[ebp], eax
  0019b	eb 07		 jmp	 SHORT $LN108@Resize
$LN114@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  0019d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T64[ebp], 0
$LN108@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1441 : 			const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

  001a4	8b 55 c0	 mov	 edx, DWORD PTR $T64[ebp]
  001a7	89 55 d8	 mov	 DWORD PTR __Newvec$69[ebp], edx

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  001aa	8b 45 d8	 mov	 eax, DWORD PTR __Newvec$69[ebp]
  001ad	03 45 e0	 add	 eax, DWORD PTR __Oldsize$[ebp]
  001b0	89 45 dc	 mov	 DWORD PTR __Appended_first$70[ebp], eax

; 1443 : 			pointer _Appended_last = _Appended_first;

  001b3	8b 4d dc	 mov	 ecx, DWORD PTR __Appended_first$70[ebp]
  001b6	89 4d a8	 mov	 DWORD PTR __Appended_last$59[ebp], ecx

; 1444 : 
; 1445 : 			_TRY_BEGIN

  001b9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1479 : 			return (_Udefault(_Dest, _Count));

  001c0	8b 55 0c	 mov	 edx, DWORD PTR __Udefault_or_fill$[ebp]
  001c3	89 95 4c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], edx

; 545  : 		return (_Mypair._Get_first());

  001c9	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  001cf	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T37[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  001d5	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR $T37[ebp]
  001db	89 8d b8 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  001e1	33 d2		 xor	 edx, edx
  001e3	88 55 eb	 mov	 BYTE PTR $T74[ebp], dl
  001e6	8a 45 eb	 mov	 al, BYTE PTR $T74[ebp]
  001e9	88 45 d0	 mov	 BYTE PTR ___formal$67[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1446 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

  001ec	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  001ef	2b 4d e0	 sub	 ecx, DWORD PTR __Oldsize$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  001f2	03 4d dc	 add	 ecx, DWORD PTR __Appended_first$70[ebp]
  001f5	89 4d ac	 mov	 DWORD PTR __Last$60[ebp], ecx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  001f8	8b 55 dc	 mov	 edx, DWORD PTR __Appended_first$70[ebp]
  001fb	89 55 b0	 mov	 DWORD PTR __First_ch$61[ebp], edx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  001fe	8b 45 ac	 mov	 eax, DWORD PTR __Last$60[ebp]
  00201	89 85 44 ff ff
	ff		 mov	 DWORD PTR __Last_ch$36[ebp], eax

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00207	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR __Last_ch$36[ebp]
  0020d	2b 4d b0	 sub	 ecx, DWORD PTR __First_ch$61[ebp]
  00210	51		 push	 ecx
  00211	6a 00		 push	 0
  00213	8b 55 b0	 mov	 edx, DWORD PTR __First_ch$61[ebp]
  00216	52		 push	 edx
  00217	e8 00 00 00 00	 call	 _memset
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1446 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);

  0021f	8b 45 ac	 mov	 eax, DWORD PTR __Last$60[ebp]
  00222	89 45 a8	 mov	 DWORD PTR __Appended_last$59[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00225	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00228	89 8d 40 ff ff
	ff		 mov	 DWORD PTR $T35[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0022e	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR $T35[ebp]
  00234	89 95 3c ff ff
	ff		 mov	 DWORD PTR $T34[ebp], edx

; 586  : 		return (_Get_data()._Mylast);

  0023a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T34[ebp]
  00240	83 c0 08	 add	 eax, 8
  00243	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T31[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00249	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	89 8d 38 ff ff
	ff		 mov	 DWORD PTR $T33[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00252	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR $T33[ebp]
  00258	89 95 34 ff ff
	ff		 mov	 DWORD PTR $T32[ebp], edx

; 576  : 		return (_Get_data()._Myfirst);

  0025e	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR $T32[ebp]
  00264	83 c0 04	 add	 eax, 4
  00267	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  0026d	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR $T31[ebp]
  00273	8b 11		 mov	 edx, DWORD PTR [ecx]
  00275	89 95 20 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], edx
  0027b	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  00281	8b 08		 mov	 ecx, DWORD PTR [eax]
  00283	89 8d 1c ff ff
	ff		 mov	 DWORD PTR __First$[ebp], ecx

; 1843 : 		_Umove_if_noexcept1(_First, _Last, _Dest,

  00289	33 d2		 xor	 edx, edx
  0028b	88 55 ea	 mov	 BYTE PTR $T73[ebp], dl
  0028e	8a 45 ea	 mov	 al, BYTE PTR $T73[ebp]
  00291	88 45 cc	 mov	 BYTE PTR ___formal$[ebp], al

; 545  : 		return (_Mypair._Get_first());

  00294	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00297	89 8d 28 ff ff
	ff		 mov	 DWORD PTR $T29[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0029d	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR $T29[ebp]
  002a3	89 95 24 ff ff
	ff		 mov	 DWORD PTR $T28[ebp], edx

; 1833 : 		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());

  002a9	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  002af	50		 push	 eax
  002b0	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$69[ebp]
  002b3	51		 push	 ecx
  002b4	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR __Last$[ebp]
  002ba	52		 push	 edx
  002bb	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,char *,std::allocator<char> >
  002c7	83 c4 10	 add	 esp, 16			; 00000010H

; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);

  002ca	eb 36		 jmp	 SHORT $LN11@Resize
__catch$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$0:

; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);

  002cc	8b 4d a8	 mov	 ecx, DWORD PTR __Appended_last$59[ebp]
  002cf	51		 push	 ecx
  002d0	8b 55 dc	 mov	 edx, DWORD PTR __Appended_first$70[ebp]
  002d3	52		 push	 edx
  002d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002d7	e8 00 00 00 00	 call	 ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);

  002dc	8b 45 e4	 mov	 eax, DWORD PTR __Newcapacity$71[ebp]
  002df	50		 push	 eax
  002e0	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$69[ebp]
  002e3	51		 push	 ecx
  002e4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002e7	e8 00 00 00 00	 call	 ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
  002ec	8b c8		 mov	 ecx, eax
  002ee	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 1451 : 			_RERAISE;

  002f3	6a 00		 push	 0
  002f5	6a 00		 push	 0
  002f7	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1452 : 			_CATCH_END

  002fc	b8 00 00 00 00	 mov	 eax, $LN14@Resize
  00301	c3		 ret	 0
$LN11@Resize:
  00302	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00309	eb 07		 jmp	 SHORT __tryend$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$1
$LN14@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
  0030b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z$1:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);

  00312	8b 55 e4	 mov	 edx, DWORD PTR __Newcapacity$71[ebp]
  00315	52		 push	 edx
  00316	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00319	50		 push	 eax
  0031a	8b 4d d8	 mov	 ecx, DWORD PTR __Newvec$69[ebp]
  0031d	51		 push	 ecx
  0031e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00321	e8 00 00 00 00	 call	 ?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AAEXQADII@Z ; std::vector<char,std::allocator<char> >::_Change_array
  00326	e9 d1 01 00 00	 jmp	 $LN10@Resize
$LN2@Resize:

; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  0032b	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0032e	3b 55 e0	 cmp	 edx, DWORD PTR __Oldsize$[ebp]
  00331	0f 86 d2 00 00
	00		 jbe	 $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00337	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0033a	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T27[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00340	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR $T27[ebp]
  00346	89 8d 14 ff ff
	ff		 mov	 DWORD PTR $T26[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  0034c	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR $T26[ebp]
  00352	83 c2 08	 add	 edx, 8
  00355	89 95 10 ff ff
	ff		 mov	 DWORD PTR $T25[ebp], edx

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();

  0035b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  00361	8b 08		 mov	 ecx, DWORD PTR [eax]
  00363	89 4d d4	 mov	 DWORD PTR __Oldlast$68[ebp], ecx

; 1479 : 			return (_Udefault(_Dest, _Count));

  00366	8b 55 0c	 mov	 edx, DWORD PTR __Udefault_or_fill$[ebp]
  00369	89 95 0c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], edx

; 545  : 		return (_Mypair._Get_first());

  0036f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00375	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0037b	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T24[ebp]
  00381	89 8d b4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00387	33 d2		 xor	 edx, edx
  00389	88 55 e9	 mov	 BYTE PTR $T72[ebp], dl
  0038c	8a 45 e9	 mov	 al, BYTE PTR $T72[ebp]
  0038f	88 45 c8	 mov	 BYTE PTR ___formal$66[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

  00392	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00395	2b 4d e0	 sub	 ecx, DWORD PTR __Oldsize$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00398	03 4d d4	 add	 ecx, DWORD PTR __Oldlast$68[ebp]
  0039b	89 4d a0	 mov	 DWORD PTR __Last$57[ebp], ecx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  0039e	8b 55 d4	 mov	 edx, DWORD PTR __Oldlast$68[ebp]
  003a1	89 55 a4	 mov	 DWORD PTR __First_ch$58[ebp], edx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  003a4	8b 45 a0	 mov	 eax, DWORD PTR __Last$57[ebp]
  003a7	89 85 04 ff ff
	ff		 mov	 DWORD PTR __Last_ch$23[ebp], eax

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  003ad	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR __Last_ch$23[ebp]
  003b3	2b 4d a4	 sub	 ecx, DWORD PTR __First_ch$58[ebp]
  003b6	51		 push	 ecx
  003b7	6a 00		 push	 0
  003b9	8b 55 a4	 mov	 edx, DWORD PTR __First_ch$58[ebp]
  003bc	52		 push	 edx
  003bd	e8 00 00 00 00	 call	 _memset
  003c2	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  003c5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  003c8	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  003ce	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  003d4	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T21[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  003da	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR $T21[ebp]
  003e0	83 c2 08	 add	 edx, 8
  003e3	89 95 f8 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], edx

; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);

  003e9	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  003ef	8b 4d a0	 mov	 ecx, DWORD PTR __Last$57[ebp]
  003f2	89 08		 mov	 DWORD PTR [eax], ecx

; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);

  003f4	8b 55 d4	 mov	 edx, DWORD PTR __Oldlast$68[ebp]
  003f7	52		 push	 edx
  003f8	8b 45 d4	 mov	 eax, DWORD PTR __Oldlast$68[ebp]
  003fb	50		 push	 eax
  003fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003ff	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Orphan_range
  00404	e9 f3 00 00 00	 jmp	 $LN10@Resize
$LN6@Resize:

; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00409	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0040c	3b 4d e0	 cmp	 ecx, DWORD PTR __Oldsize$[ebp]
  0040f	75 05		 jne	 SHORT $LN8@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else

  00411	e9 e6 00 00 00	 jmp	 $LN10@Resize
$LN8@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00416	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00419	89 95 f4 fe ff
	ff		 mov	 DWORD PTR $T19[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0041f	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T19[ebp]
  00425	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  0042b	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T18[ebp]
  00431	83 c1 04	 add	 ecx, 4
  00434	89 8d ec fe ff
	ff		 mov	 DWORD PTR $T17[ebp], ecx

; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  0043a	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR $T17[ebp]
  00440	8b 02		 mov	 eax, DWORD PTR [edx]
  00442	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00445	89 45 9c	 mov	 DWORD PTR __Newlast$56[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00448	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0044b	89 8d e8 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00451	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR $T16[ebp]
  00457	89 95 e4 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], edx

; 586  : 		return (_Get_data()._Mylast);

  0045d	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  00463	83 c0 08	 add	 eax, 8
  00466	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax

; 1468 : 			_Orphan_range(_Newlast, this->_Mylast());

  0046c	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  00472	8b 11		 mov	 edx, DWORD PTR [ecx]
  00474	52		 push	 edx
  00475	8b 45 9c	 mov	 eax, DWORD PTR __Newlast$56[ebp]
  00478	50		 push	 eax
  00479	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0047c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Orphan_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00481	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00484	89 8d dc fe ff
	ff		 mov	 DWORD PTR $T13[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0048a	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR $T13[ebp]
  00490	89 95 d8 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], edx

; 586  : 		return (_Get_data()._Mylast);

  00496	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  0049c	83 c0 08	 add	 eax, 8
  0049f	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 1469 : 			_Destroy(_Newlast, this->_Mylast());

  004a5	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  004ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  004ad	89 95 b0 fe ff
	ff		 mov	 DWORD PTR __Last$[ebp], edx

; 545  : 		return (_Mypair._Get_first());

  004b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  004b6	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  004bc	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  004c2	89 8d ac fe ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

  004c8	33 d2		 xor	 edx, edx
  004ca	88 55 c7	 mov	 BYTE PTR $T65[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  004cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  004d0	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  004d6	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  004dc	89 8d c8 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  004e2	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  004e8	83 c2 08	 add	 edx, 8
  004eb	89 95 c4 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], edx

; 1470 : 			this->_Mylast() = _Newlast;

  004f1	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  004f7	8b 4d 9c	 mov	 ecx, DWORD PTR __Newlast$56[ebp]
  004fa	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Resize:

; 1471 : 			}
; 1472 : 		}

  004fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  004ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00506	59		 pop	 ecx
  00507	5f		 pop	 edi
  00508	5e		 pop	 esi
  00509	5b		 pop	 ebx
  0050a	8b e5		 mov	 esp, ebp
  0050c	5d		 pop	 ebp
  0050d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-344]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z
  00019	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z ENDP ; std::vector<char,std::allocator<char> >::_Resize<<lambda_c82d6fc6887df3275822341e5972f698> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0<lambda_c82d6fc6887df3275822341e5972f698>@@QAE@QAV?$vector@DV?$allocator@D@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__This$ = 8						; size = 4
??0<lambda_c82d6fc6887df3275822341e5972f698>@@QAE@QAV?$vector@DV?$allocator@D@std@@@std@@@Z PROC ; <lambda_c82d6fc6887df3275822341e5972f698>::<lambda_c82d6fc6887df3275822341e5972f698>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __This$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0<lambda_c82d6fc6887df3275822341e5972f698>@@QAE@QAV?$vector@DV?$allocator@D@std@@@std@@@Z ENDP ; <lambda_c82d6fc6887df3275822341e5972f698>::<lambda_c82d6fc6887df3275822341e5972f698>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??R<lambda_c82d6fc6887df3275822341e5972f698>@@QBEPADPADI@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
__Last_ch$2 = -32					; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
__Last$4 = -16						; size = 4
__First_ch$5 = -12					; size = 4
___formal$6 = -8					; size = 1
$T7 = -1						; size = 1
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_c82d6fc6887df3275822341e5972f698>@@QBEPADPADI@Z PROC ; <lambda_c82d6fc6887df3275822341e5972f698>::operator(), COMDAT
; _this$ = ecx

; 1478 : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1479 : 			return (_Udefault(_Dest, _Count));

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00011	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00014	89 55 e4	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  00017	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  0001a	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  0001d	33 c9		 xor	 ecx, ecx
  0001f	88 4d ff	 mov	 BYTE PTR $T7[ebp], cl
  00022	8a 55 ff	 mov	 dl, BYTE PTR $T7[ebp]
  00025	88 55 f8	 mov	 BYTE PTR ___formal$6[ebp], dl

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00028	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002b	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Last$4[ebp], eax

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	89 4d f4	 mov	 DWORD PTR __First_ch$5[ebp], ecx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  00037	8b 55 f0	 mov	 edx, DWORD PTR __Last$4[ebp]
  0003a	89 55 e0	 mov	 DWORD PTR __Last_ch$2[ebp], edx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0003d	8b 45 e0	 mov	 eax, DWORD PTR __Last_ch$2[ebp]
  00040	2b 45 f4	 sub	 eax, DWORD PTR __First_ch$5[ebp]
  00043	50		 push	 eax
  00044	6a 00		 push	 0
  00046	8b 4d f4	 mov	 ecx, DWORD PTR __First_ch$5[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _memset
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00052	8b 45 f0	 mov	 eax, DWORD PTR __Last$4[ebp]

; 1480 : 			};

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
??R<lambda_c82d6fc6887df3275822341e5972f698>@@QBEPADPADI@Z ENDP ; <lambda_c82d6fc6887df3275822341e5972f698>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<char> > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Plist$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 328  : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
__Result$ = -1						; size = 1
__Pred$ = 8						; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z PROC ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1109 : 	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 1110 : 	const auto _Result = static_cast<bool>(_Pred(_Left, _Right));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00018	e8 00 00 00 00	 call	 ??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; zl::base::string_cmp_nocase::operator()
  0001d	88 45 ff	 mov	 BYTE PTR __Result$[ebp], al

; 1111 : 	if (_Result)

  00020	0f b6 55 ff	 movzx	 edx, BYTE PTR __Result$[ebp]
  00024	85 d2		 test	 edx, edx
  00026	74 67		 je	 SHORT $LN8@Debug_lt_p
$LN4@Debug_lt_p:

; 1112 : 		{
; 1113 : 		_STL_VERIFY(!_Pred(_Right, _Left), "invalid comparator");

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002f	51		 push	 ecx
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00033	e8 00 00 00 00	 call	 ??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; zl::base::string_cmp_nocase::operator()
  00038	0f b6 d0	 movzx	 edx, al
  0003b	85 d2		 test	 edx, edx
  0003d	75 02		 jne	 SHORT $LN7@Debug_lt_p
  0003f	eb 4a		 jmp	 SHORT $LN2@Debug_lt_p
$LN7@Debug_lt_p:
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FEEMDEPI@invalid?5comparator@
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0004b	6a 00		 push	 0
  0004d	68 59 04 00 00	 push	 1113			; 00000459H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00057	6a 02		 push	 2
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005f	83 c4 18	 add	 esp, 24			; 00000018H
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 01		 jne	 SHORT $LN12@Debug_lt_p
  00067	cc		 int	 3
$LN12@Debug_lt_p:
  00068	6a 00		 push	 0
  0006a	68 59 04 00 00	 push	 1113			; 00000459H
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1CI@JONCLBEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAb?$AAu?$AAg?$AA_?$AAl?$AAt?$AA_@
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@NDNHPKPI@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAc?$AAo?$AAm?$AAp?$AAa?$AAr@
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00084	83 c4 14	 add	 esp, 20			; 00000014H
  00087	33 c9		 xor	 ecx, ecx
  00089	75 b6		 jne	 SHORT $LN7@Debug_lt_p
$LN2@Debug_lt_p:
  0008b	33 d2		 xor	 edx, edx
  0008d	75 99		 jne	 SHORT $LN4@Debug_lt_p
$LN8@Debug_lt_p:

; 1114 : 		}
; 1115 : 
; 1116 : 	return (_Result);

  0008f	8a 45 ff	 mov	 al, BYTE PTR __Result$[ebp]

; 1117 : 	}

  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ENDP ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@SAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@ABU32@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@SAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@ABU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *>::pointer_to, COMDAT

; 341  : 		{	// convert raw reference to pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 342  : 		return (_STD addressof(_Val));

  0000a	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 343  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@SAPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@ABU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 259  :   if (fields_ != NULL) {

  00035	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003b	74 08		 je	 SHORT $LN7@scalar

; 260  :     ClearFallback();

  0003d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN7@scalar:

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 55 08	 mov	 edx, DWORD PTR ___flags$[ebp]
  0004f	83 e2 01	 and	 edx, 1
  00052	74 0e		 je	 SHORT $LN2@scalar
  00054	6a 08		 push	 8
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005f	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_GContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAXI@Z ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::`scalar deleting destructor'
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::~Container, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 259  :   if (fields_ != NULL) {

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003b	74 08		 je	 SHORT $LN3@Container

; 260  :     ClearFallback();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN3@Container:

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00045	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::~Container
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ??0Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::Container, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 252  : inline UnknownFieldSet::UnknownFieldSet() : fields_(NULL) {}

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??0Container@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container::Container
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ??$PtrValue@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAUContainer@0123@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$PtrValue@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAUContainer@0123@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrValue<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>, COMDAT
; _this$ = ecx

; 148  :   template<typename U> U* PtrValue() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 149  :     return reinterpret_cast<U*>(

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	83 e0 fe	 and	 eax, -2			; fffffffeH

; 150  :         reinterpret_cast<intptr_t>(ptr_) & kPtrValueMask);
; 151  :   }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$PtrValue@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEPAUContainer@0123@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrValue<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT _CreateTCPNetworkEngine
_TEXT	SEGMENT
tv129 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
tv150 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
tv151 = -44						; size = 4
tv153 = -40						; size = 4
_pObject$6 = -36					; size = 4
tv75 = -32						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
_pTCPNetworkEngine$ = -20				; size = 4
__$EHRec$ = -16						; size = 16
_Guid$ = 8						; size = 4
_dwInterfaceVer$ = 12					; size = 4
_CreateTCPNetworkEngine PROC				; COMDAT

; 2451 : DECLARE_CREATE_MODULE(TCPNetworkEngine);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_CreateTCPNetworkEngine
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 34	 sub	 esp, 52			; 00000034H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkEngine$[ebp], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003a	68 78 81 00 00	 push	 33144			; 00008178H
  0003f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 d8	 mov	 DWORD PTR tv153[ebp], eax
  0004a	8b 45 d8	 mov	 eax, DWORD PTR tv153[ebp]
  0004d	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax
  00050	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00054	83 7d e4 00	 cmp	 DWORD PTR $T7[ebp], 0
  00058	74 13		 je	 SHORT $LN7@CreateTCPN
  0005a	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  0005d	e8 00 00 00 00	 call	 ??0CTCPNetworkEngine@@QAE@XZ ; CTCPNetworkEngine::CTCPNetworkEngine
  00062	89 45 d4	 mov	 DWORD PTR tv151[ebp], eax
  00065	8b 4d d4	 mov	 ecx, DWORD PTR tv151[ebp]
  00068	89 4d e0	 mov	 DWORD PTR tv75[ebp], ecx
  0006b	eb 07		 jmp	 SHORT $LN8@CreateTCPN
$LN7@CreateTCPN:
  0006d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN8@CreateTCPN:
  00074	8b 55 e0	 mov	 edx, DWORD PTR tv75[ebp]
  00077	89 55 d0	 mov	 DWORD PTR $T5[ebp], edx
  0007a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0007e	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  00081	89 45 ec	 mov	 DWORD PTR _pTCPNetworkEngine$[ebp], eax
  00084	83 7d ec 00	 cmp	 DWORD PTR _pTCPNetworkEngine$[ebp], 0
  00088	75 15		 jne	 SHORT $LN3@CreateTCPN
  0008a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@
  00091	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00096	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@CreateTCPN:
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _pTCPNetworkEngine$[ebp]
  000aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ac	8b 4d ec	 mov	 ecx, DWORD PTR _pTCPNetworkEngine$[ebp]
  000af	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b2	ff d0		 call	 eax
  000b4	89 45 c8	 mov	 DWORD PTR tv150[ebp], eax
  000b7	8b 4d c8	 mov	 ecx, DWORD PTR tv150[ebp]
  000ba	89 4d dc	 mov	 DWORD PTR _pObject$6[ebp], ecx
  000bd	83 7d dc 00	 cmp	 DWORD PTR _pObject$6[ebp], 0
  000c1	75 15		 jne	 SHORT $LN4@CreateTCPN
  000c3	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@
  000ca	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000cf	8d 55 c4	 lea	 edx, DWORD PTR $T3[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN4@CreateTCPN:
  000d8	8b 45 dc	 mov	 eax, DWORD PTR _pObject$6[ebp]
  000db	e9 83 00 00 00	 jmp	 $LN6@CreateTCPN
__catch$_CreateTCPNetworkEngine$0:
  000e0	b8 00 00 00 00	 mov	 eax, $LN18@CreateTCPN
  000e5	c3		 ret	 0
  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000ed	eb 07		 jmp	 SHORT __tryend$_CreateTCPNetworkEngine$1
$LN18@CreateTCPN:
  000ef	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$_CreateTCPNetworkEngine$1:
  000f6	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _pTCPNetworkEngine$[ebp]
  00100	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  00103	8b 4d c0	 mov	 ecx, DWORD PTR $T2[ebp]
  00106	89 4d e8	 mov	 DWORD PTR $T8[ebp], ecx
  00109	83 7d e8 00	 cmp	 DWORD PTR $T8[ebp], 0
  0010d	74 14		 je	 SHORT $LN9@CreateTCPN
  0010f	6a 01		 push	 1
  00111	8b 55 e8	 mov	 edx, DWORD PTR $T8[ebp]
  00114	8b 02		 mov	 eax, DWORD PTR [edx]
  00116	8b 4d e8	 mov	 ecx, DWORD PTR $T8[ebp]
  00119	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  0011c	ff d2		 call	 edx
  0011e	89 45 bc	 mov	 DWORD PTR tv129[ebp], eax
  00121	eb 07		 jmp	 SHORT $LN10@CreateTCPN
$LN9@CreateTCPN:
  00123	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN10@CreateTCPN:
  0012a	eb 1e		 jmp	 SHORT $LN14@CreateTCPN
__catch$_CreateTCPNetworkEngine$2:
  0012c	33 c0		 xor	 eax, eax
  0012e	75 14		 jne	 SHORT $LN11@CreateTCPN
  00130	68 93 09 00 00	 push	 2451			; 00000993H
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0013a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0013f	85 c0		 test	 eax, eax
  00141	74 01		 je	 SHORT $LN11@CreateTCPN
  00143	cc		 int	 3
$LN11@CreateTCPN:
  00144	b8 00 00 00 00	 mov	 eax, $LN20@CreateTCPN
  00149	c3		 ret	 0
$LN14@CreateTCPN:
  0014a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00151	eb 07		 jmp	 SHORT __tryend$_CreateTCPNetworkEngine$3
$LN20@CreateTCPN:
  00153	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$_CreateTCPNetworkEngine$3:
  0015a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkEngine$[ebp], 0
  00161	33 c0		 xor	 eax, eax
$LN6@CreateTCPN:
  00163	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00166	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016d	59		 pop	 ecx
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_CreateTCPNetworkEngine$4:
  00000	68 78 81 00 00	 push	 33144			; 00008178H
  00005	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$_CreateTCPNetworkEngine:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_CreateTCPNetworkEngine
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_CreateTCPNetworkEngine ENDP
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
;	COMDAT ??$search@PADPBD@std@@YAPADQAD0QBD1@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$search@PADPBD@std@@YAPADQAD0QBD1@Z PROC		; std::search<char *,char const *>, COMDAT

; 987  : 	{	// find first [_First2, _Last2) match

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 988  : 	return (_STD search(_First1, _Last1, _First2, _Last2, equal_to<>()));

  00004	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00008	50		 push	 eax
  00009	8b 4d 14	 mov	 ecx, DWORD PTR __Last2$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 10	 mov	 edx, DWORD PTR __First2$[ebp]
  00010	52		 push	 edx
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last1$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z ; std::search<char *,char const *,std::equal_to<void> >
  0001e	83 c4 14	 add	 esp, 20			; 00000014H

; 989  : 	}

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$search@PADPBD@std@@YAPADQAD0QBD1@Z ENDP		; std::search<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??$?0D$0A@@?$shared_ptr@D@std@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Px$ = 8						; size = 4
??$?0D$0A@@?$shared_ptr@D@std@@QAE@PAD@Z PROC		; std::shared_ptr<char>::shared_ptr<char><char,0>, COMDAT
; _this$ = ecx

; 1283 : 		{	// construct shared_ptr object that owns _Px

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1157 : 	element_type * _Ptr{nullptr};

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1158 : 	_Ref_count_base * _Rep{nullptr};

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1284 : 		_Setp(_Px, is_array<_Ty>{});

  0001c	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __Px$[ebp]
  00024	50		 push	 eax
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z ; std::shared_ptr<char>::_Setp<char>

; 1285 : 		}

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??$?0D$0A@@?$shared_ptr@D@std@@QAE@PAD@Z ENDP		; std::shared_ptr<char>::shared_ptr<char><char,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??1?$shared_ptr@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$shared_ptr@D@std@@QAE@XZ PROC			; std::shared_ptr<char>::~shared_ptr<char>, COMDAT
; _this$ = ecx

; 1402 : 		{	// release resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$shared_ptr@D@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1118 : 		if (_Rep)

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002d	74 0b		 je	 SHORT $LN2@shared_ptr

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00035	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN2@shared_ptr:

; 1403 : 		this->_Decref();
; 1404 : 		}

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$shared_ptr@D@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$shared_ptr@D@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$shared_ptr@D@std@@QAE@XZ ENDP			; std::shared_ptr<char>::~shared_ptr<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Set_ptr_rep@?$_Ptr_base@D@std@@IAEXPADPAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other_ptr$ = 8					; size = 4
__Other_rep$ = 12					; size = 4
?_Set_ptr_rep@?$_Ptr_base@D@std@@IAEXPADPAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<char>::_Set_ptr_rep, COMDAT
; _this$ = ecx

; 1131 : 		{	// take new resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1132 : 		_Ptr = _Other_ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Other_ptr$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1133 : 		_Rep = _Other_rep;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Other_rep$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1134 : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Set_ptr_rep@?$_Ptr_base@D@std@@IAEXPADPAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<char>::_Set_ptr_rep
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@D@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@?$_Ptr_base@D@std@@IAEXXZ PROC			; std::_Ptr_base<char>::_Decref, COMDAT
; _this$ = ecx

; 1117 : 		{	// decrement reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1118 : 		if (_Rep)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 0b		 je	 SHORT $LN1@Decref

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN1@Decref:

; 1121 : 			}
; 1122 : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Decref@?$_Ptr_base@D@std@@IAEXXZ ENDP			; std::_Ptr_base<char>::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0?$_Ptr_base@D@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ptr_base@D@std@@IAE@XZ PROC			; std::_Ptr_base<char>::_Ptr_base<char>, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1157 : 	element_type * _Ptr{nullptr};

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1158 : 	_Ref_count_base * _Rep{nullptr};

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$_Ptr_base@D@std@@IAE@XZ ENDP			; std::_Ptr_base<char>::_Ptr_base<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?get@?$_Ptr_base@D@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$_Ptr_base@D@std@@IBEPADXZ PROC			; std::_Ptr_base<char>::get, COMDAT
; _this$ = ecx

; 1058 : 		{	// return pointer to resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1059 : 		return (_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1060 : 		}

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?get@?$_Ptr_base@D@std@@IBEPADXZ ENDP			; std::_Ptr_base<char>::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@PAVhead@NullPmd@@X@std@@YAXAAPAVhead@NullPmd@@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Tmp$ = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVhead@NullPmd@@X@std@@YAXAAPAVhead@NullPmd@@0@Z PROC ; std::swap<NullPmd::head *,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f4	 mov	 DWORD PTR __Tmp$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@PAVhead@NullPmd@@X@std@@YAXAAPAVhead@NullPmd@@0@Z ENDP ; std::swap<NullPmd::head *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVmessage@NullPmd@@@internal@protobuf@google@@YAPBVmessage@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVmessage@NullPmd@@@internal@protobuf@google@@YAPBVmessage@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::message const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@message@NullPmd@@SAABV12@XZ ; NullPmd::message::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVmessage@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVmessage@NullPmd@@@internal@protobuf@google@@YAPBVmessage@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::message const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$MessageSizeNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVhead@NullPmd@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_length$ = -4						; size = 4
_value$ = 8						; size = 4
??$MessageSizeNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVhead@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::head>, COMDAT

; 861  :     const MessageType_WorkAroundCppLookupDefect& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 862  :   return LengthDelimitedSize(

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00009	e8 00 00 00 00	 call	 ?ByteSizeLong@head@NullPmd@@UBEIXZ ; NullPmd::head::ByteSizeLong
  0000e	89 45 fc	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  00011	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  00018	73 0b		 jae	 SHORT $LN6@MessageSiz

; 1296 :     return 1;

  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00021	eb 11		 jmp	 SHORT $LN3@MessageSiz

; 1297 :   } else  {

  00023	eb 0f		 jmp	 SHORT $LN3@MessageSiz
$LN6@MessageSiz:

; 1298 :     return VarintSize32Fallback(value);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
$LN3@MessageSiz:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  00034	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00037	03 45 f8	 add	 eax, DWORD PTR $T1[ebp]

; 863  :       value.MessageType_WorkAroundCppLookupDefect::ByteSizeLong());
; 864  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$MessageSizeNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVhead@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::head>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$InternalWriteMessageNoVirtualToArray@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVhead@NullPmd@@_NPAE@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_target$ = -16						; size = 4
_value$ = -12						; size = 4
_target$2 = -8						; size = 4
_value$3 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_deterministic$ = 16					; size = 1
_target$ = 20						; size = 4
??$InternalWriteMessageNoVirtualToArray@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVhead@NullPmd@@_NPAE@Z PROC ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::head>, COMDAT

; 806  :     bool deterministic, uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 14	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$2[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx
$LN10@InternalWr:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$3[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN11@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$3[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$3[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$2[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN10@InternalWr
$LN11@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$3[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0004e	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 807  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  00051	89 55 14	 mov	 DWORD PTR _target$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 554  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00054	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00057	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0005a	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  0005d	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  00060	89 55 f0	 mov	 DWORD PTR _target$[ebp], edx
  00063	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00066	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
$LN16@InternalWr:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1197 :   while (value >= 0x80) {

  00069	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00070	72 22		 jb	 SHORT $LN17@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00072	8b 4d f4	 mov	 ecx, DWORD PTR _value$[ebp]
  00075	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  0007e	88 0a		 mov	 BYTE PTR [edx], cl

; 1199 :     value >>= 7;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00083	c1 e8 07	 shr	 eax, 7
  00086	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax

; 1200 :     ++target;

  00089	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d f0	 mov	 DWORD PTR _target$[ebp], ecx

; 1201 :   }

  00092	eb d5		 jmp	 SHORT $LN16@InternalWr
$LN17@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00094	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  00097	8a 45 f4	 mov	 al, BYTE PTR _value$[ebp]
  0009a	88 02		 mov	 BYTE PTR [edx], al

; 1203 :   return target + 1;

  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  000a2	89 4d 14	 mov	 DWORD PTR _target$[ebp], ecx

; 809  :     value.MessageType_WorkAroundCppLookupDefect::GetCachedSize(), target);
; 810  :   return value.InternalSerializeWithCachedSizesToArray(deterministic, target);

  000a5	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  000a8	52		 push	 edx
  000a9	0f b6 45 10	 movzx	 eax, BYTE PTR _deterministic$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000b1	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::head::InternalSerializeWithCachedSizesToArray

; 811  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$InternalWriteMessageNoVirtualToArray@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVhead@NullPmd@@_NPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::head>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$ReadMessageNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVhead@NullPmd@@@Z
_TEXT	SEGMENT
_p$ = -12						; size = 8
_length$ = -4						; size = 4
_input$ = 8						; size = 4
_value$ = 12						; size = 4
??$ReadMessageNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVhead@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::head>, COMDAT

; 493  :     io::CodedInputStream* input, MessageType_WorkAroundCppLookupDefect* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 494  :   int length;
; 495  :   if (!input->ReadVarintSizeAsInt(&length)) return false;

  00006	8d 45 fc	 lea	 eax, DWORD PTR _length$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 04		 jne	 SHORT $LN2@ReadMessag
  00019	32 c0		 xor	 al, al
  0001b	eb 39		 jmp	 SHORT $LN1@ReadMessag
$LN2@ReadMessag:

; 496  :   std::pair<io::CodedInputStream::Limit, int> p =
; 497  :       input->IncrementRecursionDepthAndPushLimit(length);

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _length$[ebp]
  00020	52		 push	 edx
  00021	8d 45 f4	 lea	 eax, DWORD PTR _p$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00028	e8 00 00 00 00	 call	 ?IncrementRecursionDepthAndPushLimit@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@HH@std@@H@Z ; google::protobuf::io::CodedInputStream::IncrementRecursionDepthAndPushLimit

; 498  :   if (p.second < 0 || !value->

  0002d	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp+4], 0
  00031	7c 13		 jl	 SHORT $LN4@ReadMessag
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0003a	e8 00 00 00 00	 call	 ?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::head::MergePartialFromCodedStream
  0003f	0f b6 d0	 movzx	 edx, al
  00042	85 d2		 test	 edx, edx
  00044	75 04		 jne	 SHORT $LN3@ReadMessag
$LN4@ReadMessag:

; 499  :       MessageType_WorkAroundCppLookupDefect::MergePartialFromCodedStream(input))
; 500  :     return false;

  00046	32 c0		 xor	 al, al
  00048	eb 0c		 jmp	 SHORT $LN1@ReadMessag
$LN3@ReadMessag:

; 501  :   // Make sure that parsing stopped when the limit was hit, not at an endgroup
; 502  :   // tag.
; 503  :   return input->DecrementRecursionDepthAndPopLimit(p.first);

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00051	e8 00 00 00 00	 call	 ?DecrementRecursionDepthAndPopLimit@CodedInputStream@io@protobuf@google@@QAE_NH@Z ; google::protobuf::io::CodedInputStream::DecrementRecursionDepthAndPopLimit
$LN1@ReadMessag:

; 504  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$ReadMessageNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVhead@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::head>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vmessage@NullPmd@@@Arena@protobuf@google@@QAEXPAVmessage@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vmessage@NullPmd@@@Arena@protobuf@google@@QAEXPAVmessage@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::message>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vmessage@NullPmd@@@Arena@protobuf@google@@QAEXPAVmessage@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::message>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@PAVinfo@NullPmd@@X@std@@YAXAAPAVinfo@NullPmd@@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Tmp$ = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVinfo@NullPmd@@X@std@@YAXAAPAVinfo@NullPmd@@0@Z PROC ; std::swap<NullPmd::info *,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f4	 mov	 DWORD PTR __Tmp$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@PAVinfo@NullPmd@@X@std@@YAXAAPAVinfo@NullPmd@@0@Z ENDP ; std::swap<NullPmd::info *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@PAVcommand@NullPmd@@X@std@@YAXAAPAVcommand@NullPmd@@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Tmp$ = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVcommand@NullPmd@@X@std@@YAXAAPAVcommand@NullPmd@@0@Z PROC ; std::swap<NullPmd::command *,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f4	 mov	 DWORD PTR __Tmp$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@PAVcommand@NullPmd@@X@std@@YAXAAPAVcommand@NullPmd@@0@Z ENDP ; std::swap<NullPmd::command *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVhead@NullPmd@@@internal@protobuf@google@@YAPBVhead@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVhead@NullPmd@@@internal@protobuf@google@@YAPBVhead@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::head const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@head@NullPmd@@SAABV12@XZ ; NullPmd::head::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVhead@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVhead@NullPmd@@@internal@protobuf@google@@YAPBVhead@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::head const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$MessageSizeNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVinfo@NullPmd@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_length$ = -4						; size = 4
_value$ = 8						; size = 4
??$MessageSizeNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVinfo@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::info>, COMDAT

; 861  :     const MessageType_WorkAroundCppLookupDefect& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 862  :   return LengthDelimitedSize(

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00009	e8 00 00 00 00	 call	 ?ByteSizeLong@info@NullPmd@@UBEIXZ ; NullPmd::info::ByteSizeLong
  0000e	89 45 fc	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  00011	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  00018	73 0b		 jae	 SHORT $LN6@MessageSiz

; 1296 :     return 1;

  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00021	eb 11		 jmp	 SHORT $LN3@MessageSiz

; 1297 :   } else  {

  00023	eb 0f		 jmp	 SHORT $LN3@MessageSiz
$LN6@MessageSiz:

; 1298 :     return VarintSize32Fallback(value);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
$LN3@MessageSiz:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  00034	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00037	03 45 f8	 add	 eax, DWORD PTR $T1[ebp]

; 863  :       value.MessageType_WorkAroundCppLookupDefect::ByteSizeLong());
; 864  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$MessageSizeNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVinfo@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$MessageSizeNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVcommand@NullPmd@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_length$ = -4						; size = 4
_value$ = 8						; size = 4
??$MessageSizeNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVcommand@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::command>, COMDAT

; 861  :     const MessageType_WorkAroundCppLookupDefect& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 862  :   return LengthDelimitedSize(

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00009	e8 00 00 00 00	 call	 ?ByteSizeLong@command@NullPmd@@UBEIXZ ; NullPmd::command::ByteSizeLong
  0000e	89 45 fc	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  00011	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  00018	73 0b		 jae	 SHORT $LN6@MessageSiz

; 1296 :     return 1;

  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00021	eb 11		 jmp	 SHORT $LN3@MessageSiz

; 1297 :   } else  {

  00023	eb 0f		 jmp	 SHORT $LN3@MessageSiz
$LN6@MessageSiz:

; 1298 :     return VarintSize32Fallback(value);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
$LN3@MessageSiz:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  00034	8b 45 fc	 mov	 eax, DWORD PTR _length$[ebp]
  00037	03 45 f8	 add	 eax, DWORD PTR $T1[ebp]

; 863  :       value.MessageType_WorkAroundCppLookupDefect::ByteSizeLong());
; 864  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$MessageSizeNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAIABVcommand@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual<NullPmd::command>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$InternalWriteMessageNoVirtualToArray@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVinfo@NullPmd@@_NPAE@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_target$ = -16						; size = 4
_value$ = -12						; size = 4
_target$2 = -8						; size = 4
_value$3 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_deterministic$ = 16					; size = 1
_target$ = 20						; size = 4
??$InternalWriteMessageNoVirtualToArray@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVinfo@NullPmd@@_NPAE@Z PROC ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::info>, COMDAT

; 806  :     bool deterministic, uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 14	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$2[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx
$LN10@InternalWr:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$3[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN11@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$3[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$3[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$2[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN10@InternalWr
$LN11@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$3[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0004e	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 807  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  00051	89 55 14	 mov	 DWORD PTR _target$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 457  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00054	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00057	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0005a	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  0005d	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  00060	89 55 f0	 mov	 DWORD PTR _target$[ebp], edx
  00063	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00066	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
$LN16@InternalWr:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1197 :   while (value >= 0x80) {

  00069	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00070	72 22		 jb	 SHORT $LN17@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00072	8b 4d f4	 mov	 ecx, DWORD PTR _value$[ebp]
  00075	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  0007e	88 0a		 mov	 BYTE PTR [edx], cl

; 1199 :     value >>= 7;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00083	c1 e8 07	 shr	 eax, 7
  00086	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax

; 1200 :     ++target;

  00089	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d f0	 mov	 DWORD PTR _target$[ebp], ecx

; 1201 :   }

  00092	eb d5		 jmp	 SHORT $LN16@InternalWr
$LN17@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00094	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  00097	8a 45 f4	 mov	 al, BYTE PTR _value$[ebp]
  0009a	88 02		 mov	 BYTE PTR [edx], al

; 1203 :   return target + 1;

  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  000a2	89 4d 14	 mov	 DWORD PTR _target$[ebp], ecx

; 809  :     value.MessageType_WorkAroundCppLookupDefect::GetCachedSize(), target);
; 810  :   return value.InternalSerializeWithCachedSizesToArray(deterministic, target);

  000a5	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  000a8	52		 push	 edx
  000a9	0f b6 45 10	 movzx	 eax, BYTE PTR _deterministic$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000b1	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::info::InternalSerializeWithCachedSizesToArray

; 811  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$InternalWriteMessageNoVirtualToArray@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVinfo@NullPmd@@_NPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$InternalWriteMessageNoVirtualToArray@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVcommand@NullPmd@@_NPAE@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_target$ = -16						; size = 4
_value$ = -12						; size = 4
_target$2 = -8						; size = 4
_value$3 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_deterministic$ = 16					; size = 1
_target$ = 20						; size = 4
??$InternalWriteMessageNoVirtualToArray@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVcommand@NullPmd@@_NPAE@Z PROC ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::command>, COMDAT

; 806  :     bool deterministic, uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 14	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$2[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx
$LN10@InternalWr:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$3[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN11@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$3[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$3[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$3[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$2[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN10@InternalWr
$LN11@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$2[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$3[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _target$2[ebp]
  0004e	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 807  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  00051	89 55 14	 mov	 DWORD PTR _target$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 367  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00054	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00057	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005a	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  0005d	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  00060	89 55 f0	 mov	 DWORD PTR _target$[ebp], edx
  00063	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00066	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
$LN16@InternalWr:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1197 :   while (value >= 0x80) {

  00069	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00070	72 22		 jb	 SHORT $LN17@InternalWr

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00072	8b 4d f4	 mov	 ecx, DWORD PTR _value$[ebp]
  00075	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0007b	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  0007e	88 0a		 mov	 BYTE PTR [edx], cl

; 1199 :     value >>= 7;

  00080	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00083	c1 e8 07	 shr	 eax, 7
  00086	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax

; 1200 :     ++target;

  00089	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0008c	83 c1 01	 add	 ecx, 1
  0008f	89 4d f0	 mov	 DWORD PTR _target$[ebp], ecx

; 1201 :   }

  00092	eb d5		 jmp	 SHORT $LN16@InternalWr
$LN17@InternalWr:

; 1202 :   *target = static_cast<uint8>(value);

  00094	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  00097	8a 45 f4	 mov	 al, BYTE PTR _value$[ebp]
  0009a	88 02		 mov	 BYTE PTR [edx], al

; 1203 :   return target + 1;

  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _target$[ebp]
  0009f	83 c1 01	 add	 ecx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 808  :   target = io::CodedOutputStream::WriteVarint32ToArray(

  000a2	89 4d 14	 mov	 DWORD PTR _target$[ebp], ecx

; 809  :     value.MessageType_WorkAroundCppLookupDefect::GetCachedSize(), target);
; 810  :   return value.InternalSerializeWithCachedSizesToArray(deterministic, target);

  000a5	8b 55 14	 mov	 edx, DWORD PTR _target$[ebp]
  000a8	52		 push	 edx
  000a9	0f b6 45 10	 movzx	 eax, BYTE PTR _deterministic$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000b1	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::command::InternalSerializeWithCachedSizesToArray

; 811  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$InternalWriteMessageNoVirtualToArray@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVcommand@NullPmd@@_NPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::command>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$ReadMessageNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVinfo@NullPmd@@@Z
_TEXT	SEGMENT
_p$ = -12						; size = 8
_length$ = -4						; size = 4
_input$ = 8						; size = 4
_value$ = 12						; size = 4
??$ReadMessageNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVinfo@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::info>, COMDAT

; 493  :     io::CodedInputStream* input, MessageType_WorkAroundCppLookupDefect* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 494  :   int length;
; 495  :   if (!input->ReadVarintSizeAsInt(&length)) return false;

  00006	8d 45 fc	 lea	 eax, DWORD PTR _length$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 04		 jne	 SHORT $LN2@ReadMessag
  00019	32 c0		 xor	 al, al
  0001b	eb 39		 jmp	 SHORT $LN1@ReadMessag
$LN2@ReadMessag:

; 496  :   std::pair<io::CodedInputStream::Limit, int> p =
; 497  :       input->IncrementRecursionDepthAndPushLimit(length);

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _length$[ebp]
  00020	52		 push	 edx
  00021	8d 45 f4	 lea	 eax, DWORD PTR _p$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00028	e8 00 00 00 00	 call	 ?IncrementRecursionDepthAndPushLimit@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@HH@std@@H@Z ; google::protobuf::io::CodedInputStream::IncrementRecursionDepthAndPushLimit

; 498  :   if (p.second < 0 || !value->

  0002d	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp+4], 0
  00031	7c 13		 jl	 SHORT $LN4@ReadMessag
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0003a	e8 00 00 00 00	 call	 ?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::info::MergePartialFromCodedStream
  0003f	0f b6 d0	 movzx	 edx, al
  00042	85 d2		 test	 edx, edx
  00044	75 04		 jne	 SHORT $LN3@ReadMessag
$LN4@ReadMessag:

; 499  :       MessageType_WorkAroundCppLookupDefect::MergePartialFromCodedStream(input))
; 500  :     return false;

  00046	32 c0		 xor	 al, al
  00048	eb 0c		 jmp	 SHORT $LN1@ReadMessag
$LN3@ReadMessag:

; 501  :   // Make sure that parsing stopped when the limit was hit, not at an endgroup
; 502  :   // tag.
; 503  :   return input->DecrementRecursionDepthAndPopLimit(p.first);

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00051	e8 00 00 00 00	 call	 ?DecrementRecursionDepthAndPopLimit@CodedInputStream@io@protobuf@google@@QAE_NH@Z ; google::protobuf::io::CodedInputStream::DecrementRecursionDepthAndPopLimit
$LN1@ReadMessag:

; 504  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$ReadMessageNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVinfo@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$ReadMessageNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVcommand@NullPmd@@@Z
_TEXT	SEGMENT
_p$ = -12						; size = 8
_length$ = -4						; size = 4
_input$ = 8						; size = 4
_value$ = 12						; size = 4
??$ReadMessageNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVcommand@NullPmd@@@Z PROC ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::command>, COMDAT

; 493  :     io::CodedInputStream* input, MessageType_WorkAroundCppLookupDefect* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 494  :   int length;
; 495  :   if (!input->ReadVarintSizeAsInt(&length)) return false;

  00006	8d 45 fc	 lea	 eax, DWORD PTR _length$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000d	e8 00 00 00 00	 call	 ?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 04		 jne	 SHORT $LN2@ReadMessag
  00019	32 c0		 xor	 al, al
  0001b	eb 39		 jmp	 SHORT $LN1@ReadMessag
$LN2@ReadMessag:

; 496  :   std::pair<io::CodedInputStream::Limit, int> p =
; 497  :       input->IncrementRecursionDepthAndPushLimit(length);

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _length$[ebp]
  00020	52		 push	 edx
  00021	8d 45 f4	 lea	 eax, DWORD PTR _p$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00028	e8 00 00 00 00	 call	 ?IncrementRecursionDepthAndPushLimit@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@HH@std@@H@Z ; google::protobuf::io::CodedInputStream::IncrementRecursionDepthAndPushLimit

; 498  :   if (p.second < 0 || !value->

  0002d	83 7d f8 00	 cmp	 DWORD PTR _p$[ebp+4], 0
  00031	7c 13		 jl	 SHORT $LN4@ReadMessag
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0003a	e8 00 00 00 00	 call	 ?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ; NullPmd::command::MergePartialFromCodedStream
  0003f	0f b6 d0	 movzx	 edx, al
  00042	85 d2		 test	 edx, edx
  00044	75 04		 jne	 SHORT $LN3@ReadMessag
$LN4@ReadMessag:

; 499  :       MessageType_WorkAroundCppLookupDefect::MergePartialFromCodedStream(input))
; 500  :     return false;

  00046	32 c0		 xor	 al, al
  00048	eb 0c		 jmp	 SHORT $LN1@ReadMessag
$LN3@ReadMessag:

; 501  :   // Make sure that parsing stopped when the limit was hit, not at an endgroup
; 502  :   // tag.
; 503  :   return input->DecrementRecursionDepthAndPopLimit(p.first);

  0004a	8b 45 f4	 mov	 eax, DWORD PTR _p$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00051	e8 00 00 00 00	 call	 ?DecrementRecursionDepthAndPopLimit@CodedInputStream@io@protobuf@google@@QAE_NH@Z ; google::protobuf::io::CodedInputStream::DecrementRecursionDepthAndPopLimit
$LN1@ReadMessag:

; 504  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$ReadMessageNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVcommand@NullPmd@@@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::command>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vhead@NullPmd@@@Arena@protobuf@google@@QAEXPAVhead@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vhead@NullPmd@@@Arena@protobuf@google@@QAEXPAVhead@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::head>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vhead@NullPmd@@@Arena@protobuf@google@@QAEXPAVhead@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::head>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVinfo@NullPmd@@@internal@protobuf@google@@YAPBVinfo@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVinfo@NullPmd@@@internal@protobuf@google@@YAPBVinfo@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::info const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@info@NullPmd@@SAABV12@XZ ; NullPmd::info::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVinfo@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVinfo@NullPmd@@@internal@protobuf@google@@YAPBVinfo@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::info const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vinfo@NullPmd@@@Arena@protobuf@google@@QAEXPAVinfo@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vinfo@NullPmd@@@Arena@protobuf@google@@QAEXPAVinfo@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::info>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vinfo@NullPmd@@@Arena@protobuf@google@@QAEXPAVinfo@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::info>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@_KX@std@@YAXAA_K0@Z
_TEXT	SEGMENT
__Tmp$ = -20						; size = 8
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@_KX@std@@YAXAA_K0@Z PROC			; std::swap<unsigned __int64,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 ec	 mov	 DWORD PTR __Tmp$[ebp], edx
  00014	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00017	89 45 f0	 mov	 DWORD PTR __Tmp$[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001d	89 4d f8	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00020	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00023	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	89 0a		 mov	 DWORD PTR [edx], ecx
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00030	8d 4d ec	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00033	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  00036	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00039	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	89 0a		 mov	 DWORD PTR [edx], ecx
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 70   : 	}

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$swap@_KX@std@@YAXAA_K0@Z ENDP			; std::swap<unsigned __int64,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVcommand@NullPmd@@@internal@protobuf@google@@YAPBVcommand@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVcommand@NullPmd@@@internal@protobuf@google@@YAPBVcommand@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::command const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@command@NullPmd@@SAABV12@XZ ; NullPmd::command::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVcommand@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVcommand@NullPmd@@@internal@protobuf@google@@YAPBVcommand@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::command const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vcommand@NullPmd@@@Arena@protobuf@google@@QAEXPAVcommand@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vcommand@NullPmd@@@Arena@protobuf@google@@QAEXPAVcommand@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::command>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vcommand@NullPmd@@@Arena@protobuf@google@@QAEXPAVcommand@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::command>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVindication@NullPmd@@@internal@protobuf@google@@YAPBVindication@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVindication@NullPmd@@@internal@protobuf@google@@YAPBVindication@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::indication const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@indication@NullPmd@@SAABV12@XZ ; NullPmd::indication::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVindication@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVindication@NullPmd@@@internal@protobuf@google@@YAPBVindication@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::indication const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vindication@NullPmd@@@Arena@protobuf@google@@QAEXPAVindication@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vindication@NullPmd@@@Arena@protobuf@google@@QAEXPAVindication@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::indication>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vindication@NullPmd@@@Arena@protobuf@google@@QAEXPAVindication@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::indication>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVresponse@NullPmd@@@internal@protobuf@google@@YAPBVresponse@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVresponse@NullPmd@@@internal@protobuf@google@@YAPBVresponse@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::response const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@response@NullPmd@@SAABV12@XZ ; NullPmd::response::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVresponse@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVresponse@NullPmd@@@internal@protobuf@google@@YAPBVresponse@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::response const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vresponse@NullPmd@@@Arena@protobuf@google@@QAEXPAVresponse@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vresponse@NullPmd@@@Arena@protobuf@google@@QAEXPAVresponse@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::response>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vresponse@NullPmd@@@Arena@protobuf@google@@QAEXPAVresponse@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::response>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_reflection.h
;	COMDAT ??$DynamicCastToGenerated@$$CBVrequest@NullPmd@@@internal@protobuf@google@@YAPBVrequest@NullPmd@@PBVMessage@12@@Z
_TEXT	SEGMENT
_unused$ = -8						; size = 4
_get_default_instance$ = -4				; size = 4
_from$ = 8						; size = 4
??$DynamicCastToGenerated@$$CBVrequest@NullPmd@@@internal@protobuf@google@@YAPBVrequest@NullPmd@@PBVMessage@12@@Z PROC ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::request const >, COMDAT

; 692  : T* DynamicCastToGenerated(const Message* from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 693  :   // Compile-time assert that T is a generated type that has a
; 694  :   // default_instance() accessor, but avoid actually calling it.
; 695  :   const T&(*get_default_instance)() = &T::default_instance;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _get_default_instance$[ebp], OFFSET ?default_instance@request@NullPmd@@SAABV12@XZ ; NullPmd::request::default_instance

; 696  :   (void)get_default_instance;
; 697  : 
; 698  :   // Compile-time assert that T is a subclass of google::protobuf::Message.
; 699  :   const Message* unused = static_cast<T*>(NULL);

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _unused$[ebp], 0

; 700  :   (void)unused;
; 701  : 
; 702  : #if defined(GOOGLE_PROTOBUF_NO_RTTI) || \
; 703  :   (defined(_MSC_VER) && !defined(_CPPRTTI))
; 704  :   bool ok = &T::default_instance() ==
; 705  :             from->GetReflection()->GetMessageFactory()->GetPrototype(
; 706  :                 from->GetDescriptor());
; 707  :   return ok ? down_cast<T*>(from) : NULL;
; 708  : #else
; 709  :   return dynamic_cast<T*>(from);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_R0?AVrequest@NullPmd@@@8
  0001b	68 00 00 00 00	 push	 OFFSET ??_R0?AVMessage@protobuf@google@@@8
  00020	6a 00		 push	 0
  00022	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___RTDynamicCast
  0002b	83 c4 14	 add	 esp, 20			; 00000014H

; 710  : #endif
; 711  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$DynamicCastToGenerated@$$CBVrequest@NullPmd@@@internal@protobuf@google@@YAPBVrequest@NullPmd@@PBVMessage@12@@Z ENDP ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::request const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@Vrequest@NullPmd@@@Arena@protobuf@google@@QAEXPAVrequest@NullPmd@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@Vrequest@NullPmd@@@Arena@protobuf@google@@QAEXPAVrequest@NullPmd@@@Z PROC ; google::protobuf::Arena::Own<NullPmd::request>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@Vrequest@NullPmd@@@Arena@protobuf@google@@QAEXPAVrequest@NullPmd@@@Z ENDP ; google::protobuf::Arena::Own<NullPmd::request>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??__Estatic_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
text$di	SEGMENT
??__Estatic_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::`dynamic initializer for 'static_descriptor_initializer'', COMDAT

; 199  : } static_descriptor_initializer;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  :     AddDescriptors();

  00003	e8 00 00 00 00	 call	 ?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors

; 199  : } static_descriptor_initializer;

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??__Estatic_descriptor_initializer@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::`dynamic initializer for 'static_descriptor_initializer''
text$di	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0StaticDescriptorInitializer@protobuf_NullPmd_2eproto@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0StaticDescriptorInitializer@protobuf_NullPmd_2eproto@NullPmd@@QAE@XZ PROC ; NullPmd::protobuf_NullPmd_2eproto::StaticDescriptorInitializer::StaticDescriptorInitializer, COMDAT
; _this$ = ecx

; 196  :   StaticDescriptorInitializer() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :     AddDescriptors();

  00007	e8 00 00 00 00	 call	 ?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors

; 198  :   }

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??0StaticDescriptorInitializer@protobuf_NullPmd_2eproto@NullPmd@@QAE@XZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::StaticDescriptorInitializer::StaticDescriptorInitializer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
_TEXT	SEGMENT
?AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptorsImpl, COMDAT

; 170  : void AddDescriptorsImpl() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  :   InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 172  :   static const char descriptor[] = {
; 173  :       "\n\rNullPmd.proto\022\007NullPmd\"\t\n\007request\"4\n\010r"
; 174  :       "esponse\022\016\n\006result\030\001 \001(\005\022\030\n\020errordescript"
; 175  :       "ion\030\002 \001(\t\"\014\n\nindication\"(\n\007command\022\016\n\006ma"
; 176  :       "inid\030\001 \001(\004\022\r\n\005subid\030\002 \001(\004\"D\n\004info\022\022\n\ncbd"
; 177  :       "atakind\030\001 \001(\004\022\023\n\013cbcheckcode\030\002 \001(\004\022\023\n\013wp"
; 178  :       "acketsize\030\003 \001(\004\"F\n\004head\022!\n\007command\030\001 \001(\013"
; 179  :       "2\020.NullPmd.command\022\033\n\004info\030\002 \001(\0132\r.NullP"
; 180  :       "md.info\"4\n\007message\022\033\n\004head\030\001 \001(\0132\r.NullP"
; 181  :       "md.head\022\014\n\004data\030\002 \001(\014b\006proto3"
; 182  :   };
; 183  :   ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(

  00008	68 5d 01 00 00	 push	 349			; 0000015dH
  0000d	68 00 00 00 00	 push	 OFFSET ?descriptor@?1??AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4QBDB
  00012	e8 00 00 00 00	 call	 ?InternalAddGeneratedFile@DescriptorPool@protobuf@google@@SAXPBXH@Z ; google::protobuf::DescriptorPool::InternalAddGeneratedFile
  00017	83 c4 08	 add	 esp, 8

; 184  :       descriptor, 349);
; 185  :   ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(

  0001a	68 00 00 00 00	 push	 OFFSET ?protobuf_RegisterTypes@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_RegisterTypes
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBNICMEM@NullPmd?4proto@
  00024	e8 00 00 00 00	 call	 ?InternalRegisterGeneratedFile@MessageFactory@protobuf@google@@SAXPBDP6AXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@Z ; google::protobuf::MessageFactory::InternalRegisterGeneratedFile
  00029	83 c4 08	 add	 esp, 8

; 186  :     "NullPmd.proto", &protobuf_RegisterTypes);
; 187  :   ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);

  0002c	68 00 00 00 00	 push	 OFFSET ?Shutdown@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::Shutdown
  00031	e8 00 00 00 00	 call	 ?OnShutdown@internal@protobuf@google@@YAXP6AXXZ@Z ; google::protobuf::internal::OnShutdown
  00036	83 c4 04	 add	 esp, 4

; 188  : }

  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptorsImpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?protobuf_RegisterTypes@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?protobuf_RegisterTypes@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_RegisterTypes, COMDAT

; 123  : void protobuf_RegisterTypes(const ::std::string&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 124  :   protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 125  :   ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 7);

  00008	6a 07		 push	 7
  0000a	68 00 00 00 00	 push	 OFFSET ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::file_level_metadata
  0000f	e8 00 00 00 00	 call	 ?RegisterAllTypes@internal@protobuf@google@@YAXPBUMetadata@23@H@Z ; google::protobuf::internal::RegisterAllTypes
  00014	83 c4 08	 add	 esp, 8

; 126  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?protobuf_RegisterTypes@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_RegisterTypes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
_TEXT	SEGMENT
?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce, COMDAT

; 117  : void protobuf_AssignDescriptorsOnce() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 118  :   static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
; 119  :   ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);

  00003	68 00 00 00 00	 push	 OFFSET ?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptors
  00008	68 00 00 00 00	 push	 OFFSET ?once@?1??protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
  0000d	e8 00 00 00 00	 call	 ?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z ; google::protobuf::GoogleOnceInit
  00012	83 c4 08	 add	 esp, 8

; 120  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
_TEXT	SEGMENT
_factory$ = -48						; size = 4
$T2 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptors, COMDAT

; 109  : void protobuf_AssignDescriptors() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 110  :   AddDescriptors();

  00028	e8 00 00 00 00	 call	 ?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors

; 111  :   ::google::protobuf::MessageFactory* factory = NULL;

  0002d	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _factory$[ebp], 0

; 112  :   AssignDescriptors(

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0O@PBNICMEM@NullPmd?4proto@
  00039	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  0003c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	68 00 00 00 00	 push	 OFFSET ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::file_level_metadata
  00051	8b 45 d0	 mov	 eax, DWORD PTR _factory$[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ?offsets@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@2QBIB ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::offsets
  0005a	68 00 00 00 00	 push	 OFFSET ?file_default_instances@protobuf_NullPmd_2eproto@NullPmd@@3QBQBVMessage@protobuf@google@@B
  0005f	68 00 00 00 00	 push	 OFFSET ?schemas@protobuf_NullPmd_2eproto@NullPmd@@3QBUMigrationSchema@internal@protobuf@google@@B
  00064	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?AssignDescriptors@internal@protobuf@google@@YAXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBUMigrationSchema@123@PBQBVMessage@23@PBIPAVMessageFactory@23@PAUMetadata@23@PAPBVEnumDescriptor@23@PAPBVServiceDescriptor@23@@Z ; google::protobuf::internal::AssignDescriptors
  0006d	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00070	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2460 : 		_Tidy_deallocate();

  00077	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0007f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1949 : 		_Free_proxy();

  00083	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00086	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0008b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 115  : }

  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a0	33 cd		 xor	 ecx, ebp
  000a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?protobuf_AssignDescriptors@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptors
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEPAVmessage@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEPAVmessage@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEPAVmessage@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vmessage@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::message>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEPAVhead@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEPAVhead@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEPAVhead@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@XZ	; NullPmd::head::head

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vhead@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::head>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEPAVinfo@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEPAVinfo@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEPAVinfo@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 28	 movzx	 ecx, BYTE PTR [eax+40]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 28 00	 mov	 BYTE PTR [edx+40], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@XZ	; NullPmd::info::info

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 28 01	 mov	 BYTE PTR [ecx+40], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vinfo@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::info>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEPAVcommand@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEPAVcommand@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEPAVcommand@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 20	 movzx	 ecx, BYTE PTR [eax+32]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 20 00	 mov	 BYTE PTR [edx+32], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@XZ ; NullPmd::command::command

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vcommand@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::command>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEPAVindication@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEPAVindication@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEPAVindication@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0indication@NullPmd@@QAE@XZ ; NullPmd::indication::indication

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 10 01	 mov	 BYTE PTR [ecx+16], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vindication@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::indication>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEPAVresponse@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEPAVresponse@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEPAVresponse@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 18 00	 mov	 BYTE PTR [edx+24], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0response@NullPmd@@QAE@XZ ; NullPmd::response::response

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vresponse@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::response>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get_mutable@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEPAVrequest@NullPmd@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get_mutable@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEPAVrequest@NullPmd@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::get_mutable, COMDAT
; _this$ = ecx

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get_mutable@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEPAVrequest@NullPmd@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::get_mutable
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?Shutdown@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Shutdown@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::Shutdown, COMDAT
; _this$ = ecx

; 95   :   void Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :     if (init_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 10	 movzx	 ecx, BYTE PTR [eax+16]
  00010	85 c9		 test	 ecx, ecx
  00012	74 1b		 je	 SHORT $LN1@Shutdown

; 97   :       init_ = false;

  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	c6 42 10 00	 mov	 BYTE PTR [edx+16], 0

; 109  :   T* get_mutable() { return reinterpret_cast<T*>(&union_); }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 98   :       get_mutable()->~T();

  0001e	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00021	6a 00		 push	 0
  00023	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  0002b	8b 02		 mov	 eax, DWORD PTR [edx]
  0002d	ff d0		 call	 eax
$LN1@Shutdown:

; 99   :     }
; 100  :   }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?Shutdown@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?DefaultConstruct@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DefaultConstruct@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ PROC ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::DefaultConstruct, COMDAT
; _this$ = ecx

; 89   :   void DefaultConstruct() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   :     new (&union_) T();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	e8 00 00 00 00	 call	 ??0request@NullPmd@@QAE@XZ ; NullPmd::request::request

; 91   :     init_ = true;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	c6 41 10 01	 mov	 BYTE PTR [ecx+16], 1

; 92   :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?DefaultConstruct@?$ExplicitlyConstructed@Vrequest@NullPmd@@@internal@protobuf@google@@QAEXXZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<NullPmd::request>::DefaultConstruct
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$ReadPrimitive@_K$03@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PA_K@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_value$ = 12						; size = 4
??$ReadPrimitive@_K$03@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PA_K@Z PROC ; google::protobuf::internal::WireFormatLite::ReadPrimitive<unsigned __int64,4>, COMDAT

; 87   :     uint64* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 88   :   return input->ReadVarint64(value);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000a	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64

; 89   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$ReadPrimitive@_K$03@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PA_K@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadPrimitive<unsigned __int64,4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ??$ReadPrimitive@H$04@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAH@Z
_TEXT	SEGMENT
_temp$ = -4						; size = 4
_input$ = 8						; size = 4
_value$ = 12						; size = 4
??$ReadPrimitive@H$04@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAH@Z PROC ; google::protobuf::internal::WireFormatLite::ReadPrimitive<int,5>, COMDAT

; 63   :     int32* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 64   :   uint32 temp;
; 65   :   if (!input->ReadVarint32(&temp)) return false;

  00004	8d 45 fc	 lea	 eax, DWORD PTR _temp$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000b	e8 00 00 00 00	 call	 ?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z ; google::protobuf::io::CodedInputStream::ReadVarint32
  00010	0f b6 c8	 movzx	 ecx, al
  00013	85 c9		 test	 ecx, ecx
  00015	75 04		 jne	 SHORT $LN2@ReadPrimit
  00017	32 c0		 xor	 al, al
  00019	eb 0a		 jmp	 SHORT $LN1@ReadPrimit
$LN2@ReadPrimit:

; 66   :   *value = static_cast<int32>(temp);

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _temp$[ebp]
  00021	89 02		 mov	 DWORD PTR [edx], eax

; 67   :   return true;

  00023	b0 01		 mov	 al, 1
$LN1@ReadPrimit:

; 68   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$ReadPrimitive@H$04@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAH@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadPrimitive<int,5>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?LengthDelimitedSize@WireFormatLite@internal@protobuf@google@@SAII@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_length$ = 8						; size = 4
?LengthDelimitedSize@WireFormatLite@internal@protobuf@google@@SAII@Z PROC ; google::protobuf::internal::WireFormatLite::LengthDelimitedSize, COMDAT

; 866  : inline size_t WireFormatLite::LengthDelimitedSize(size_t length) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  00004	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  0000b	73 0b		 jae	 SHORT $LN4@LengthDeli

; 1296 :     return 1;

  0000d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00014	eb 11		 jmp	 SHORT $LN3@LengthDeli

; 1297 :   } else  {

  00016	eb 0f		 jmp	 SHORT $LN3@LengthDeli
$LN4@LengthDeli:

; 1298 :     return VarintSize32Fallback(value);

  00018	8b 45 08	 mov	 eax, DWORD PTR _length$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00021	83 c4 04	 add	 esp, 4
  00024	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
$LN3@LengthDeli:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  00027	8b 45 08	 mov	 eax, DWORD PTR _length$[ebp]
  0002a	03 45 fc	 add	 eax, DWORD PTR $T1[ebp]

; 872  :       static_cast<uint32>(length));
; 873  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?LengthDelimitedSize@WireFormatLite@internal@protobuf@google@@SAII@Z ENDP ; google::protobuf::internal::WireFormatLite::LengthDelimitedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?BytesSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
_value$ = 8						; size = 4
?BytesSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::WireFormatLite::BytesSize, COMDAT

; 840  : inline size_t WireFormatLite::BytesSize(const string& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00006	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  00012	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  0001b	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR $T4[ebp], 128	; 00000080H
  00022	73 0b		 jae	 SHORT $LN15@BytesSize

; 1296 :     return 1;

  00024	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  0002b	eb 11		 jmp	 SHORT $LN12@BytesSize

; 1297 :   } else  {

  0002d	eb 0f		 jmp	 SHORT $LN12@BytesSize
$LN15@BytesSize:

; 1298 :     return VarintSize32Fallback(value);

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
$LN12@BytesSize:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  00041	03 45 f8	 add	 eax, DWORD PTR $T3[ebp]

; 841  :   return LengthDelimitedSize(value.size());
; 842  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?BytesSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::WireFormatLite::BytesSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?StringSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
_value$ = 8						; size = 4
?StringSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::WireFormatLite::StringSize, COMDAT

; 837  : inline size_t WireFormatLite::StringSize(const string& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00006	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  00012	8b 55 f0	 mov	 edx, DWORD PTR $T1[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  0001b	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR $T4[ebp], 128	; 00000080H
  00022	73 0b		 jae	 SHORT $LN15@StringSize

; 1296 :     return 1;

  00024	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
  0002b	eb 11		 jmp	 SHORT $LN12@StringSize

; 1297 :   } else  {

  0002d	eb 0f		 jmp	 SHORT $LN12@StringSize
$LN15@StringSize:

; 1298 :     return VarintSize32Fallback(value);

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
$LN12@StringSize:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  00041	03 45 f8	 add	 eax, DWORD PTR $T3[ebp]

; 838  :   return LengthDelimitedSize(value.size());
; 839  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?StringSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::WireFormatLite::StringSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?UInt64Size@WireFormatLite@internal@protobuf@google@@SAI_K@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
?UInt64Size@WireFormatLite@internal@protobuf@google@@SAI_K@Z PROC ; google::protobuf::internal::WireFormatLite::UInt64Size, COMDAT

; 824  : inline size_t WireFormatLite::UInt64Size(uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp+4]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  00010	83 c4 08	 add	 esp, 8

; 826  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?UInt64Size@WireFormatLite@internal@protobuf@google@@SAI_K@Z ENDP ; google::protobuf::internal::WireFormatLite::UInt64Size
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?Int32Size@WireFormatLite@internal@protobuf@google@@SAIH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_value$ = 8						; size = 4
?Int32Size@WireFormatLite@internal@protobuf@google@@SAIH@Z PROC ; google::protobuf::internal::WireFormatLite::Int32Size, COMDAT

; 815  : inline size_t WireFormatLite::Int32Size(int32 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1303 :   if (value < 0) {

  00006	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  0000a	7d 0b		 jge	 SHORT $LN4@Int32Size

; 1304 :     return 10;     // TODO(kenton):  Make this a symbolic constant.

  0000c	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR $T1[ebp], 10	; 0000000aH
  00013	eb 2b		 jmp	 SHORT $LN3@Int32Size

; 1305 :   } else {

  00015	eb 29		 jmp	 SHORT $LN3@Int32Size
$LN4@Int32Size:

; 1295 :   if (value < (1 << 7)) {

  00017	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  0001e	73 0b		 jae	 SHORT $LN8@Int32Size

; 1296 :     return 1;

  00020	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  00027	eb 11		 jmp	 SHORT $LN7@Int32Size

; 1297 :   } else  {

  00029	eb 0f		 jmp	 SHORT $LN7@Int32Size
$LN8@Int32Size:

; 1298 :     return VarintSize32Fallback(value);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
$LN7@Int32Size:

; 1306 :     return VarintSize32(static_cast<uint32>(value));

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  0003d	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
$LN3@Int32Size:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 816  :   return io::CodedOutputStream::VarintSize32SignExtended(value);

  00040	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 817  : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?Int32Size@WireFormatLite@internal@protobuf@google@@SAIH@Z ENDP ; google::protobuf::internal::WireFormatLite::Int32Size
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteBytesToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z
_TEXT	SEGMENT
_target$1 = -8						; size = 4
_value$2 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_target$ = 16						; size = 4
?WriteBytesToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteBytesToArray, COMDAT

; 771  :                                                 uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx
$LN10@WriteBytes:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$2[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN11@WriteBytes

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$2[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$2[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$1[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN10@WriteBytes
$LN11@WriteBytes:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$2[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  0004e	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 772  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  00051	89 55 10	 mov	 DWORD PTR _target$[ebp], edx

; 773  :   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);

  00054	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?WriteStringWithSizeToArray@CodedOutputStream@io@protobuf@google@@SAPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; google::protobuf::io::CodedOutputStream::WriteStringWithSizeToArray
  00061	83 c4 08	 add	 esp, 8

; 774  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?WriteBytesToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteBytesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteStringToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z
_TEXT	SEGMENT
_target$1 = -8						; size = 4
_value$2 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_target$ = 16						; size = 4
?WriteStringToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteStringToArray, COMDAT

; 761  :                                                  uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx
$LN10@WriteStrin:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$2[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN11@WriteStrin

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$2[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$2[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$1[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN10@WriteStrin
$LN11@WriteStrin:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$2[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  0004e	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 766  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  00051	89 55 10	 mov	 DWORD PTR _target$[ebp], edx

; 767  :   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);

  00054	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ?WriteStringWithSizeToArray@CodedOutputStream@io@protobuf@google@@SAPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; google::protobuf::io::CodedOutputStream::WriteStringWithSizeToArray
  00061	83 c4 08	 add	 esp, 8

; 768  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
?WriteStringToArray@WireFormatLite@internal@protobuf@google@@SAPAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteStringToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z
_TEXT	SEGMENT
_value$ = -20						; size = 8
_target$ = -12						; size = 4
_target$1 = -8						; size = 4
_value$2 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 8
_target$ = 20						; size = 4
?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray, COMDAT

; 694  :                                                  uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 14	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$1[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00012	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx
$LN10@WriteUInt6:

; 1197 :   while (value >= 0x80) {

  00015	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$2[ebp], 128 ; 00000080H
  0001c	72 22		 jb	 SHORT $LN11@WriteUInt6

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _value$2[ebp]
  00021	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00027	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  0002a	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _value$2[ebp]
  0002f	c1 e9 07	 shr	 ecx, 7
  00032	89 4d fc	 mov	 DWORD PTR _value$2[ebp], ecx

; 1200 :     ++target;

  00035	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 f8	 mov	 DWORD PTR _target$1[ebp], edx

; 1201 :   }

  0003e	eb d5		 jmp	 SHORT $LN10@WriteUInt6
$LN11@WriteUInt6:

; 1202 :   *target = static_cast<uint8>(value);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _target$1[ebp]
  00043	8a 4d fc	 mov	 cl, BYTE PTR _value$2[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  00048	8b 55 f8	 mov	 edx, DWORD PTR _target$1[ebp]
  0004b	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 695  :   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);

  0004e	89 55 14	 mov	 DWORD PTR _target$[ebp], edx

; 625  :   return io::CodedOutputStream::WriteVarint64ToArray(value, target);

  00051	8b 45 14	 mov	 eax, DWORD PTR _target$[ebp]
  00054	89 45 f4	 mov	 DWORD PTR _target$[ebp], eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0005a	89 4d ec	 mov	 DWORD PTR _value$[ebp], ecx
  0005d	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp+4]
  00060	89 55 f0	 mov	 DWORD PTR _value$[ebp+4], edx
$LN16@WriteUInt6:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1208 :   while (value >= 0x80) {

  00063	83 7d f0 00	 cmp	 DWORD PTR _value$[ebp+4], 0
  00067	77 09		 ja	 SHORT $LN19@WriteUInt6
  00069	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00070	72 2b		 jb	 SHORT $LN17@WriteUInt6
$LN19@WriteUInt6:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00072	8b 45 ec	 mov	 eax, DWORD PTR _value$[ebp]
  00075	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  0007d	88 01		 mov	 BYTE PTR [ecx], al

; 1210 :     value >>= 7;

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _value$[ebp]
  00082	8b 55 f0	 mov	 edx, DWORD PTR _value$[ebp+4]
  00085	b1 07		 mov	 cl, 7
  00087	e8 00 00 00 00	 call	 __aullshr
  0008c	89 45 ec	 mov	 DWORD PTR _value$[ebp], eax
  0008f	89 55 f0	 mov	 DWORD PTR _value$[ebp+4], edx

; 1211 :     ++target;

  00092	8b 55 f4	 mov	 edx, DWORD PTR _target$[ebp]
  00095	83 c2 01	 add	 edx, 1
  00098	89 55 f4	 mov	 DWORD PTR _target$[ebp], edx

; 1212 :   }

  0009b	eb c6		 jmp	 SHORT $LN16@WriteUInt6
$LN17@WriteUInt6:

; 1213 :   *target = static_cast<uint8>(value);

  0009d	8a 45 ec	 mov	 al, BYTE PTR _value$[ebp]
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _target$[ebp]
  000a3	88 01		 mov	 BYTE PTR [ecx], al

; 1214 :   return target + 1;

  000a5	8b 45 f4	 mov	 eax, DWORD PTR _target$[ebp]
  000a8	83 c0 01	 add	 eax, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 697  : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteInt32ToArray@WireFormatLite@internal@protobuf@google@@SAPAEHHPAE@Z
_TEXT	SEGMENT
_value$1 = -20						; size = 8
_target$2 = -12						; size = 4
_target$3 = -8						; size = 4
_value$4 = -4						; size = 4
_field_number$ = 8					; size = 4
_value$ = 12						; size = 4
_target$ = 16						; size = 4
?WriteInt32ToArray@WireFormatLite@internal@protobuf@google@@SAPAEHHPAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteInt32ToArray, COMDAT

; 676  :                                                 uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$3[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00012	89 4d fc	 mov	 DWORD PTR _value$4[ebp], ecx
$LN10@WriteInt32:

; 1197 :   while (value >= 0x80) {

  00015	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$4[ebp], 128 ; 00000080H
  0001c	72 22		 jb	 SHORT $LN11@WriteInt32

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _value$4[ebp]
  00021	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00027	8b 45 f8	 mov	 eax, DWORD PTR _target$3[ebp]
  0002a	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _value$4[ebp]
  0002f	c1 e9 07	 shr	 ecx, 7
  00032	89 4d fc	 mov	 DWORD PTR _value$4[ebp], ecx

; 1200 :     ++target;

  00035	8b 55 f8	 mov	 edx, DWORD PTR _target$3[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 f8	 mov	 DWORD PTR _target$3[ebp], edx

; 1201 :   }

  0003e	eb d5		 jmp	 SHORT $LN10@WriteInt32
$LN11@WriteInt32:

; 1202 :   *target = static_cast<uint8>(value);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _target$3[ebp]
  00043	8a 4d fc	 mov	 cl, BYTE PTR _value$4[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  00048	8b 55 f8	 mov	 edx, DWORD PTR _target$3[ebp]
  0004b	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 677  :   target = WriteTagToArray(field_number, WIRETYPE_VARINT, target);

  0004e	89 55 10	 mov	 DWORD PTR _target$[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1223 :   return WriteVarint64ToArray(static_cast<uint64>(value), target);

  00051	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00054	89 45 f4	 mov	 DWORD PTR _target$2[ebp], eax
  00057	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0005a	99		 cdq
  0005b	89 45 ec	 mov	 DWORD PTR _value$1[ebp], eax
  0005e	89 55 f0	 mov	 DWORD PTR _value$1[ebp+4], edx
$LN18@WriteInt32:

; 1208 :   while (value >= 0x80) {

  00061	83 7d f0 00	 cmp	 DWORD PTR _value$1[ebp+4], 0
  00065	77 09		 ja	 SHORT $LN21@WriteInt32
  00067	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _value$1[ebp], 128 ; 00000080H
  0006e	72 2c		 jb	 SHORT $LN19@WriteInt32
$LN21@WriteInt32:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00070	8b 4d ec	 mov	 ecx, DWORD PTR _value$1[ebp]
  00073	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00079	8b 55 f4	 mov	 edx, DWORD PTR _target$2[ebp]
  0007c	88 0a		 mov	 BYTE PTR [edx], cl

; 1210 :     value >>= 7;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR _value$1[ebp]
  00081	8b 55 f0	 mov	 edx, DWORD PTR _value$1[ebp+4]
  00084	b1 07		 mov	 cl, 7
  00086	e8 00 00 00 00	 call	 __aullshr
  0008b	89 45 ec	 mov	 DWORD PTR _value$1[ebp], eax
  0008e	89 55 f0	 mov	 DWORD PTR _value$1[ebp+4], edx

; 1211 :     ++target;

  00091	8b 45 f4	 mov	 eax, DWORD PTR _target$2[ebp]
  00094	83 c0 01	 add	 eax, 1
  00097	89 45 f4	 mov	 DWORD PTR _target$2[ebp], eax

; 1212 :   }

  0009a	eb c5		 jmp	 SHORT $LN18@WriteInt32
$LN19@WriteInt32:

; 1213 :   *target = static_cast<uint8>(value);

  0009c	8a 4d ec	 mov	 cl, BYTE PTR _value$1[ebp]
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _target$2[ebp]
  000a2	88 0a		 mov	 BYTE PTR [edx], cl

; 1214 :   return target + 1;

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _target$2[ebp]
  000a7	83 c0 01	 add	 eax, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 679  : }

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?WriteInt32ToArray@WireFormatLite@internal@protobuf@google@@SAPAEHHPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteInt32ToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteUInt64NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAE_KPAE@Z
_TEXT	SEGMENT
_value$ = -12						; size = 8
_target$ = -4						; size = 4
_value$ = 8						; size = 8
_target$ = 16						; size = 4
?WriteUInt64NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAE_KPAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteUInt64NoTagToArray, COMDAT

; 624  :                                                       uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 625  :   return io::CodedOutputStream::WriteVarint64ToArray(value, target);

  00006	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000f	89 4d f4	 mov	 DWORD PTR _value$[ebp], ecx
  00012	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00015	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx
$LN4@WriteUInt6:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1208 :   while (value >= 0x80) {

  00018	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp+4], 0
  0001c	77 09		 ja	 SHORT $LN7@WriteUInt6
  0001e	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00025	72 2b		 jb	 SHORT $LN5@WriteUInt6
$LN7@WriteUInt6:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00027	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  0002a	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _target$[ebp]
  00032	88 01		 mov	 BYTE PTR [ecx], al

; 1210 :     value >>= 7;

  00034	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00037	8b 55 f8	 mov	 edx, DWORD PTR _value$[ebp+4]
  0003a	b1 07		 mov	 cl, 7
  0003c	e8 00 00 00 00	 call	 __aullshr
  00041	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
  00044	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx

; 1211 :     ++target;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _target$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 fc	 mov	 DWORD PTR _target$[ebp], edx

; 1212 :   }

  00050	eb c6		 jmp	 SHORT $LN4@WriteUInt6
$LN5@WriteUInt6:

; 1213 :   *target = static_cast<uint8>(value);

  00052	8a 45 f4	 mov	 al, BYTE PTR _value$[ebp]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _target$[ebp]
  00058	88 01		 mov	 BYTE PTR [ecx], al

; 1214 :   return target + 1;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  0005d	83 c0 01	 add	 eax, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 626  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?WriteUInt64NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAE_KPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteUInt64NoTagToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteInt32NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHPAE@Z
_TEXT	SEGMENT
_value$ = -12						; size = 8
_target$ = -4						; size = 4
_value$ = 8						; size = 4
_target$ = 12						; size = 4
?WriteInt32NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHPAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteInt32NoTagToArray, COMDAT

; 611  :                                                      uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1223 :   return WriteVarint64ToArray(static_cast<uint64>(value), target);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax
  0000c	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000f	99		 cdq
  00010	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
  00013	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx
$LN6@WriteInt32:

; 1208 :   while (value >= 0x80) {

  00016	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp+4], 0
  0001a	77 09		 ja	 SHORT $LN9@WriteInt32
  0001c	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00023	72 2c		 jb	 SHORT $LN7@WriteInt32
$LN9@WriteInt32:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _value$[ebp]
  00028	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _target$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 1210 :     value >>= 7;

  00033	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00036	8b 55 f8	 mov	 edx, DWORD PTR _value$[ebp+4]
  00039	b1 07		 mov	 cl, 7
  0003b	e8 00 00 00 00	 call	 __aullshr
  00040	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
  00043	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx

; 1211 :     ++target;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax

; 1212 :   }

  0004f	eb c5		 jmp	 SHORT $LN6@WriteInt32
$LN7@WriteInt32:

; 1213 :   *target = static_cast<uint8>(value);

  00051	8a 4d f4	 mov	 cl, BYTE PTR _value$[ebp]
  00054	8b 55 fc	 mov	 edx, DWORD PTR _target$[ebp]
  00057	88 0a		 mov	 BYTE PTR [edx], cl

; 1214 :   return target + 1;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  0005c	83 c0 01	 add	 eax, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 613  : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?WriteInt32NoTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHPAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteInt32NoTagToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
;	COMDAT ?WriteTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHW4WireType@1234@PAE@Z
_TEXT	SEGMENT
_target$ = -8						; size = 4
_value$ = -4						; size = 4
_field_number$ = 8					; size = 4
_type$ = 12						; size = 4
_target$ = 16						; size = 4
?WriteTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHW4WireType@1234@PAE@Z PROC ; google::protobuf::internal::WireFormatLite::WriteTagToArray, COMDAT

; 605  :                                               uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _field_number$[ebp]
  0000f	c1 e1 03	 shl	 ecx, 3
  00012	0b 4d 0c	 or	 ecx, DWORD PTR _type$[ebp]
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00015	89 4d fc	 mov	 DWORD PTR _value$[ebp], ecx
$LN8@WriteTagTo:

; 1197 :   while (value >= 0x80) {

  00018	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  0001f	72 22		 jb	 SHORT $LN9@WriteTagTo

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  00021	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  00024	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0002d	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _value$[ebp]
  00032	c1 e9 07	 shr	 ecx, 7
  00035	89 4d fc	 mov	 DWORD PTR _value$[ebp], ecx

; 1200 :     ++target;

  00038	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 f8	 mov	 DWORD PTR _target$[ebp], edx

; 1201 :   }

  00041	eb d5		 jmp	 SHORT $LN8@WriteTagTo
$LN9@WriteTagTo:

; 1202 :   *target = static_cast<uint8>(value);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00046	8a 4d fc	 mov	 cl, BYTE PTR _value$[ebp]
  00049	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  0004e	83 c0 01	 add	 eax, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 608  : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?WriteTagToArray@WireFormatLite@internal@protobuf@google@@SAPAEHW4WireType@1234@PAE@Z ENDP ; google::protobuf::internal::WireFormatLite::WriteTagToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
;	COMDAT ?ReadString@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_input$ = 8						; size = 4
_value$ = 12						; size = 4
?ReadString@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::WireFormatLite::ReadString, COMDAT

; 738  :                                        string* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 739  :   return ReadBytes(input, value);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ?ReadBytes@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::ReadBytes
  00010	83 c4 08	 add	 esp, 8

; 740  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?ReadString@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::WireFormatLite::ReadString
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
;	COMDAT ?GetTagFieldNumber@WireFormatLite@internal@protobuf@google@@SAHI@Z
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?GetTagFieldNumber@WireFormatLite@internal@protobuf@google@@SAHI@Z PROC ; google::protobuf::internal::WireFormatLite::GetTagFieldNumber, COMDAT

; 652  : inline int WireFormatLite::GetTagFieldNumber(uint32 tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  00003	8b 45 08	 mov	 eax, DWORD PTR _tag$[ebp]
  00006	c1 e8 03	 shr	 eax, 3

; 654  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?GetTagFieldNumber@WireFormatLite@internal@protobuf@google@@SAHI@Z ENDP ; google::protobuf::internal::WireFormatLite::GetTagFieldNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
;	COMDAT ?GetTagWireType@WireFormatLite@internal@protobuf@google@@SA?AW4WireType@1234@I@Z
_TEXT	SEGMENT
_tag$ = 8						; size = 4
?GetTagWireType@WireFormatLite@internal@protobuf@google@@SA?AW4WireType@1234@I@Z PROC ; google::protobuf::internal::WireFormatLite::GetTagWireType, COMDAT

; 648  : inline WireFormatLite::WireType WireFormatLite::GetTagWireType(uint32 tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00003	8b 45 08	 mov	 eax, DWORD PTR _tag$[ebp]
  00006	83 e0 07	 and	 eax, 7

; 650  : }

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?GetTagWireType@WireFormatLite@internal@protobuf@google@@SA?AW4WireType@1234@I@Z ENDP ; google::protobuf::internal::WireFormatLite::GetTagWireType
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
;	COMDAT ?MakeTag@WireFormatLite@internal@protobuf@google@@SAIHW4WireType@1234@@Z
_TEXT	SEGMENT
_field_number$ = 8					; size = 4
_type$ = 12						; size = 4
?MakeTag@WireFormatLite@internal@protobuf@google@@SAIHW4WireType@1234@@Z PROC ; google::protobuf::internal::WireFormatLite::MakeTag, COMDAT

; 644  : inline uint32 WireFormatLite::MakeTag(int field_number, WireType type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  00003	8b 45 08	 mov	 eax, DWORD PTR _field_number$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	0b 45 0c	 or	 eax, DWORD PTR _type$[ebp]

; 646  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?MakeTag@WireFormatLite@internal@protobuf@google@@SAIHW4WireType@1234@@Z ENDP ; google::protobuf::internal::WireFormatLite::MakeTag
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gmessage@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gmessage@NullPmd@@UAEPAXI@Z PROC			; NullPmd::message::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gmessage@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::message::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ PROC	; NullPmd::message::mutable_head, COMDAT
; _this$ = ecx

; 962  : inline ::NullPmd::head* message::mutable_head() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 963  :   
; 964  :   if (head_ == NULL) {

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002f	75 44		 jne	 SHORT $LN2@mutable_he

; 965  :     head_ = new ::NullPmd::head;

  00031	6a 14		 push	 20			; 00000014H
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00049	74 0d		 je	 SHORT $LN4@mutable_he
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004e	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@XZ	; NullPmd::head::head
  00053	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00056	eb 07		 jmp	 SHORT $LN5@mutable_he
$LN4@mutable_he:
  00058	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN5@mutable_he:
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00062	89 4d e4	 mov	 DWORD PTR $T2[ebp], ecx
  00065	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00072	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN2@mutable_he:

; 966  :   }
; 967  :   // @@protoc_insertion_point(field_mutable:NullPmd.message.head)
; 968  :   return head_;

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 969  : }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ ENDP	; NullPmd::message::mutable_head
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?head@message@NullPmd@@QBEABV02@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?head@message@NullPmd@@QBEABV02@XZ PROC			; NullPmd::message::head, COMDAT
; _this$ = ecx

; 957  : inline const ::NullPmd::head& message::head() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 958  :   // @@protoc_insertion_point(field_get:NullPmd.message.head)
; 959  :   return head_ != NULL ? *head_

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	74 0b		 je	 SHORT $LN5@head
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00018	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  0001b	eb 07		 jmp	 SHORT $LN4@head
$LN5@head:
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
$LN4@head:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00027	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 960  :                          : *::NullPmd::head::internal_default_instance();
; 961  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?head@message@NullPmd@@QBEABV02@XZ ENDP			; NullPmd::message::head
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?has_head@message@NullPmd@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?has_head@message@NullPmd@@QBE_NXZ PROC			; NullPmd::message::has_head, COMDAT
; _this$ = ecx

; 950  : inline bool message::has_head() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 951  :   return this != internal_default_instance() && head_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00010	74 12		 je	 SHORT $LN3@has_head
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00019	74 09		 je	 SHORT $LN3@has_head
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@has_head
$LN3@has_head:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@has_head:
  0002b	8a 45 f8	 mov	 al, BYTE PTR tv68[ebp]

; 952  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?has_head@message@NullPmd@@QBE_NXZ ENDP			; NullPmd::message::has_head
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mutable_data@message@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_default_value$ = -8					; size = 4
_this$ = -4						; size = 4
?mutable_data@message@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; NullPmd::message::mutable_data, COMDAT
; _this$ = ecx

; 1020 : inline ::std::string* message::mutable_data() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1023 :   return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _default_value$[ebp], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 08	 add	 eax, 8
  00016	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 228  :     if (ptr_ == default_value) {

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	3b 55 f8	 cmp	 edx, DWORD PTR _default_value$[ebp]
  00021	75 0c		 jne	 SHORT $LN8@mutable_da

; 229  :       CreateInstanceNoArena(default_value);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _default_value$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
$LN8@mutable_da:

; 230  :     }
; 231  :     return ptr_;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 1023 :   return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00037	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 1024 : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?mutable_data@message@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; NullPmd::message::mutable_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_data@message@NullPmd@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
tv75 = -52						; size = 4
tv69 = -48						; size = 4
$T2 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?set_data@message@NullPmd@@QAEXPBD@Z PROC		; NullPmd::message::set_data, COMDAT
; _this$ = ecx

; 1009 : inline void message::set_data(const char* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?set_data@message@NullPmd@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 1010 :   
; 1011 :   data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));

  0002b	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00037	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  0003a	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  0003d	89 4d cc	 mov	 DWORD PTR tv75[ebp], ecx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00047	8b 55 cc	 mov	 edx, DWORD PTR tv75[ebp]
  0004a	52		 push	 edx
  0004b	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  00050	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 08	 add	 ecx, 8
  00056	e8 00 00 00 00	 call	 ?SetNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QAV56@@Z ; google::protobuf::internal::ArenaStringPtr::SetNoArena
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  0005b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2460 : 		_Tidy_deallocate();

  00062	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00065	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0006a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1949 : 		_Free_proxy();

  0006e	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00071	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 1013 : }

  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?set_data@message@NullPmd@@QAEXPBD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?set_data@message@NullPmd@@QAEXPBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?set_data@message@NullPmd@@QAEXPBD@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?set_data@message@NullPmd@@QAEXPBD@Z ENDP		; NullPmd::message::set_data
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?data@message@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?data@message@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; NullPmd::message::data, COMDAT
; _this$ = ecx

; 992  : inline const ::std::string& message::data() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 994  :   return data_.GetNoArena();

  00012	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 995  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?data@message@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; NullPmd::message::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?clear_data@message@NullPmd@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear_data@message@NullPmd@@QAEXXZ PROC		; NullPmd::message::clear_data, COMDAT
; _this$ = ecx

; 989  : inline void message::clear_data() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear_data@message@NullPmd@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 990  :   data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 263  :     if (ptr_ == default_value) {

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 39 00 00 00
	00		 cmp	 DWORD PTR [ecx], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0003a	75 02		 jne	 SHORT $LN8@clear_data

; 264  :       // Nothing: already equal to default (which is the empty string).
; 265  :     } else {

  0003c	eb 20		 jmp	 SHORT $LN1@clear_data
$LN8@clear_data:

; 266  :       ptr_->clear();

  0003e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2870 : 		{	// erase all

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2871 : 		_Eos(0);

  0004d	6a 00		 push	 0
  0004f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@clear_data:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 991  : }

  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear_data@message@NullPmd@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear_data@message@NullPmd@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear_data@message@NullPmd@@QAEXXZ ENDP		; NullPmd::message::clear_data
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@message@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@message@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::message::GetMetadata, COMDAT
; _this$ = ecx

; 2083 : ::google::protobuf::Metadata message::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2084 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 2085 :   return protobuf_NullPmd_2eproto::file_level_metadata[6];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	6b c8 06	 imul	 ecx, eax, 6
  00014	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]
  0001a	8b 81 04 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2086 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@message@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::message::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetArenaNoVirtual@message@NullPmd@@ABEPAVArena@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArenaNoVirtual@message@NullPmd@@ABEPAVArena@protobuf@google@@XZ PROC ; NullPmd::message::GetArenaNoVirtual, COMDAT
; _this$ = ecx

; 657  :   inline ::google::protobuf::Arena* GetArenaNoVirtual() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  :     return NULL;

  00007	33 c0		 xor	 eax, eax

; 659  :   }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?GetArenaNoVirtual@message@NullPmd@@ABEPAVArena@protobuf@google@@XZ ENDP ; NullPmd::message::GetArenaNoVirtual
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@message@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
__Tmp$2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
__Tmp$6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
__Tmp$10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@message@NullPmd@@AAEXPAV12@@Z PROC	; NullPmd::message::InternalSwap, COMDAT
; _this$ = ecx

; 2077 : void message::InternalSwap(message* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 147  :     std::swap(ptr_, other->ptr_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d f8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 e0	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 e0	 mov	 eax, DWORD PTR $T12[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d d8	 mov	 DWORD PTR __Tmp$10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00029	8b 55 f4	 mov	 edx, DWORD PTR __Right$[ebp]
  0002c	89 55 dc	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  00032	8b 4d dc	 mov	 ecx, DWORD PTR $T11[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00039	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0003c	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00042	8b 55 d4	 mov	 edx, DWORD PTR $T9[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2079 :   std::swap(head_, other->head_);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  0004c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004f	89 4d ec	 mov	 DWORD PTR __Right$[ebp], ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	83 c2 0c	 add	 edx, 12			; 0000000cH
  00058	89 55 f0	 mov	 DWORD PTR __Left$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0005b	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00061	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 c8	 mov	 DWORD PTR __Tmp$6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  0006c	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Left$[ebp]
  00072	8b 55 cc	 mov	 edx, DWORD PTR $T7[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00079	8d 4d c8	 lea	 ecx, DWORD PTR __Tmp$6[ebp]
  0007c	89 4d c4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0007f	8b 55 ec	 mov	 edx, DWORD PTR __Right$[ebp]
  00082	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 0a		 mov	 DWORD PTR [edx], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2080 :   std::swap(_cached_size_, other->_cached_size_);

  00089	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  0008c	83 c2 10	 add	 edx, 16			; 00000010H
  0008f	89 55 e4	 mov	 DWORD PTR __Right$[ebp], edx
  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 10	 add	 eax, 16			; 00000010H
  00098	89 45 e8	 mov	 DWORD PTR __Left$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0009b	8b 4d e8	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009e	89 4d c0	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  000a1	8b 55 c0	 mov	 edx, DWORD PTR $T4[ebp]
  000a4	8b 02		 mov	 eax, DWORD PTR [edx]
  000a6	89 45 b8	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ac	89 4d bc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  000af	8b 55 e8	 mov	 edx, DWORD PTR __Left$[ebp]
  000b2	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000b9	8d 55 b8	 lea	 edx, DWORD PTR __Tmp$2[ebp]
  000bc	89 55 b4	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  000bf	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  000c2	8b 4d b4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	89 10		 mov	 DWORD PTR [eax], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2081 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?InternalSwap@message@NullPmd@@AAEXPAV12@@Z ENDP	; NullPmd::message::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@message@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@message@NullPmd@@EBEXH@Z PROC		; NullPmd::message::SetCachedSize, COMDAT
; _this$ = ecx

; 1877 : void message::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1878 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1879 :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1880 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1881 : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@message@NullPmd@@EBEXH@Z ENDP		; NullPmd::message::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@message@NullPmd@@AAEXXZ
_TEXT	SEGMENT
tv81 = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?SharedDtor@message@NullPmd@@AAEXXZ PROC		; NullPmd::message::SharedDtor, COMDAT
; _this$ = ecx

; 1870 : void message::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1871 :   data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00009	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 08	 add	 ecx, 8
  00014	e8 00 00 00 00	 call	 ?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::DestroyNoArena

; 1872 :   if (this != internal_default_instance()) {

  00019	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00020	74 2f		 je	 SHORT $LN1@SharedDtor

; 1873 :     delete head_;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00028	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  0002b	8b 55 f4	 mov	 edx, DWORD PTR $T1[ebp]
  0002e	89 55 f8	 mov	 DWORD PTR $T2[ebp], edx
  00031	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00035	74 13		 je	 SHORT $LN4@SharedDtor
  00037	6a 01		 push	 1
  00039	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	ff d0		 call	 eax
  00045	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  00048	eb 07		 jmp	 SHORT $LN1@SharedDtor
$LN4@SharedDtor:
  0004a	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN1@SharedDtor:

; 1874 :   }
; 1875 : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?SharedDtor@message@NullPmd@@AAEXXZ ENDP		; NullPmd::message::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@message@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@message@NullPmd@@AAEXXZ PROC		; NullPmd::message::SharedCtor, COMDAT
; _this$ = ecx

; 1859 : void message::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 194  :     ptr_ = const_cast< ::std::string* >(default_value);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1861 :   head_ = NULL;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1862 :   _cached_size_ = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 1863 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?SharedCtor@message@NullPmd@@AAEXXZ ENDP		; NullPmd::message::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@message@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@message@NullPmd@@UBEHXZ PROC		; NullPmd::message::GetCachedSize, COMDAT
; _this$ = ecx

; 650  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@message@NullPmd@@UBEHXZ ENDP		; NullPmd::message::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@message@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@message@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::message::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 646  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 647  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::message::InternalSerializeWithCachedSizesToArray

; 648  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 649  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@message@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::message::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
tv89 = -20						; size = 4
_target$ = -16						; size = 4
_target$6 = -12						; size = 4
_value$7 = -8						; size = 4
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::message::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 1981 :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 951  :   return this != internal_default_instance() && head_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00010	74 12		 je	 SHORT $LN7@InternalSe
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00019	74 09		 je	 SHORT $LN7@InternalSe
  0001b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN5@InternalSe
$LN7@InternalSe:
  00024	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN5@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1985 :   if (this->has_head()) {

  0002b	0f b6 4d ec	 movzx	 ecx, BYTE PTR tv89[ebp]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 1a		 je	 SHORT $LN2@InternalSe

; 1986 :     target = ::google::protobuf::internal::WireFormatLite::

  00033	8b 55 0c	 mov	 edx, DWORD PTR _target$[ebp]
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003f	51		 push	 ecx
  00040	6a 01		 push	 1
  00042	e8 00 00 00 00	 call	 ??$InternalWriteMessageNoVirtualToArray@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVhead@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::head>
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN2@InternalSe:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  0004d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00050	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00053	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00056	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  00059	89 4d e4	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0005c	8b 55 e4	 mov	 edx, DWORD PTR $T4[ebp]
  0005f	89 55 e0	 mov	 DWORD PTR $T3[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  00062	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00065	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00068	89 4d dc	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1992 :   if (this->data().size() > 0) {

  0006b	83 7d dc 00	 cmp	 DWORD PTR $T2[ebp], 0
  0006f	76 72		 jbe	 SHORT $LN3@InternalSe
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00071	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00077	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1993 :     target =

  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR _target$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00080	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  00083	89 55 f4	 mov	 DWORD PTR _target$6[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  00086	b8 02 00 00 00	 mov	 eax, 2
  0008b	c1 e0 03	 shl	 eax, 3
  0008e	83 c8 02	 or	 eax, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00091	89 45 f8	 mov	 DWORD PTR _value$7[ebp], eax
$LN37@InternalSe:

; 1197 :   while (value >= 0x80) {

  00094	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _value$7[ebp], 128 ; 00000080H
  0009b	72 22		 jb	 SHORT $LN38@InternalSe

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _value$7[ebp]
  000a0	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  000a6	8b 55 f4	 mov	 edx, DWORD PTR _target$6[ebp]
  000a9	88 0a		 mov	 BYTE PTR [edx], cl

; 1199 :     value >>= 7;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _value$7[ebp]
  000ae	c1 e8 07	 shr	 eax, 7
  000b1	89 45 f8	 mov	 DWORD PTR _value$7[ebp], eax

; 1200 :     ++target;

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR _target$6[ebp]
  000b7	83 c1 01	 add	 ecx, 1
  000ba	89 4d f4	 mov	 DWORD PTR _target$6[ebp], ecx

; 1201 :   }

  000bd	eb d5		 jmp	 SHORT $LN37@InternalSe
$LN38@InternalSe:

; 1202 :   *target = static_cast<uint8>(value);

  000bf	8b 55 f4	 mov	 edx, DWORD PTR _target$6[ebp]
  000c2	8a 45 f8	 mov	 al, BYTE PTR _value$7[ebp]
  000c5	88 02		 mov	 BYTE PTR [edx], al

; 1203 :   return target + 1;

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR _target$6[ebp]
  000ca	83 c1 01	 add	 ecx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 772  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  000cd	89 4d f0	 mov	 DWORD PTR _target$[ebp], ecx

; 773  :   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);

  000d0	8b 55 f0	 mov	 edx, DWORD PTR _target$[ebp]
  000d3	52		 push	 edx
  000d4	8b 45 d8	 mov	 eax, DWORD PTR $T1[ebp]
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ?WriteStringWithSizeToArray@CodedOutputStream@io@protobuf@google@@SAPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; google::protobuf::io::CodedOutputStream::WriteStringWithSizeToArray
  000dd	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1993 :     target =

  000e0	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN3@InternalSe:

; 1994 :       ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
; 1995 :         2, this->data(), target);
; 1996 :   }
; 1997 : 
; 1998 :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.message)
; 1999 :   return target;

  000e3	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 2000 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@message@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::message::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@message@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
tv90 = -8						; size = 4
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@message@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::message::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 1963 :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 951  :   return this != internal_default_instance() && head_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00010	74 12		 je	 SHORT $LN7@SerializeW
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00019	74 09		 je	 SHORT $LN7@SerializeW
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN5@SerializeW
$LN7@SerializeW:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN5@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1966 :   if (this->has_head()) {

  0002b	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv90[ebp]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 15		 je	 SHORT $LN2@SerializeW

; 1967 :     ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(

  00033	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00036	52		 push	 edx
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003d	51		 push	 ecx
  0003e	6a 01		 push	 1
  00040	e8 00 00 00 00	 call	 ?WriteMessageMaybeToArray@WireFormatLite@internal@protobuf@google@@SAXHABVMessageLite@34@PAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SerializeW:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004e	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00051	8b 4d f4	 mov	 ecx, DWORD PTR $T5[ebp]
  00054	89 4d f0	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00057	8b 55 f0	 mov	 edx, DWORD PTR $T4[ebp]
  0005a	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00060	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00063	89 4d e8	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1972 :   if (this->data().size() > 0) {

  00066	83 7d e8 00	 cmp	 DWORD PTR $T2[ebp], 0
  0006a	76 1b		 jbe	 SHORT $LN1@SerializeW
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  0006c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00072	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1973 :     ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(

  00075	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  0007c	52		 push	 edx
  0007d	6a 02		 push	 2
  0007f	e8 00 00 00 00	 call	 ?WriteBytesMaybeAliased@WireFormatLite@internal@protobuf@google@@SAXHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SerializeW:

; 1974 :       2, this->data(), output);
; 1975 :   }
; 1976 : 
; 1977 :   // @@protoc_insertion_point(serialize_end:NullPmd.message)
; 1978 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?SerializeWithCachedSizes@message@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::message::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -32						; size = 8
$T2 = -24						; size = 4
_default_value$ = -20					; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
_this$ = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::message::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 1910 :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 e0	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1916 :     tag = p.first;

  00017	8b 4d e0	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx

; 1917 :     if (!p.second) goto handle_unusual;

  0001d	0f b6 55 e4	 movzx	 edx, BYTE PTR _p$1[ebp+4]
  00021	85 d2		 test	 edx, edx
  00023	75 05		 jne	 SHORT $LN30@MergeParti
  00025	e9 9a 00 00 00	 jmp	 $handle_unusual$62
$LN30@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  0002d	c1 e8 03	 shr	 eax, 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1918 :     switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {

  00030	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00033	83 7d f4 01	 cmp	 DWORD PTR tv71[ebp], 1
  00037	74 0b		 je	 SHORT $LN9@MergeParti
  00039	83 7d f4 02	 cmp	 DWORD PTR tv71[ebp], 2
  0003d	74 32		 je	 SHORT $LN15@MergeParti
  0003f	e9 80 00 00 00	 jmp	 $handle_unusual$62
$LN9@MergeParti:

; 1919 :       // .NullPmd.head head = 1;
; 1920 :       case 1: {
; 1921 :         if (tag == 10u) {

  00044	83 7d fc 0a	 cmp	 DWORD PTR _tag$[ebp], 10 ; 0000000aH
  00048	75 23		 jne	 SHORT __unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2

; 1922 :           DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(

  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ ; NullPmd::message::mutable_head
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$ReadMessageNoVirtual@Vhead@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVhead@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::head>
  0005c	83 c4 08	 add	 esp, 8
  0005f	0f b6 d0	 movzx	 edx, al
  00062	85 d2		 test	 edx, edx
  00064	75 05		 jne	 SHORT $LN12@MergeParti
  00066	e9 8e 00 00 00	 jmp	 $failure$63
$LN12@MergeParti:

; 1923 :                input, mutable_head()));
; 1924 :         } else {

  0006b	eb 02		 jmp	 SHORT $LN11@MergeParti
__unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2:

; 1925 :           goto handle_unusual;

  0006d	eb 55		 jmp	 SHORT $handle_unusual$62
$LN11@MergeParti:

; 1926 :         }
; 1927 :         break;

  0006f	eb 7f		 jmp	 SHORT $LN5@MergeParti
$LN15@MergeParti:

; 1928 :       }
; 1929 : 
; 1930 :       // bytes data = 2;
; 1931 :       case 2: {
; 1932 :         if (tag == 18u) {

  00071	83 7d fc 12	 cmp	 DWORD PTR _tag$[ebp], 18 ; 00000012H
  00075	75 49		 jne	 SHORT __unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$4
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 1023 :   return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00077	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _default_value$[ebp], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	83 c0 08	 add	 eax, 8
  00084	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 228  :     if (ptr_ == default_value) {

  00087	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008c	3b 55 ec	 cmp	 edx, DWORD PTR _default_value$[ebp]
  0008f	75 0c		 jne	 SHORT $LN58@MergeParti

; 229  :       CreateInstanceNoArena(default_value);

  00091	8b 45 ec	 mov	 eax, DWORD PTR _default_value$[ebp]
  00094	50		 push	 eax
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
$LN58@MergeParti:

; 230  :     }
; 231  :     return ptr_;

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a2	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1933 :           DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(

  000a5	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ?ReadBytes@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::ReadBytes
  000b2	83 c4 08	 add	 esp, 8
  000b5	0f b6 d0	 movzx	 edx, al
  000b8	85 d2		 test	 edx, edx
  000ba	75 02		 jne	 SHORT $LN18@MergeParti
  000bc	eb 3b		 jmp	 SHORT $failure$63
$LN18@MergeParti:

; 1934 :                 input, this->mutable_data()));
; 1935 :         } else {

  000be	eb 02		 jmp	 SHORT $LN17@MergeParti
__unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$4:

; 1936 :           goto handle_unusual;

  000c0	eb 02		 jmp	 SHORT $handle_unusual$62
$LN17@MergeParti:

; 1937 :         }
; 1938 :         break;

  000c2	eb 2c		 jmp	 SHORT $LN5@MergeParti
$handle_unusual$62:

; 1943 :         if (tag == 0 ||

  000c4	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  000c8	74 0b		 je	 SHORT __unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  000cd	83 e0 07	 and	 eax, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1943 :         if (tag == 0 ||

  000d0	83 f8 04	 cmp	 eax, 4
  000d3	75 02		 jne	 SHORT $LN22@MergeParti
__unwind$?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5:

; 1944 :             ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 1945 :             ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 1946 :           goto success;

  000d5	eb 1e		 jmp	 SHORT $success$64
$LN22@MergeParti:

; 1947 :         }
; 1948 :         DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _tag$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  000e4	83 c4 08	 add	 esp, 8
  000e7	0f b6 c0	 movzx	 eax, al
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN5@MergeParti
  000ee	eb 09		 jmp	 SHORT $failure$63
$LN5@MergeParti:

; 1949 :         break;
; 1950 :       }
; 1951 :     }
; 1952 :   }

  000f0	e9 14 ff ff ff	 jmp	 $LN4@MergeParti
$success$64:

; 1953 : success:
; 1954 :   // @@protoc_insertion_point(parse_success:NullPmd.message)
; 1955 :   return true;

  000f5	b0 01		 mov	 al, 1
  000f7	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$63:

; 1956 : failure:
; 1957 :   // @@protoc_insertion_point(parse_failure:NullPmd.message)
; 1958 :   return false;

  000f9	32 c0		 xor	 al, al
$LN1@MergeParti:

; 1959 : #undef DO_
; 1960 : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
?MergePartialFromCodedStream@message@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::message::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@message@NullPmd@@UBEIXZ
_TEXT	SEGMENT
_cached_size$ = -48					; size = 4
_value$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
tv141 = -16						; size = 4
_length$ = -12						; size = 4
_total_size$ = -8					; size = 4
_this$ = -4						; size = 4
?ByteSizeLong@message@NullPmd@@UBEIXZ PROC		; NullPmd::message::ByteSizeLong, COMDAT
; _this$ = ecx

; 2002 : size_t message::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2003 : // @@protoc_insertion_point(message_byte_size_start:NullPmd.message)
; 2004 :   size_t total_size = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	89 4d e8	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00019	8b 55 e8	 mov	 edx, DWORD PTR $T5[ebp]
  0001c	89 55 e4	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0001f	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00022	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 3302 : 		return (this->_Get_data()._Mysize);

  00025	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  00028	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002b	89 55 dc	 mov	 DWORD PTR $T2[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2007 :   if (this->data().size() > 0) {

  0002e	83 7d dc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00032	76 1f		 jbe	 SHORT $LN43@ByteSizeLo
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	89 4d d8	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2008 :     total_size += 1 +

  0003d	8b 55 d8	 mov	 edx, DWORD PTR $T1[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?BytesSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::BytesSize
  00046	83 c4 04	 add	 esp, 4
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _total_size$[ebp]
  0004c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00050	89 55 f8	 mov	 DWORD PTR _total_size$[ebp], edx
$LN43@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 951  :   return this != internal_default_instance() && head_ != NULL;

  00053	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  0005a	74 12		 je	 SHORT $LN41@ByteSizeLo
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00063	74 09		 je	 SHORT $LN41@ByteSizeLo
  00065	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
  0006c	eb 07		 jmp	 SHORT $LN39@ByteSizeLo
$LN41@ByteSizeLo:
  0006e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv141[ebp], 0
$LN39@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2014 :   if (this->has_head()) {

  00075	0f b6 4d f0	 movzx	 ecx, BYTE PTR tv141[ebp]
  00079	85 c9		 test	 ecx, ecx
  0007b	74 47		 je	 SHORT $LN53@ByteSizeLo

; 2015 :     total_size += 1 +

  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00083	89 45 d4	 mov	 DWORD PTR _value$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 862  :   return LengthDelimitedSize(

  00086	8b 4d d4	 mov	 ecx, DWORD PTR _value$[ebp]
  00089	e8 00 00 00 00	 call	 ?ByteSizeLong@head@NullPmd@@UBEIXZ ; NullPmd::head::ByteSizeLong
  0008e	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  00091	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  00098	73 0b		 jae	 SHORT $LN50@ByteSizeLo

; 1296 :     return 1;

  0009a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
  000a1	eb 11		 jmp	 SHORT $LN45@ByteSizeLo

; 1297 :   } else  {

  000a3	eb 0f		 jmp	 SHORT $LN45@ByteSizeLo
$LN50@ByteSizeLo:

; 1298 :     return VarintSize32Fallback(value);

  000a5	8b 4d f4	 mov	 ecx, DWORD PTR _length$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  000ae	83 c4 04	 add	 esp, 4
  000b1	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
$LN45@ByteSizeLo:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  000b4	8b 55 f4	 mov	 edx, DWORD PTR _length$[ebp]
  000b7	03 55 ec	 add	 edx, DWORD PTR $T6[ebp]
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2015 :     total_size += 1 +

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _total_size$[ebp]
  000bd	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  000c1	89 4d f8	 mov	 DWORD PTR _total_size$[ebp], ecx
$LN53@ByteSizeLo:

; 2016 :       ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
; 2017 :         *this->head_);
; 2018 :   }
; 2019 : 
; 2020 :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  000c4	8b 55 f8	 mov	 edx, DWORD PTR _total_size$[ebp]
  000c7	89 55 d0	 mov	 DWORD PTR _cached_size$[ebp], edx

; 2021 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 2022 :   _cached_size_ = cached_size;

  000ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 4d d0	 mov	 ecx, DWORD PTR _cached_size$[ebp]
  000d0	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2023 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 2024 :   return total_size;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _total_size$[ebp]

; 2025 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?ByteSizeLong@message@NullPmd@@UBEIXZ ENDP		; NullPmd::message::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@message@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@message@NullPmd@@UBE_NXZ PROC		; NullPmd::message::IsInitialized, COMDAT
; _this$ = ecx

; 2069 : bool message::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2070 :   return true;

  00007	b0 01		 mov	 al, 1

; 2071 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@message@NullPmd@@UBE_NXZ ENDP		; NullPmd::message::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@message@NullPmd@@UAEXXZ
_TEXT	SEGMENT
tv84 = -36						; size = 4
$T2 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clear@message@NullPmd@@UAEXXZ PROC			; NullPmd::message::Clear, COMDAT
; _this$ = ecx

; 1900 : void message::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clear@message@NullPmd@@UAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1901 : // @@protoc_insertion_point(message_clear_start:NullPmd.message)
; 1902 :   data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 263  :     if (ptr_ == default_value) {

  00031	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 39 00 00 00
	00		 cmp	 DWORD PTR [ecx], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0003a	75 02		 jne	 SHORT $LN11@Clear

; 264  :       // Nothing: already equal to default (which is the empty string).
; 265  :     } else {

  0003c	eb 20		 jmp	 SHORT $LN37@Clear
$LN11@Clear:

; 266  :       ptr_->clear();

  0003e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2870 : 		{	// erase all

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2871 : 		_Eos(0);

  0004d	6a 00		 push	 0
  0004f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN37@Clear:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1903 :   if (GetArenaNoVirtual() == NULL && head_ != NULL) {

  0005e	33 c9		 xor	 ecx, ecx
  00060	75 38		 jne	 SHORT $LN2@Clear
  00062	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00065	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00069	74 2f		 je	 SHORT $LN2@Clear

; 1904 :     delete head_;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00071	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
  00074	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  00077	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
  0007a	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  0007e	74 13		 je	 SHORT $LN4@Clear
  00080	6a 01		 push	 1
  00082	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00085	8b 10		 mov	 edx, DWORD PTR [eax]
  00087	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0008a	8b 02		 mov	 eax, DWORD PTR [edx]
  0008c	ff d0		 call	 eax
  0008e	89 45 dc	 mov	 DWORD PTR tv84[ebp], eax
  00091	eb 07		 jmp	 SHORT $LN2@Clear
$LN4@Clear:
  00093	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN2@Clear:

; 1905 :   }
; 1906 :   head_ = NULL;

  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1907 : }

  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ae	59		 pop	 ecx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Clear@message@NullPmd@@UAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clear@message@NullPmd@@UAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clear@message@NullPmd@@UAEXXZ ENDP			; NullPmd::message::Clear
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@message@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
$T2 = -104						; size = 4
$T3 = -100						; size = 4
$T4 = -96						; size = 4
$T5 = -92						; size = 4
$T6 = -88						; size = 4
tv142 = -84						; size = 4
tv205 = -80						; size = 4
tv170 = -76						; size = 4
tv151 = -72						; size = 4
$T7 = -65						; size = 1
_this$ = -64						; size = 4
$T8 = -60						; size = 4
$T9 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@message@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::message::MergeFrom, COMDAT
; _this$ = ecx

; 2042 : void message::MergeFrom(const message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@message@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0

; 2043 : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.message)
; 2044 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 c0	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 fc 07 00 00	 push	 2044			; 000007fcH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T9[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b0	 mov	 DWORD PTR tv205[ebp], eax
  00053	8b 4d b0	 mov	 ecx, DWORD PTR tv205[ebp]
  00056	89 4d ac	 mov	 DWORD PTR tv142[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T8[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T8[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d ac	 mov	 ecx, DWORD PTR tv142[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d bf	 lea	 ecx, DWORD PTR $T7[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T8[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T9[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 2045 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000ac	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b2	89 45 a8	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000b5	8b 4d a8	 mov	 ecx, DWORD PTR $T6[ebp]
  000b8	89 4d a4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  000bb	8b 55 a4	 mov	 edx, DWORD PTR $T5[ebp]
  000be	89 55 a0	 mov	 DWORD PTR $T4[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  000c1	8b 45 a0	 mov	 eax, DWORD PTR $T4[ebp]
  000c4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c7	89 4d 9c	 mov	 DWORD PTR $T3[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2046 :   if (from.data().size() > 0) {

  000ca	83 7d 9c 00	 cmp	 DWORD PTR $T3[ebp], 0
  000ce	76 17		 jbe	 SHORT $LN68@MergeFrom

; 2047 : 
; 2048 :     data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);

  000d0	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  000dc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	83 c1 08	 add	 ecx, 8
  000e2	e8 00 00 00 00	 call	 ?AssignWithDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U1234@@Z ; google::protobuf::internal::ArenaStringPtr::AssignWithDefault
$LN68@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 951  :   return this != internal_default_instance() && head_ != NULL;

  000e7	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  000ee	74 12		 je	 SHORT $LN66@MergeFrom
  000f0	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000f3	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000f7	74 09		 je	 SHORT $LN66@MergeFrom
  000f9	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv151[ebp], 1
  00100	eb 07		 jmp	 SHORT $LN64@MergeFrom
$LN66@MergeFrom:
  00102	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
$LN64@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2050 :   if (from.has_head()) {

  00109	0f b6 55 b8	 movzx	 edx, BYTE PTR tv151[ebp]
  0010d	85 d2		 test	 edx, edx
  0010f	74 34		 je	 SHORT $LN1@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 959  :   return head_ != NULL ? *head_

  00111	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00114	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00118	74 0b		 je	 SHORT $LN74@MergeFrom
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0011d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00120	89 55 b4	 mov	 DWORD PTR tv170[ebp], edx
  00123	eb 07		 jmp	 SHORT $LN73@MergeFrom
$LN74@MergeFrom:
  00125	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
$LN73@MergeFrom:
  0012c	8b 45 b4	 mov	 eax, DWORD PTR tv170[ebp]
  0012f	89 45 98	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 2051 :     mutable_head()->::NullPmd::head::MergeFrom(from.head());

  00132	8b 4d 98	 mov	 ecx, DWORD PTR $T2[ebp]
  00135	51		 push	 ecx
  00136	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ ; NullPmd::message::mutable_head
  0013e	8b c8		 mov	 ecx, eax
  00140	e8 00 00 00 00	 call	 ?MergeFrom@head@NullPmd@@QAEXABV12@@Z ; NullPmd::head::MergeFrom
$LN1@MergeFrom:

; 2052 :   }
; 2053 : }

  00145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014f	59		 pop	 ecx
  00150	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@message@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T8[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T9[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@message@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@message@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@message@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::message::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@message@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@message@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::message::CopyFrom, COMDAT
; _this$ = ecx

; 2062 : void message::CopyFrom(const message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2063 : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.message)
; 2064 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 2065 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@message@NullPmd@@UAEXXZ ; NullPmd::message::Clear

; 2066 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@message@NullPmd@@QAEXABV12@@Z ; NullPmd::message::MergeFrom
$LN1@CopyFrom:

; 2067 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@message@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::message::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::message::MergeFrom, COMDAT
; _this$ = ecx

; 2027 : void message::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 2028 : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.message)
; 2029 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 ed 07 00 00	 push	 2029			; 000007edH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 2030 :   const message* source =
; 2031 :       ::google::protobuf::internal::DynamicCastToGenerated<const message>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVmessage@NullPmd@@@internal@protobuf@google@@YAPBVmessage@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::message const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 2032 :           &from);
; 2033 :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 2034 :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.message)
; 2035 :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 2036 :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 2037 :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.message)
; 2038 :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@message@NullPmd@@QAEXABV12@@Z ; NullPmd::message::MergeFrom
$LN1@MergeFrom:

; 2039 :   }
; 2040 : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::message::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::message::CopyFrom, COMDAT
; _this$ = ecx

; 2055 : void message::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2056 : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.message)
; 2057 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 2058 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@message@NullPmd@@UAEXXZ ; NullPmd::message::Clear

; 2059 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::message::MergeFrom
$LN1@CopyFrom:

; 2060 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@message@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::message::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::message::New, COMDAT
; _this$ = ecx

; 1892 : message* message::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1893 :   message* n = new message;

  00028	6a 14		 push	 20			; 00000014H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 1894 :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 1895 :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vmessage@NullPmd@@@Arena@protobuf@google@@QAEXPAVmessage@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::message>
$LN2@New:

; 1896 :   }
; 1897 :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 1898 : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::message::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@message@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@message@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::message::New, COMDAT
; _this$ = ecx

; 628  :   inline message* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@message@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::message::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@message@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::message::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@message@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@message@NullPmd@@QAEXPAV12@@Z PROC		; NullPmd::message::Swap, COMDAT
; _this$ = ecx

; 2073 : void message::Swap(message* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2074 :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 2075 :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@message@NullPmd@@AAEXPAV12@@Z ; NullPmd::message::InternalSwap
$LN1@Swap:

; 2076 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@message@NullPmd@@QAEXPAV12@@Z ENDP		; NullPmd::message::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@message@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@message@NullPmd@@SAPBV12@XZ PROC ; NullPmd::message::internal_default_instance, COMDAT

; 619  :   static inline const message* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 620  :     return reinterpret_cast<const message*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_

; 621  :                &_message_default_instance_);
; 622  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@message@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::message::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@message@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@message@NullPmd@@SAABV12@XZ PROC	; NullPmd::message::default_instance, COMDAT

; 1887 : const message& message::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1888 :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 1889 :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_

; 1890 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@message@NullPmd@@SAABV12@XZ ENDP	; NullPmd::message::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@message@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@message@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::message::descriptor, COMDAT

; 1882 : const ::google::protobuf::Descriptor* message::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1883 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1884 :   return protobuf_NullPmd_2eproto::file_level_metadata[6].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	6b c8 06	 imul	 ecx, eax, 6
  00010	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]

; 1885 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@message@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::message::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0message@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
_this$ = -32						; size = 4
tv160 = -28						; size = 4
$T7 = -24						; size = 4
tv216 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0message@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::message::message, COMDAT
; _this$ = ecx

; 1845 :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0message@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1843 :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1845 :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7message@NullPmd@@6B@

; 1844 :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1844 :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1845 :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 1846 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 194  :     ptr_ = const_cast< ::std::string* >(default_value);

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00086	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  00089	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008c	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR $T6[ebp]
  00092	89 4d d8	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00095	8b 55 d8	 mov	 edx, DWORD PTR $T5[ebp]
  00098	89 55 d4	 mov	 DWORD PTR $T4[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0009b	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  0009e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a1	89 4d d0	 mov	 DWORD PTR $T3[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1848 :   if (from.data().size() > 0) {

  000a4	83 7d d0 00	 cmp	 DWORD PTR $T3[ebp], 0
  000a8	76 17		 jbe	 SHORT $LN85@message

; 1849 :     data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);

  000aa	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 08	 add	 ecx, 8
  000bc	e8 00 00 00 00	 call	 ?AssignWithDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U1234@@Z ; google::protobuf::internal::ArenaStringPtr::AssignWithDefault
$LN85@message:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 951  :   return this != internal_default_instance() && head_ != NULL;

  000c1	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  000c8	74 12		 je	 SHORT $LN83@message
  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000cd	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000d1	74 09		 je	 SHORT $LN83@message
  000d3	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv216[ebp], 1
  000da	eb 07		 jmp	 SHORT $LN81@message
$LN83@message:
  000dc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv216[ebp], 0
$LN81@message:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1851 :   if (from.has_head()) {

  000e3	0f b6 55 ec	 movzx	 edx, BYTE PTR tv216[ebp]
  000e7	85 d2		 test	 edx, edx
  000e9	74 47		 je	 SHORT $LN3@message

; 1852 :     head_ = new ::NullPmd::head(*from.head_);

  000eb	6a 14		 push	 20			; 00000014H
  000ed	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000f2	83 c4 04	 add	 esp, 4
  000f5	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax
  000f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000fc	83 7d e8 00	 cmp	 DWORD PTR $T7[ebp], 0
  00100	74 14		 je	 SHORT $LN6@message
  00102	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00105	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00108	51		 push	 ecx
  00109	8b 4d e8	 mov	 ecx, DWORD PTR $T7[ebp]
  0010c	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@ABV01@@Z ; NullPmd::head::head
  00111	89 45 e4	 mov	 DWORD PTR tv160[ebp], eax
  00114	eb 07		 jmp	 SHORT $LN7@message
$LN6@message:
  00116	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
$LN7@message:
  0011d	8b 55 e4	 mov	 edx, DWORD PTR tv160[ebp]
  00120	89 55 cc	 mov	 DWORD PTR $T2[ebp], edx
  00123	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00127	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0012a	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
  0012d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1853 :   } else {

  00130	eb 0a		 jmp	 SHORT $LN1@message
$LN3@message:

; 1854 :     head_ = NULL;

  00132	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00135	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
$LN1@message:

; 1855 :   }
; 1856 :   // @@protoc_insertion_point(copy_constructor:NullPmd.message)
; 1857 : }

  0013c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00143	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00146	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00149	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00150	59		 pop	 ecx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__unwindfunclet$??0message@NullPmd@@QAE@ABV01@@Z$2:
  00013	6a 14		 push	 20			; 00000014H
  00015	8b 45 e8	 mov	 eax, DWORD PTR $T7[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__ehhandler$??0message@NullPmd@@QAE@ABV01@@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0message@NullPmd@@QAE@ABV01@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0message@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::message::message
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1message@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1message@NullPmd@@UAE@XZ PROC				; NullPmd::message::~message, COMDAT
; _this$ = ecx

; 1865 : message::~message() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1message@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7message@NullPmd@@6B@

; 1866 :   // @@protoc_insertion_point(destructor:NullPmd.message)
; 1867 :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@message@NullPmd@@AAEXXZ ; NullPmd::message::SharedDtor

; 1868 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1868 : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1message@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1message@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1message@NullPmd@@UAE@XZ ENDP				; NullPmd::message::~message
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0message@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0message@NullPmd@@QAE@XZ PROC				; NullPmd::message::message, COMDAT
; _this$ = ecx

; 1835 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0message@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1835 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7message@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1835 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1836 :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00067	74 05		 je	 SHORT $LN2@message

; 1837 :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@message:

; 1838 :   }
; 1839 :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@message@NullPmd@@AAEXXZ ; NullPmd::message::SharedCtor

; 1840 :   // @@protoc_insertion_point(constructor:NullPmd.message)
; 1841 : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0message@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0message@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0message@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0message@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0message@NullPmd@@QAE@XZ ENDP				; NullPmd::message::message
; Function compile flags: /Odtp
;	COMDAT ??_Ghead@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Ghead@NullPmd@@UAEPAXI@Z PROC			; NullPmd::head::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1head@NullPmd@@UAE@XZ	; NullPmd::head::~head
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Ghead@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::head::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ PROC	; NullPmd::head::mutable_info, COMDAT
; _this$ = ecx

; 919  : inline ::NullPmd::info* head::mutable_info() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 920  :   
; 921  :   if (info_ == NULL) {

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0002f	75 44		 jne	 SHORT $LN2@mutable_in

; 922  :     info_ = new ::NullPmd::info;

  00031	6a 28		 push	 40			; 00000028H
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00049	74 0d		 je	 SHORT $LN4@mutable_in
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004e	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@XZ	; NullPmd::info::info
  00053	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00056	eb 07		 jmp	 SHORT $LN5@mutable_in
$LN4@mutable_in:
  00058	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN5@mutable_in:
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00062	89 4d e4	 mov	 DWORD PTR $T2[ebp], ecx
  00065	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00072	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN2@mutable_in:

; 923  :   }
; 924  :   // @@protoc_insertion_point(field_mutable:NullPmd.head.info)
; 925  :   return info_;

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 926  : }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ$0:
  00000	6a 28		 push	 40			; 00000028H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ ENDP	; NullPmd::head::mutable_info
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?info@head@NullPmd@@QBEABV02@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?info@head@NullPmd@@QBEABV02@XZ PROC			; NullPmd::head::info, COMDAT
; _this$ = ecx

; 914  : inline const ::NullPmd::info& head::info() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 915  :   // @@protoc_insertion_point(field_get:NullPmd.head.info)
; 916  :   return info_ != NULL ? *info_

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00010	74 0b		 je	 SHORT $LN5@info
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00018	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  0001b	eb 07		 jmp	 SHORT $LN4@info
$LN5@info:
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
$LN4@info:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00027	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 917  :                          : *::NullPmd::info::internal_default_instance();
; 918  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?info@head@NullPmd@@QBEABV02@XZ ENDP			; NullPmd::head::info
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?has_info@head@NullPmd@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?has_info@head@NullPmd@@QBE_NXZ PROC			; NullPmd::head::has_info, COMDAT
; _this$ = ecx

; 907  : inline bool head::has_info() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  :   return this != internal_default_instance() && info_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00010	74 12		 je	 SHORT $LN3@has_info
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00019	74 09		 je	 SHORT $LN3@has_info
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@has_info
$LN3@has_info:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@has_info:
  0002b	8a 45 f8	 mov	 al, BYTE PTR tv68[ebp]

; 909  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?has_info@head@NullPmd@@QBE_NXZ ENDP			; NullPmd::head::has_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ PROC	; NullPmd::head::mutable_command, COMDAT
; _this$ = ecx

; 880  : inline ::NullPmd::command* head::mutable_command() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 881  :   
; 882  :   if (command_ == NULL) {

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002f	75 44		 jne	 SHORT $LN2@mutable_co

; 883  :     command_ = new ::NullPmd::command;

  00031	6a 20		 push	 32			; 00000020H
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00049	74 0d		 je	 SHORT $LN4@mutable_co
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004e	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@XZ ; NullPmd::command::command
  00053	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00056	eb 07		 jmp	 SHORT $LN5@mutable_co
$LN4@mutable_co:
  00058	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN5@mutable_co:
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00062	89 4d e4	 mov	 DWORD PTR $T2[ebp], ecx
  00065	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00072	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN2@mutable_co:

; 884  :   }
; 885  :   // @@protoc_insertion_point(field_mutable:NullPmd.head.command)
; 886  :   return command_;

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 887  : }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ$0:
  00000	6a 20		 push	 32			; 00000020H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ENDP	; NullPmd::head::mutable_command
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?command@head@NullPmd@@QBEABV02@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?command@head@NullPmd@@QBEABV02@XZ PROC			; NullPmd::head::command, COMDAT
; _this$ = ecx

; 875  : inline const ::NullPmd::command& head::command() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 876  :   // @@protoc_insertion_point(field_get:NullPmd.head.command)
; 877  :   return command_ != NULL ? *command_

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 0b		 je	 SHORT $LN5@command
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00018	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  0001b	eb 07		 jmp	 SHORT $LN4@command
$LN5@command:
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
$LN4@command:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00027	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 878  :                          : *::NullPmd::command::internal_default_instance();
; 879  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?command@head@NullPmd@@QBEABV02@XZ ENDP			; NullPmd::head::command
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?has_command@head@NullPmd@@QBE_NXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?has_command@head@NullPmd@@QBE_NXZ PROC			; NullPmd::head::has_command, COMDAT
; _this$ = ecx

; 868  : inline bool head::has_command() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 869  :   return this != internal_default_instance() && command_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00010	74 12		 je	 SHORT $LN3@has_comman
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00019	74 09		 je	 SHORT $LN3@has_comman
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@has_comman
$LN3@has_comman:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@has_comman:
  0002b	8a 45 f8	 mov	 al, BYTE PTR tv68[ebp]

; 870  : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?has_command@head@NullPmd@@QBE_NXZ ENDP			; NullPmd::head::has_command
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@head@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@head@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::head::GetMetadata, COMDAT
; _this$ = ecx

; 1739 : ::google::protobuf::Metadata head::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1740 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1741 :   return protobuf_NullPmd_2eproto::file_level_metadata[5];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	6b c8 05	 imul	 ecx, eax, 5
  00014	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]
  0001a	8b 81 04 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1742 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@head@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::head::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetArenaNoVirtual@head@NullPmd@@ABEPAVArena@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArenaNoVirtual@head@NullPmd@@ABEPAVArena@protobuf@google@@XZ PROC ; NullPmd::head::GetArenaNoVirtual, COMDAT
; _this$ = ecx

; 561  :   inline ::google::protobuf::Arena* GetArenaNoVirtual() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 562  :     return NULL;

  00007	33 c0		 xor	 eax, eax

; 563  :   }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?GetArenaNoVirtual@head@NullPmd@@ABEPAVArena@protobuf@google@@XZ ENDP ; NullPmd::head::GetArenaNoVirtual
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@head@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
__Tmp$2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
__Tmp$6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
__Tmp$10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@head@NullPmd@@AAEXPAV12@@Z PROC		; NullPmd::head::InternalSwap, COMDAT
; _this$ = ecx

; 1733 : void head::InternalSwap(head* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1734 :   std::swap(command_, other->command_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d f8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 e0	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 e0	 mov	 eax, DWORD PTR $T12[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d d8	 mov	 DWORD PTR __Tmp$10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00029	8b 55 f4	 mov	 edx, DWORD PTR __Right$[ebp]
  0002c	89 55 dc	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  00032	8b 4d dc	 mov	 ecx, DWORD PTR $T11[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00039	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0003c	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00042	8b 55 d4	 mov	 edx, DWORD PTR $T9[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1735 :   std::swap(info_, other->info_);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  0004c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004f	89 4d ec	 mov	 DWORD PTR __Right$[ebp], ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	83 c2 0c	 add	 edx, 12			; 0000000cH
  00058	89 55 f0	 mov	 DWORD PTR __Left$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0005b	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00061	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 c8	 mov	 DWORD PTR __Tmp$6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  0006c	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Left$[ebp]
  00072	8b 55 cc	 mov	 edx, DWORD PTR $T7[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00079	8d 4d c8	 lea	 ecx, DWORD PTR __Tmp$6[ebp]
  0007c	89 4d c4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0007f	8b 55 ec	 mov	 edx, DWORD PTR __Right$[ebp]
  00082	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 0a		 mov	 DWORD PTR [edx], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1736 :   std::swap(_cached_size_, other->_cached_size_);

  00089	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  0008c	83 c2 10	 add	 edx, 16			; 00000010H
  0008f	89 55 e4	 mov	 DWORD PTR __Right$[ebp], edx
  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 10	 add	 eax, 16			; 00000010H
  00098	89 45 e8	 mov	 DWORD PTR __Left$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0009b	8b 4d e8	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009e	89 4d c0	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  000a1	8b 55 c0	 mov	 edx, DWORD PTR $T4[ebp]
  000a4	8b 02		 mov	 eax, DWORD PTR [edx]
  000a6	89 45 b8	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ac	89 4d bc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  000af	8b 55 e8	 mov	 edx, DWORD PTR __Left$[ebp]
  000b2	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000b9	8d 55 b8	 lea	 edx, DWORD PTR __Tmp$2[ebp]
  000bc	89 55 b4	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  000bf	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  000c2	8b 4d b4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	89 10		 mov	 DWORD PTR [eax], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1737 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?InternalSwap@head@NullPmd@@AAEXPAV12@@Z ENDP		; NullPmd::head::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@head@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@head@NullPmd@@EBEXH@Z PROC		; NullPmd::head::SetCachedSize, COMDAT
; _this$ = ecx

; 1531 : void head::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1532 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1533 :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1534 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1535 : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@head@NullPmd@@EBEXH@Z ENDP		; NullPmd::head::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@head@NullPmd@@AAEXXZ
_TEXT	SEGMENT
tv91 = -28						; size = 4
$T1 = -24						; size = 4
tv77 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
?SharedDtor@head@NullPmd@@AAEXXZ PROC			; NullPmd::head::SharedDtor, COMDAT
; _this$ = ecx

; 1522 : void head::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1523 :   if (this != internal_default_instance()) {

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00010	74 2f		 je	 SHORT $LN11@SharedDtor

; 1524 :     delete command_;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00018	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  0001e	89 55 f8	 mov	 DWORD PTR $T4[ebp], edx
  00021	83 7d f8 00	 cmp	 DWORD PTR $T4[ebp], 0
  00025	74 13		 je	 SHORT $LN5@SharedDtor
  00027	6a 01		 push	 1
  00029	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	ff d0		 call	 eax
  00035	89 45 ec	 mov	 DWORD PTR tv77[ebp], eax
  00038	eb 07		 jmp	 SHORT $LN11@SharedDtor
$LN5@SharedDtor:
  0003a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN11@SharedDtor:

; 1525 :   }
; 1526 :   if (this != internal_default_instance()) {

  00041	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00048	74 2f		 je	 SHORT $LN1@SharedDtor

; 1527 :     delete info_;

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00050	89 55 e8	 mov	 DWORD PTR $T1[ebp], edx
  00053	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00056	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  00059	83 7d f4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0005d	74 13		 je	 SHORT $LN7@SharedDtor
  0005f	6a 01		 push	 1
  00061	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00069	8b 02		 mov	 eax, DWORD PTR [edx]
  0006b	ff d0		 call	 eax
  0006d	89 45 e4	 mov	 DWORD PTR tv91[ebp], eax
  00070	eb 07		 jmp	 SHORT $LN1@SharedDtor
$LN7@SharedDtor:
  00072	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv91[ebp], 0
$LN1@SharedDtor:

; 1528 :   }
; 1529 : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?SharedDtor@head@NullPmd@@AAEXXZ ENDP			; NullPmd::head::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@head@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@head@NullPmd@@AAEXXZ PROC			; NullPmd::head::SharedCtor, COMDAT
; _this$ = ecx

; 1511 : void head::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1512 :   ::memset(&command_, 0, reinterpret_cast<char*>(&info_) -

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 08	 add	 ecx, 8
  00013	2b c1		 sub	 eax, ecx
  00015	83 c0 04	 add	 eax, 4
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 c2 08	 add	 edx, 8
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1513 :     reinterpret_cast<char*>(&command_) + sizeof(info_));
; 1514 :   _cached_size_ = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1515 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SharedCtor@head@NullPmd@@AAEXXZ ENDP			; NullPmd::head::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@head@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@head@NullPmd@@UBEHXZ PROC		; NullPmd::head::GetCachedSize, COMDAT
; _this$ = ecx

; 554  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@head@NullPmd@@UBEHXZ ENDP		; NullPmd::head::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@head@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@head@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::head::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 550  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 551  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::head::InternalSerializeWithCachedSizesToArray

; 552  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 553  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@head@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::head::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
tv93 = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::head::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 1638 :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 869  :   return this != internal_default_instance() && command_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00010	74 12		 je	 SHORT $LN7@InternalSe
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00019	74 09		 je	 SHORT $LN7@InternalSe
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN5@InternalSe
$LN7@InternalSe:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$LN5@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1642 :   if (this->has_command()) {

  0002b	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv88[ebp]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 1a		 je	 SHORT $LN15@InternalSe

; 1643 :     target = ::google::protobuf::internal::WireFormatLite::

  00033	8b 55 0c	 mov	 edx, DWORD PTR _target$[ebp]
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003f	51		 push	 ecx
  00040	6a 01		 push	 1
  00042	e8 00 00 00 00	 call	 ??$InternalWriteMessageNoVirtualToArray@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVcommand@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::command>
  00047	83 c4 10	 add	 esp, 16			; 00000010H
  0004a	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN15@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 908  :   return this != internal_default_instance() && info_ != NULL;

  0004d	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00054	74 12		 je	 SHORT $LN13@InternalSe
  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0005d	74 09		 je	 SHORT $LN13@InternalSe
  0005f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  00066	eb 07		 jmp	 SHORT $LN11@InternalSe
$LN13@InternalSe:
  00068	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN11@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1649 :   if (this->has_info()) {

  0006f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv93[ebp]
  00073	85 c0		 test	 eax, eax
  00075	74 1a		 je	 SHORT $LN3@InternalSe

; 1650 :     target = ::google::protobuf::internal::WireFormatLite::

  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  0007a	51		 push	 ecx
  0007b	6a 00		 push	 0
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00083	50		 push	 eax
  00084	6a 02		 push	 2
  00086	e8 00 00 00 00	 call	 ??$InternalWriteMessageNoVirtualToArray@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SAPAEHABVinfo@NullPmd@@_NPAE@Z ; google::protobuf::internal::WireFormatLite::InternalWriteMessageNoVirtualToArray<NullPmd::info>
  0008b	83 c4 10	 add	 esp, 16			; 00000010H
  0008e	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN3@InternalSe:

; 1651 :       InternalWriteMessageNoVirtualToArray(
; 1652 :         2, *this->info_, false, target);
; 1653 :   }
; 1654 : 
; 1655 :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.head)
; 1656 :   return target;

  00091	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 1657 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@head@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::head::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@head@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
tv129 = -12						; size = 4
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@head@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::head::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 1620 :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 869  :   return this != internal_default_instance() && command_ != NULL;

  00009	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00010	74 12		 je	 SHORT $LN7@SerializeW
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00019	74 09		 je	 SHORT $LN7@SerializeW
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN5@SerializeW
$LN7@SerializeW:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN5@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1623 :   if (this->has_command()) {

  0002b	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv92[ebp]
  0002f	85 c9		 test	 ecx, ecx
  00031	74 15		 je	 SHORT $LN15@SerializeW

; 1624 :     ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(

  00033	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  00036	52		 push	 edx
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003d	51		 push	 ecx
  0003e	6a 01		 push	 1
  00040	e8 00 00 00 00	 call	 ?WriteMessageMaybeToArray@WireFormatLite@internal@protobuf@google@@SAXHABVMessageLite@34@PAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 908  :   return this != internal_default_instance() && info_ != NULL;

  00048	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  0004f	74 12		 je	 SHORT $LN13@SerializeW
  00051	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00054	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00058	74 09		 je	 SHORT $LN13@SerializeW
  0005a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  00061	eb 07		 jmp	 SHORT $LN11@SerializeW
$LN13@SerializeW:
  00063	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN11@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1629 :   if (this->has_info()) {

  0006a	0f b6 45 f4	 movzx	 eax, BYTE PTR tv129[ebp]
  0006e	85 c0		 test	 eax, eax
  00070	74 15		 je	 SHORT $LN1@SerializeW

; 1630 :     ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007c	50		 push	 eax
  0007d	6a 02		 push	 2
  0007f	e8 00 00 00 00	 call	 ?WriteMessageMaybeToArray@WireFormatLite@internal@protobuf@google@@SAXHABVMessageLite@34@PAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SerializeW:

; 1631 :       2, *this->info_, output);
; 1632 :   }
; 1633 : 
; 1634 :   // @@protoc_insertion_point(serialize_end:NullPmd.head)
; 1635 : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
?SerializeWithCachedSizes@head@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::head::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -20						; size = 8
_this$ = -12						; size = 4
tv71 = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::head::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 1567 :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 ec	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1573 :     tag = p.first;

  00017	8b 4d ec	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx

; 1574 :     if (!p.second) goto handle_unusual;

  0001d	0f b6 55 f0	 movzx	 edx, BYTE PTR _p$1[ebp+4]
  00021	85 d2		 test	 edx, edx
  00023	75 02		 jne	 SHORT $LN30@MergeParti
  00025	eb 6b		 jmp	 SHORT $handle_unusual$72
$LN30@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  0002a	c1 e8 03	 shr	 eax, 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1575 :     switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {

  0002d	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00030	83 7d f8 01	 cmp	 DWORD PTR tv71[ebp], 1
  00034	74 08		 je	 SHORT $LN9@MergeParti
  00036	83 7d f8 02	 cmp	 DWORD PTR tv71[ebp], 2
  0003a	74 2c		 je	 SHORT $LN15@MergeParti
  0003c	eb 54		 jmp	 SHORT $handle_unusual$72
$LN9@MergeParti:

; 1576 :       // .NullPmd.command command = 1;
; 1577 :       case 1: {
; 1578 :         if (tag == 10u) {

  0003e	83 7d fc 0a	 cmp	 DWORD PTR _tag$[ebp], 10 ; 0000000aH
  00042	75 20		 jne	 SHORT __unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2

; 1579 :           DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(

  00044	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ; NullPmd::head::mutable_command
  0004c	50		 push	 eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??$ReadMessageNoVirtual@Vcommand@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVcommand@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::command>
  00056	83 c4 08	 add	 esp, 8
  00059	0f b6 d0	 movzx	 edx, al
  0005c	85 d2		 test	 edx, edx
  0005e	75 02		 jne	 SHORT $LN12@MergeParti
  00060	eb 65		 jmp	 SHORT $failure$73
$LN12@MergeParti:

; 1580 :                input, mutable_command()));
; 1581 :         } else {

  00062	eb 02		 jmp	 SHORT $LN11@MergeParti
__unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2:

; 1582 :           goto handle_unusual;

  00064	eb 2c		 jmp	 SHORT $handle_unusual$72
$LN11@MergeParti:

; 1583 :         }
; 1584 :         break;

  00066	eb 56		 jmp	 SHORT $LN5@MergeParti
$LN15@MergeParti:

; 1585 :       }
; 1586 : 
; 1587 :       // .NullPmd.info info = 2;
; 1588 :       case 2: {
; 1589 :         if (tag == 18u) {

  00068	83 7d fc 12	 cmp	 DWORD PTR _tag$[ebp], 18 ; 00000012H
  0006c	75 20		 jne	 SHORT __unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$4

; 1590 :           DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ ; NullPmd::head::mutable_info
  00076	50		 push	 eax
  00077	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??$ReadMessageNoVirtual@Vinfo@NullPmd@@@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@23@PAVinfo@NullPmd@@@Z ; google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual<NullPmd::info>
  00080	83 c4 08	 add	 esp, 8
  00083	0f b6 c8	 movzx	 ecx, al
  00086	85 c9		 test	 ecx, ecx
  00088	75 02		 jne	 SHORT $LN18@MergeParti
  0008a	eb 3b		 jmp	 SHORT $failure$73
$LN18@MergeParti:

; 1591 :                input, mutable_info()));
; 1592 :         } else {

  0008c	eb 02		 jmp	 SHORT $LN17@MergeParti
__unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$4:

; 1593 :           goto handle_unusual;

  0008e	eb 02		 jmp	 SHORT $handle_unusual$72
$LN17@MergeParti:

; 1594 :         }
; 1595 :         break;

  00090	eb 2c		 jmp	 SHORT $LN5@MergeParti
$handle_unusual$72:

; 1600 :         if (tag == 0 ||

  00092	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  00096	74 0b		 je	 SHORT __unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00098	8b 55 fc	 mov	 edx, DWORD PTR _tag$[ebp]
  0009b	83 e2 07	 and	 edx, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1600 :         if (tag == 0 ||

  0009e	83 fa 04	 cmp	 edx, 4
  000a1	75 02		 jne	 SHORT $LN22@MergeParti
__unwind$?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5:

; 1601 :             ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 1602 :             ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 1603 :           goto success;

  000a3	eb 1e		 jmp	 SHORT $success$74
$LN22@MergeParti:

; 1604 :         }
; 1605 :         DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  000b2	83 c4 08	 add	 esp, 8
  000b5	0f b6 d0	 movzx	 edx, al
  000b8	85 d2		 test	 edx, edx
  000ba	75 02		 jne	 SHORT $LN5@MergeParti
  000bc	eb 09		 jmp	 SHORT $failure$73
$LN5@MergeParti:

; 1606 :         break;
; 1607 :       }
; 1608 :     }
; 1609 :   }

  000be	e9 46 ff ff ff	 jmp	 $LN4@MergeParti
$success$74:

; 1610 : success:
; 1611 :   // @@protoc_insertion_point(parse_success:NullPmd.head)
; 1612 :   return true;

  000c3	b0 01		 mov	 al, 1
  000c5	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$73:

; 1613 : failure:
; 1614 :   // @@protoc_insertion_point(parse_failure:NullPmd.head)
; 1615 :   return false;

  000c7	32 c0		 xor	 al, al
$LN1@MergeParti:

; 1616 : #undef DO_
; 1617 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?MergePartialFromCodedStream@head@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::head::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@head@NullPmd@@UBEIXZ
_TEXT	SEGMENT
_cached_size$ = -44					; size = 4
_value$ = -40						; size = 4
_value$ = -36						; size = 4
$T1 = -32						; size = 4
tv133 = -28						; size = 4
$T2 = -24						; size = 4
tv89 = -20						; size = 4
_length$ = -16						; size = 4
_length$ = -12						; size = 4
_total_size$ = -8					; size = 4
_this$ = -4						; size = 4
?ByteSizeLong@head@NullPmd@@UBEIXZ PROC			; NullPmd::head::ByteSizeLong, COMDAT
; _this$ = ecx

; 1659 : size_t head::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1660 : // @@protoc_insertion_point(message_byte_size_start:NullPmd.head)
; 1661 :   size_t total_size = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 869  :   return this != internal_default_instance() && command_ != NULL;

  00010	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00017	74 12		 je	 SHORT $LN7@ByteSizeLo
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00020	74 09		 je	 SHORT $LN7@ByteSizeLo
  00022	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00029	eb 07		 jmp	 SHORT $LN5@ByteSizeLo
$LN7@ByteSizeLo:
  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN5@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1664 :   if (this->has_command()) {

  00032	0f b6 4d ec	 movzx	 ecx, BYTE PTR tv89[ebp]
  00036	85 c9		 test	 ecx, ecx
  00038	74 47		 je	 SHORT $LN23@ByteSizeLo

; 1665 :     total_size += 1 +

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00040	89 45 dc	 mov	 DWORD PTR _value$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 862  :   return LengthDelimitedSize(

  00043	8b 4d dc	 mov	 ecx, DWORD PTR _value$[ebp]
  00046	e8 00 00 00 00	 call	 ?ByteSizeLong@command@NullPmd@@UBEIXZ ; NullPmd::command::ByteSizeLong
  0004b	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  0004e	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  00055	73 0b		 jae	 SHORT $LN16@ByteSizeLo

; 1296 :     return 1;

  00057	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0005e	eb 11		 jmp	 SHORT $LN11@ByteSizeLo

; 1297 :   } else  {

  00060	eb 0f		 jmp	 SHORT $LN11@ByteSizeLo
$LN16@ByteSizeLo:

; 1298 :     return VarintSize32Fallback(value);

  00062	8b 4d f4	 mov	 ecx, DWORD PTR _length$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
$LN11@ByteSizeLo:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  00071	8b 55 f4	 mov	 edx, DWORD PTR _length$[ebp]
  00074	03 55 e8	 add	 edx, DWORD PTR $T2[ebp]
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1665 :     total_size += 1 +

  00077	8b 45 f8	 mov	 eax, DWORD PTR _total_size$[ebp]
  0007a	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  0007e	89 4d f8	 mov	 DWORD PTR _total_size$[ebp], ecx
$LN23@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 908  :   return this != internal_default_instance() && info_ != NULL;

  00081	81 7d fc 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00088	74 12		 je	 SHORT $LN21@ByteSizeLo
  0008a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008d	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  00091	74 09		 je	 SHORT $LN21@ByteSizeLo
  00093	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  0009a	eb 07		 jmp	 SHORT $LN19@ByteSizeLo
$LN21@ByteSizeLo:
  0009c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
$LN19@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1671 :   if (this->has_info()) {

  000a3	0f b6 45 e4	 movzx	 eax, BYTE PTR tv133[ebp]
  000a7	85 c0		 test	 eax, eax
  000a9	74 47		 je	 SHORT $LN33@ByteSizeLo

; 1672 :     total_size += 1 +

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000b1	89 55 d8	 mov	 DWORD PTR _value$[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 862  :   return LengthDelimitedSize(

  000b4	8b 4d d8	 mov	 ecx, DWORD PTR _value$[ebp]
  000b7	e8 00 00 00 00	 call	 ?ByteSizeLong@info@NullPmd@@UBEIXZ ; NullPmd::info::ByteSizeLong
  000bc	89 45 f0	 mov	 DWORD PTR _length$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1295 :   if (value < (1 << 7)) {

  000bf	81 7d f0 80 00
	00 00		 cmp	 DWORD PTR _length$[ebp], 128 ; 00000080H
  000c6	73 0b		 jae	 SHORT $LN30@ByteSizeLo

; 1296 :     return 1;

  000c8	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  000cf	eb 11		 jmp	 SHORT $LN25@ByteSizeLo

; 1297 :   } else  {

  000d1	eb 0f		 jmp	 SHORT $LN25@ByteSizeLo
$LN30@ByteSizeLo:

; 1298 :     return VarintSize32Fallback(value);

  000d3	8b 45 f0	 mov	 eax, DWORD PTR _length$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  000dc	83 c4 04	 add	 esp, 4
  000df	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
$LN25@ByteSizeLo:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 871  :   return length + io::CodedOutputStream::VarintSize32(

  000e2	8b 4d f0	 mov	 ecx, DWORD PTR _length$[ebp]
  000e5	03 4d e0	 add	 ecx, DWORD PTR $T1[ebp]
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1672 :     total_size += 1 +

  000e8	8b 55 f8	 mov	 edx, DWORD PTR _total_size$[ebp]
  000eb	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  000ef	89 45 f8	 mov	 DWORD PTR _total_size$[ebp], eax
$LN33@ByteSizeLo:

; 1673 :       ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
; 1674 :         *this->info_);
; 1675 :   }
; 1676 : 
; 1677 :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  000f2	8b 4d f8	 mov	 ecx, DWORD PTR _total_size$[ebp]
  000f5	89 4d d4	 mov	 DWORD PTR _cached_size$[ebp], ecx

; 1678 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1679 :   _cached_size_ = cached_size;

  000f8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000fb	8b 45 d4	 mov	 eax, DWORD PTR _cached_size$[ebp]
  000fe	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 1680 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1681 :   return total_size;

  00101	8b 45 f8	 mov	 eax, DWORD PTR _total_size$[ebp]

; 1682 : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
?ByteSizeLong@head@NullPmd@@UBEIXZ ENDP			; NullPmd::head::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@head@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@head@NullPmd@@UBE_NXZ PROC		; NullPmd::head::IsInitialized, COMDAT
; _this$ = ecx

; 1725 : bool head::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1726 :   return true;

  00007	b0 01		 mov	 al, 1

; 1727 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@head@NullPmd@@UBE_NXZ ENDP		; NullPmd::head::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@head@NullPmd@@UAEXXZ
_TEXT	SEGMENT
tv130 = -28						; size = 4
$T1 = -24						; size = 4
tv80 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
?Clear@head@NullPmd@@UAEXXZ PROC			; NullPmd::head::Clear, COMDAT
; _this$ = ecx

; 1554 : void head::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1555 : // @@protoc_insertion_point(message_clear_start:NullPmd.head)
; 1556 :   if (GetArenaNoVirtual() == NULL && command_ != NULL) {

  00009	33 c0		 xor	 eax, eax
  0000b	75 38		 jne	 SHORT $LN2@Clear
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00014	74 2f		 je	 SHORT $LN2@Clear

; 1557 :     delete command_;

  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0001f	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00022	89 4d f8	 mov	 DWORD PTR $T4[ebp], ecx
  00025	83 7d f8 00	 cmp	 DWORD PTR $T4[ebp], 0
  00029	74 13		 je	 SHORT $LN5@Clear
  0002b	6a 01		 push	 1
  0002d	8b 55 f8	 mov	 edx, DWORD PTR $T4[ebp]
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	ff d2		 call	 edx
  00039	89 45 ec	 mov	 DWORD PTR tv80[ebp], eax
  0003c	eb 07		 jmp	 SHORT $LN2@Clear
$LN5@Clear:
  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN2@Clear:

; 1558 :   }
; 1559 :   command_ = NULL;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 1560 :   if (GetArenaNoVirtual() == NULL && info_ != NULL) {

  0004f	33 c9		 xor	 ecx, ecx
  00051	75 38		 jne	 SHORT $LN3@Clear
  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0005a	74 2f		 je	 SHORT $LN3@Clear

; 1561 :     delete info_;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00062	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
  00065	8b 55 e8	 mov	 edx, DWORD PTR $T1[ebp]
  00068	89 55 f4	 mov	 DWORD PTR $T3[ebp], edx
  0006b	83 7d f4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0006f	74 13		 je	 SHORT $LN7@Clear
  00071	6a 01		 push	 1
  00073	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00076	8b 10		 mov	 edx, DWORD PTR [eax]
  00078	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0007b	8b 02		 mov	 eax, DWORD PTR [edx]
  0007d	ff d0		 call	 eax
  0007f	89 45 e4	 mov	 DWORD PTR tv130[ebp], eax
  00082	eb 07		 jmp	 SHORT $LN3@Clear
$LN7@Clear:
  00084	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN3@Clear:

; 1562 :   }
; 1563 :   info_ = NULL;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 1564 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?Clear@head@NullPmd@@UAEXXZ ENDP			; NullPmd::head::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@head@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
$T3 = -96						; size = 4
tv141 = -92						; size = 4
tv205 = -88						; size = 4
tv92 = -84						; size = 4
tv169 = -80						; size = 4
tv171 = -76						; size = 4
tv173 = -72						; size = 4
$T4 = -65						; size = 1
_this$ = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@head@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::head::MergeFrom, COMDAT
; _this$ = ecx

; 1699 : void head::MergeFrom(const head& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@head@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 1700 : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.head)
; 1701 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 c0	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 a5 06 00 00	 push	 1701			; 000006a5H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 a8	 mov	 DWORD PTR tv205[ebp], eax
  00053	8b 4d a8	 mov	 ecx, DWORD PTR tv205[ebp]
  00056	89 4d a4	 mov	 DWORD PTR tv141[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T5[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T5[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d a4	 mov	 ecx, DWORD PTR tv141[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d bf	 lea	 ecx, DWORD PTR $T4[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 1702 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 869  :   return this != internal_default_instance() && command_ != NULL;

  000ac	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  000b3	74 12		 je	 SHORT $LN49@MergeFrom
  000b5	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000b8	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000bc	74 09		 je	 SHORT $LN49@MergeFrom
  000be	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv173[ebp], 1
  000c5	eb 07		 jmp	 SHORT $LN47@MergeFrom
$LN49@MergeFrom:
  000c7	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv173[ebp], 0
$LN47@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1703 :   if (from.has_command()) {

  000ce	0f b6 45 b8	 movzx	 eax, BYTE PTR tv173[ebp]
  000d2	85 c0		 test	 eax, eax
  000d4	74 34		 je	 SHORT $LN69@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 877  :   return command_ != NULL ? *command_

  000d6	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000d9	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  000dd	74 0b		 je	 SHORT $LN57@MergeFrom
  000df	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000e2	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e5	89 45 b4	 mov	 DWORD PTR tv171[ebp], eax
  000e8	eb 07		 jmp	 SHORT $LN56@MergeFrom
$LN57@MergeFrom:
  000ea	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
$LN56@MergeFrom:
  000f1	8b 4d b4	 mov	 ecx, DWORD PTR tv171[ebp]
  000f4	89 4d a0	 mov	 DWORD PTR $T3[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1704 :     mutable_command()->::NullPmd::command::MergeFrom(from.command());

  000f7	8b 55 a0	 mov	 edx, DWORD PTR $T3[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ; NullPmd::head::mutable_command
  00103	8b c8		 mov	 ecx, eax
  00105	e8 00 00 00 00	 call	 ?MergeFrom@command@NullPmd@@QAEXABV12@@Z ; NullPmd::command::MergeFrom
$LN69@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 908  :   return this != internal_default_instance() && info_ != NULL;

  0010a	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00111	74 12		 je	 SHORT $LN67@MergeFrom
  00113	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00116	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0011a	74 09		 je	 SHORT $LN67@MergeFrom
  0011c	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv169[ebp], 1
  00123	eb 07		 jmp	 SHORT $LN65@MergeFrom
$LN67@MergeFrom:
  00125	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv169[ebp], 0
$LN65@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1706 :   if (from.has_info()) {

  0012c	0f b6 4d b0	 movzx	 ecx, BYTE PTR tv169[ebp]
  00130	85 c9		 test	 ecx, ecx
  00132	74 34		 je	 SHORT $LN1@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 916  :   return info_ != NULL ? *info_

  00134	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  00137	83 7a 0c 00	 cmp	 DWORD PTR [edx+12], 0
  0013b	74 0b		 je	 SHORT $LN75@MergeFrom
  0013d	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00140	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00143	89 4d ac	 mov	 DWORD PTR tv92[ebp], ecx
  00146	eb 07		 jmp	 SHORT $LN74@MergeFrom
$LN75@MergeFrom:
  00148	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
$LN74@MergeFrom:
  0014f	8b 55 ac	 mov	 edx, DWORD PTR tv92[ebp]
  00152	89 55 9c	 mov	 DWORD PTR $T2[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1707 :     mutable_info()->::NullPmd::info::MergeFrom(from.info());

  00155	8b 45 9c	 mov	 eax, DWORD PTR $T2[ebp]
  00158	50		 push	 eax
  00159	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ ; NullPmd::head::mutable_info
  00161	8b c8		 mov	 ecx, eax
  00163	e8 00 00 00 00	 call	 ?MergeFrom@info@NullPmd@@QAEXABV12@@Z ; NullPmd::info::MergeFrom
$LN1@MergeFrom:

; 1708 :   }
; 1709 : }

  00168	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00172	59		 pop	 ecx
  00173	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00176	33 cd		 xor	 ecx, ebp
  00178	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@head@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@head@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@head@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@head@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::head::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@head@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@head@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::head::CopyFrom, COMDAT
; _this$ = ecx

; 1718 : void head::CopyFrom(const head& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1719 : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.head)
; 1720 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1721 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@head@NullPmd@@UAEXXZ ; NullPmd::head::Clear

; 1722 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@head@NullPmd@@QAEXABV12@@Z ; NullPmd::head::MergeFrom
$LN1@CopyFrom:

; 1723 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@head@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::head::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::head::MergeFrom, COMDAT
; _this$ = ecx

; 1684 : void head::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 1685 : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.head)
; 1686 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 96 06 00 00	 push	 1686			; 00000696H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 1687 :   const head* source =
; 1688 :       ::google::protobuf::internal::DynamicCastToGenerated<const head>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVhead@NullPmd@@@internal@protobuf@google@@YAPBVhead@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::head const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 1689 :           &from);
; 1690 :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 1691 :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.head)
; 1692 :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 1693 :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 1694 :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.head)
; 1695 :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@head@NullPmd@@QAEXABV12@@Z ; NullPmd::head::MergeFrom
$LN1@MergeFrom:

; 1696 :   }
; 1697 : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::head::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::head::CopyFrom, COMDAT
; _this$ = ecx

; 1711 : void head::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1712 : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.head)
; 1713 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1714 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@head@NullPmd@@UAEXXZ ; NullPmd::head::Clear

; 1715 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::head::MergeFrom
$LN1@CopyFrom:

; 1716 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@head@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::head::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::head::New, COMDAT
; _this$ = ecx

; 1546 : head* head::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1547 :   head* n = new head;

  00028	6a 14		 push	 20			; 00000014H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@XZ	; NullPmd::head::head
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 1548 :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 1549 :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vhead@NullPmd@@@Arena@protobuf@google@@QAEXPAVhead@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::head>
$LN2@New:

; 1550 :   }
; 1551 :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 1552 : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::head::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@head@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@head@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::head::New, COMDAT
; _this$ = ecx

; 532  :   inline head* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@head@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::head::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@head@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::head::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@head@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@head@NullPmd@@QAEXPAV12@@Z PROC			; NullPmd::head::Swap, COMDAT
; _this$ = ecx

; 1729 : void head::Swap(head* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1730 :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 1731 :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@head@NullPmd@@AAEXPAV12@@Z ; NullPmd::head::InternalSwap
$LN1@Swap:

; 1732 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@head@NullPmd@@QAEXPAV12@@Z ENDP			; NullPmd::head::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@head@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@head@NullPmd@@SAPBV12@XZ PROC ; NullPmd::head::internal_default_instance, COMDAT

; 523  :   static inline const head* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 524  :     return reinterpret_cast<const head*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_

; 525  :                &_head_default_instance_);
; 526  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@head@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::head::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@head@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@head@NullPmd@@SAABV12@XZ PROC		; NullPmd::head::default_instance, COMDAT

; 1541 : const head& head::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1542 :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 1543 :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_

; 1544 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@head@NullPmd@@SAABV12@XZ ENDP		; NullPmd::head::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@head@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@head@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::head::descriptor, COMDAT

; 1536 : const ::google::protobuf::Descriptor* head::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1537 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1538 :   return protobuf_NullPmd_2eproto::file_level_metadata[5].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	6b c8 05	 imul	 ecx, eax, 5
  00010	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]

; 1539 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@head@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::head::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0head@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -52						; size = 4
$T3 = -48						; size = 4
_this$ = -44						; size = 4
tv164 = -40						; size = 4
$T4 = -36						; size = 4
tv225 = -32						; size = 4
tv145 = -28						; size = 4
$T5 = -24						; size = 4
tv227 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0head@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::head::head, COMDAT
; _this$ = ecx

; 1496 :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0head@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1494 :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1496 :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7head@NullPmd@@6B@

; 1495 :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1495 :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1496 :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 1497 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 869  :   return this != internal_default_instance() && command_ != NULL;

  0007c	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00083	74 12		 je	 SHORT $LN64@head
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  00088	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0008c	74 09		 je	 SHORT $LN64@head
  0008e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv227[ebp], 1
  00095	eb 07		 jmp	 SHORT $LN62@head
$LN64@head:
  00097	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv227[ebp], 0
$LN62@head:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1498 :   if (from.has_command()) {

  0009e	0f b6 55 ec	 movzx	 edx, BYTE PTR tv227[ebp]
  000a2	85 d2		 test	 edx, edx
  000a4	74 47		 je	 SHORT $LN2@head

; 1499 :     command_ = new ::NullPmd::command(*from.command_);

  000a6	6a 20		 push	 32			; 00000020H
  000a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ad	83 c4 04	 add	 esp, 4
  000b0	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  000b3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b7	83 7d e8 00	 cmp	 DWORD PTR $T5[ebp], 0
  000bb	74 14		 je	 SHORT $LN7@head
  000bd	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000c0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c3	51		 push	 ecx
  000c4	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  000c7	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@ABV01@@Z ; NullPmd::command::command
  000cc	89 45 e4	 mov	 DWORD PTR tv145[ebp], eax
  000cf	eb 07		 jmp	 SHORT $LN8@head
$LN7@head:
  000d1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
$LN8@head:
  000d8	8b 55 e4	 mov	 edx, DWORD PTR tv145[ebp]
  000db	89 55 d0	 mov	 DWORD PTR $T3[ebp], edx
  000de	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000e2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	8b 4d d0	 mov	 ecx, DWORD PTR $T3[ebp]
  000e8	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1500 :   } else {

  000eb	eb 0a		 jmp	 SHORT $LN72@head
$LN2@head:

; 1501 :     command_ = NULL;

  000ed	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
$LN72@head:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 908  :   return this != internal_default_instance() && info_ != NULL;

  000f7	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _from$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  000fe	74 12		 je	 SHORT $LN70@head
  00100	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00103	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00107	74 09		 je	 SHORT $LN70@head
  00109	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv225[ebp], 1
  00110	eb 07		 jmp	 SHORT $LN68@head
$LN70@head:
  00112	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv225[ebp], 0
$LN68@head:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1503 :   if (from.has_info()) {

  00119	0f b6 4d e0	 movzx	 ecx, BYTE PTR tv225[ebp]
  0011d	85 c9		 test	 ecx, ecx
  0011f	74 47		 je	 SHORT $LN4@head

; 1504 :     info_ = new ::NullPmd::info(*from.info_);

  00121	6a 28		 push	 40			; 00000028H
  00123	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00128	83 c4 04	 add	 esp, 4
  0012b	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  0012e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00132	83 7d dc 00	 cmp	 DWORD PTR $T4[ebp], 0
  00136	74 14		 je	 SHORT $LN9@head
  00138	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  0013b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0013e	50		 push	 eax
  0013f	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  00142	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@ABV01@@Z ; NullPmd::info::info
  00147	89 45 d8	 mov	 DWORD PTR tv164[ebp], eax
  0014a	eb 07		 jmp	 SHORT $LN10@head
$LN9@head:
  0014c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv164[ebp], 0
$LN10@head:
  00153	8b 4d d8	 mov	 ecx, DWORD PTR tv164[ebp]
  00156	89 4d cc	 mov	 DWORD PTR $T2[ebp], ecx
  00159	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0015d	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00160	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  00163	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 1505 :   } else {

  00166	eb 0a		 jmp	 SHORT $LN1@head
$LN4@head:

; 1506 :     info_ = NULL;

  00168	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN1@head:

; 1507 :   }
; 1508 :   // @@protoc_insertion_point(copy_constructor:NullPmd.head)
; 1509 : }

  00172	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00179	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00186	59		 pop	 ecx
  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$2:
  00013	6a 20		 push	 32			; 00000020H
  00015	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001e	83 c4 08	 add	 esp, 8
  00021	c3		 ret	 0
__unwindfunclet$??0head@NullPmd@@QAE@ABV01@@Z$3:
  00022	6a 28		 push	 40			; 00000028H
  00024	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	83 c4 08	 add	 esp, 8
  00030	c3		 ret	 0
__ehhandler$??0head@NullPmd@@QAE@ABV01@@Z:
  00031	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00035	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00038	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0head@NullPmd@@QAE@ABV01@@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0head@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::head::head
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1head@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1head@NullPmd@@UAE@XZ PROC				; NullPmd::head::~head, COMDAT
; _this$ = ecx

; 1517 : head::~head() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1head@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7head@NullPmd@@6B@

; 1518 :   // @@protoc_insertion_point(destructor:NullPmd.head)
; 1519 :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@head@NullPmd@@AAEXXZ ; NullPmd::head::SharedDtor

; 1520 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1520 : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1head@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1head@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1head@NullPmd@@UAE@XZ ENDP				; NullPmd::head::~head
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0head@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0head@NullPmd@@QAE@XZ PROC				; NullPmd::head::head, COMDAT
; _this$ = ecx

; 1486 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0head@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1486 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7head@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1486 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1487 :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  00067	74 05		 je	 SHORT $LN2@head

; 1488 :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@head:

; 1489 :   }
; 1490 :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@head@NullPmd@@AAEXXZ ; NullPmd::head::SharedCtor

; 1491 :   // @@protoc_insertion_point(constructor:NullPmd.head)
; 1492 : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0head@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0head@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0head@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0head@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0head@NullPmd@@QAE@XZ ENDP				; NullPmd::head::head
; Function compile flags: /Odtp
;	COMDAT ??_Ginfo@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Ginfo@NullPmd@@UAEPAXI@Z PROC			; NullPmd::info::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1info@NullPmd@@UAE@XZ	; NullPmd::info::~info
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Ginfo@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::info::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_wpacketsize@info@NullPmd@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
?set_wpacketsize@info@NullPmd@@QAEX_K@Z PROC		; NullPmd::info::set_wpacketsize, COMDAT
; _this$ = ecx

; 857  : inline void info::set_wpacketsize(::google::protobuf::uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 858  :   
; 859  :   wpacketsize_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00013	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 860  :   // @@protoc_insertion_point(field_set:NullPmd.info.wpacketsize)
; 861  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?set_wpacketsize@info@NullPmd@@QAEX_K@Z ENDP		; NullPmd::info::set_wpacketsize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?wpacketsize@info@NullPmd@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?wpacketsize@info@NullPmd@@QBE_KXZ PROC			; NullPmd::info::wpacketsize, COMDAT
; _this$ = ecx

; 853  : inline ::google::protobuf::uint64 info::wpacketsize() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 854  :   // @@protoc_insertion_point(field_get:NullPmd.info.wpacketsize)
; 855  :   return wpacketsize_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 856  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?wpacketsize@info@NullPmd@@QBE_KXZ ENDP			; NullPmd::info::wpacketsize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_cbcheckcode@info@NullPmd@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
?set_cbcheckcode@info@NullPmd@@QAEX_K@Z PROC		; NullPmd::info::set_cbcheckcode, COMDAT
; _this$ = ecx

; 843  : inline void info::set_cbcheckcode(::google::protobuf::uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 844  :   
; 845  :   cbcheckcode_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00013	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 846  :   // @@protoc_insertion_point(field_set:NullPmd.info.cbcheckcode)
; 847  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?set_cbcheckcode@info@NullPmd@@QAEX_K@Z ENDP		; NullPmd::info::set_cbcheckcode
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?cbcheckcode@info@NullPmd@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?cbcheckcode@info@NullPmd@@QBE_KXZ PROC			; NullPmd::info::cbcheckcode, COMDAT
; _this$ = ecx

; 839  : inline ::google::protobuf::uint64 info::cbcheckcode() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 840  :   // @@protoc_insertion_point(field_get:NullPmd.info.cbcheckcode)
; 841  :   return cbcheckcode_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]

; 842  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?cbcheckcode@info@NullPmd@@QBE_KXZ ENDP			; NullPmd::info::cbcheckcode
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_cbdatakind@info@NullPmd@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
?set_cbdatakind@info@NullPmd@@QAEX_K@Z PROC		; NullPmd::info::set_cbdatakind, COMDAT
; _this$ = ecx

; 829  : inline void info::set_cbdatakind(::google::protobuf::uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 830  :   
; 831  :   cbdatakind_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00013	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 832  :   // @@protoc_insertion_point(field_set:NullPmd.info.cbdatakind)
; 833  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?set_cbdatakind@info@NullPmd@@QAEX_K@Z ENDP		; NullPmd::info::set_cbdatakind
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?cbdatakind@info@NullPmd@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?cbdatakind@info@NullPmd@@QBE_KXZ PROC			; NullPmd::info::cbdatakind, COMDAT
; _this$ = ecx

; 825  : inline ::google::protobuf::uint64 info::cbdatakind() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 826  :   // @@protoc_insertion_point(field_get:NullPmd.info.cbdatakind)
; 827  :   return cbdatakind_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 828  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?cbdatakind@info@NullPmd@@QBE_KXZ ENDP			; NullPmd::info::cbdatakind
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@info@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@info@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::info::GetMetadata, COMDAT
; _this$ = ecx

; 1426 : ::google::protobuf::Metadata info::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1428 :   return protobuf_NullPmd_2eproto::file_level_metadata[4];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	c1 e0 02	 shl	 eax, 2
  00014	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]
  0001a	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax+4]
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1429 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@info@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::info::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@info@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
__Tmp$1 = -112						; size = 8
__Tmp$2 = -104						; size = 8
__Tmp$3 = -96						; size = 8
$T4 = -88						; size = 4
__Tmp$5 = -84						; size = 4
$T6 = -80						; size = 4
$T7 = -76						; size = 4
$T8 = -72						; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
__Right$ = -36						; size = 4
__Left$ = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@info@NullPmd@@AAEXPAV12@@Z PROC		; NullPmd::info::InternalSwap, COMDAT
; _this$ = ecx

; 1419 : void info::InternalSwap(info* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1420 :   std::swap(cbdatakind_, other->cbdatakind_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d f8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 d8	 mov	 DWORD PTR $T16[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d a0	 mov	 DWORD PTR __Tmp$3[ebp], ecx
  00029	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002c	89 55 a4	 mov	 DWORD PTR __Tmp$3[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0002f	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00035	8b 4d f8	 mov	 ecx, DWORD PTR __Left$[ebp]
  00038	8b 55 d4	 mov	 edx, DWORD PTR $T15[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00045	8d 45 a0	 lea	 eax, DWORD PTR __Tmp$3[ebp]
  00048	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 55 d0	 mov	 edx, DWORD PTR $T14[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00058	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1421 :   std::swap(cbcheckcode_, other->cbcheckcode_);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0005e	83 c0 10	 add	 eax, 16			; 00000010H
  00061	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 10	 add	 ecx, 16			; 00000010H
  0006a	89 4d f0	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0006d	8b 55 f0	 mov	 edx, DWORD PTR __Left$[ebp]
  00070	89 55 cc	 mov	 DWORD PTR $T13[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00073	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 4d 98	 mov	 DWORD PTR __Tmp$2[ebp], ecx
  0007b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007e	89 55 9c	 mov	 DWORD PTR __Tmp$2[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00081	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  00084	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008a	8b 55 c8	 mov	 edx, DWORD PTR $T12[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	89 01		 mov	 DWORD PTR [ecx], eax
  00091	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00094	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00097	8d 45 98	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  0009a	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0009d	8b 4d ec	 mov	 ecx, DWORD PTR __Right$[ebp]
  000a0	8b 55 c4	 mov	 edx, DWORD PTR $T11[ebp]
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax
  000a7	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000aa	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1422 :   std::swap(wpacketsize_, other->wpacketsize_);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  000b0	83 c0 18	 add	 eax, 24			; 00000018H
  000b3	89 45 e4	 mov	 DWORD PTR __Right$[ebp], eax
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 18	 add	 ecx, 24			; 00000018H
  000bc	89 4d e8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000bf	8b 55 e8	 mov	 edx, DWORD PTR __Left$[ebp]
  000c2	89 55 c0	 mov	 DWORD PTR $T10[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  000c5	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	89 4d 90	 mov	 DWORD PTR __Tmp$1[ebp], ecx
  000cd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000d0	89 55 94	 mov	 DWORD PTR __Tmp$1[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000d3	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  000d6	89 45 bc	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  000d9	8b 4d e8	 mov	 ecx, DWORD PTR __Left$[ebp]
  000dc	8b 55 bc	 mov	 edx, DWORD PTR $T9[ebp]
  000df	8b 02		 mov	 eax, DWORD PTR [edx]
  000e1	89 01		 mov	 DWORD PTR [ecx], eax
  000e3	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000e6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000e9	8d 45 90	 lea	 eax, DWORD PTR __Tmp$1[ebp]
  000ec	89 45 b8	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  000ef	8b 4d e4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000f2	8b 55 b8	 mov	 edx, DWORD PTR $T8[ebp]
  000f5	8b 02		 mov	 eax, DWORD PTR [edx]
  000f7	89 01		 mov	 DWORD PTR [ecx], eax
  000f9	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fc	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1423 :   std::swap(_cached_size_, other->_cached_size_);

  000ff	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  00102	83 c0 20	 add	 eax, 32			; 00000020H
  00105	89 45 dc	 mov	 DWORD PTR __Right$[ebp], eax
  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	83 c1 20	 add	 ecx, 32			; 00000020H
  0010e	89 4d e0	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00111	8b 55 e0	 mov	 edx, DWORD PTR __Left$[ebp]
  00114	89 55 b4	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00117	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0011a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011c	89 4d ac	 mov	 DWORD PTR __Tmp$5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0011f	8b 55 dc	 mov	 edx, DWORD PTR __Right$[ebp]
  00122	89 55 b0	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00125	8b 45 e0	 mov	 eax, DWORD PTR __Left$[ebp]
  00128	8b 4d b0	 mov	 ecx, DWORD PTR $T6[ebp]
  0012b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012d	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0012f	8d 45 ac	 lea	 eax, DWORD PTR __Tmp$5[ebp]
  00132	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  00135	8b 4d dc	 mov	 ecx, DWORD PTR __Right$[ebp]
  00138	8b 55 a8	 mov	 edx, DWORD PTR $T4[ebp]
  0013b	8b 02		 mov	 eax, DWORD PTR [edx]
  0013d	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1424 : }

  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c2 04 00	 ret	 4
?InternalSwap@info@NullPmd@@AAEXPAV12@@Z ENDP		; NullPmd::info::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@info@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@info@NullPmd@@EBEXH@Z PROC		; NullPmd::info::SetCachedSize, COMDAT
; _this$ = ecx

; 1192 : void info::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1193 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1194 :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 1195 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1196 : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@info@NullPmd@@EBEXH@Z ENDP		; NullPmd::info::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@info@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedDtor@info@NullPmd@@AAEXXZ PROC			; NullPmd::info::SharedDtor, COMDAT
; _this$ = ecx

; 1189 : void info::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1190 : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?SharedDtor@info@NullPmd@@AAEXXZ ENDP			; NullPmd::info::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@info@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@info@NullPmd@@AAEXXZ PROC			; NullPmd::info::SharedCtor, COMDAT
; _this$ = ecx

; 1178 : void info::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1179 :   ::memset(&cbdatakind_, 0, reinterpret_cast<char*>(&wpacketsize_) -

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 18	 add	 eax, 24			; 00000018H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 08	 add	 ecx, 8
  00013	2b c1		 sub	 eax, ecx
  00015	83 c0 08	 add	 eax, 8
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 c2 08	 add	 edx, 8
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1180 :     reinterpret_cast<char*>(&cbdatakind_) + sizeof(wpacketsize_));
; 1181 :   _cached_size_ = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 1182 : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SharedCtor@info@NullPmd@@AAEXXZ ENDP			; NullPmd::info::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@info@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@info@NullPmd@@UBEHXZ PROC		; NullPmd::info::GetCachedSize, COMDAT
; _this$ = ecx

; 457  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@info@NullPmd@@UBEHXZ ENDP		; NullPmd::info::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@info@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@info@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::info::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 453  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 454  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::info::InternalSerializeWithCachedSizesToArray

; 455  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 456  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@info@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::info::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
$T1 = -52						; size = 8
$T2 = -44						; size = 8
$T3 = -36						; size = 8
$T4 = -28						; size = 8
$T5 = -20						; size = 8
$T6 = -12						; size = 8
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::info::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 1313 :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f4	 mov	 DWORD PTR $T6[ebp], ecx
  00012	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00015	89 55 f8	 mov	 DWORD PTR $T6[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1317 :   if (this->cbdatakind() != 0) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0001b	0b 45 f8	 or	 eax, DWORD PTR $T6[ebp+4]
  0001e	74 28		 je	 SHORT $LN2@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	89 55 ec	 mov	 DWORD PTR $T5[ebp], edx
  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 45 f0	 mov	 DWORD PTR $T5[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1318 :     target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->cbdatakind(), target);

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp+4]
  00036	52		 push	 edx
  00037	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN2@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004e	89 55 e4	 mov	 DWORD PTR $T4[ebp], edx
  00051	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00054	89 45 e8	 mov	 DWORD PTR $T4[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1322 :   if (this->cbcheckcode() != 0) {

  00057	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  0005a	0b 4d e8	 or	 ecx, DWORD PTR $T4[ebp+4]
  0005d	74 28		 je	 SHORT $LN3@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00065	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
  00068	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0006b	89 4d e0	 mov	 DWORD PTR $T3[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1323 :     target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->cbcheckcode(), target);

  0006e	8b 55 0c	 mov	 edx, DWORD PTR _target$[ebp]
  00071	52		 push	 edx
  00072	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp+4]
  00075	50		 push	 eax
  00076	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00079	51		 push	 ecx
  0007a	6a 02		 push	 2
  0007c	e8 00 00 00 00	 call	 ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN3@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  00087	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0008d	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  00090	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00093	89 4d d8	 mov	 DWORD PTR $T2[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1327 :   if (this->wpacketsize() != 0) {

  00096	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  00099	0b 55 d8	 or	 edx, DWORD PTR $T2[ebp+4]
  0009c	74 28		 je	 SHORT $LN4@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000a4	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  000a7	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000aa	89 55 d0	 mov	 DWORD PTR $T1[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1328 :     target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->wpacketsize(), target);

  000ad	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d d0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  000b4	51		 push	 ecx
  000b5	8b 55 cc	 mov	 edx, DWORD PTR $T1[ebp]
  000b8	52		 push	 edx
  000b9	6a 03		 push	 3
  000bb	e8 00 00 00 00	 call	 ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
  000c0	83 c4 10	 add	 esp, 16			; 00000010H
  000c3	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN4@InternalSe:

; 1329 :   }
; 1330 : 
; 1331 :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.info)
; 1332 :   return target;

  000c6	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 1333 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@info@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::info::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@info@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 8
$T2 = -44						; size = 8
$T3 = -36						; size = 8
$T4 = -28						; size = 8
$T5 = -20						; size = 8
$T6 = -12						; size = 8
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@info@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::info::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 1292 :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f4	 mov	 DWORD PTR $T6[ebp], ecx
  00012	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00015	89 55 f8	 mov	 DWORD PTR $T6[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1295 :   if (this->cbdatakind() != 0) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0001b	0b 45 f8	 or	 eax, DWORD PTR $T6[ebp+4]
  0001e	74 25		 je	 SHORT $LN2@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	89 55 ec	 mov	 DWORD PTR $T5[ebp], edx
  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 45 f0	 mov	 DWORD PTR $T5[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1296 :     ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->cbdatakind(), output);

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp+4]
  00036	52		 push	 edx
  00037	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64
  00042	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 e4	 mov	 DWORD PTR $T4[ebp], edx
  0004e	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00051	89 45 e8	 mov	 DWORD PTR $T4[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1300 :   if (this->cbcheckcode() != 0) {

  00054	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  00057	0b 4d e8	 or	 ecx, DWORD PTR $T4[ebp+4]
  0005a	74 25		 je	 SHORT $LN3@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00062	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
  00065	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00068	89 4d e0	 mov	 DWORD PTR $T3[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1301 :     ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->cbcheckcode(), output);

  0006b	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp+4]
  00072	50		 push	 eax
  00073	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00076	51		 push	 ecx
  00077	6a 02		 push	 2
  00079	e8 00 00 00 00	 call	 ?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
$LN3@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  00081	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00084	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00087	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  0008a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0008d	89 4d d8	 mov	 DWORD PTR $T2[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1305 :   if (this->wpacketsize() != 0) {

  00090	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  00093	0b 55 d8	 or	 edx, DWORD PTR $T2[ebp+4]
  00096	74 25		 je	 SHORT $LN1@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0009e	89 4d cc	 mov	 DWORD PTR $T1[ebp], ecx
  000a1	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000a4	89 55 d0	 mov	 DWORD PTR $T1[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1306 :     ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->wpacketsize(), output);

  000a7	8b 45 08	 mov	 eax, DWORD PTR _output$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d d0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  000ae	51		 push	 ecx
  000af	8b 55 cc	 mov	 edx, DWORD PTR $T1[ebp]
  000b2	52		 push	 edx
  000b3	6a 03		 push	 3
  000b5	e8 00 00 00 00	 call	 ?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64
  000ba	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SerializeW:

; 1307 :   }
; 1308 : 
; 1309 :   // @@protoc_insertion_point(serialize_end:NullPmd.info)
; 1310 : }

  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 04 00	 ret	 4
?SerializeWithCachedSizes@info@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::info::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -20						; size = 8
_this$ = -12						; size = 4
tv71 = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::info::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 1222 :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 ec	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1228 :     tag = p.first;

  00017	8b 4d ec	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx

; 1229 :     if (!p.second) goto handle_unusual;

  0001d	0f b6 55 f0	 movzx	 edx, BYTE PTR _p$1[ebp+4]
  00021	85 d2		 test	 edx, edx
  00023	75 0a		 jne	 SHORT $LN36@MergeParti
  00025	e9 a6 00 00 00	 jmp	 $handle_unusual$61
  0002a	e9 a1 00 00 00	 jmp	 $handle_unusual$61
$LN36@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  00032	c1 e8 03	 shr	 eax, 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1230 :     switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {

  00035	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00038	83 7d f8 01	 cmp	 DWORD PTR tv71[ebp], 1
  0003c	74 11		 je	 SHORT $LN9@MergeParti
  0003e	83 7d f8 02	 cmp	 DWORD PTR tv71[ebp], 2
  00042	74 3c		 je	 SHORT $LN15@MergeParti
  00044	83 7d f8 03	 cmp	 DWORD PTR tv71[ebp], 3
  00048	74 5e		 je	 SHORT $LN21@MergeParti
  0004a	e9 81 00 00 00	 jmp	 $handle_unusual$61
$LN9@MergeParti:

; 1231 :       // uint64 cbdatakind = 1;
; 1232 :       case 1: {
; 1233 :         if (tag == 8u) {

  0004f	83 7d fc 08	 cmp	 DWORD PTR _tag$[ebp], 8
  00053	75 22		 jne	 SHORT $LN10@MergeParti

; 1235 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00055	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 08	 add	 ecx, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 88   :   return input->ReadVarint64(value);

  0005b	51		 push	 ecx
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  0005f	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1235 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00064	0f b6 d0	 movzx	 edx, al
  00067	85 d2		 test	 edx, edx
  00069	75 0a		 jne	 SHORT $LN12@MergeParti
  0006b	e9 99 00 00 00	 jmp	 $failure$62
  00070	e9 94 00 00 00	 jmp	 $failure$62
$LN12@MergeParti:

; 1236 :                    ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
; 1237 :                  input, &cbdatakind_)));
; 1238 :         } else {

  00075	eb 04		 jmp	 SHORT $LN11@MergeParti
$LN10@MergeParti:

; 1239 :           goto handle_unusual;

  00077	eb 57		 jmp	 SHORT $handle_unusual$61
  00079	eb 55		 jmp	 SHORT $handle_unusual$61
$LN11@MergeParti:

; 1240 :         }
; 1241 :         break;

  0007b	e9 80 00 00 00	 jmp	 $LN5@MergeParti
$LN15@MergeParti:

; 1242 :       }
; 1243 : 
; 1244 :       // uint64 cbcheckcode = 2;
; 1245 :       case 2: {
; 1246 :         if (tag == 16u) {

  00080	83 7d fc 10	 cmp	 DWORD PTR _tag$[ebp], 16 ; 00000010H
  00084	75 1c		 jne	 SHORT $LN16@MergeParti

; 1248 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00086	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 10	 add	 eax, 16			; 00000010H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 88   :   return input->ReadVarint64(value);

  0008c	50		 push	 eax
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00090	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1248 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00095	0f b6 c8	 movzx	 ecx, al
  00098	85 c9		 test	 ecx, ecx
  0009a	75 04		 jne	 SHORT $LN18@MergeParti
  0009c	eb 6b		 jmp	 SHORT $failure$62
  0009e	eb 69		 jmp	 SHORT $failure$62
$LN18@MergeParti:

; 1249 :                    ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
; 1250 :                  input, &cbcheckcode_)));
; 1251 :         } else {

  000a0	eb 04		 jmp	 SHORT $LN17@MergeParti
$LN16@MergeParti:

; 1252 :           goto handle_unusual;

  000a2	eb 2c		 jmp	 SHORT $handle_unusual$61
  000a4	eb 2a		 jmp	 SHORT $handle_unusual$61
$LN17@MergeParti:

; 1253 :         }
; 1254 :         break;

  000a6	eb 58		 jmp	 SHORT $LN5@MergeParti
$LN21@MergeParti:

; 1255 :       }
; 1256 : 
; 1257 :       // uint64 wpacketsize = 3;
; 1258 :       case 3: {
; 1259 :         if (tag == 24u) {

  000a8	83 7d fc 18	 cmp	 DWORD PTR _tag$[ebp], 24 ; 00000018H
  000ac	75 1c		 jne	 SHORT $LN22@MergeParti

; 1261 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  000ae	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000b1	83 c2 18	 add	 edx, 24			; 00000018H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 88   :   return input->ReadVarint64(value);

  000b4	52		 push	 edx
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000b8	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1261 :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  000bd	0f b6 c0	 movzx	 eax, al
  000c0	85 c0		 test	 eax, eax
  000c2	75 04		 jne	 SHORT $LN24@MergeParti
  000c4	eb 43		 jmp	 SHORT $failure$62
  000c6	eb 41		 jmp	 SHORT $failure$62
$LN24@MergeParti:

; 1262 :                    ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
; 1263 :                  input, &wpacketsize_)));
; 1264 :         } else {

  000c8	eb 04		 jmp	 SHORT $LN23@MergeParti
$LN22@MergeParti:

; 1265 :           goto handle_unusual;

  000ca	eb 04		 jmp	 SHORT $handle_unusual$61
  000cc	eb 02		 jmp	 SHORT $handle_unusual$61
$LN23@MergeParti:

; 1266 :         }
; 1267 :         break;

  000ce	eb 30		 jmp	 SHORT $LN5@MergeParti
$handle_unusual$61:

; 1272 :         if (tag == 0 ||

  000d0	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  000d4	74 0b		 je	 SHORT $LN29@MergeParti
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _tag$[ebp]
  000d9	83 e1 07	 and	 ecx, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1272 :         if (tag == 0 ||

  000dc	83 f9 04	 cmp	 ecx, 4
  000df	75 04		 jne	 SHORT $LN28@MergeParti
$LN29@MergeParti:

; 1273 :             ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 1274 :             ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 1275 :           goto success;

  000e1	eb 22		 jmp	 SHORT $success$63
  000e3	eb 20		 jmp	 SHORT $success$63
$LN28@MergeParti:

; 1276 :         }
; 1277 :         DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _tag$[ebp]
  000e8	52		 push	 edx
  000e9	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  000f2	83 c4 08	 add	 esp, 8
  000f5	0f b6 c8	 movzx	 ecx, al
  000f8	85 c9		 test	 ecx, ecx
  000fa	75 04		 jne	 SHORT $LN5@MergeParti
  000fc	eb 0b		 jmp	 SHORT $failure$62
  000fe	eb 09		 jmp	 SHORT $failure$62
$LN5@MergeParti:

; 1278 :         break;
; 1279 :       }
; 1280 :     }
; 1281 :   }

  00100	e9 04 ff ff ff	 jmp	 $LN4@MergeParti
$success$63:

; 1282 : success:
; 1283 :   // @@protoc_insertion_point(parse_success:NullPmd.info)
; 1284 :   return true;

  00105	b0 01		 mov	 al, 1
  00107	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$62:

; 1285 : failure:
; 1286 :   // @@protoc_insertion_point(parse_failure:NullPmd.info)
; 1287 :   return false;

  00109	32 c0		 xor	 al, al
$LN1@MergeParti:

; 1288 : #undef DO_
; 1289 : }

  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c2 04 00	 ret	 4
?MergePartialFromCodedStream@info@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::info::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@info@NullPmd@@UBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 8
$T2 = -52						; size = 8
$T3 = -44						; size = 8
$T4 = -36						; size = 8
$T5 = -28						; size = 8
$T6 = -20						; size = 8
_cached_size$ = -12					; size = 4
_this$ = -8						; size = 4
_total_size$ = -4					; size = 4
?ByteSizeLong@info@NullPmd@@UBEIXZ PROC			; NullPmd::info::ByteSizeLong, COMDAT
; _this$ = ecx

; 1335 : size_t info::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1336 : // @@protoc_insertion_point(message_byte_size_start:NullPmd.info)
; 1337 :   size_t total_size = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	89 4d ec	 mov	 DWORD PTR $T6[ebp], ecx
  00019	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001c	89 55 f0	 mov	 DWORD PTR $T6[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1340 :   if (this->cbdatakind() != 0) {

  0001f	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00022	0b 45 f0	 or	 eax, DWORD PTR $T6[ebp+4]
  00025	74 29		 je	 SHORT $LN2@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002d	89 55 e4	 mov	 DWORD PTR $T5[ebp], edx
  00030	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00033	89 45 e8	 mov	 DWORD PTR $T5[ebp+4], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp+4]
  00039	51		 push	 ecx
  0003a	8b 55 e4	 mov	 edx, DWORD PTR $T5[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  00043	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1341 :     total_size += 1 +

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  00049	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0004d	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN2@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00056	89 4d dc	 mov	 DWORD PTR $T4[ebp], ecx
  00059	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0005c	89 55 e0	 mov	 DWORD PTR $T4[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1347 :   if (this->cbcheckcode() != 0) {

  0005f	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00062	0b 45 e0	 or	 eax, DWORD PTR $T4[ebp+4]
  00065	74 29		 je	 SHORT $LN3@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006d	89 55 d4	 mov	 DWORD PTR $T3[ebp], edx
  00070	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00073	89 45 d8	 mov	 DWORD PTR $T3[ebp+4], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  00076	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp+4]
  00079	51		 push	 ecx
  0007a	8b 55 d4	 mov	 edx, DWORD PTR $T3[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  00083	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1348 :     total_size += 1 +

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  00089	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0008d	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN3@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  00090	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00096	89 4d cc	 mov	 DWORD PTR $T2[ebp], ecx
  00099	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0009c	89 55 d0	 mov	 DWORD PTR $T2[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1354 :   if (this->wpacketsize() != 0) {

  0009f	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	0b 45 d0	 or	 eax, DWORD PTR $T2[ebp+4]
  000a5	74 29		 je	 SHORT $LN24@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  000a7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000ad	89 55 c4	 mov	 DWORD PTR $T1[ebp], edx
  000b0	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000b3	89 45 c8	 mov	 DWORD PTR $T1[ebp+4], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  000b6	8b 4d c8	 mov	 ecx, DWORD PTR $T1[ebp+4]
  000b9	51		 push	 ecx
  000ba	8b 55 c4	 mov	 edx, DWORD PTR $T1[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  000c3	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1355 :     total_size += 1 +

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  000c9	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000cd	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN24@ByteSizeLo:

; 1356 :       ::google::protobuf::internal::WireFormatLite::UInt64Size(
; 1357 :         this->wpacketsize());
; 1358 :   }
; 1359 : 
; 1360 :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  000d0	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]
  000d3	89 45 f4	 mov	 DWORD PTR _cached_size$[ebp], eax

; 1361 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1362 :   _cached_size_ = cached_size;

  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 55 f4	 mov	 edx, DWORD PTR _cached_size$[ebp]
  000dc	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 1363 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1364 :   return total_size;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]

; 1365 : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c3		 ret	 0
?ByteSizeLong@info@NullPmd@@UBEIXZ ENDP			; NullPmd::info::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@info@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@info@NullPmd@@UBE_NXZ PROC		; NullPmd::info::IsInitialized, COMDAT
; _this$ = ecx

; 1411 : bool info::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1412 :   return true;

  00007	b0 01		 mov	 al, 1

; 1413 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@info@NullPmd@@UBE_NXZ ENDP		; NullPmd::info::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@info@NullPmd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@info@NullPmd@@UAEXXZ PROC			; NullPmd::info::Clear, COMDAT
; _this$ = ecx

; 1215 : void info::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1216 : // @@protoc_insertion_point(message_clear_start:NullPmd.info)
; 1217 :   ::memset(&cbdatakind_, 0, reinterpret_cast<char*>(&wpacketsize_) -

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 18	 add	 eax, 24			; 00000018H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 08	 add	 ecx, 8
  00013	2b c1		 sub	 eax, ecx
  00015	83 c0 08	 add	 eax, 8
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 c2 08	 add	 edx, 8
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1218 :     reinterpret_cast<char*>(&cbdatakind_) + sizeof(wpacketsize_));
; 1219 : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?Clear@info@NullPmd@@UAEXXZ ENDP			; NullPmd::info::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@info@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
$T2 = -124						; size = 8
$T3 = -116						; size = 8
$T4 = -108						; size = 8
$T5 = -100						; size = 8
$T6 = -92						; size = 8
$T7 = -84						; size = 8
tv142 = -76						; size = 4
tv137 = -72						; size = 4
$T8 = -65						; size = 1
_this$ = -64						; size = 4
$T9 = -60						; size = 4
$T10 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@info@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::info::MergeFrom, COMDAT
; _this$ = ecx

; 1382 : void info::MergeFrom(const info& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@info@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0

; 1383 : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.info)
; 1384 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 c0	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN6@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN7@MergeFrom
$LN6@MergeFrom:
  0003c	68 68 05 00 00	 push	 1384			; 00000568H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b8	 mov	 DWORD PTR tv137[ebp], eax
  00053	8b 4d b8	 mov	 ecx, DWORD PTR tv137[ebp]
  00056	89 4d b4	 mov	 DWORD PTR tv142[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T9[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T9[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b4	 mov	 ecx, DWORD PTR tv142[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d bf	 lea	 ecx, DWORD PTR $T8[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN7@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN10@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN10@MergeFrom:

; 1385 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  000ac	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b2	89 45 ac	 mov	 DWORD PTR $T7[ebp], eax
  000b5	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000b8	89 4d b0	 mov	 DWORD PTR $T7[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1386 :   if (from.cbdatakind() != 0) {

  000bb	8b 55 ac	 mov	 edx, DWORD PTR $T7[ebp]
  000be	0b 55 b0	 or	 edx, DWORD PTR $T7[ebp+4]
  000c1	74 1e		 je	 SHORT $LN2@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000c6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c9	89 4d a4	 mov	 DWORD PTR $T6[ebp], ecx
  000cc	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000cf	89 55 a8	 mov	 DWORD PTR $T6[ebp+4], edx

; 831  :   cbdatakind_ = value;

  000d2	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d a4	 mov	 ecx, DWORD PTR $T6[ebp]
  000d8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000db	8b 55 a8	 mov	 edx, DWORD PTR $T6[ebp+4]
  000de	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@MergeFrom:

; 841  :   return cbcheckcode_;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000e4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000e7	89 4d 9c	 mov	 DWORD PTR $T5[ebp], ecx
  000ea	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ed	89 55 a0	 mov	 DWORD PTR $T5[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1389 :   if (from.cbcheckcode() != 0) {

  000f0	8b 45 9c	 mov	 eax, DWORD PTR $T5[ebp]
  000f3	0b 45 a0	 or	 eax, DWORD PTR $T5[ebp+4]
  000f6	74 1e		 je	 SHORT $LN3@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 841  :   return cbcheckcode_;

  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000fb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fe	89 55 94	 mov	 DWORD PTR $T4[ebp], edx
  00101	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00104	89 45 98	 mov	 DWORD PTR $T4[ebp+4], eax

; 845  :   cbcheckcode_ = value;

  00107	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	8b 55 94	 mov	 edx, DWORD PTR $T4[ebp]
  0010d	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00110	8b 45 98	 mov	 eax, DWORD PTR $T4[ebp+4]
  00113	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN3@MergeFrom:

; 855  :   return wpacketsize_;

  00116	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  00119	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0011c	89 55 8c	 mov	 DWORD PTR $T3[ebp], edx
  0011f	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00122	89 45 90	 mov	 DWORD PTR $T3[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1392 :   if (from.wpacketsize() != 0) {

  00125	8b 4d 8c	 mov	 ecx, DWORD PTR $T3[ebp]
  00128	0b 4d 90	 or	 ecx, DWORD PTR $T3[ebp+4]
  0012b	74 1e		 je	 SHORT $LN1@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 855  :   return wpacketsize_;

  0012d	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  00130	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00133	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
  00136	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00139	89 4d 88	 mov	 DWORD PTR $T2[ebp+4], ecx

; 859  :   wpacketsize_ = value;

  0013c	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  0013f	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  00142	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00145	8b 4d 88	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00148	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
$LN1@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1395 : }

  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00155	59		 pop	 ecx
  00156	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00159	33 cd		 xor	 ecx, ebp
  0015b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@info@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN9@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@info@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@info@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@info@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::info::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@info@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@info@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::info::CopyFrom, COMDAT
; _this$ = ecx

; 1404 : void info::CopyFrom(const info& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1405 : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.info)
; 1406 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1407 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@info@NullPmd@@UAEXXZ ; NullPmd::info::Clear

; 1408 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@info@NullPmd@@QAEXABV12@@Z ; NullPmd::info::MergeFrom
$LN1@CopyFrom:

; 1409 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@info@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::info::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::info::MergeFrom, COMDAT
; _this$ = ecx

; 1367 : void info::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 1368 : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.info)
; 1369 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 59 05 00 00	 push	 1369			; 00000559H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 1370 :   const info* source =
; 1371 :       ::google::protobuf::internal::DynamicCastToGenerated<const info>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVinfo@NullPmd@@@internal@protobuf@google@@YAPBVinfo@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::info const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 1372 :           &from);
; 1373 :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 1374 :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.info)
; 1375 :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 1376 :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 1377 :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.info)
; 1378 :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@info@NullPmd@@QAEXABV12@@Z ; NullPmd::info::MergeFrom
$LN1@MergeFrom:

; 1379 :   }
; 1380 : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::info::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::info::CopyFrom, COMDAT
; _this$ = ecx

; 1397 : void info::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1398 : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.info)
; 1399 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1400 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@info@NullPmd@@UAEXXZ ; NullPmd::info::Clear

; 1401 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::info::MergeFrom
$LN1@CopyFrom:

; 1402 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@info@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::info::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::info::New, COMDAT
; _this$ = ecx

; 1207 : info* info::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1208 :   info* n = new info;

  00028	6a 28		 push	 40			; 00000028H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@XZ	; NullPmd::info::info
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 1209 :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 1210 :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vinfo@NullPmd@@@Arena@protobuf@google@@QAEXPAVinfo@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::info>
$LN2@New:

; 1211 :   }
; 1212 :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 1213 : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 28		 push	 40			; 00000028H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::info::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@info@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@info@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::info::New, COMDAT
; _this$ = ecx

; 435  :   inline info* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@info@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::info::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@info@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::info::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@info@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@info@NullPmd@@QAEXPAV12@@Z PROC			; NullPmd::info::Swap, COMDAT
; _this$ = ecx

; 1415 : void info::Swap(info* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1416 :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 1417 :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@info@NullPmd@@AAEXPAV12@@Z ; NullPmd::info::InternalSwap
$LN1@Swap:

; 1418 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@info@NullPmd@@QAEXPAV12@@Z ENDP			; NullPmd::info::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@info@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@info@NullPmd@@SAPBV12@XZ PROC ; NullPmd::info::internal_default_instance, COMDAT

; 426  :   static inline const info* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 427  :     return reinterpret_cast<const info*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_

; 428  :                &_info_default_instance_);
; 429  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@info@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::info::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@info@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@info@NullPmd@@SAABV12@XZ PROC		; NullPmd::info::default_instance, COMDAT

; 1202 : const info& info::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1203 :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 1204 :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_

; 1205 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@info@NullPmd@@SAABV12@XZ ENDP		; NullPmd::info::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@info@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@info@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::info::descriptor, COMDAT

; 1197 : const ::google::protobuf::Descriptor* info::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1198 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1199 :   return protobuf_NullPmd_2eproto::file_level_metadata[4].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	c1 e0 02	 shl	 eax, 2
  00010	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]

; 1200 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@info@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::info::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0info@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0info@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::info::info, COMDAT
; _this$ = ecx

; 1170 :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0info@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1168 :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1170 :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7info@NullPmd@@6B@

; 1169 :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1169 :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1170 :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 1171 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 1172 :   ::memcpy(&cbdatakind_, &from.cbdatakind_,

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 18	 add	 ecx, 24			; 00000018H
  00082	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00085	83 c2 08	 add	 edx, 8
  00088	2b ca		 sub	 ecx, edx
  0008a	83 c1 08	 add	 ecx, 8
  0008d	51		 push	 ecx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00091	83 c0 08	 add	 eax, 8
  00094	50		 push	 eax
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	83 c1 08	 add	 ecx, 8
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1173 :     reinterpret_cast<char*>(&wpacketsize_) -
; 1174 :     reinterpret_cast<char*>(&cbdatakind_) + sizeof(wpacketsize_));
; 1175 :   // @@protoc_insertion_point(copy_constructor:NullPmd.info)
; 1176 : }

  000a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0info@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0info@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0info@NullPmd@@QAE@ABV01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0info@NullPmd@@QAE@ABV01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0info@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::info::info
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1info@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1info@NullPmd@@UAE@XZ PROC				; NullPmd::info::~info, COMDAT
; _this$ = ecx

; 1184 : info::~info() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1info@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7info@NullPmd@@6B@

; 1185 :   // @@protoc_insertion_point(destructor:NullPmd.info)
; 1186 :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@info@NullPmd@@AAEXXZ ; NullPmd::info::SharedDtor

; 1187 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1187 : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1info@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1info@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1info@NullPmd@@UAE@XZ ENDP				; NullPmd::info::~info
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0info@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0info@NullPmd@@QAE@XZ PROC				; NullPmd::info::info, COMDAT
; _this$ = ecx

; 1160 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0info@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1160 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7info@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1160 :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1161 :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
  00067	74 05		 je	 SHORT $LN2@info

; 1162 :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@info:

; 1163 :   }
; 1164 :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@info@NullPmd@@AAEXXZ ; NullPmd::info::SharedCtor

; 1165 :   // @@protoc_insertion_point(constructor:NullPmd.info)
; 1166 : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0info@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0info@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0info@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0info@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0info@NullPmd@@QAE@XZ ENDP				; NullPmd::info::info
; Function compile flags: /Odtp
;	COMDAT ??_Gcommand@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gcommand@NullPmd@@UAEPAXI@Z PROC			; NullPmd::command::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1command@NullPmd@@UAE@XZ ; NullPmd::command::~command
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 20		 push	 32			; 00000020H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gcommand@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::command::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_subid@command@NullPmd@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
?set_subid@command@NullPmd@@QAEX_K@Z PROC		; NullPmd::command::set_subid, COMDAT
; _this$ = ecx

; 811  : inline void command::set_subid(::google::protobuf::uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 812  :   
; 813  :   subid_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00013	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 814  :   // @@protoc_insertion_point(field_set:NullPmd.command.subid)
; 815  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?set_subid@command@NullPmd@@QAEX_K@Z ENDP		; NullPmd::command::set_subid
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?subid@command@NullPmd@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?subid@command@NullPmd@@QBE_KXZ PROC			; NullPmd::command::subid, COMDAT
; _this$ = ecx

; 807  : inline ::google::protobuf::uint64 command::subid() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 808  :   // @@protoc_insertion_point(field_get:NullPmd.command.subid)
; 809  :   return subid_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]

; 810  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?subid@command@NullPmd@@QBE_KXZ ENDP			; NullPmd::command::subid
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_mainid@command@NullPmd@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
?set_mainid@command@NullPmd@@QAEX_K@Z PROC		; NullPmd::command::set_mainid, COMDAT
; _this$ = ecx

; 797  : inline void command::set_mainid(::google::protobuf::uint64 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 798  :   
; 799  :   mainid_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00013	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 800  :   // @@protoc_insertion_point(field_set:NullPmd.command.mainid)
; 801  : }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?set_mainid@command@NullPmd@@QAEX_K@Z ENDP		; NullPmd::command::set_mainid
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mainid@command@NullPmd@@QBE_KXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?mainid@command@NullPmd@@QBE_KXZ PROC			; NullPmd::command::mainid, COMDAT
; _this$ = ecx

; 793  : inline ::google::protobuf::uint64 command::mainid() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 794  :   // @@protoc_insertion_point(field_get:NullPmd.command.mainid)
; 795  :   return mainid_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0000d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]

; 796  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?mainid@command@NullPmd@@QBE_KXZ ENDP			; NullPmd::command::mainid
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@command@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@command@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::command::GetMetadata, COMDAT
; _this$ = ecx

; 1113 : ::google::protobuf::Metadata command::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1114 :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 1115 :   return protobuf_NullPmd_2eproto::file_level_metadata[3];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	6b c8 03	 imul	 ecx, eax, 3
  00014	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]
  0001a	8b 81 04 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1116 : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@command@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::command::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@command@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
__Tmp$1 = -84						; size = 8
__Tmp$2 = -76						; size = 8
$T3 = -68						; size = 4
__Tmp$4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@command@NullPmd@@AAEXPAV12@@Z PROC	; NullPmd::command::InternalSwap, COMDAT
; _this$ = ecx

; 1107 : void command::InternalSwap(command* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1108 :   std::swap(mainid_, other->mainid_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d f8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 e0	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 e0	 mov	 eax, DWORD PTR $T12[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d b4	 mov	 DWORD PTR __Tmp$2[ebp], ecx
  00029	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002c	89 55 b8	 mov	 DWORD PTR __Tmp$2[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0002f	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00035	8b 4d f8	 mov	 ecx, DWORD PTR __Left$[ebp]
  00038	8b 55 dc	 mov	 edx, DWORD PTR $T11[ebp]
  0003b	8b 02		 mov	 eax, DWORD PTR [edx]
  0003d	89 01		 mov	 DWORD PTR [ecx], eax
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00045	8d 45 b4	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  00048	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004e	8b 55 d8	 mov	 edx, DWORD PTR $T10[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	89 01		 mov	 DWORD PTR [ecx], eax
  00055	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00058	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1109 :   std::swap(subid_, other->subid_);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0005e	83 c0 10	 add	 eax, 16			; 00000010H
  00061	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 10	 add	 ecx, 16			; 00000010H
  0006a	89 4d f0	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0006d	8b 55 f0	 mov	 edx, DWORD PTR __Left$[ebp]
  00070	89 55 d4	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00073	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	89 4d ac	 mov	 DWORD PTR __Tmp$1[ebp], ecx
  0007b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0007e	89 55 b0	 mov	 DWORD PTR __Tmp$1[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00081	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  00084	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008a	8b 55 d0	 mov	 edx, DWORD PTR $T8[ebp]
  0008d	8b 02		 mov	 eax, DWORD PTR [edx]
  0008f	89 01		 mov	 DWORD PTR [ecx], eax
  00091	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00094	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00097	8d 45 ac	 lea	 eax, DWORD PTR __Tmp$1[ebp]
  0009a	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0009d	8b 4d ec	 mov	 ecx, DWORD PTR __Right$[ebp]
  000a0	8b 55 cc	 mov	 edx, DWORD PTR $T7[ebp]
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax
  000a7	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000aa	89 51 04	 mov	 DWORD PTR [ecx+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1110 :   std::swap(_cached_size_, other->_cached_size_);

  000ad	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  000b0	83 c0 18	 add	 eax, 24			; 00000018H
  000b3	89 45 e4	 mov	 DWORD PTR __Right$[ebp], eax
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 18	 add	 ecx, 24			; 00000018H
  000bc	89 4d e8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000bf	8b 55 e8	 mov	 edx, DWORD PTR __Left$[ebp]
  000c2	89 55 c8	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  000c5	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	89 4d c0	 mov	 DWORD PTR __Tmp$4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000cd	8b 55 e4	 mov	 edx, DWORD PTR __Right$[ebp]
  000d0	89 55 c4	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  000d3	8b 45 e8	 mov	 eax, DWORD PTR __Left$[ebp]
  000d6	8b 4d c4	 mov	 ecx, DWORD PTR $T5[ebp]
  000d9	8b 11		 mov	 edx, DWORD PTR [ecx]
  000db	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000dd	8d 45 c0	 lea	 eax, DWORD PTR __Tmp$4[ebp]
  000e0	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  000e3	8b 4d e4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000e6	8b 55 bc	 mov	 edx, DWORD PTR $T3[ebp]
  000e9	8b 02		 mov	 eax, DWORD PTR [edx]
  000eb	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1111 : }

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 04 00	 ret	 4
?InternalSwap@command@NullPmd@@AAEXPAV12@@Z ENDP	; NullPmd::command::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@command@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@command@NullPmd@@EBEXH@Z PROC		; NullPmd::command::SetCachedSize, COMDAT
; _this$ = ecx

; 913  : void command::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 914  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 915  :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 916  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 917  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@command@NullPmd@@EBEXH@Z ENDP		; NullPmd::command::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@command@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedDtor@command@NullPmd@@AAEXXZ PROC		; NullPmd::command::SharedDtor, COMDAT
; _this$ = ecx

; 910  : void command::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 911  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?SharedDtor@command@NullPmd@@AAEXXZ ENDP		; NullPmd::command::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@command@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@command@NullPmd@@AAEXXZ PROC		; NullPmd::command::SharedCtor, COMDAT
; _this$ = ecx

; 899  : void command::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 900  :   ::memset(&mainid_, 0, reinterpret_cast<char*>(&subid_) -

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 08	 add	 ecx, 8
  00013	2b c1		 sub	 eax, ecx
  00015	83 c0 08	 add	 eax, 8
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 c2 08	 add	 edx, 8
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  :     reinterpret_cast<char*>(&mainid_) + sizeof(subid_));
; 902  :   _cached_size_ = 0;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 903  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SharedCtor@command@NullPmd@@AAEXXZ ENDP		; NullPmd::command::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@command@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@command@NullPmd@@UBEHXZ PROC		; NullPmd::command::GetCachedSize, COMDAT
; _this$ = ecx

; 367  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@command@NullPmd@@UBEHXZ ENDP		; NullPmd::command::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@command@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@command@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::command::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 363  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 364  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::command::InternalSerializeWithCachedSizesToArray

; 365  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 366  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@command@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::command::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::command::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 1016 :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f4	 mov	 DWORD PTR $T4[ebp], ecx
  00012	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00015	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1020 :   if (this->mainid() != 0) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	0b 45 f8	 or	 eax, DWORD PTR $T4[ebp+4]
  0001e	74 28		 je	 SHORT $LN2@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 45 f0	 mov	 DWORD PTR $T3[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1021 :     target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->mainid(), target);

  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp+4]
  00036	52		 push	 edx
  00037	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN2@InternalSe:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004e	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  00051	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1025 :   if (this->subid() != 0) {

  00057	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0005a	0b 4d e8	 or	 ecx, DWORD PTR $T2[ebp+4]
  0005d	74 28		 je	 SHORT $LN3@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  0005f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00062	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00065	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  00068	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  0006b	89 4d e0	 mov	 DWORD PTR $T1[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1026 :     target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->subid(), target);

  0006e	8b 55 0c	 mov	 edx, DWORD PTR _target$[ebp]
  00071	52		 push	 edx
  00072	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp+4]
  00075	50		 push	 eax
  00076	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
  00079	51		 push	 ecx
  0007a	6a 02		 push	 2
  0007c	e8 00 00 00 00	 call	 ?WriteUInt64ToArray@WireFormatLite@internal@protobuf@google@@SAPAEH_KPAE@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64ToArray
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN3@InternalSe:

; 1027 :   }
; 1028 : 
; 1029 :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.command)
; 1030 :   return target;

  00087	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 1031 : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@command@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::command::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@command@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -12						; size = 8
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@command@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::command::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 1000 :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f4	 mov	 DWORD PTR $T4[ebp], ecx
  00012	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00015	89 55 f8	 mov	 DWORD PTR $T4[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1003 :   if (this->mainid() != 0) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	0b 45 f8	 or	 eax, DWORD PTR $T4[ebp+4]
  0001e	74 25		 je	 SHORT $LN2@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00026	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
  00029	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0002c	89 45 f0	 mov	 DWORD PTR $T3[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1004 :     ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->mainid(), output);

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp+4]
  00036	52		 push	 edx
  00037	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0003a	50		 push	 eax
  0003b	6a 01		 push	 1
  0003d	e8 00 00 00 00	 call	 ?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64
  00042	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@SerializeW:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 e4	 mov	 DWORD PTR $T2[ebp], edx
  0004e	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00051	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1008 :   if (this->subid() != 0) {

  00054	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00057	0b 4d e8	 or	 ecx, DWORD PTR $T2[ebp+4]
  0005a	74 25		 je	 SHORT $LN1@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00062	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  00065	8b 4a 14	 mov	 ecx, DWORD PTR [edx+20]
  00068	89 4d e0	 mov	 DWORD PTR $T1[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1009 :     ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->subid(), output);

  0006b	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  0006e	52		 push	 edx
  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp+4]
  00072	50		 push	 eax
  00073	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
  00076	51		 push	 ecx
  00077	6a 02		 push	 2
  00079	e8 00 00 00 00	 call	 ?WriteUInt64@WireFormatLite@internal@protobuf@google@@SAXH_KPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteUInt64
  0007e	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@SerializeW:

; 1010 :   }
; 1011 : 
; 1012 :   // @@protoc_insertion_point(serialize_end:NullPmd.command)
; 1013 : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
?SerializeWithCachedSizes@command@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::command::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -20						; size = 8
_this$ = -12						; size = 4
tv71 = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::command::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 943  :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 ec	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 949  :     tag = p.first;

  00017	8b 4d ec	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx

; 950  :     if (!p.second) goto handle_unusual;

  0001d	0f b6 55 f0	 movzx	 edx, BYTE PTR _p$1[ebp+4]
  00021	85 d2		 test	 edx, edx
  00023	75 04		 jne	 SHORT $LN30@MergeParti
  00025	eb 69		 jmp	 SHORT $handle_unusual$48
  00027	eb 67		 jmp	 SHORT $handle_unusual$48
$LN30@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  0002c	c1 e8 03	 shr	 eax, 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 951  :     switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {

  0002f	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00032	83 7d f8 01	 cmp	 DWORD PTR tv71[ebp], 1
  00036	74 08		 je	 SHORT $LN9@MergeParti
  00038	83 7d f8 02	 cmp	 DWORD PTR tv71[ebp], 2
  0003c	74 2a		 je	 SHORT $LN15@MergeParti
  0003e	eb 50		 jmp	 SHORT $handle_unusual$48
$LN9@MergeParti:

; 952  :       // uint64 mainid = 1;
; 953  :       case 1: {
; 954  :         if (tag == 8u) {

  00040	83 7d fc 08	 cmp	 DWORD PTR _tag$[ebp], 8
  00044	75 1c		 jne	 SHORT $LN10@MergeParti

; 956  :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00046	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 08	 add	 ecx, 8
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 88   :   return input->ReadVarint64(value);

  0004c	51		 push	 ecx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00050	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 956  :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00055	0f b6 d0	 movzx	 edx, al
  00058	85 d2		 test	 edx, edx
  0005a	75 04		 jne	 SHORT $LN12@MergeParti
  0005c	eb 6b		 jmp	 SHORT $failure$49
  0005e	eb 69		 jmp	 SHORT $failure$49
$LN12@MergeParti:

; 957  :                    ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
; 958  :                  input, &mainid_)));
; 959  :         } else {

  00060	eb 04		 jmp	 SHORT $LN11@MergeParti
$LN10@MergeParti:

; 960  :           goto handle_unusual;

  00062	eb 2c		 jmp	 SHORT $handle_unusual$48
  00064	eb 2a		 jmp	 SHORT $handle_unusual$48
$LN11@MergeParti:

; 961  :         }
; 962  :         break;

  00066	eb 58		 jmp	 SHORT $LN5@MergeParti
$LN15@MergeParti:

; 963  :       }
; 964  : 
; 965  :       // uint64 subid = 2;
; 966  :       case 2: {
; 967  :         if (tag == 16u) {

  00068	83 7d fc 10	 cmp	 DWORD PTR _tag$[ebp], 16 ; 00000010H
  0006c	75 1c		 jne	 SHORT $LN16@MergeParti

; 969  :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  0006e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 c0 10	 add	 eax, 16			; 00000010H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 88   :   return input->ReadVarint64(value);

  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00078	e8 00 00 00 00	 call	 ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ; google::protobuf::io::CodedInputStream::ReadVarint64
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 969  :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  0007d	0f b6 c8	 movzx	 ecx, al
  00080	85 c9		 test	 ecx, ecx
  00082	75 04		 jne	 SHORT $LN18@MergeParti
  00084	eb 43		 jmp	 SHORT $failure$49
  00086	eb 41		 jmp	 SHORT $failure$49
$LN18@MergeParti:

; 970  :                    ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
; 971  :                  input, &subid_)));
; 972  :         } else {

  00088	eb 04		 jmp	 SHORT $LN17@MergeParti
$LN16@MergeParti:

; 973  :           goto handle_unusual;

  0008a	eb 04		 jmp	 SHORT $handle_unusual$48
  0008c	eb 02		 jmp	 SHORT $handle_unusual$48
$LN17@MergeParti:

; 974  :         }
; 975  :         break;

  0008e	eb 30		 jmp	 SHORT $LN5@MergeParti
$handle_unusual$48:

; 980  :         if (tag == 0 ||

  00090	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  00094	74 0b		 je	 SHORT $LN23@MergeParti
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00096	8b 55 fc	 mov	 edx, DWORD PTR _tag$[ebp]
  00099	83 e2 07	 and	 edx, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 980  :         if (tag == 0 ||

  0009c	83 fa 04	 cmp	 edx, 4
  0009f	75 04		 jne	 SHORT $LN22@MergeParti
$LN23@MergeParti:

; 981  :             ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 982  :             ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 983  :           goto success;

  000a1	eb 22		 jmp	 SHORT $success$50
  000a3	eb 20		 jmp	 SHORT $success$50
$LN22@MergeParti:

; 984  :         }
; 985  :         DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000ac	51		 push	 ecx
  000ad	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  000b2	83 c4 08	 add	 esp, 8
  000b5	0f b6 d0	 movzx	 edx, al
  000b8	85 d2		 test	 edx, edx
  000ba	75 04		 jne	 SHORT $LN5@MergeParti
  000bc	eb 0b		 jmp	 SHORT $failure$49
  000be	eb 09		 jmp	 SHORT $failure$49
$LN5@MergeParti:

; 986  :         break;
; 987  :       }
; 988  :     }
; 989  :   }

  000c0	e9 44 ff ff ff	 jmp	 $LN4@MergeParti
$success$50:

; 990  : success:
; 991  :   // @@protoc_insertion_point(parse_success:NullPmd.command)
; 992  :   return true;

  000c5	b0 01		 mov	 al, 1
  000c7	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$49:

; 993  : failure:
; 994  :   // @@protoc_insertion_point(parse_failure:NullPmd.command)
; 995  :   return false;

  000c9	32 c0		 xor	 al, al
$LN1@MergeParti:

; 996  : #undef DO_
; 997  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
?MergePartialFromCodedStream@command@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::command::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@command@NullPmd@@UBEIXZ
_TEXT	SEGMENT
$T1 = -44						; size = 8
$T2 = -36						; size = 8
$T3 = -28						; size = 8
$T4 = -20						; size = 8
_cached_size$ = -12					; size = 4
_this$ = -8						; size = 4
_total_size$ = -4					; size = 4
?ByteSizeLong@command@NullPmd@@UBEIXZ PROC		; NullPmd::command::ByteSizeLong, COMDAT
; _this$ = ecx

; 1033 : size_t command::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1034 : // @@protoc_insertion_point(message_byte_size_start:NullPmd.command)
; 1035 :   size_t total_size = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	89 4d ec	 mov	 DWORD PTR $T4[ebp], ecx
  00019	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001c	89 55 f0	 mov	 DWORD PTR $T4[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1038 :   if (this->mainid() != 0) {

  0001f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00022	0b 45 f0	 or	 eax, DWORD PTR $T4[ebp+4]
  00025	74 29		 je	 SHORT $LN2@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002d	89 55 e4	 mov	 DWORD PTR $T3[ebp], edx
  00030	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00033	89 45 e8	 mov	 DWORD PTR $T3[ebp+4], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp+4]
  00039	51		 push	 ecx
  0003a	8b 55 e4	 mov	 edx, DWORD PTR $T3[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  00043	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1039 :     total_size += 1 +

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  00049	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0004d	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN2@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00056	89 4d dc	 mov	 DWORD PTR $T2[ebp], ecx
  00059	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  0005c	89 55 e0	 mov	 DWORD PTR $T2[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1045 :   if (this->subid() != 0) {

  0005f	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00062	0b 45 e0	 or	 eax, DWORD PTR $T2[ebp+4]
  00065	74 29		 je	 SHORT $LN17@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0006d	89 55 d4	 mov	 DWORD PTR $T1[ebp], edx
  00070	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00073	89 45 d8	 mov	 DWORD PTR $T1[ebp+4], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 825  :   return io::CodedOutputStream::VarintSize64(value);

  00076	8b 4d d8	 mov	 ecx, DWORD PTR $T1[ebp+4]
  00079	51		 push	 ecx
  0007a	8b 55 d4	 mov	 edx, DWORD PTR $T1[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ?VarintSize64@CodedOutputStream@io@protobuf@google@@SAI_K@Z ; google::protobuf::io::CodedOutputStream::VarintSize64
  00083	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1046 :     total_size += 1 +

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  00089	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  0008d	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN17@ByteSizeLo:

; 1047 :       ::google::protobuf::internal::WireFormatLite::UInt64Size(
; 1048 :         this->subid());
; 1049 :   }
; 1050 : 
; 1051 :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  00090	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]
  00093	89 45 f4	 mov	 DWORD PTR _cached_size$[ebp], eax

; 1052 :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 1053 :   _cached_size_ = cached_size;

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	8b 55 f4	 mov	 edx, DWORD PTR _cached_size$[ebp]
  0009c	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1054 :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 1055 :   return total_size;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]

; 1056 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?ByteSizeLong@command@NullPmd@@UBEIXZ ENDP		; NullPmd::command::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@command@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@command@NullPmd@@UBE_NXZ PROC		; NullPmd::command::IsInitialized, COMDAT
; _this$ = ecx

; 1099 : bool command::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1100 :   return true;

  00007	b0 01		 mov	 al, 1

; 1101 : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@command@NullPmd@@UBE_NXZ ENDP		; NullPmd::command::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@command@NullPmd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@command@NullPmd@@UAEXXZ PROC			; NullPmd::command::Clear, COMDAT
; _this$ = ecx

; 936  : void command::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 937  : // @@protoc_insertion_point(message_clear_start:NullPmd.command)
; 938  :   ::memset(&mainid_, 0, reinterpret_cast<char*>(&subid_) -

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 08	 add	 ecx, 8
  00013	2b c1		 sub	 eax, ecx
  00015	83 c0 08	 add	 eax, 8
  00018	50		 push	 eax
  00019	6a 00		 push	 0
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	83 c2 08	 add	 edx, 8
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _memset
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 939  :     reinterpret_cast<char*>(&mainid_) + sizeof(subid_));
; 940  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?Clear@command@NullPmd@@UAEXXZ ENDP			; NullPmd::command::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@command@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
$T2 = -108						; size = 8
$T3 = -100						; size = 8
$T4 = -92						; size = 8
$T5 = -84						; size = 8
tv135 = -76						; size = 4
tv130 = -72						; size = 4
$T6 = -65						; size = 1
_this$ = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@command@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::command::MergeFrom, COMDAT
; _this$ = ecx

; 1073 : void command::MergeFrom(const command& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@command@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 1074 : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.command)
; 1075 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 c0	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 33 04 00 00	 push	 1075			; 00000433H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T8[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b8	 mov	 DWORD PTR tv130[ebp], eax
  00053	8b 4d b8	 mov	 ecx, DWORD PTR tv130[ebp]
  00056	89 4d b4	 mov	 DWORD PTR tv135[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T7[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T7[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b4	 mov	 ecx, DWORD PTR tv135[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d bf	 lea	 ecx, DWORD PTR $T6[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T8[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 1076 :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  000ac	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b2	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
  000b5	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000b8	89 4d b0	 mov	 DWORD PTR $T5[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1077 :   if (from.mainid() != 0) {

  000bb	8b 55 ac	 mov	 edx, DWORD PTR $T5[ebp]
  000be	0b 55 b0	 or	 edx, DWORD PTR $T5[ebp+4]
  000c1	74 1e		 je	 SHORT $LN2@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000c6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000c9	89 4d a4	 mov	 DWORD PTR $T4[ebp], ecx
  000cc	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000cf	89 55 a8	 mov	 DWORD PTR $T4[ebp+4], edx

; 799  :   mainid_ = value;

  000d2	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  000d8	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000db	8b 55 a8	 mov	 edx, DWORD PTR $T4[ebp+4]
  000de	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@MergeFrom:

; 809  :   return subid_;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000e4	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000e7	89 4d 9c	 mov	 DWORD PTR $T3[ebp], ecx
  000ea	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  000ed	89 55 a0	 mov	 DWORD PTR $T3[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1080 :   if (from.subid() != 0) {

  000f0	8b 45 9c	 mov	 eax, DWORD PTR $T3[ebp]
  000f3	0b 45 a0	 or	 eax, DWORD PTR $T3[ebp+4]
  000f6	74 1e		 je	 SHORT $LN1@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000fb	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000fe	89 55 94	 mov	 DWORD PTR $T2[ebp], edx
  00101	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00104	89 45 98	 mov	 DWORD PTR $T2[ebp+4], eax

; 813  :   subid_ = value;

  00107	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	8b 55 94	 mov	 edx, DWORD PTR $T2[ebp]
  0010d	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00110	8b 45 98	 mov	 eax, DWORD PTR $T2[ebp+4]
  00113	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN1@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 1083 : }

  00116	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00119	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00120	59		 pop	 ecx
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@command@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T7[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T8[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@command@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@command@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@command@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::command::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@command@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@command@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::command::CopyFrom, COMDAT
; _this$ = ecx

; 1092 : void command::CopyFrom(const command& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1093 : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.command)
; 1094 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1095 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@command@NullPmd@@UAEXXZ ; NullPmd::command::Clear

; 1096 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@command@NullPmd@@QAEXABV12@@Z ; NullPmd::command::MergeFrom
$LN1@CopyFrom:

; 1097 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@command@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::command::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::command::MergeFrom, COMDAT
; _this$ = ecx

; 1058 : void command::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 1059 : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.command)
; 1060 :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 24 04 00 00	 push	 1060			; 00000424H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 1061 :   const command* source =
; 1062 :       ::google::protobuf::internal::DynamicCastToGenerated<const command>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVcommand@NullPmd@@@internal@protobuf@google@@YAPBVcommand@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::command const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 1063 :           &from);
; 1064 :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 1065 :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.command)
; 1066 :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 1067 :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 1068 :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.command)
; 1069 :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@command@NullPmd@@QAEXABV12@@Z ; NullPmd::command::MergeFrom
$LN1@MergeFrom:

; 1070 :   }
; 1071 : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::command::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::command::CopyFrom, COMDAT
; _this$ = ecx

; 1085 : void command::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1086 : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.command)
; 1087 :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 1088 :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@command@NullPmd@@UAEXXZ ; NullPmd::command::Clear

; 1089 :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::command::MergeFrom
$LN1@CopyFrom:

; 1090 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@command@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::command::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::command::New, COMDAT
; _this$ = ecx

; 928  : command* command::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 929  :   command* n = new command;

  00028	6a 20		 push	 32			; 00000020H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@XZ ; NullPmd::command::command
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 930  :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 931  :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vcommand@NullPmd@@@Arena@protobuf@google@@QAEXPAVcommand@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::command>
$LN2@New:

; 932  :   }
; 933  :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 934  : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 20		 push	 32			; 00000020H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::command::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@command@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@command@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::command::New, COMDAT
; _this$ = ecx

; 345  :   inline command* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@command@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::command::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@command@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::command::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@command@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@command@NullPmd@@QAEXPAV12@@Z PROC		; NullPmd::command::Swap, COMDAT
; _this$ = ecx

; 1103 : void command::Swap(command* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1104 :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 1105 :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@command@NullPmd@@AAEXPAV12@@Z ; NullPmd::command::InternalSwap
$LN1@Swap:

; 1106 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@command@NullPmd@@QAEXPAV12@@Z ENDP		; NullPmd::command::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@command@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@command@NullPmd@@SAPBV12@XZ PROC ; NullPmd::command::internal_default_instance, COMDAT

; 336  :   static inline const command* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 337  :     return reinterpret_cast<const command*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_

; 338  :                &_command_default_instance_);
; 339  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@command@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::command::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@command@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@command@NullPmd@@SAABV12@XZ PROC	; NullPmd::command::default_instance, COMDAT

; 923  : const command& command::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 924  :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 925  :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_

; 926  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@command@NullPmd@@SAABV12@XZ ENDP	; NullPmd::command::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@command@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@command@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::command::descriptor, COMDAT

; 918  : const ::google::protobuf::Descriptor* command::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 919  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 920  :   return protobuf_NullPmd_2eproto::file_level_metadata[3].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	6b c8 03	 imul	 ecx, eax, 3
  00010	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]

; 921  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@command@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::command::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0command@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0command@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::command::command, COMDAT
; _this$ = ecx

; 891  :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0command@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 889  :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 891  :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7command@NullPmd@@6B@

; 890  :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 890  :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 891  :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 892  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 893  :   ::memcpy(&mainid_, &from.mainid_,

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	83 c1 10	 add	 ecx, 16			; 00000010H
  00082	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00085	83 c2 08	 add	 edx, 8
  00088	2b ca		 sub	 ecx, edx
  0008a	83 c1 08	 add	 ecx, 8
  0008d	51		 push	 ecx
  0008e	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00091	83 c0 08	 add	 eax, 8
  00094	50		 push	 eax
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	83 c1 08	 add	 ecx, 8
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 894  :     reinterpret_cast<char*>(&subid_) -
; 895  :     reinterpret_cast<char*>(&mainid_) + sizeof(subid_));
; 896  :   // @@protoc_insertion_point(copy_constructor:NullPmd.command)
; 897  : }

  000a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0command@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0command@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0command@NullPmd@@QAE@ABV01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0command@NullPmd@@QAE@ABV01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0command@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::command::command
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1command@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1command@NullPmd@@UAE@XZ PROC				; NullPmd::command::~command, COMDAT
; _this$ = ecx

; 905  : command::~command() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1command@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7command@NullPmd@@6B@

; 906  :   // @@protoc_insertion_point(destructor:NullPmd.command)
; 907  :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@command@NullPmd@@AAEXXZ ; NullPmd::command::SharedDtor

; 908  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 908  : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1command@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1command@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1command@NullPmd@@UAE@XZ ENDP				; NullPmd::command::~command
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0command@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0command@NullPmd@@QAE@XZ PROC				; NullPmd::command::command, COMDAT
; _this$ = ecx

; 881  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0command@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 881  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7command@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 881  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 882  :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
  00067	74 05		 je	 SHORT $LN2@command

; 883  :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@command:

; 884  :   }
; 885  :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@command@NullPmd@@AAEXXZ ; NullPmd::command::SharedCtor

; 886  :   // @@protoc_insertion_point(constructor:NullPmd.command)
; 887  : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0command@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0command@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0command@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0command@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0command@NullPmd@@QAE@XZ ENDP				; NullPmd::command::command
; Function compile flags: /Odtp
;	COMDAT ??_Gindication@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gindication@NullPmd@@UAEPAXI@Z PROC			; NullPmd::indication::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1indication@NullPmd@@UAE@XZ ; NullPmd::indication::~indication
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gindication@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::indication::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@indication@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@indication@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::indication::GetMetadata, COMDAT
; _this$ = ecx

; 863  : ::google::protobuf::Metadata indication::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 864  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 865  :   return protobuf_NullPmd_2eproto::file_level_metadata[2];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	d1 e0		 shl	 eax, 1
  00013	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]
  00019	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax+4]
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 866  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetMetadata@indication@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::indication::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@indication@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Tmp$2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
__Left$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@indication@NullPmd@@AAEXPAV12@@Z PROC	; NullPmd::indication::InternalSwap, COMDAT
; _this$ = ecx

; 859  : void indication::InternalSwap(indication* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 860  :   std::swap(_cached_size_, other->_cached_size_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d fc	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 f0	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d e8	 mov	 DWORD PTR __Tmp$2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00029	8b 55 f8	 mov	 edx, DWORD PTR __Right$[ebp]
  0002c	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Left$[ebp]
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00039	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  0003c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00042	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 861  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?InternalSwap@indication@NullPmd@@AAEXPAV12@@Z ENDP	; NullPmd::indication::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@indication@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@indication@NullPmd@@EBEXH@Z PROC		; NullPmd::indication::SetCachedSize, COMDAT
; _this$ = ecx

; 738  : void indication::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 739  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 740  :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 741  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 742  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@indication@NullPmd@@EBEXH@Z ENDP		; NullPmd::indication::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@indication@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedDtor@indication@NullPmd@@AAEXXZ PROC		; NullPmd::indication::SharedDtor, COMDAT
; _this$ = ecx

; 735  : void indication::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 736  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?SharedDtor@indication@NullPmd@@AAEXXZ ENDP		; NullPmd::indication::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@indication@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@indication@NullPmd@@AAEXXZ PROC		; NullPmd::indication::SharedCtor, COMDAT
; _this$ = ecx

; 726  : void indication::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 727  :   _cached_size_ = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 728  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?SharedCtor@indication@NullPmd@@AAEXXZ ENDP		; NullPmd::indication::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@indication@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@indication@NullPmd@@UBEHXZ PROC		; NullPmd::indication::GetCachedSize, COMDAT
; _this$ = ecx

; 291  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@indication@NullPmd@@UBEHXZ ENDP		; NullPmd::indication::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::indication::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 287  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 288  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::indication::InternalSerializeWithCachedSizesToArray

; 289  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 290  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::indication::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::indication::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 798  :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 799  :   (void)deterministic;  // Unused
; 800  :   // @@protoc_insertion_point(serialize_to_array_start:NullPmd.indication)
; 801  :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.indication)
; 802  :   return target;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 803  : }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@indication@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::indication::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@indication@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@indication@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::indication::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 792  :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 793  :   // @@protoc_insertion_point(serialize_start:NullPmd.indication)
; 794  :   // @@protoc_insertion_point(serialize_end:NullPmd.indication)
; 795  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SerializeWithCachedSizes@indication@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::indication::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@indication@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -16						; size = 8
_this$ = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@indication@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::indication::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 766  :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 f0	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 772  :     tag = p.first;

  00017	8b 4d f0	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx
$handle_unusual$17:

; 775  :     if (tag == 0 ||

  0001d	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  00021	74 0b		 je	 SHORT $LN8@MergeParti
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  00026	83 e0 07	 and	 eax, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 775  :     if (tag == 0 ||

  00029	83 f8 04	 cmp	 eax, 4
  0002c	75 04		 jne	 SHORT $LN7@MergeParti
$LN8@MergeParti:

; 776  :         ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 777  :         ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 778  :       goto success;

  0002e	eb 1f		 jmp	 SHORT $success$18
  00030	eb 1d		 jmp	 SHORT $success$18
$LN7@MergeParti:

; 779  :     }
; 780  :     DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _tag$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  0003f	83 c4 08	 add	 esp, 8
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	75 04		 jne	 SHORT $LN10@MergeParti
  00049	eb 08		 jmp	 SHORT $failure$19
  0004b	eb 06		 jmp	 SHORT $failure$19
$LN10@MergeParti:

; 781  :   }

  0004d	eb ba		 jmp	 SHORT $LN4@MergeParti
$success$18:

; 782  : success:
; 783  :   // @@protoc_insertion_point(parse_success:NullPmd.indication)
; 784  :   return true;

  0004f	b0 01		 mov	 al, 1
  00051	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$19:

; 785  : failure:
; 786  :   // @@protoc_insertion_point(parse_failure:NullPmd.indication)
; 787  :   return false;

  00053	32 c0		 xor	 al, al
$LN1@MergeParti:

; 788  : #undef DO_
; 789  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?MergePartialFromCodedStream@indication@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::indication::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@indication@NullPmd@@UBEIXZ
_TEXT	SEGMENT
_cached_size$ = -12					; size = 4
_this$ = -8						; size = 4
_total_size$ = -4					; size = 4
?ByteSizeLong@indication@NullPmd@@UBEIXZ PROC		; NullPmd::indication::ByteSizeLong, COMDAT
; _this$ = ecx

; 805  : size_t indication::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 806  : // @@protoc_insertion_point(message_byte_size_start:NullPmd.indication)
; 807  :   size_t total_size = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0

; 808  : 
; 809  :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR _cached_size$[ebp], eax

; 810  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 811  :   _cached_size_ = cached_size;

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 55 f4	 mov	 edx, DWORD PTR _cached_size$[ebp]
  0001c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 812  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 813  :   return total_size;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]

; 814  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?ByteSizeLong@indication@NullPmd@@UBEIXZ ENDP		; NullPmd::indication::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@indication@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@indication@NullPmd@@UBE_NXZ PROC		; NullPmd::indication::IsInitialized, COMDAT
; _this$ = ecx

; 851  : bool indication::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 852  :   return true;

  00007	b0 01		 mov	 al, 1

; 853  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@indication@NullPmd@@UBE_NXZ ENDP		; NullPmd::indication::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@indication@NullPmd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@indication@NullPmd@@UAEXXZ PROC			; NullPmd::indication::Clear, COMDAT
; _this$ = ecx

; 761  : void indication::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 762  : // @@protoc_insertion_point(message_clear_start:NullPmd.indication)
; 763  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?Clear@indication@NullPmd@@UAEXXZ ENDP			; NullPmd::indication::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@indication@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
tv89 = -76						; size = 4
tv169 = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@indication@NullPmd@@QAEXABV12@@Z PROC	; NullPmd::indication::MergeFrom, COMDAT
; _this$ = ecx

; 831  : void indication::MergeFrom(const indication& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 832  : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.indication)
; 833  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN3@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN4@MergeFrom
$LN3@MergeFrom:
  0003c	68 41 03 00 00	 push	 833			; 00000341H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  00053	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  00056	89 4d b4	 mov	 DWORD PTR tv89[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b4	 mov	 ecx, DWORD PTR tv89[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN4@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN7@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN7@MergeFrom:

; 834  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 835  : }

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b6	59		 pop	 ecx
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN6@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@indication@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@indication@NullPmd@@QAEXABV12@@Z ENDP	; NullPmd::indication::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@indication@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@indication@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::indication::CopyFrom, COMDAT
; _this$ = ecx

; 844  : void indication::CopyFrom(const indication& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 845  : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.indication)
; 846  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 847  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@indication@NullPmd@@UAEXXZ ; NullPmd::indication::Clear

; 848  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@indication@NullPmd@@QAEXABV12@@Z ; NullPmd::indication::MergeFrom
$LN1@CopyFrom:

; 849  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@indication@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::indication::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::indication::MergeFrom, COMDAT
; _this$ = ecx

; 816  : void indication::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 817  : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.indication)
; 818  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 32 03 00 00	 push	 818			; 00000332H
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 819  :   const indication* source =
; 820  :       ::google::protobuf::internal::DynamicCastToGenerated<const indication>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVindication@NullPmd@@@internal@protobuf@google@@YAPBVindication@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::indication const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 821  :           &from);
; 822  :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 823  :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.indication)
; 824  :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 825  :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 826  :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.indication)
; 827  :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@indication@NullPmd@@QAEXABV12@@Z ; NullPmd::indication::MergeFrom
$LN1@MergeFrom:

; 828  :   }
; 829  : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::indication::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::indication::CopyFrom, COMDAT
; _this$ = ecx

; 837  : void indication::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 838  : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.indication)
; 839  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 840  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@indication@NullPmd@@UAEXXZ ; NullPmd::indication::Clear

; 841  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::indication::MergeFrom
$LN1@CopyFrom:

; 842  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@indication@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::indication::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::indication::New, COMDAT
; _this$ = ecx

; 753  : indication* indication::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 754  :   indication* n = new indication;

  00028	6a 0c		 push	 12			; 0000000cH
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0indication@NullPmd@@QAE@XZ ; NullPmd::indication::indication
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 755  :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 756  :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vindication@NullPmd@@@Arena@protobuf@google@@QAEXPAVindication@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::indication>
$LN2@New:

; 757  :   }
; 758  :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 759  : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::indication::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@indication@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@indication@NullPmd@@UBEPAV12@XZ PROC		; NullPmd::indication::New, COMDAT
; _this$ = ecx

; 269  :   inline indication* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@indication@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::indication::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@indication@NullPmd@@UBEPAV12@XZ ENDP		; NullPmd::indication::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@indication@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@indication@NullPmd@@QAEXPAV12@@Z PROC		; NullPmd::indication::Swap, COMDAT
; _this$ = ecx

; 855  : void indication::Swap(indication* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 857  :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@indication@NullPmd@@AAEXPAV12@@Z ; NullPmd::indication::InternalSwap
$LN1@Swap:

; 858  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@indication@NullPmd@@QAEXPAV12@@Z ENDP		; NullPmd::indication::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@indication@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@indication@NullPmd@@SAPBV12@XZ PROC ; NullPmd::indication::internal_default_instance, COMDAT

; 260  :   static inline const indication* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 261  :     return reinterpret_cast<const indication*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_

; 262  :                &_indication_default_instance_);
; 263  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@indication@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::indication::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@indication@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@indication@NullPmd@@SAABV12@XZ PROC	; NullPmd::indication::default_instance, COMDAT

; 748  : const indication& indication::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 749  :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 750  :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_

; 751  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@indication@NullPmd@@SAABV12@XZ ENDP	; NullPmd::indication::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@indication@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@indication@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::indication::descriptor, COMDAT

; 743  : const ::google::protobuf::Descriptor* indication::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 745  :   return protobuf_NullPmd_2eproto::file_level_metadata[2].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	d1 e0		 shl	 eax, 1
  0000f	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]

; 746  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?descriptor@indication@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::indication::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0indication@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0indication@NullPmd@@QAE@ABV01@@Z PROC		; NullPmd::indication::indication, COMDAT
; _this$ = ecx

; 721  :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0indication@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 719  :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 721  :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7indication@NullPmd@@6B@

; 720  :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 720  :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 721  :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 722  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 723  :   // @@protoc_insertion_point(copy_constructor:NullPmd.indication)
; 724  : }

  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0indication@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0indication@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0indication@NullPmd@@QAE@ABV01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0indication@NullPmd@@QAE@ABV01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0indication@NullPmd@@QAE@ABV01@@Z ENDP		; NullPmd::indication::indication
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1indication@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1indication@NullPmd@@UAE@XZ PROC			; NullPmd::indication::~indication, COMDAT
; _this$ = ecx

; 730  : indication::~indication() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1indication@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7indication@NullPmd@@6B@

; 731  :   // @@protoc_insertion_point(destructor:NullPmd.indication)
; 732  :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@indication@NullPmd@@AAEXXZ ; NullPmd::indication::SharedDtor

; 733  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 733  : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1indication@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1indication@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1indication@NullPmd@@UAE@XZ ENDP			; NullPmd::indication::~indication
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0indication@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0indication@NullPmd@@QAE@XZ PROC			; NullPmd::indication::indication, COMDAT
; _this$ = ecx

; 711  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0indication@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 711  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7indication@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 711  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 712  :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_
  00067	74 05		 je	 SHORT $LN2@indication

; 713  :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@indication:

; 714  :   }
; 715  :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@indication@NullPmd@@AAEXXZ ; NullPmd::indication::SharedCtor

; 716  :   // @@protoc_insertion_point(constructor:NullPmd.indication)
; 717  : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0indication@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0indication@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0indication@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0indication@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0indication@NullPmd@@QAE@XZ ENDP			; NullPmd::indication::indication
; Function compile flags: /Odtp
;	COMDAT ??_Gresponse@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gresponse@NullPmd@@UAEPAXI@Z PROC			; NullPmd::response::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1response@NullPmd@@UAE@XZ ; NullPmd::response::~response
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gresponse@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::response::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?set_result@response@NullPmd@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?set_result@response@NullPmd@@QAEXH@Z PROC		; NullPmd::response::set_result, COMDAT
; _this$ = ecx

; 723  : inline void response::set_result(::google::protobuf::int32 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 724  :   
; 725  :   result_ = value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 726  :   // @@protoc_insertion_point(field_set:NullPmd.response.result)
; 727  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?set_result@response@NullPmd@@QAEXH@Z ENDP		; NullPmd::response::set_result
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?result@response@NullPmd@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?result@response@NullPmd@@QBEHXZ PROC			; NullPmd::response::result, COMDAT
; _this$ = ecx

; 719  : inline ::google::protobuf::int32 response::result() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 720  :   // @@protoc_insertion_point(field_get:NullPmd.response.result)
; 721  :   return result_;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 722  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?result@response@NullPmd@@QBEHXZ ENDP			; NullPmd::response::result
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?mutable_errordescription@response@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_default_value$ = -8					; size = 4
_this$ = -4						; size = 4
?mutable_errordescription@response@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; NullPmd::response::mutable_errordescription, COMDAT
; _this$ = ecx

; 761  : inline ::std::string* response::mutable_errordescription() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 764  :   return errordescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _default_value$[ebp], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 08	 add	 eax, 8
  00016	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 228  :     if (ptr_ == default_value) {

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	3b 55 f8	 cmp	 edx, DWORD PTR _default_value$[ebp]
  00021	75 0c		 jne	 SHORT $LN8@mutable_er

; 229  :       CreateInstanceNoArena(default_value);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _default_value$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
$LN8@mutable_er:

; 230  :     }
; 231  :     return ptr_;

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 11		 mov	 edx, DWORD PTR [ecx]
  00034	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 764  :   return errordescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00037	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 765  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?mutable_errordescription@response@NullPmd@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; NullPmd::response::mutable_errordescription
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?errordescription@response@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?errordescription@response@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; NullPmd::response::errordescription, COMDAT
; _this$ = ecx

; 733  : inline const ::std::string& response::errordescription() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 735  :   return errordescription_.GetNoArena();

  00012	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 736  : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?errordescription@response@NullPmd@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; NullPmd::response::errordescription
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@response@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@response@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::response::GetMetadata, COMDAT
; _this$ = ecx

; 629  : ::google::protobuf::Metadata response::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 630  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 631  :   return protobuf_NullPmd_2eproto::file_level_metadata[1];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	c1 e0 00	 shl	 eax, 0
  00014	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]
  0001a	8b 90 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax+4]
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 632  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@response@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::response::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@response@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
__Tmp$2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
__Tmp$6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
__Tmp$10 = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@response@NullPmd@@AAEXPAV12@@Z PROC	; NullPmd::response::InternalSwap, COMDAT
; _this$ = ecx

; 623  : void response::InternalSwap(response* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 147  :     std::swap(ptr_, other->ptr_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d f8	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 e0	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 e0	 mov	 eax, DWORD PTR $T12[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d d8	 mov	 DWORD PTR __Tmp$10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00029	8b 55 f4	 mov	 edx, DWORD PTR __Right$[ebp]
  0002c	89 55 dc	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  00032	8b 4d dc	 mov	 ecx, DWORD PTR $T11[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00039	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0003c	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  00042	8b 55 d4	 mov	 edx, DWORD PTR $T9[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 625  :   std::swap(result_, other->result_);

  00049	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  0004c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004f	89 4d ec	 mov	 DWORD PTR __Right$[ebp], ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	83 c2 0c	 add	 edx, 12			; 0000000cH
  00058	89 55 f0	 mov	 DWORD PTR __Left$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0005b	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00061	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	89 55 c8	 mov	 DWORD PTR __Tmp$6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  0006c	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Left$[ebp]
  00072	8b 55 cc	 mov	 edx, DWORD PTR $T7[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00079	8d 4d c8	 lea	 ecx, DWORD PTR __Tmp$6[ebp]
  0007c	89 4d c4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0007f	8b 55 ec	 mov	 edx, DWORD PTR __Right$[ebp]
  00082	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	89 0a		 mov	 DWORD PTR [edx], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 626  :   std::swap(_cached_size_, other->_cached_size_);

  00089	8b 55 08	 mov	 edx, DWORD PTR _other$[ebp]
  0008c	83 c2 10	 add	 edx, 16			; 00000010H
  0008f	89 55 e4	 mov	 DWORD PTR __Right$[ebp], edx
  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 10	 add	 eax, 16			; 00000010H
  00098	89 45 e8	 mov	 DWORD PTR __Left$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0009b	8b 4d e8	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009e	89 4d c0	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  000a1	8b 55 c0	 mov	 edx, DWORD PTR $T4[ebp]
  000a4	8b 02		 mov	 eax, DWORD PTR [edx]
  000a6	89 45 b8	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ac	89 4d bc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  000af	8b 55 e8	 mov	 edx, DWORD PTR __Left$[ebp]
  000b2	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b7	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  000b9	8d 55 b8	 lea	 edx, DWORD PTR __Tmp$2[ebp]
  000bc	89 55 b4	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  000bf	8b 45 e4	 mov	 eax, DWORD PTR __Right$[ebp]
  000c2	8b 4d b4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c7	89 10		 mov	 DWORD PTR [eax], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 627  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?InternalSwap@response@NullPmd@@AAEXPAV12@@Z ENDP	; NullPmd::response::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@response@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@response@NullPmd@@EBEXH@Z PROC		; NullPmd::response::SetCachedSize, COMDAT
; _this$ = ecx

; 415  : void response::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 416  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 417  :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 418  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 419  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@response@NullPmd@@EBEXH@Z ENDP		; NullPmd::response::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@response@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedDtor@response@NullPmd@@AAEXXZ PROC		; NullPmd::response::SharedDtor, COMDAT
; _this$ = ecx

; 411  : void response::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 412  :   errordescription_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00007	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 08	 add	 ecx, 8
  00012	e8 00 00 00 00	 call	 ?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::DestroyNoArena

; 413  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?SharedDtor@response@NullPmd@@AAEXXZ ENDP		; NullPmd::response::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@response@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@response@NullPmd@@AAEXXZ PROC		; NullPmd::response::SharedCtor, COMDAT
; _this$ = ecx

; 400  : void response::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 194  :     ptr_ = const_cast< ::std::string* >(default_value);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 402  :   result_ = 0;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 403  :   _cached_size_ = 0;

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001e	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 404  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?SharedCtor@response@NullPmd@@AAEXXZ ENDP		; NullPmd::response::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@response@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@response@NullPmd@@UBEHXZ PROC		; NullPmd::response::GetCachedSize, COMDAT
; _this$ = ecx

; 193  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@response@NullPmd@@UBEHXZ ENDP		; NullPmd::response::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@response@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@response@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::response::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 189  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 190  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::response::InternalSerializeWithCachedSizesToArray

; 191  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 192  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@response@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::response::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
$T6 = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
$T13 = -36						; size = 4
$T14 = -32						; size = 4
__Result$15 = -28					; size = 4
tv179 = -24						; size = 4
_target$ = -20						; size = 4
$T16 = -16						; size = 4
_target$17 = -12					; size = 4
_value$18 = -8						; size = 4
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::response::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 525  :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	89 4d e0	 mov	 DWORD PTR $T14[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 529  :   if (this->result() != 0) {

  00012	83 7d e0 00	 cmp	 DWORD PTR $T14[ebp], 0
  00016	74 1e		 je	 SHORT $LN2@InternalSe
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001e	89 45 dc	 mov	 DWORD PTR $T13[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 530  :     target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->result(), target);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 dc	 mov	 edx, DWORD PTR $T13[ebp]
  00028	52		 push	 edx
  00029	6a 01		 push	 1
  0002b	e8 00 00 00 00	 call	 ?WriteInt32ToArray@WireFormatLite@internal@protobuf@google@@SAPAEHHPAE@Z ; google::protobuf::internal::WireFormatLite::WriteInt32ToArray
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN2@InternalSe:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003c	89 4d d8	 mov	 DWORD PTR $T12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0003f	8b 55 d8	 mov	 edx, DWORD PTR $T12[ebp]
  00042	89 55 d4	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00045	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
  00048	89 45 d0	 mov	 DWORD PTR $T10[ebp], eax

; 3302 : 		return (this->_Get_data()._Mysize);

  0004b	8b 4d d0	 mov	 ecx, DWORD PTR $T10[ebp]
  0004e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00051	89 55 cc	 mov	 DWORD PTR $T9[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 534  :   if (this->errordescription().size() > 0) {

  00054	83 7d cc 00	 cmp	 DWORD PTR $T9[ebp], 0
  00058	0f 86 f5 00 00
	00		 jbe	 $LN3@InternalSe
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	89 4d c8	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00067	8b 55 c8	 mov	 edx, DWORD PTR $T8[ebp]
  0006a	89 55 c4	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0006d	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00070	89 45 c0	 mov	 DWORD PTR $T6[ebp], eax

; 3297 : 		return (this->_Get_data()._Mysize);

  00073	8b 4d c0	 mov	 ecx, DWORD PTR $T6[ebp]
  00076	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00079	89 55 b4	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00082	89 4d bc	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00085	8b 55 bc	 mov	 edx, DWORD PTR $T5[ebp]
  00088	89 55 b8	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0008b	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0008e	89 45 f0	 mov	 DWORD PTR $T16[ebp], eax

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00091	8b 4d f0	 mov	 ecx, DWORD PTR $T16[ebp]
  00094	83 c1 04	 add	 ecx, 4
  00097	89 4d e4	 mov	 DWORD PTR __Result$15[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0009a	8b 55 f0	 mov	 edx, DWORD PTR $T16[ebp]
  0009d	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  000a1	72 09		 jb	 SHORT $LN73@InternalSe
  000a3	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv179[ebp], 1
  000aa	eb 07		 jmp	 SHORT $LN71@InternalSe
$LN73@InternalSe:
  000ac	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
$LN71@InternalSe:

; 1815 : 		if (_Large_string_engaged())

  000b3	0f b6 45 e8	 movzx	 eax, BYTE PTR tv179[ebp]
  000b7	85 c0		 test	 eax, eax
  000b9	74 09		 je	 SHORT $LN68@InternalSe
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000bb	8b 4d f0	 mov	 ecx, DWORD PTR $T16[ebp]
  000be	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000c1	89 55 e4	 mov	 DWORD PTR __Result$15[ebp], edx
$LN68@InternalSe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3285 : 		return (this->_Get_data()._Myptr());

  000c4	8b 45 e4	 mov	 eax, DWORD PTR __Result$15[ebp]
  000c7	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 535  :     ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@
  000cf	6a 01		 push	 1
  000d1	8b 4d b4	 mov	 ecx, DWORD PTR $T3[ebp]
  000d4	51		 push	 ecx
  000d5	8b 55 b0	 mov	 edx, DWORD PTR $T2[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ?VerifyUtf8String@WireFormatLite@internal@protobuf@google@@SA_NPBDHW4Operation@1234@0@Z ; google::protobuf::internal::WireFormatLite::VerifyUtf8String
  000de	83 c4 10	 add	 esp, 16			; 00000010H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e7	89 4d ac	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 539  :     target =

  000ea	8b 55 0c	 mov	 edx, DWORD PTR _target$[ebp]
  000ed	89 55 ec	 mov	 DWORD PTR _target$[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  000f0	8b 45 ec	 mov	 eax, DWORD PTR _target$[ebp]
  000f3	89 45 f4	 mov	 DWORD PTR _target$17[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 645  :   return GOOGLE_PROTOBUF_WIRE_FORMAT_MAKE_TAG(field_number, type);

  000f6	b9 02 00 00 00	 mov	 ecx, 2
  000fb	c1 e1 03	 shl	 ecx, 3
  000fe	83 c9 02	 or	 ecx, 2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1291 :   return WriteVarint32ToArray(value, target);

  00101	89 4d f8	 mov	 DWORD PTR _value$18[ebp], ecx
$LN90@InternalSe:

; 1197 :   while (value >= 0x80) {

  00104	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _value$18[ebp], 128 ; 00000080H
  0010b	72 22		 jb	 SHORT $LN91@InternalSe

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0010d	8b 55 f8	 mov	 edx, DWORD PTR _value$18[ebp]
  00110	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00116	8b 45 f4	 mov	 eax, DWORD PTR _target$17[ebp]
  00119	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _value$18[ebp]
  0011e	c1 e9 07	 shr	 ecx, 7
  00121	89 4d f8	 mov	 DWORD PTR _value$18[ebp], ecx

; 1200 :     ++target;

  00124	8b 55 f4	 mov	 edx, DWORD PTR _target$17[ebp]
  00127	83 c2 01	 add	 edx, 1
  0012a	89 55 f4	 mov	 DWORD PTR _target$17[ebp], edx

; 1201 :   }

  0012d	eb d5		 jmp	 SHORT $LN90@InternalSe
$LN91@InternalSe:

; 1202 :   *target = static_cast<uint8>(value);

  0012f	8b 45 f4	 mov	 eax, DWORD PTR _target$17[ebp]
  00132	8a 4d f8	 mov	 cl, BYTE PTR _value$18[ebp]
  00135	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  00137	8b 55 f4	 mov	 edx, DWORD PTR _target$17[ebp]
  0013a	83 c2 01	 add	 edx, 1
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 766  :   target = WriteTagToArray(field_number, WIRETYPE_LENGTH_DELIMITED, target);

  0013d	89 55 ec	 mov	 DWORD PTR _target$[ebp], edx

; 767  :   return io::CodedOutputStream::WriteStringWithSizeToArray(value, target);

  00140	8b 45 ec	 mov	 eax, DWORD PTR _target$[ebp]
  00143	50		 push	 eax
  00144	8b 4d ac	 mov	 ecx, DWORD PTR $T1[ebp]
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 ?WriteStringWithSizeToArray@CodedOutputStream@io@protobuf@google@@SAPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; google::protobuf::io::CodedOutputStream::WriteStringWithSizeToArray
  0014d	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 539  :     target =

  00150	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax
$LN3@InternalSe:

; 540  :       ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
; 541  :         2, this->errordescription(), target);
; 542  :   }
; 543  : 
; 544  :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.response)
; 545  :   return target;

  00153	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 546  : }

  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@response@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::response::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@response@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
$T11 = -32						; size = 4
$T12 = -28						; size = 4
$T13 = -24						; size = 4
$T14 = -20						; size = 4
__Result$15 = -16					; size = 4
tv170 = -12						; size = 4
$T16 = -8						; size = 4
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@response@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::response::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 504  :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	89 4d ec	 mov	 DWORD PTR $T14[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 507  :   if (this->result() != 0) {

  00012	83 7d ec 00	 cmp	 DWORD PTR $T14[ebp], 0
  00016	74 1b		 je	 SHORT $LN2@SerializeW
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00018	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001e	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 508  :     ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 e8	 mov	 edx, DWORD PTR $T13[ebp]
  00028	52		 push	 edx
  00029	6a 01		 push	 1
  0002b	e8 00 00 00 00	 call	 ?WriteInt32@WireFormatLite@internal@protobuf@google@@SAXHHPAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteInt32
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SerializeW:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00039	89 4d e4	 mov	 DWORD PTR $T12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0003c	8b 55 e4	 mov	 edx, DWORD PTR $T12[ebp]
  0003f	89 55 e0	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T11[ebp]
  00045	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax

; 3302 : 		return (this->_Get_data()._Mysize);

  00048	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  0004b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004e	89 55 d8	 mov	 DWORD PTR $T9[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 512  :   if (this->errordescription().size() > 0) {

  00051	83 7d d8 00	 cmp	 DWORD PTR $T9[ebp], 0
  00055	0f 86 9e 00 00
	00		 jbe	 $LN1@SerializeW
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00061	89 4d d4	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00064	8b 55 d4	 mov	 edx, DWORD PTR $T8[ebp]
  00067	89 55 d0	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0006a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0006d	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 3297 : 		return (this->_Get_data()._Mysize);

  00070	8b 4d cc	 mov	 ecx, DWORD PTR $T6[ebp]
  00073	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00076	89 55 c0	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0007f	89 4d c8	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00082	8b 55 c8	 mov	 edx, DWORD PTR $T5[ebp]
  00085	89 55 c4	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00088	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  0008b	89 45 f8	 mov	 DWORD PTR $T16[ebp], eax

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0008e	8b 4d f8	 mov	 ecx, DWORD PTR $T16[ebp]
  00091	83 c1 04	 add	 ecx, 4
  00094	89 4d f0	 mov	 DWORD PTR __Result$15[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00097	8b 55 f8	 mov	 edx, DWORD PTR $T16[ebp]
  0009a	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  0009e	72 09		 jb	 SHORT $LN53@SerializeW
  000a0	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv170[ebp], 1
  000a7	eb 07		 jmp	 SHORT $LN51@SerializeW
$LN53@SerializeW:
  000a9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
$LN51@SerializeW:

; 1815 : 		if (_Large_string_engaged())

  000b0	0f b6 45 f4	 movzx	 eax, BYTE PTR tv170[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 09		 je	 SHORT $LN48@SerializeW
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR $T16[ebp]
  000bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000be	89 55 f0	 mov	 DWORD PTR __Result$15[ebp], edx
$LN48@SerializeW:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3285 : 		return (this->_Get_data()._Myptr());

  000c1	8b 45 f0	 mov	 eax, DWORD PTR __Result$15[ebp]
  000c4	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 513  :     ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@
  000cc	6a 01		 push	 1
  000ce	8b 4d c0	 mov	 ecx, DWORD PTR $T3[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 bc	 mov	 edx, DWORD PTR $T2[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?VerifyUtf8String@WireFormatLite@internal@protobuf@google@@SA_NPBDHW4Operation@1234@0@Z ; google::protobuf::internal::WireFormatLite::VerifyUtf8String
  000db	83 c4 10	 add	 esp, 16			; 00000010H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000de	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e4	89 4d b8	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 517  :     ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(

  000e7	8b 55 08	 mov	 edx, DWORD PTR _output$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 b8	 mov	 eax, DWORD PTR $T1[ebp]
  000ee	50		 push	 eax
  000ef	6a 02		 push	 2
  000f1	e8 00 00 00 00	 call	 ?WriteStringMaybeAliased@WireFormatLite@internal@protobuf@google@@SAXHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVCodedOutputStream@io@34@@Z ; google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SerializeW:

; 518  :       2, this->errordescription(), output);
; 519  :   }
; 520  : 
; 521  :   // @@protoc_insertion_point(serialize_end:NullPmd.response)
; 522  : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 04 00	 ret	 4
?SerializeWithCachedSizes@response@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::response::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -80						; size = 8
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
$T9 = -44						; size = 4
_temp$10 = -40						; size = 4
__Result$11 = -36					; size = 4
tv192 = -32						; size = 4
_default_value$ = -28					; size = 4
tv71 = -24						; size = 4
$T12 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_tag$ = -8						; size = 4
$T13 = -1						; size = 1
_input$ = 8						; size = 4
?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::response::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 445  :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 b0	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 451  :     tag = p.first;

  00017	8b 4d b0	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d f8	 mov	 DWORD PTR _tag$[ebp], ecx

; 452  :     if (!p.second) goto handle_unusual;

  0001d	0f b6 55 b4	 movzx	 edx, BYTE PTR _p$1[ebp+4]
  00021	85 d2		 test	 edx, edx
  00023	75 05		 jne	 SHORT $LN32@MergeParti
  00025	e9 45 01 00 00	 jmp	 $handle_unusual$93
$LN32@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 653  :   return static_cast<int>(tag >> kTagTypeBits);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _tag$[ebp]
  0002d	c1 e8 03	 shr	 eax, 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 453  :     switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {

  00030	89 45 e8	 mov	 DWORD PTR tv71[ebp], eax
  00033	83 7d e8 01	 cmp	 DWORD PTR tv71[ebp], 1
  00037	74 0b		 je	 SHORT $LN9@MergeParti
  00039	83 7d e8 02	 cmp	 DWORD PTR tv71[ebp], 2
  0003d	74 4a		 je	 SHORT $LN15@MergeParti
  0003f	e9 2b 01 00 00	 jmp	 $handle_unusual$93
$LN9@MergeParti:

; 454  :       // int32 result = 1;
; 455  :       case 1: {
; 456  :         if (tag == 8u) {

  00044	83 7d f8 08	 cmp	 DWORD PTR _tag$[ebp], 8
  00048	75 35		 jne	 SHORT __unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite_inl.h

; 65   :   if (!input->ReadVarint32(&temp)) return false;

  0004a	8d 4d d8	 lea	 ecx, DWORD PTR _temp$10[ebp]
  0004d	51		 push	 ecx
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00051	e8 00 00 00 00	 call	 ?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z ; google::protobuf::io::CodedInputStream::ReadVarint32
  00056	0f b6 d0	 movzx	 edx, al
  00059	85 d2		 test	 edx, edx
  0005b	75 06		 jne	 SHORT $LN35@MergeParti
  0005d	c6 45 ff 00	 mov	 BYTE PTR $T13[ebp], 0
  00061	eb 0d		 jmp	 SHORT $LN34@MergeParti
$LN35@MergeParti:

; 66   :   *value = static_cast<int32>(temp);

  00063	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 4d d8	 mov	 ecx, DWORD PTR _temp$10[ebp]
  00069	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 67   :   return true;

  0006c	c6 45 ff 01	 mov	 BYTE PTR $T13[ebp], 1
$LN34@MergeParti:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 458  :           DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<

  00070	0f b6 55 ff	 movzx	 edx, BYTE PTR $T13[ebp]
  00074	85 d2		 test	 edx, edx
  00076	75 05		 jne	 SHORT $LN12@MergeParti
  00078	e9 27 01 00 00	 jmp	 $failure$94
$LN12@MergeParti:

; 459  :                    ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
; 460  :                  input, &result_)));
; 461  :         } else {

  0007d	eb 05		 jmp	 SHORT $LN11@MergeParti
__unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$2:

; 462  :           goto handle_unusual;

  0007f	e9 eb 00 00 00	 jmp	 $handle_unusual$93
$LN11@MergeParti:

; 463  :         }
; 464  :         break;

  00084	e9 12 01 00 00	 jmp	 $LN5@MergeParti
$LN15@MergeParti:

; 465  :       }
; 466  : 
; 467  :       // string errordescription = 2;
; 468  :       case 2: {
; 469  :         if (tag == 18u) {

  00089	83 7d f8 12	 cmp	 DWORD PTR _tag$[ebp], 18 ; 00000012H
  0008d	0f 85 d8 00 00
	00		 jne	 __unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 764  :   return errordescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00093	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _default_value$[ebp], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0009a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	83 c0 08	 add	 eax, 8
  000a0	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 228  :     if (ptr_ == default_value) {

  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a8	3b 55 e4	 cmp	 edx, DWORD PTR _default_value$[ebp]
  000ab	75 0c		 jne	 SHORT $LN52@MergeParti

; 229  :       CreateInstanceNoArena(default_value);

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _default_value$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
$LN52@MergeParti:

; 230  :     }
; 231  :     return ptr_;

  000b9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000be	89 55 d4	 mov	 DWORD PTR $T9[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 739  :   return ReadBytes(input, value);

  000c1	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ?ReadBytes@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::ReadBytes
  000ce	83 c4 08	 add	 esp, 8
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 470  :           DO_(::google::protobuf::internal::WireFormatLite::ReadString(

  000d1	0f b6 d0	 movzx	 edx, al
  000d4	85 d2		 test	 edx, edx
  000d6	75 05		 jne	 SHORT $LN18@MergeParti
  000d8	e9 c7 00 00 00	 jmp	 $failure$94
$LN18@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000dd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e3	89 4d d0	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000e6	8b 55 d0	 mov	 edx, DWORD PTR $T8[ebp]
  000e9	89 55 cc	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  000ec	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  000ef	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 3297 : 		return (this->_Get_data()._Mysize);

  000f2	8b 4d c8	 mov	 ecx, DWORD PTR $T6[ebp]
  000f5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000f8	89 55 bc	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000fb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00101	89 4d c4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00104	8b 55 c4	 mov	 edx, DWORD PTR $T5[ebp]
  00107	89 55 c0	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0010a	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  0010d	89 45 ec	 mov	 DWORD PTR $T12[ebp], eax

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00110	8b 4d ec	 mov	 ecx, DWORD PTR $T12[ebp]
  00113	83 c1 04	 add	 ecx, 4
  00116	89 4d dc	 mov	 DWORD PTR __Result$11[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00119	8b 55 ec	 mov	 edx, DWORD PTR $T12[ebp]
  0011c	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  00120	72 09		 jb	 SHORT $LN87@MergeParti
  00122	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  00129	eb 07		 jmp	 SHORT $LN85@MergeParti
$LN87@MergeParti:
  0012b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv192[ebp], 0
$LN85@MergeParti:

; 1815 : 		if (_Large_string_engaged())

  00132	0f b6 45 e0	 movzx	 eax, BYTE PTR tv192[ebp]
  00136	85 c0		 test	 eax, eax
  00138	74 09		 je	 SHORT $LN82@MergeParti
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0013a	8b 4d ec	 mov	 ecx, DWORD PTR $T12[ebp]
  0013d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00140	89 55 dc	 mov	 DWORD PTR __Result$11[ebp], edx
$LN82@MergeParti:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3285 : 		return (this->_Get_data()._Myptr());

  00143	8b 45 dc	 mov	 eax, DWORD PTR __Result$11[ebp]
  00146	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 472  :           DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(

  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@NINJIOJL@NullPmd?4response?4errordescripti@
  0014e	6a 00		 push	 0
  00150	8b 4d bc	 mov	 ecx, DWORD PTR $T3[ebp]
  00153	51		 push	 ecx
  00154	8b 55 b8	 mov	 edx, DWORD PTR $T2[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 ?VerifyUtf8String@WireFormatLite@internal@protobuf@google@@SA_NPBDHW4Operation@1234@0@Z ; google::protobuf::internal::WireFormatLite::VerifyUtf8String
  0015d	83 c4 10	 add	 esp, 16			; 00000010H
  00160	0f b6 c0	 movzx	 eax, al
  00163	85 c0		 test	 eax, eax
  00165	75 02		 jne	 SHORT $LN20@MergeParti
  00167	eb 3b		 jmp	 SHORT $failure$94
$LN20@MergeParti:

; 473  :             this->errordescription().data(), this->errordescription().length(),
; 474  :             ::google::protobuf::internal::WireFormatLite::PARSE,
; 475  :             "NullPmd.response.errordescription"));
; 476  :         } else {

  00169	eb 02		 jmp	 SHORT $LN17@MergeParti
__unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$5:

; 477  :           goto handle_unusual;

  0016b	eb 02		 jmp	 SHORT $handle_unusual$93
$LN17@MergeParti:

; 478  :         }
; 479  :         break;

  0016d	eb 2c		 jmp	 SHORT $LN5@MergeParti
$handle_unusual$93:

; 484  :         if (tag == 0 ||

  0016f	83 7d f8 00	 cmp	 DWORD PTR _tag$[ebp], 0
  00173	74 0b		 je	 SHORT __unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$6
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00175	8b 4d f8	 mov	 ecx, DWORD PTR _tag$[ebp]
  00178	83 e1 07	 and	 ecx, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 484  :         if (tag == 0 ||

  0017b	83 f9 04	 cmp	 ecx, 4
  0017e	75 02		 jne	 SHORT $LN24@MergeParti
__unwind$?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z$6:

; 485  :             ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 486  :             ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 487  :           goto success;

  00180	eb 1e		 jmp	 SHORT $success$95
$LN24@MergeParti:

; 488  :         }
; 489  :         DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  00182	8b 55 f8	 mov	 edx, DWORD PTR _tag$[ebp]
  00185	52		 push	 edx
  00186	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00189	50		 push	 eax
  0018a	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  0018f	83 c4 08	 add	 esp, 8
  00192	0f b6 c8	 movzx	 ecx, al
  00195	85 c9		 test	 ecx, ecx
  00197	75 02		 jne	 SHORT $LN5@MergeParti
  00199	eb 09		 jmp	 SHORT $failure$94
$LN5@MergeParti:

; 490  :         break;
; 491  :       }
; 492  :     }
; 493  :   }

  0019b	e9 69 fe ff ff	 jmp	 $LN4@MergeParti
$success$95:

; 494  : success:
; 495  :   // @@protoc_insertion_point(parse_success:NullPmd.response)
; 496  :   return true;

  001a0	b0 01		 mov	 al, 1
  001a2	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$94:

; 497  : failure:
; 498  :   // @@protoc_insertion_point(parse_failure:NullPmd.response)
; 499  :   return false;

  001a4	32 c0		 xor	 al, al
$LN1@MergeParti:

; 500  : #undef DO_
; 501  : }

  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c2 04 00	 ret	 4
?MergePartialFromCodedStream@response@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::response::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@response@NullPmd@@UBEIXZ
_TEXT	SEGMENT
_cached_size$ = -48					; size = 4
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
_this$ = -8						; size = 4
_total_size$ = -4					; size = 4
?ByteSizeLong@response@NullPmd@@UBEIXZ PROC		; NullPmd::response::ByteSizeLong, COMDAT
; _this$ = ecx

; 548  : size_t response::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : // @@protoc_insertion_point(message_byte_size_start:NullPmd.response)
; 550  :   size_t total_size = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	89 4d e8	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00019	8b 55 e8	 mov	 edx, DWORD PTR $T6[ebp]
  0001c	89 55 e4	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0001f	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  00022	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 3302 : 		return (this->_Get_data()._Mysize);

  00025	8b 4d e0	 mov	 ecx, DWORD PTR $T4[ebp]
  00028	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002b	89 55 dc	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 553  :   if (this->errordescription().size() > 0) {

  0002e	83 7d dc 00	 cmp	 DWORD PTR $T3[ebp], 0
  00032	76 1f		 jbe	 SHORT $LN2@ByteSizeLo
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003a	89 4d d8	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 554  :     total_size += 1 +

  0003d	8b 55 d8	 mov	 edx, DWORD PTR $T2[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?StringSize@WireFormatLite@internal@protobuf@google@@SAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::WireFormatLite::StringSize
  00046	83 c4 04	 add	 esp, 4
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  0004c	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00050	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN2@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00053	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00059	89 4d d4	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 560  :   if (this->result() != 0) {

  0005c	83 7d d4 00	 cmp	 DWORD PTR $T1[ebp], 0
  00060	74 50		 je	 SHORT $LN53@ByteSizeLo
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00068	89 45 f4	 mov	 DWORD PTR $T9[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1303 :   if (value < 0) {

  0006b	83 7d f4 00	 cmp	 DWORD PTR $T9[ebp], 0
  0006f	7d 0b		 jge	 SHORT $LN46@ByteSizeLo

; 1304 :     return 10;     // TODO(kenton):  Make this a symbolic constant.

  00071	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR $T7[ebp], 10	; 0000000aH
  00078	eb 2b		 jmp	 SHORT $LN43@ByteSizeLo

; 1305 :   } else {

  0007a	eb 29		 jmp	 SHORT $LN43@ByteSizeLo
$LN46@ByteSizeLo:

; 1295 :   if (value < (1 << 7)) {

  0007c	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR $T9[ebp], 128	; 00000080H
  00083	73 0b		 jae	 SHORT $LN50@ByteSizeLo

; 1296 :     return 1;

  00085	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  0008c	eb 11		 jmp	 SHORT $LN49@ByteSizeLo

; 1297 :   } else  {

  0008e	eb 0f		 jmp	 SHORT $LN49@ByteSizeLo
$LN50@ByteSizeLo:

; 1298 :     return VarintSize32Fallback(value);

  00090	8b 4d f4	 mov	 ecx, DWORD PTR $T9[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00099	83 c4 04	 add	 esp, 4
  0009c	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
$LN49@ByteSizeLo:

; 1306 :     return VarintSize32(static_cast<uint32>(value));

  0009f	8b 55 f0	 mov	 edx, DWORD PTR $T8[ebp]
  000a2	89 55 ec	 mov	 DWORD PTR $T7[ebp], edx
$LN43@ByteSizeLo:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 561  :     total_size += 1 +

  000a5	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR _total_size$[ebp]
  000ab	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000af	89 55 fc	 mov	 DWORD PTR _total_size$[ebp], edx
$LN53@ByteSizeLo:

; 562  :       ::google::protobuf::internal::WireFormatLite::Int32Size(
; 563  :         this->result());
; 564  :   }
; 565  : 
; 566  :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  000b2	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]
  000b5	89 45 d0	 mov	 DWORD PTR _cached_size$[ebp], eax

; 567  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 568  :   _cached_size_ = cached_size;

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 55 d0	 mov	 edx, DWORD PTR _cached_size$[ebp]
  000be	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 569  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 570  :   return total_size;

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]

; 571  : }

  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?ByteSizeLong@response@NullPmd@@UBEIXZ ENDP		; NullPmd::response::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@response@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@response@NullPmd@@UBE_NXZ PROC		; NullPmd::response::IsInitialized, COMDAT
; _this$ = ecx

; 615  : bool response::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 616  :   return true;

  00007	b0 01		 mov	 al, 1

; 617  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@response@NullPmd@@UBE_NXZ ENDP		; NullPmd::response::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@response@NullPmd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clear@response@NullPmd@@UAEXXZ PROC			; NullPmd::response::Clear, COMDAT
; _this$ = ecx

; 438  : void response::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clear@response@NullPmd@@UAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : // @@protoc_insertion_point(message_clear_start:NullPmd.response)
; 440  :   errordescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 263  :     if (ptr_ == default_value) {

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	81 39 00 00 00
	00		 cmp	 DWORD PTR [ecx], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0003a	75 02		 jne	 SHORT $LN8@Clear

; 264  :       // Nothing: already equal to default (which is the empty string).
; 265  :     } else {

  0003c	eb 20		 jmp	 SHORT $LN7@Clear
$LN8@Clear:

; 266  :       ptr_->clear();

  0003e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 02		 mov	 eax, DWORD PTR [edx]
  00043	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2870 : 		{	// erase all

  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2871 : 		_Eos(0);

  0004d	6a 00		 push	 0
  0004f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  00057	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN7@Clear:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 441  :   result_ = 0;

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 442  : }

  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Clear@response@NullPmd@@UAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clear@response@NullPmd@@UAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clear@response@NullPmd@@UAEXXZ ENDP			; NullPmd::response::Clear
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@response@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
tv139 = -76						; size = 4
tv134 = -72						; size = 4
$T8 = -65						; size = 1
_this$ = -64						; size = 4
$T9 = -60						; size = 4
$T10 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@response@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::response::MergeFrom, COMDAT
; _this$ = ecx

; 588  : void response::MergeFrom(const response& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@response@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0

; 589  : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.response)
; 590  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 c0	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 4e 02 00 00	 push	 590			; 0000024eH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b8	 mov	 DWORD PTR tv134[ebp], eax
  00053	8b 4d b8	 mov	 ecx, DWORD PTR tv134[ebp]
  00056	89 4d b4	 mov	 DWORD PTR tv139[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T9[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T9[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b4	 mov	 ecx, DWORD PTR tv139[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d bf	 lea	 ecx, DWORD PTR $T8[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 591  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  000ac	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000af	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b2	89 45 b0	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000b5	8b 4d b0	 mov	 ecx, DWORD PTR $T7[ebp]
  000b8	89 4d ac	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  000bb	8b 55 ac	 mov	 edx, DWORD PTR $T6[ebp]
  000be	89 55 a8	 mov	 DWORD PTR $T5[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  000c1	8b 45 a8	 mov	 eax, DWORD PTR $T5[ebp]
  000c4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c7	89 4d a4	 mov	 DWORD PTR $T4[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 592  :   if (from.errordescription().size() > 0) {

  000ca	83 7d a4 00	 cmp	 DWORD PTR $T4[ebp], 0
  000ce	76 17		 jbe	 SHORT $LN2@MergeFrom

; 593  : 
; 594  :     errordescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.errordescription_);

  000d0	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  000dc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	83 c1 08	 add	 ecx, 8
  000e2	e8 00 00 00 00	 call	 ?AssignWithDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U1234@@Z ; google::protobuf::internal::ArenaStringPtr::AssignWithDefault
$LN2@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  000e7	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  000ea	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ed	89 55 a0	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 596  :   if (from.result() != 0) {

  000f0	83 7d a0 00	 cmp	 DWORD PTR $T3[ebp], 0
  000f4	74 12		 je	 SHORT $LN1@MergeFrom
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 721  :   return result_;

  000f6	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000f9	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000fc	89 4d 9c	 mov	 DWORD PTR $T2[ebp], ecx

; 725  :   result_ = value;

  000ff	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00102	8b 45 9c	 mov	 eax, DWORD PTR $T2[ebp]
  00105	89 42 0c	 mov	 DWORD PTR [edx+12], eax
$LN1@MergeFrom:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 599  : }

  00108	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00112	59		 pop	 ecx
  00113	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00116	33 cd		 xor	 ecx, ebp
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@response@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T10[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@response@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@response@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@response@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::response::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@response@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@response@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::response::CopyFrom, COMDAT
; _this$ = ecx

; 608  : void response::CopyFrom(const response& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 609  : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.response)
; 610  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 611  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@response@NullPmd@@UAEXXZ ; NullPmd::response::Clear

; 612  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@response@NullPmd@@QAEXABV12@@Z ; NullPmd::response::MergeFrom
$LN1@CopyFrom:

; 613  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@response@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::response::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::response::MergeFrom, COMDAT
; _this$ = ecx

; 573  : void response::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 574  : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.response)
; 575  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 3f 02 00 00	 push	 575			; 0000023fH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 576  :   const response* source =
; 577  :       ::google::protobuf::internal::DynamicCastToGenerated<const response>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVresponse@NullPmd@@@internal@protobuf@google@@YAPBVresponse@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::response const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 578  :           &from);
; 579  :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 580  :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.response)
; 581  :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 582  :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 583  :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.response)
; 584  :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@response@NullPmd@@QAEXABV12@@Z ; NullPmd::response::MergeFrom
$LN1@MergeFrom:

; 585  :   }
; 586  : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::response::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::response::CopyFrom, COMDAT
; _this$ = ecx

; 601  : void response::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 602  : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.response)
; 603  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 604  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@response@NullPmd@@UAEXXZ ; NullPmd::response::Clear

; 605  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::response::MergeFrom
$LN1@CopyFrom:

; 606  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@response@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::response::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::response::New, COMDAT
; _this$ = ecx

; 430  : response* response::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 431  :   response* n = new response;

  00028	6a 14		 push	 20			; 00000014H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0response@NullPmd@@QAE@XZ ; NullPmd::response::response
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 432  :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 433  :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vresponse@NullPmd@@@Arena@protobuf@google@@QAEXPAVresponse@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::response>
$LN2@New:

; 434  :   }
; 435  :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 436  : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::response::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@response@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@response@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::response::New, COMDAT
; _this$ = ecx

; 171  :   inline response* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@response@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::response::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@response@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::response::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@response@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@response@NullPmd@@QAEXPAV12@@Z PROC		; NullPmd::response::Swap, COMDAT
; _this$ = ecx

; 619  : void response::Swap(response* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 620  :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 621  :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@response@NullPmd@@AAEXPAV12@@Z ; NullPmd::response::InternalSwap
$LN1@Swap:

; 622  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@response@NullPmd@@QAEXPAV12@@Z ENDP		; NullPmd::response::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@response@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@response@NullPmd@@SAPBV12@XZ PROC ; NullPmd::response::internal_default_instance, COMDAT

; 162  :   static inline const response* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  :     return reinterpret_cast<const response*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_

; 164  :                &_response_default_instance_);
; 165  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@response@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::response::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@response@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@response@NullPmd@@SAABV12@XZ PROC	; NullPmd::response::default_instance, COMDAT

; 425  : const response& response::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 426  :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 427  :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_

; 428  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@response@NullPmd@@SAABV12@XZ ENDP	; NullPmd::response::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@response@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@response@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::response::descriptor, COMDAT

; 420  : const ::google::protobuf::Descriptor* response::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 421  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 422  :   return protobuf_NullPmd_2eproto::file_level_metadata[1].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	c1 e0 00	 shl	 eax, 0
  00010	8b 80 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax]

; 423  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@response@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::response::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0response@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0response@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::response::response, COMDAT
; _this$ = ecx

; 390  :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0response@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 388  :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 390  :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7response@NullPmd@@6B@

; 389  :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 389  :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 390  :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 391  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 194  :     ptr_ = const_cast< ::std::string* >(default_value);

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00086	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  00089	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0008f	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  00092	89 4d e4	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00095	8b 55 e4	 mov	 edx, DWORD PTR $T4[ebp]
  00098	89 55 e0	 mov	 DWORD PTR $T3[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0009b	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0009e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000a1	89 4d dc	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 393  :   if (from.errordescription().size() > 0) {

  000a4	83 7d dc 00	 cmp	 DWORD PTR $T2[ebp], 0
  000a8	76 17		 jbe	 SHORT $LN2@response

; 394  :     errordescription_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.errordescription_);

  000aa	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000ad	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000b0	50		 push	 eax
  000b1	68 00 00 00 00	 push	 OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 08	 add	 ecx, 8
  000bc	e8 00 00 00 00	 call	 ?AssignWithDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U1234@@Z ; google::protobuf::internal::ArenaStringPtr::AssignWithDefault
$LN2@response:

; 395  :   }
; 396  :   result_ = from.result_;

  000c1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	8b 55 08	 mov	 edx, DWORD PTR _from$[ebp]
  000c7	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000ca	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 397  :   // @@protoc_insertion_point(copy_constructor:NullPmd.response)
; 398  : }

  000cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0response@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0response@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0response@NullPmd@@QAE@ABV01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0response@NullPmd@@QAE@ABV01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0response@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::response::response
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1response@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1response@NullPmd@@UAE@XZ PROC			; NullPmd::response::~response, COMDAT
; _this$ = ecx

; 406  : response::~response() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1response@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7response@NullPmd@@6B@

; 407  :   // @@protoc_insertion_point(destructor:NullPmd.response)
; 408  :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@response@NullPmd@@AAEXXZ ; NullPmd::response::SharedDtor

; 409  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 409  : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1response@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1response@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1response@NullPmd@@UAE@XZ ENDP			; NullPmd::response::~response
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0response@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0response@NullPmd@@QAE@XZ PROC			; NullPmd::response::response, COMDAT
; _this$ = ecx

; 380  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0response@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 380  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7response@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 380  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 381  :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_
  00067	74 05		 je	 SHORT $LN2@response

; 382  :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@response:

; 383  :   }
; 384  :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@response@NullPmd@@AAEXXZ ; NullPmd::response::SharedCtor

; 385  :   // @@protoc_insertion_point(constructor:NullPmd.response)
; 386  : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0response@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0response@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0response@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0response@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0response@NullPmd@@QAE@XZ ENDP			; NullPmd::response::response
; Function compile flags: /Odtp
;	COMDAT ??_Grequest@NullPmd@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Grequest@NullPmd@@UAEPAXI@Z PROC			; NullPmd::request::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1request@NullPmd@@UAE@XZ ; NullPmd::request::~request
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Grequest@NullPmd@@UAEPAXI@Z ENDP			; NullPmd::request::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?GetMetadata@request@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetMetadata@request@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ PROC ; NullPmd::request::GetMetadata, COMDAT
; _this$ = ecx

; 362  : ::google::protobuf::Metadata request::GetMetadata() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 363  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00007	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 364  :   return protobuf_NullPmd_2eproto::file_level_metadata[0];

  0000c	b8 08 00 00 00	 mov	 eax, 8
  00011	6b c8 00	 imul	 ecx, eax, 0
  00014	8b 91 00 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]
  0001a	8b 81 04 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00023	89 11		 mov	 DWORD PTR [ecx], edx
  00025	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 365  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?GetMetadata@request@NullPmd@@UBE?AUMetadata@protobuf@google@@XZ ENDP ; NullPmd::request::GetMetadata
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSwap@request@NullPmd@@AAEXPAV12@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Tmp$2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
__Left$ = -4						; size = 4
_other$ = 8						; size = 4
?InternalSwap@request@NullPmd@@AAEXPAV12@@Z PROC	; NullPmd::request::InternalSwap, COMDAT
; _this$ = ecx

; 358  : void request::InternalSwap(request* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 359  :   std::swap(_cached_size_, other->_cached_size_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	83 c0 08	 add	 eax, 8
  0000f	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 08	 add	 ecx, 8
  00018	89 4d fc	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0001b	8b 55 fc	 mov	 edx, DWORD PTR __Left$[ebp]
  0001e	89 55 f0	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	89 4d e8	 mov	 DWORD PTR __Tmp$2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00029	8b 55 f8	 mov	 edx, DWORD PTR __Right$[ebp]
  0002c	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0002f	8b 45 fc	 mov	 eax, DWORD PTR __Left$[ebp]
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00039	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  0003c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00042	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  00045	8b 02		 mov	 eax, DWORD PTR [edx]
  00047	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 360  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?InternalSwap@request@NullPmd@@AAEXPAV12@@Z ENDP	; NullPmd::request::InternalSwap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SetCachedSize@request@NullPmd@@EBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetCachedSize@request@NullPmd@@EBEXH@Z PROC		; NullPmd::request::SetCachedSize, COMDAT
; _this$ = ecx

; 237  : void request::SetCachedSize(int size) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 238  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 239  :   _cached_size_ = size;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 240  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 241  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?SetCachedSize@request@NullPmd@@EBEXH@Z ENDP		; NullPmd::request::SetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedDtor@request@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedDtor@request@NullPmd@@AAEXXZ PROC		; NullPmd::request::SharedDtor, COMDAT
; _this$ = ecx

; 234  : void request::SharedDtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 235  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?SharedDtor@request@NullPmd@@AAEXXZ ENDP		; NullPmd::request::SharedDtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SharedCtor@request@NullPmd@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SharedCtor@request@NullPmd@@AAEXXZ PROC		; NullPmd::request::SharedCtor, COMDAT
; _this$ = ecx

; 225  : void request::SharedCtor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  :   _cached_size_ = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 227  : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?SharedCtor@request@NullPmd@@AAEXXZ ENDP		; NullPmd::request::SharedCtor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?GetCachedSize@request@NullPmd@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCachedSize@request@NullPmd@@UBEHXZ PROC		; NullPmd::request::GetCachedSize, COMDAT
; _this$ = ecx

; 117  :   int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCachedSize@request@NullPmd@@UBEHXZ ENDP		; NullPmd::request::GetCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?SerializeWithCachedSizesToArray@request@NullPmd@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
_output$ = 8						; size = 4
?SerializeWithCachedSizesToArray@request@NullPmd@@UBEPAEPAE@Z PROC ; NullPmd::request::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 113  :       const PROTOBUF_FINAL {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 873  :     return default_serialization_deterministic_;

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_
  0000e	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 114  :     return InternalSerializeWithCachedSizesToArray(

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _output$[ebp]
  00014	51		 push	 ecx
  00015	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z ; NullPmd::request::InternalSerializeWithCachedSizesToArray

; 115  :         ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
; 116  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@request@NullPmd@@UBEPAEPAE@Z ENDP ; NullPmd::request::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_deterministic$ = 8					; size = 1
_target$ = 12						; size = 4
?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z PROC ; NullPmd::request::InternalSerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 297  :     bool deterministic, ::google::protobuf::uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 298  :   (void)deterministic;  // Unused
; 299  :   // @@protoc_insertion_point(serialize_to_array_start:NullPmd.request)
; 300  :   // @@protoc_insertion_point(serialize_to_array_end:NullPmd.request)
; 301  :   return target;

  00007	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]

; 302  : }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
?InternalSerializeWithCachedSizesToArray@request@NullPmd@@UBEPAE_NPAE@Z ENDP ; NullPmd::request::InternalSerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?SerializeWithCachedSizes@request@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_output$ = 8						; size = 4
?SerializeWithCachedSizes@request@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z PROC ; NullPmd::request::SerializeWithCachedSizes, COMDAT
; _this$ = ecx

; 291  :     ::google::protobuf::io::CodedOutputStream* output) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  :   // @@protoc_insertion_point(serialize_start:NullPmd.request)
; 293  :   // @@protoc_insertion_point(serialize_end:NullPmd.request)
; 294  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SerializeWithCachedSizes@request@NullPmd@@UBEXPAVCodedOutputStream@io@protobuf@google@@@Z ENDP ; NullPmd::request::SerializeWithCachedSizes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergePartialFromCodedStream@request@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z
_TEXT	SEGMENT
_p$1 = -16						; size = 8
_this$ = -8						; size = 4
_tag$ = -4						; size = 4
_input$ = 8						; size = 4
?MergePartialFromCodedStream@request@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z PROC ; NullPmd::request::MergePartialFromCodedStream, COMDAT
; _this$ = ecx

; 265  :     ::google::protobuf::io::CodedInputStream* input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@MergeParti:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00009	6a 7f		 push	 127			; 0000007fH
  0000b	8d 45 f0	 lea	 eax, DWORD PTR _p$1[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 271  :     tag = p.first;

  00017	8b 4d f0	 mov	 ecx, DWORD PTR _p$1[ebp]
  0001a	89 4d fc	 mov	 DWORD PTR _tag$[ebp], ecx
$handle_unusual$17:

; 274  :     if (tag == 0 ||

  0001d	83 7d fc 00	 cmp	 DWORD PTR _tag$[ebp], 0
  00021	74 0b		 je	 SHORT $LN8@MergeParti
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\wire_format_lite.h

; 649  :   return static_cast<WireType>(tag & kTagTypeMask);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _tag$[ebp]
  00026	83 e0 07	 and	 eax, 7
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 274  :     if (tag == 0 ||

  00029	83 f8 04	 cmp	 eax, 4
  0002c	75 04		 jne	 SHORT $LN7@MergeParti
$LN8@MergeParti:

; 275  :         ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
; 276  :         ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
; 277  :       goto success;

  0002e	eb 1f		 jmp	 SHORT $success$18
  00030	eb 1d		 jmp	 SHORT $success$18
$LN7@MergeParti:

; 278  :     }
; 279  :     DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));

  00032	8b 4d fc	 mov	 ecx, DWORD PTR _tag$[ebp]
  00035	51		 push	 ecx
  00036	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?SkipField@WireFormatLite@internal@protobuf@google@@SA_NPAVCodedInputStream@io@34@I@Z ; google::protobuf::internal::WireFormatLite::SkipField
  0003f	83 c4 08	 add	 esp, 8
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	75 04		 jne	 SHORT $LN10@MergeParti
  00049	eb 08		 jmp	 SHORT $failure$19
  0004b	eb 06		 jmp	 SHORT $failure$19
$LN10@MergeParti:

; 280  :   }

  0004d	eb ba		 jmp	 SHORT $LN4@MergeParti
$success$18:

; 281  : success:
; 282  :   // @@protoc_insertion_point(parse_success:NullPmd.request)
; 283  :   return true;

  0004f	b0 01		 mov	 al, 1
  00051	eb 02		 jmp	 SHORT $LN1@MergeParti
$failure$19:

; 284  : failure:
; 285  :   // @@protoc_insertion_point(parse_failure:NullPmd.request)
; 286  :   return false;

  00053	32 c0		 xor	 al, al
$LN1@MergeParti:

; 287  : #undef DO_
; 288  : }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?MergePartialFromCodedStream@request@NullPmd@@UAE_NPAVCodedInputStream@io@protobuf@google@@@Z ENDP ; NullPmd::request::MergePartialFromCodedStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?ByteSizeLong@request@NullPmd@@UBEIXZ
_TEXT	SEGMENT
_cached_size$ = -12					; size = 4
_this$ = -8						; size = 4
_total_size$ = -4					; size = 4
?ByteSizeLong@request@NullPmd@@UBEIXZ PROC		; NullPmd::request::ByteSizeLong, COMDAT
; _this$ = ecx

; 304  : size_t request::ByteSizeLong() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 305  : // @@protoc_insertion_point(message_byte_size_start:NullPmd.request)
; 306  :   size_t total_size = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _total_size$[ebp], 0

; 307  : 
; 308  :   int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR _cached_size$[ebp], eax

; 309  :   GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
; 310  :   _cached_size_ = cached_size;

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	8b 55 f4	 mov	 edx, DWORD PTR _cached_size$[ebp]
  0001c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 311  :   GOOGLE_SAFE_CONCURRENT_WRITES_END();
; 312  :   return total_size;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _total_size$[ebp]

; 313  : }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?ByteSizeLong@request@NullPmd@@UBEIXZ ENDP		; NullPmd::request::ByteSizeLong
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?IsInitialized@request@NullPmd@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInitialized@request@NullPmd@@UBE_NXZ PROC		; NullPmd::request::IsInitialized, COMDAT
; _this$ = ecx

; 350  : bool request::IsInitialized() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  :   return true;

  00007	b0 01		 mov	 al, 1

; 352  : }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?IsInitialized@request@NullPmd@@UBE_NXZ ENDP		; NullPmd::request::IsInitialized
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Clear@request@NullPmd@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@request@NullPmd@@UAEXXZ PROC			; NullPmd::request::Clear, COMDAT
; _this$ = ecx

; 260  : void request::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : // @@protoc_insertion_point(message_clear_start:NullPmd.request)
; 262  : }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?Clear@request@NullPmd@@UAEXXZ ENDP			; NullPmd::request::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@request@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
tv89 = -76						; size = 4
tv169 = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@request@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::request::MergeFrom, COMDAT
; _this$ = ecx

; 330  : void request::MergeFrom(const request& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@request@NullPmd@@QAEXABV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 331  : // @@protoc_insertion_point(class_specific_merge_from_start:NullPmd.request)
; 332  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN3@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN4@MergeFrom
$LN3@MergeFrom:
  0003c	68 4c 01 00 00	 push	 332			; 0000014cH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b8	 mov	 DWORD PTR tv169[ebp], eax
  00053	8b 4d b8	 mov	 ecx, DWORD PTR tv169[ebp]
  00056	89 4d b4	 mov	 DWORD PTR tv89[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b4	 mov	 ecx, DWORD PTR tv89[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN4@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN7@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN7@MergeFrom:

; 333  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	83 c1 04	 add	 ecx, 4
  000a0	51		 push	 ecx
  000a1	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 c1 04	 add	 ecx, 4
  000a7	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 334  : }

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b6	59		 pop	 ecx
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@request@NullPmd@@QAEXABV12@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN6@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@request@NullPmd@@QAEXABV12@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@request@NullPmd@@QAEXABV12@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@request@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::request::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@request@NullPmd@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@request@NullPmd@@QAEXABV12@@Z PROC		; NullPmd::request::CopyFrom, COMDAT
; _this$ = ecx

; 343  : void request::CopyFrom(const request& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : // @@protoc_insertion_point(class_specific_copy_from_start:NullPmd.request)
; 345  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 346  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@request@NullPmd@@UAEXXZ ; NullPmd::request::Clear

; 347  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@request@NullPmd@@QAEXABV12@@Z ; NullPmd::request::MergeFrom
$LN1@CopyFrom:

; 348  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@request@NullPmd@@QAEXABV12@@Z ENDP		; NullPmd::request::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
tv128 = -80						; size = 4
tv131 = -76						; size = 4
_source$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::request::MergeFrom, COMDAT
; _this$ = ecx

; 315  : void request::MergeFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 316  : // @@protoc_insertion_point(generalized_merge_from_start:NullPmd.request)
; 317  :   GOOGLE_DCHECK_NE(&from, this);

  00032	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  00035	3b 45 bc	 cmp	 eax, DWORD PTR _this$[ebp]
  00038	74 02		 je	 SHORT $LN5@MergeFrom
  0003a	eb 43		 jmp	 SHORT $LN6@MergeFrom
$LN5@MergeFrom:
  0003c	68 3d 01 00 00	 push	 317			; 0000013dH
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00046	6a 03		 push	 3
  00048	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0004b	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00050	89 45 b4	 mov	 DWORD PTR tv131[ebp], eax
  00053	8b 4d b4	 mov	 ecx, DWORD PTR tv131[ebp]
  00056	89 4d b0	 mov	 DWORD PTR tv128[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00063	83 ca 01	 or	 edx, 1
  00066	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@HENEHLPK@CHECK?5failed?3?5?$CI?$CGfrom?$CJ?5?$CB?$DN?5?$CIthis?$CJ@
  0006e	8b 4d b0	 mov	 ecx, DWORD PTR tv128[ebp]
  00071	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00076	50		 push	 eax
  00077	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN6@MergeFrom:
  0007f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00089	83 e0 01	 and	 eax, 1
  0008c	74 0c		 je	 SHORT $LN9@MergeFrom
  0008e	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00092	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@MergeFrom:

; 318  :   const request* source =
; 319  :       ::google::protobuf::internal::DynamicCastToGenerated<const request>(

  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ??$DynamicCastToGenerated@$$CBVrequest@NullPmd@@@internal@protobuf@google@@YAPBVrequest@NullPmd@@PBVMessage@12@@Z ; google::protobuf::internal::DynamicCastToGenerated<NullPmd::request const >
  000a3	83 c4 04	 add	 esp, 4
  000a6	89 45 b8	 mov	 DWORD PTR _source$[ebp], eax

; 320  :           &from);
; 321  :   if (source == NULL) {

  000a9	83 7d b8 00	 cmp	 DWORD PTR _source$[ebp], 0
  000ad	75 12		 jne	 SHORT $LN2@MergeFrom

; 322  :   // @@protoc_insertion_point(generalized_merge_from_cast_fail:NullPmd.request)
; 323  :     ::google::protobuf::internal::ReflectionOps::Merge(from, this);

  000af	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000b2	52		 push	 edx
  000b3	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ?Merge@ReflectionOps@internal@protobuf@google@@SAXABVMessage@34@PAV534@@Z ; google::protobuf::internal::ReflectionOps::Merge
  000bc	83 c4 08	 add	 esp, 8

; 324  :   } else {

  000bf	eb 0c		 jmp	 SHORT $LN1@MergeFrom
$LN2@MergeFrom:

; 325  :   // @@protoc_insertion_point(generalized_merge_from_cast_success:NullPmd.request)
; 326  :     MergeFrom(*source);

  000c1	8b 4d b8	 mov	 ecx, DWORD PTR _source$[ebp]
  000c4	51		 push	 ecx
  000c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?MergeFrom@request@NullPmd@@QAEXABV12@@Z ; NullPmd::request::MergeFrom
$LN1@MergeFrom:

; 327  :   }
; 328  : }

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d7	59		 pop	 ecx
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000db	33 cd		 xor	 ecx, ebp
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@MergeFrom
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@MergeFrom:
  00018	c3		 ret	 0
__ehhandler$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::request::MergeFrom
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?CopyFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_from$ = 8						; size = 4
?CopyFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z PROC ; NullPmd::request::CopyFrom, COMDAT
; _this$ = ecx

; 336  : void request::CopyFrom(const ::google::protobuf::Message& from) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 337  : // @@protoc_insertion_point(generalized_copy_from_start:NullPmd.request)
; 338  :   if (&from == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@CopyFrom
  0000f	eb 14		 jmp	 SHORT $LN1@CopyFrom
$LN2@CopyFrom:

; 339  :   Clear();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?Clear@request@NullPmd@@UAEXXZ ; NullPmd::request::Clear

; 340  :   MergeFrom(from);

  00019	8b 4d 08	 mov	 ecx, DWORD PTR _from$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?MergeFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ; NullPmd::request::MergeFrom
$LN1@CopyFrom:

; 341  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?CopyFrom@request@NullPmd@@UAEXABVMessage@protobuf@google@@@Z ENDP ; NullPmd::request::CopyFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_n$ = -24						; size = 4
tv75 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_arena$ = 8						; size = 4
?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z PROC ; NullPmd::request::New, COMDAT
; _this$ = ecx

; 252  : request* request::New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 253  :   request* n = new request;

  00028	6a 0c		 push	 12			; 0000000cH
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  00040	74 0d		 je	 SHORT $LN4@New
  00042	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ??0request@NullPmd@@QAE@XZ ; NullPmd::request::request
  0004a	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004d	eb 07		 jmp	 SHORT $LN5@New
$LN4@New:
  0004f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@New:
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	89 4d e8	 mov	 DWORD PTR _n$[ebp], ecx

; 254  :   if (arena != NULL) {

  00069	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0006d	74 0c		 je	 SHORT $LN2@New

; 255  :     arena->Own(n);

  0006f	8b 55 e8	 mov	 edx, DWORD PTR _n$[ebp]
  00072	52		 push	 edx
  00073	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00076	e8 00 00 00 00	 call	 ??$Own@Vrequest@NullPmd@@@Arena@protobuf@google@@QAEXPAVrequest@NullPmd@@@Z ; google::protobuf::Arena::Own<NullPmd::request>
$LN2@New:

; 256  :   }
; 257  :   return n;

  0007b	8b 45 e8	 mov	 eax, DWORD PTR _n$[ebp]

; 258  : }

  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__ehhandler$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z:
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ENDP ; NullPmd::request::New
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?New@request@NullPmd@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?New@request@NullPmd@@UBEPAV12@XZ PROC			; NullPmd::request::New, COMDAT
; _this$ = ecx

; 95   :   inline request* New() const PROTOBUF_FINAL { return New(NULL); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?New@request@NullPmd@@UBEPAV12@PAVArena@protobuf@google@@@Z ; NullPmd::request::New
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?New@request@NullPmd@@UBEPAV12@XZ ENDP			; NullPmd::request::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Swap@request@NullPmd@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@request@NullPmd@@QAEXPAV12@@Z PROC		; NullPmd::request::Swap, COMDAT
; _this$ = ecx

; 354  : void request::Swap(request* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 355  :   if (other == this) return;

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	3b 45 fc	 cmp	 eax, DWORD PTR _this$[ebp]
  0000d	75 02		 jne	 SHORT $LN2@Swap
  0000f	eb 0c		 jmp	 SHORT $LN1@Swap
$LN2@Swap:

; 356  :   InternalSwap(other);

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _other$[ebp]
  00014	51		 push	 ecx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?InternalSwap@request@NullPmd@@AAEXPAV12@@Z ; NullPmd::request::InternalSwap
$LN1@Swap:

; 357  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?Swap@request@NullPmd@@QAEXPAV12@@Z ENDP		; NullPmd::request::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
;	COMDAT ?internal_default_instance@request@NullPmd@@SAPBV12@XZ
_TEXT	SEGMENT
?internal_default_instance@request@NullPmd@@SAPBV12@XZ PROC ; NullPmd::request::internal_default_instance, COMDAT

; 86   :   static inline const request* internal_default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :     return reinterpret_cast<const request*>(

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_

; 88   :                &_request_default_instance_);
; 89   :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?internal_default_instance@request@NullPmd@@SAPBV12@XZ ENDP ; NullPmd::request::internal_default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?default_instance@request@NullPmd@@SAABV12@XZ
_TEXT	SEGMENT
?default_instance@request@NullPmd@@SAABV12@XZ PROC	; NullPmd::request::default_instance, COMDAT

; 247  : const request& request::default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 248  :   protobuf_NullPmd_2eproto::InitDefaults();

  00003	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults

; 249  :   return *internal_default_instance();

  00008	b8 00 00 00 00	 mov	 eax, OFFSET ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_

; 250  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?default_instance@request@NullPmd@@SAABV12@XZ ENDP	; NullPmd::request::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?descriptor@request@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ
_TEXT	SEGMENT
?descriptor@request@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ PROC ; NullPmd::request::descriptor, COMDAT

; 242  : const ::google::protobuf::Descriptor* request::descriptor() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 243  :   protobuf_NullPmd_2eproto::protobuf_AssignDescriptorsOnce();

  00003	e8 00 00 00 00	 call	 ?protobuf_AssignDescriptorsOnce@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::`anonymous namespace'::protobuf_AssignDescriptorsOnce

; 244  :   return protobuf_NullPmd_2eproto::file_level_metadata[0].descriptor;

  00008	b8 08 00 00 00	 mov	 eax, 8
  0000d	6b c8 00	 imul	 ecx, eax, 0
  00010	8b 81 00 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx]

; 245  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?descriptor@request@NullPmd@@SAPBVDescriptor@protobuf@google@@XZ ENDP ; NullPmd::request::descriptor
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0request@NullPmd@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_from$ = 8						; size = 4
??0request@NullPmd@@QAE@ABV01@@Z PROC			; NullPmd::request::request, COMDAT
; _this$ = ecx

; 220  :       _cached_size_(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0request@NullPmd@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 218  :   : ::google::protobuf::Message(),

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 220  :       _cached_size_(0) {

  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7request@NullPmd@@6B@

; 219  :       _internal_metadata_(NULL),

  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 219  :       _internal_metadata_(NULL),

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 220  :       _cached_size_(0) {

  00060	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00063	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 221  :   _internal_metadata_.MergeFrom(from._internal_metadata_);

  0006a	8b 45 08	 mov	 eax, DWORD PTR _from$[ebp]
  0006d	83 c0 04	 add	 eax, 4
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	83 c1 04	 add	 ecx, 4
  00077	e8 00 00 00 00	 call	 ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom

; 222  :   // @@protoc_insertion_point(copy_constructor:NullPmd.request)
; 223  : }

  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0request@NullPmd@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0request@NullPmd@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0request@NullPmd@@QAE@ABV01@@Z:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0request@NullPmd@@QAE@ABV01@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0request@NullPmd@@QAE@ABV01@@Z ENDP			; NullPmd::request::request
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??1request@NullPmd@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1request@NullPmd@@UAE@XZ PROC				; NullPmd::request::~request, COMDAT
; _this$ = ecx

; 229  : request::~request() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1request@NullPmd@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7request@NullPmd@@6B@

; 230  :   // @@protoc_insertion_point(destructor:NullPmd.request)
; 231  :   SharedDtor();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SharedDtor@request@NullPmd@@AAEXXZ ; NullPmd::request::SharedDtor

; 232  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  0004b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0004e	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 232  : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1request@NullPmd@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1request@NullPmd@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1request@NullPmd@@UAE@XZ ENDP				; NullPmd::request::~request
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ??0request@NullPmd@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0request@NullPmd@@QAE@XZ PROC				; NullPmd::request::request, COMDAT
; _this$ = ecx

; 210  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0request@NullPmd@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 210  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00044	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7request@NullPmd@@6B@
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 210  :   : ::google::protobuf::Message(), _internal_metadata_(NULL) {

  0005c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 211  :   if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {

  00060	81 7d f0 00 00
	00 00		 cmp	 DWORD PTR _this$[ebp], OFFSET ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_
  00067	74 05		 je	 SHORT $LN2@request

; 212  :     protobuf_NullPmd_2eproto::InitDefaults();

  00069	e8 00 00 00 00	 call	 ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
$LN2@request:

; 213  :   }
; 214  :   SharedCtor();

  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	e8 00 00 00 00	 call	 ?SharedCtor@request@NullPmd@@AAEXXZ ; NullPmd::request::SharedCtor

; 215  :   // @@protoc_insertion_point(constructor:NullPmd.request)
; 216  : }

  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0request@NullPmd@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@protobuf@google@@UAE@XZ ; google::protobuf::Message::~Message
__unwindfunclet$??0request@NullPmd@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
__ehhandler$??0request@NullPmd@@QAE@XZ:
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0request@NullPmd@@QAE@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0request@NullPmd@@QAE@XZ ENDP				; NullPmd::request::request
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
_TEXT	SEGMENT
?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults, COMDAT

; 166  : void InitDefaults() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 167  :   static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
; 168  :   ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);

  00003	68 00 00 00 00	 push	 OFFSET ?InitDefaultsImpl@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::InitDefaultsImpl
  00008	68 00 00 00 00	 push	 OFFSET ?once@?1??InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
  0000d	e8 00 00 00 00	 call	 ?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z ; google::protobuf::GoogleOnceInit
  00012	83 c4 08	 add	 esp, 8

; 169  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?InitDefaults@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::InitDefaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ
_TEXT	SEGMENT
?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors, COMDAT

; 190  : void AddDescriptors() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 191  :   static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
; 192  :   ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);

  00003	68 00 00 00 00	 push	 OFFSET ?AddDescriptorsImpl@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptorsImpl
  00008	68 00 00 00 00	 push	 OFFSET ?once@?1??AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ@4HA
  0000d	e8 00 00 00 00	 call	 ?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z ; google::protobuf::GoogleOnceInit
  00012	83 c4 08	 add	 esp, 8

; 193  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?AddDescriptors@protobuf_NullPmd_2eproto@NullPmd@@YAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::AddDescriptors
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?Shutdown@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ
_TEXT	SEGMENT
tv200 = -112						; size = 4
$T1 = -108						; size = 4
tv185 = -104						; size = 4
$T2 = -100						; size = 4
tv170 = -96						; size = 4
$T3 = -92						; size = 4
tv155 = -88						; size = 4
$T4 = -84						; size = 4
tv140 = -80						; size = 4
$T5 = -76						; size = 4
tv93 = -72						; size = 4
$T6 = -68						; size = 4
tv78 = -64						; size = 4
$T7 = -60						; size = 4
tv296 = -56						; size = 4
tv282 = -52						; size = 4
tv268 = -48						; size = 4
tv254 = -44						; size = 4
tv240 = -40						; size = 4
tv226 = -36						; size = 4
tv212 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
$T10 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
$T13 = -8						; size = 4
$T14 = -4						; size = 4
?Shutdown@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::Shutdown, COMDAT

; 130  : void TableStruct::Shutdown() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  00006	0f b6 05 10 00
	00 00		 movzx	 eax, BYTE PTR ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A+16
  0000d	85 c0		 test	 eax, eax
  0000f	74 1c		 je	 SHORT $LN17@Shutdown

; 97   :       init_ = false;

  00011	c6 05 10 00 00
	00 00		 mov	 BYTE PTR ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A+16, 0

; 98   :       get_mutable()->~T();

  00018	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv212[ebp], OFFSET ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_
  0001f	6a 00		 push	 0
  00021	8b 4d e0	 mov	 ecx, DWORD PTR tv212[ebp]
  00024	8b 11		 mov	 edx, DWORD PTR [ecx]
  00026	8b 4d e0	 mov	 ecx, DWORD PTR tv212[ebp]
  00029	8b 02		 mov	 eax, DWORD PTR [edx]
  0002b	ff d0		 call	 eax
$LN17@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 132  :   delete file_level_metadata[0].reflection;

  0002d	b9 08 00 00 00	 mov	 ecx, 8
  00032	6b d1 00	 imul	 edx, ecx, 0
  00035	8b 82 04 00 00
	00		 mov	 eax, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[edx+4]
  0003b	89 45 c4	 mov	 DWORD PTR $T7[ebp], eax
  0003e	8b 4d c4	 mov	 ecx, DWORD PTR $T7[ebp]
  00041	89 4d fc	 mov	 DWORD PTR $T14[ebp], ecx
  00044	83 7d fc 00	 cmp	 DWORD PTR $T14[ebp], 0
  00048	74 13		 je	 SHORT $LN3@Shutdown
  0004a	6a 01		 push	 1
  0004c	8b 55 fc	 mov	 edx, DWORD PTR $T14[ebp]
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	8b 4d fc	 mov	 ecx, DWORD PTR $T14[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	ff d2		 call	 edx
  00058	89 45 c0	 mov	 DWORD PTR tv78[ebp], eax
  0005b	eb 07		 jmp	 SHORT $LN4@Shutdown
$LN3@Shutdown:
  0005d	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  00064	0f b6 05 18 00
	00 00		 movzx	 eax, BYTE PTR ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A+24
  0006b	85 c0		 test	 eax, eax
  0006d	74 1c		 je	 SHORT $LN22@Shutdown

; 97   :       init_ = false;

  0006f	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A+24, 0

; 98   :       get_mutable()->~T();

  00076	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv226[ebp], OFFSET ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_
  0007d	6a 00		 push	 0
  0007f	8b 4d dc	 mov	 ecx, DWORD PTR tv226[ebp]
  00082	8b 11		 mov	 edx, DWORD PTR [ecx]
  00084	8b 4d dc	 mov	 ecx, DWORD PTR tv226[ebp]
  00087	8b 02		 mov	 eax, DWORD PTR [edx]
  00089	ff d0		 call	 eax
$LN22@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 134  :   delete file_level_metadata[1].reflection;

  0008b	b9 08 00 00 00	 mov	 ecx, 8
  00090	c1 e1 00	 shl	 ecx, 0
  00093	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00099	89 55 bc	 mov	 DWORD PTR $T6[ebp], edx
  0009c	8b 45 bc	 mov	 eax, DWORD PTR $T6[ebp]
  0009f	89 45 f8	 mov	 DWORD PTR $T13[ebp], eax
  000a2	83 7d f8 00	 cmp	 DWORD PTR $T13[ebp], 0
  000a6	74 13		 je	 SHORT $LN5@Shutdown
  000a8	6a 01		 push	 1
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR $T13[ebp]
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	8b 4d f8	 mov	 ecx, DWORD PTR $T13[ebp]
  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
  000b4	ff d0		 call	 eax
  000b6	89 45 b8	 mov	 DWORD PTR tv93[ebp], eax
  000b9	eb 07		 jmp	 SHORT $LN6@Shutdown
$LN5@Shutdown:
  000bb	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN6@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  000c2	0f b6 0d 10 00
	00 00		 movzx	 ecx, BYTE PTR ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A+16
  000c9	85 c9		 test	 ecx, ecx
  000cb	74 1c		 je	 SHORT $LN27@Shutdown

; 97   :       init_ = false;

  000cd	c6 05 10 00 00
	00 00		 mov	 BYTE PTR ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A+16, 0

; 98   :       get_mutable()->~T();

  000d4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv240[ebp], OFFSET ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_
  000db	6a 00		 push	 0
  000dd	8b 55 d8	 mov	 edx, DWORD PTR tv240[ebp]
  000e0	8b 02		 mov	 eax, DWORD PTR [edx]
  000e2	8b 4d d8	 mov	 ecx, DWORD PTR tv240[ebp]
  000e5	8b 10		 mov	 edx, DWORD PTR [eax]
  000e7	ff d2		 call	 edx
$LN27@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 136  :   delete file_level_metadata[2].reflection;

  000e9	b8 08 00 00 00	 mov	 eax, 8
  000ee	d1 e0		 shl	 eax, 1
  000f0	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax+4]
  000f6	89 4d b4	 mov	 DWORD PTR $T5[ebp], ecx
  000f9	8b 55 b4	 mov	 edx, DWORD PTR $T5[ebp]
  000fc	89 55 f4	 mov	 DWORD PTR $T12[ebp], edx
  000ff	83 7d f4 00	 cmp	 DWORD PTR $T12[ebp], 0
  00103	74 13		 je	 SHORT $LN7@Shutdown
  00105	6a 01		 push	 1
  00107	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  0010a	8b 10		 mov	 edx, DWORD PTR [eax]
  0010c	8b 4d f4	 mov	 ecx, DWORD PTR $T12[ebp]
  0010f	8b 02		 mov	 eax, DWORD PTR [edx]
  00111	ff d0		 call	 eax
  00113	89 45 b0	 mov	 DWORD PTR tv140[ebp], eax
  00116	eb 07		 jmp	 SHORT $LN8@Shutdown
$LN7@Shutdown:
  00118	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN8@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  0011f	0f b6 0d 20 00
	00 00		 movzx	 ecx, BYTE PTR ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A+32
  00126	85 c9		 test	 ecx, ecx
  00128	74 1c		 je	 SHORT $LN32@Shutdown

; 97   :       init_ = false;

  0012a	c6 05 20 00 00
	00 00		 mov	 BYTE PTR ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A+32, 0

; 98   :       get_mutable()->~T();

  00131	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv254[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
  00138	6a 00		 push	 0
  0013a	8b 55 d4	 mov	 edx, DWORD PTR tv254[ebp]
  0013d	8b 02		 mov	 eax, DWORD PTR [edx]
  0013f	8b 4d d4	 mov	 ecx, DWORD PTR tv254[ebp]
  00142	8b 10		 mov	 edx, DWORD PTR [eax]
  00144	ff d2		 call	 edx
$LN32@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 138  :   delete file_level_metadata[3].reflection;

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	6b c8 03	 imul	 ecx, eax, 3
  0014e	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00154	89 55 ac	 mov	 DWORD PTR $T4[ebp], edx
  00157	8b 45 ac	 mov	 eax, DWORD PTR $T4[ebp]
  0015a	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
  0015d	83 7d f0 00	 cmp	 DWORD PTR $T11[ebp], 0
  00161	74 13		 je	 SHORT $LN9@Shutdown
  00163	6a 01		 push	 1
  00165	8b 4d f0	 mov	 ecx, DWORD PTR $T11[ebp]
  00168	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016a	8b 4d f0	 mov	 ecx, DWORD PTR $T11[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	ff d0		 call	 eax
  00171	89 45 a8	 mov	 DWORD PTR tv155[ebp], eax
  00174	eb 07		 jmp	 SHORT $LN10@Shutdown
$LN9@Shutdown:
  00176	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
$LN10@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  0017d	0f b6 0d 28 00
	00 00		 movzx	 ecx, BYTE PTR ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A+40
  00184	85 c9		 test	 ecx, ecx
  00186	74 1c		 je	 SHORT $LN37@Shutdown

; 97   :       init_ = false;

  00188	c6 05 28 00 00
	00 00		 mov	 BYTE PTR ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A+40, 0

; 98   :       get_mutable()->~T();

  0018f	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv268[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
  00196	6a 00		 push	 0
  00198	8b 55 d0	 mov	 edx, DWORD PTR tv268[ebp]
  0019b	8b 02		 mov	 eax, DWORD PTR [edx]
  0019d	8b 4d d0	 mov	 ecx, DWORD PTR tv268[ebp]
  001a0	8b 10		 mov	 edx, DWORD PTR [eax]
  001a2	ff d2		 call	 edx
$LN37@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 140  :   delete file_level_metadata[4].reflection;

  001a4	b8 08 00 00 00	 mov	 eax, 8
  001a9	c1 e0 02	 shl	 eax, 2
  001ac	8b 88 04 00 00
	00		 mov	 ecx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[eax+4]
  001b2	89 4d a4	 mov	 DWORD PTR $T3[ebp], ecx
  001b5	8b 55 a4	 mov	 edx, DWORD PTR $T3[ebp]
  001b8	89 55 ec	 mov	 DWORD PTR $T10[ebp], edx
  001bb	83 7d ec 00	 cmp	 DWORD PTR $T10[ebp], 0
  001bf	74 13		 je	 SHORT $LN11@Shutdown
  001c1	6a 01		 push	 1
  001c3	8b 45 ec	 mov	 eax, DWORD PTR $T10[ebp]
  001c6	8b 10		 mov	 edx, DWORD PTR [eax]
  001c8	8b 4d ec	 mov	 ecx, DWORD PTR $T10[ebp]
  001cb	8b 02		 mov	 eax, DWORD PTR [edx]
  001cd	ff d0		 call	 eax
  001cf	89 45 a0	 mov	 DWORD PTR tv170[ebp], eax
  001d2	eb 07		 jmp	 SHORT $LN12@Shutdown
$LN11@Shutdown:
  001d4	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
$LN12@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  001db	0f b6 0d 18 00
	00 00		 movzx	 ecx, BYTE PTR ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A+24
  001e2	85 c9		 test	 ecx, ecx
  001e4	74 1c		 je	 SHORT $LN42@Shutdown

; 97   :       init_ = false;

  001e6	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A+24, 0

; 98   :       get_mutable()->~T();

  001ed	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv282[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
  001f4	6a 00		 push	 0
  001f6	8b 55 cc	 mov	 edx, DWORD PTR tv282[ebp]
  001f9	8b 02		 mov	 eax, DWORD PTR [edx]
  001fb	8b 4d cc	 mov	 ecx, DWORD PTR tv282[ebp]
  001fe	8b 10		 mov	 edx, DWORD PTR [eax]
  00200	ff d2		 call	 edx
$LN42@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 142  :   delete file_level_metadata[5].reflection;

  00202	b8 08 00 00 00	 mov	 eax, 8
  00207	6b c8 05	 imul	 ecx, eax, 5
  0020a	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  00210	89 55 9c	 mov	 DWORD PTR $T2[ebp], edx
  00213	8b 45 9c	 mov	 eax, DWORD PTR $T2[ebp]
  00216	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
  00219	83 7d e8 00	 cmp	 DWORD PTR $T9[ebp], 0
  0021d	74 13		 je	 SHORT $LN13@Shutdown
  0021f	6a 01		 push	 1
  00221	8b 4d e8	 mov	 ecx, DWORD PTR $T9[ebp]
  00224	8b 11		 mov	 edx, DWORD PTR [ecx]
  00226	8b 4d e8	 mov	 ecx, DWORD PTR $T9[ebp]
  00229	8b 02		 mov	 eax, DWORD PTR [edx]
  0022b	ff d0		 call	 eax
  0022d	89 45 98	 mov	 DWORD PTR tv185[ebp], eax
  00230	eb 07		 jmp	 SHORT $LN14@Shutdown
$LN13@Shutdown:
  00232	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv185[ebp], 0
$LN14@Shutdown:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 96   :     if (init_) {

  00239	0f b6 0d 18 00
	00 00		 movzx	 ecx, BYTE PTR ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A+24
  00240	85 c9		 test	 ecx, ecx
  00242	74 1c		 je	 SHORT $LN47@Shutdown

; 97   :       init_ = false;

  00244	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A+24, 0

; 98   :       get_mutable()->~T();

  0024b	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv296[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
  00252	6a 00		 push	 0
  00254	8b 55 c8	 mov	 edx, DWORD PTR tv296[ebp]
  00257	8b 02		 mov	 eax, DWORD PTR [edx]
  00259	8b 4d c8	 mov	 ecx, DWORD PTR tv296[ebp]
  0025c	8b 10		 mov	 edx, DWORD PTR [eax]
  0025e	ff d2		 call	 edx
$LN47@Shutdown:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 144  :   delete file_level_metadata[6].reflection;

  00260	b8 08 00 00 00	 mov	 eax, 8
  00265	6b c8 06	 imul	 ecx, eax, 6
  00268	8b 91 04 00 00
	00		 mov	 edx, DWORD PTR ?file_level_metadata@?A0x1abee5d0@protobuf_NullPmd_2eproto@NullPmd@@3PAUMetadata@protobuf@google@@A[ecx+4]
  0026e	89 55 94	 mov	 DWORD PTR $T1[ebp], edx
  00271	8b 45 94	 mov	 eax, DWORD PTR $T1[ebp]
  00274	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax
  00277	83 7d e4 00	 cmp	 DWORD PTR $T8[ebp], 0
  0027b	74 13		 je	 SHORT $LN15@Shutdown
  0027d	6a 01		 push	 1
  0027f	8b 4d e4	 mov	 ecx, DWORD PTR $T8[ebp]
  00282	8b 11		 mov	 edx, DWORD PTR [ecx]
  00284	8b 4d e4	 mov	 ecx, DWORD PTR $T8[ebp]
  00287	8b 02		 mov	 eax, DWORD PTR [edx]
  00289	ff d0		 call	 eax
  0028b	89 45 90	 mov	 DWORD PTR tv200[ebp], eax
  0028e	eb 07		 jmp	 SHORT $LN1@Shutdown
$LN15@Shutdown:
  00290	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], 0
$LN1@Shutdown:

; 145  : }

  00297	8b e5		 mov	 esp, ebp
  00299	5d		 pop	 ebp
  0029a	c3		 ret	 0
?Shutdown@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::Shutdown
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc
;	COMDAT ?InitDefaultsImpl@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?InitDefaultsImpl@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ PROC ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::InitDefaultsImpl, COMDAT

; 147  : void TableStruct::InitDefaultsImpl() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 148  :   GOOGLE_PROTOBUF_VERIFY_VERSION;

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@IALFNHEB@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0000b	68 90 ce 2d 00	 push	 3002000			; 002dce90H
  00010	68 90 ce 2d 00	 push	 3002000			; 002dce90H
  00015	e8 00 00 00 00	 call	 ?VerifyVersion@internal@protobuf@google@@YAXHHPBD@Z ; google::protobuf::internal::VerifyVersion
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 
; 150  :   ::google::protobuf::internal::InitProtobufDefaults();

  0001d	e8 00 00 00 00	 call	 ?InitProtobufDefaults@internal@protobuf@google@@YAXXZ ; google::protobuf::internal::InitProtobufDefaults
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], OFFSET ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A ; NullPmd::_request_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  00029	8b 4d fc	 mov	 ecx, DWORD PTR $T7[ebp]
  0002c	e8 00 00 00 00	 call	 ??0request@NullPmd@@QAE@XZ ; NullPmd::request::request

; 91   :     init_ = true;

  00031	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?_request_default_instance_@NullPmd@@3VrequestDefaultTypeInternal@1@A+16, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00038	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A ; NullPmd::_response_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  00042	e8 00 00 00 00	 call	 ??0response@NullPmd@@QAE@XZ ; NullPmd::response::response

; 91   :     init_ = true;

  00047	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?_response_default_instance_@NullPmd@@3VresponseDefaultTypeInternal@1@A+24, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0004e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A ; NullPmd::_indication_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  00055	8b 4d f4	 mov	 ecx, DWORD PTR $T5[ebp]
  00058	e8 00 00 00 00	 call	 ??0indication@NullPmd@@QAE@XZ ; NullPmd::indication::indication

; 91   :     init_ = true;

  0005d	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?_indication_default_instance_@NullPmd@@3VindicationDefaultTypeInternal@1@A+16, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00064	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  0006b	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  0006e	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@XZ ; NullPmd::command::command

; 91   :     init_ = true;

  00073	c6 05 20 00 00
	00 01		 mov	 BYTE PTR ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A+32, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0007a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  00081	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00084	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@XZ	; NullPmd::info::info

; 91   :     init_ = true;

  00089	c6 05 28 00 00
	00 01		 mov	 BYTE PTR ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A+40, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00090	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  00097	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  0009a	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@XZ	; NullPmd::head::head

; 91   :     init_ = true;

  0009f	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A+24, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  000a6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A ; NullPmd::_message_default_instance_
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h

; 90   :     new (&union_) T();

  000ad	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000b0	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message

; 91   :     init_ = true;

  000b5	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A+24, 1
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.cc

; 158  :   _head_default_instance_.get_mutable()->command_ = const_cast< ::NullPmd::command*>(

  000bc	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A+8, OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_

; 159  :       ::NullPmd::command::internal_default_instance());
; 160  :   _head_default_instance_.get_mutable()->info_ = const_cast< ::NullPmd::info*>(

  000c6	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A+12, OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_

; 161  :       ::NullPmd::info::internal_default_instance());
; 162  :   _message_default_instance_.get_mutable()->head_ = const_cast< ::NullPmd::head*>(

  000d0	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_message_default_instance_@NullPmd@@3VmessageDefaultTypeInternal@1@A+12, OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_

; 163  :       ::NullPmd::head::internal_default_instance());
; 164  : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?InitDefaultsImpl@TableStruct@protobuf_NullPmd_2eproto@NullPmd@@SAXXZ ENDP ; NullPmd::protobuf_NullPmd_2eproto::TableStruct::InitDefaultsImpl
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arena.h
;	COMDAT ??$Own@VMessage@protobuf@google@@@Arena@protobuf@google@@QAEXPAVMessage@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_object$ = 8						; size = 4
??$Own@VMessage@protobuf@google@@@Arena@protobuf@google@@QAEXPAVMessage@12@@Z PROC ; google::protobuf::Arena::Own<google::protobuf::Message>, COMDAT
; _this$ = ecx

; 477  :   void Own(T* object) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 832  :     if (object != NULL) {

  00007	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000b	74 11		 je	 SHORT $LN1@Own

; 833  :       AddListNode(object, &internal::arena_delete_object< ::google::protobuf::Message >);

  0000d	68 00 00 00 00	 push	 OFFSET ??$arena_delete_object@VMessage@protobuf@google@@@internal@protobuf@google@@YAXPAX@Z ; google::protobuf::internal::arena_delete_object<google::protobuf::Message>
  00012	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?AddListNode@Arena@protobuf@google@@AAEXPAXP6AX0@Z@Z ; google::protobuf::Arena::AddListNode
$LN1@Own:

; 478  :     OwnInternal(object, google::protobuf::internal::is_convertible<T*, ::google::protobuf::Message*>());
; 479  :   }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$Own@VMessage@protobuf@google@@@Arena@protobuf@google@@QAEXPAVMessage@12@@Z ENDP ; google::protobuf::Arena::Own<google::protobuf::Message>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ??_GMessage@protobuf@google@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMessage@protobuf@google@@UAEPAXI@Z PROC		; google::protobuf::Message::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7MessageLite@protobuf@google@@6B@
  00019	8b 55 08	 mov	 edx, DWORD PTR ___flags$[ebp]
  0001c	83 e2 01	 and	 edx, 1
  0001f	74 0e		 je	 SHORT $LN2@scalar
  00021	6a 04		 push	 4
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GMessage@protobuf@google@@UAEPAXI@Z ENDP		; google::protobuf::Message::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
;	COMDAT ?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ PROC ; google::protobuf::Message::GetReflection, COMDAT
; _this$ = ecx

; 331  :   virtual const Reflection* GetReflection() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 332  :     return GetMetadata().reflection;

  00009	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00018	ff d0		 call	 eax
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 333  :   }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?GetReflection@Message@protobuf@google@@UBEPBVReflection@23@XZ ENDP ; google::protobuf::Message::GetReflection
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
;	COMDAT ?New@Message@protobuf@google@@UBEPAV123@PAVArena@23@@Z
_TEXT	SEGMENT
_message$ = -8						; size = 4
_this$ = -4						; size = 4
_arena$ = 8						; size = 4
?New@Message@protobuf@google@@UBEPAV123@PAVArena@23@@Z PROC ; google::protobuf::Message::New, COMDAT
; _this$ = ecx

; 194  :   virtual Message* New(::google::protobuf::Arena* arena) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 195  :     Message* message = New();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00014	ff d0		 call	 eax
  00016	89 45 f8	 mov	 DWORD PTR _message$[ebp], eax

; 196  :     if (arena != NULL) {

  00019	83 7d 08 00	 cmp	 DWORD PTR _arena$[ebp], 0
  0001d	74 0c		 je	 SHORT $LN2@New

; 197  :       arena->Own(message);

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _message$[ebp]
  00022	51		 push	 ecx
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  00026	e8 00 00 00 00	 call	 ??$Own@VMessage@protobuf@google@@@Arena@protobuf@google@@QAEXPAVMessage@12@@Z ; google::protobuf::Arena::Own<google::protobuf::Message>
$LN2@New:

; 198  :     }
; 199  :     return message;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _message$[ebp]

; 200  :   }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?New@Message@protobuf@google@@UBEPAV123@PAVArena@23@@Z ENDP ; google::protobuf::Message::New
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
;	COMDAT ??1Message@protobuf@google@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Message@protobuf@google@@UAE@XZ PROC			; google::protobuf::Message::~Message, COMDAT
; _this$ = ecx

; 182  :   virtual ~Message() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Message@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 86   :   virtual ~MessageLite() {}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 182  :   virtual ~Message() {}

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1Message@protobuf@google@@UAE@XZ ENDP			; google::protobuf::Message::~Message
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h
;	COMDAT ??0Message@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Message@protobuf@google@@QAE@XZ PROC			; google::protobuf::Message::Message, COMDAT
; _this$ = ecx

; 181  :   inline Message() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h

; 85   :   inline MessageLite() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message.h

; 181  :   inline Message() {}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7Message@protobuf@google@@6B@
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0Message@protobuf@google@@QAE@XZ ENDP			; google::protobuf::Message::Message
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ??_GMessageLite@protobuf@google@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMessageLite@protobuf@google@@UAEPAXI@Z PROC		; google::protobuf::MessageLite::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 86   :   virtual ~MessageLite() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___flags$[ebp]
  00013	83 e1 01	 and	 ecx, 1
  00016	74 0e		 je	 SHORT $LN2@scalar
  00018	6a 04		 push	 4
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00023	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??_GMessageLite@protobuf@google@@UAEPAXI@Z ENDP		; google::protobuf::MessageLite::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_target$ = 8						; size = 4
?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z PROC ; google::protobuf::MessageLite::SerializeWithCachedSizesToArray, COMDAT
; _this$ = ecx

; 265  :   virtual uint8* SerializeWithCachedSizesToArray(uint8* target) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 266  :     return InternalSerializeWithCachedSizesToArray(false, target);

  00007	8b 45 08	 mov	 eax, DWORD PTR _target$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00018	ff d0		 call	 eax

; 267  :   }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?SerializeWithCachedSizesToArray@MessageLite@protobuf@google@@UBEPAEPAE@Z ENDP ; google::protobuf::MessageLite::SerializeWithCachedSizesToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ?ByteSize@MessageLite@protobuf@google@@QBEHXZ
_TEXT	SEGMENT
tv85 = -80						; size = 4
tv88 = -76						; size = 4
_result$ = -72						; size = 4
_this$ = -68						; size = 4
$T2 = -61						; size = 1
$T3 = -60						; size = 4
$T4 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ByteSize@MessageLite@protobuf@google@@QBEHXZ PROC	; google::protobuf::MessageLite::ByteSize, COMDAT
; _this$ = ecx

; 251  :   int ByteSize() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ByteSize@MessageLite@protobuf@google@@QBEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 252  :     size_t result = ByteSizeLong();

  00032	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0003d	ff d0		 call	 eax
  0003f	89 45 b8	 mov	 DWORD PTR _result$[ebp], eax

; 253  :     GOOGLE_DCHECK_LE(result, static_cast<size_t>(INT_MAX));

  00042	81 7d b8 ff ff
	ff 7f		 cmp	 DWORD PTR _result$[ebp], 2147483647 ; 7fffffffH
  00049	77 02		 ja	 SHORT $LN3@ByteSize
  0004b	eb 43		 jmp	 SHORT $LN4@ByteSize
$LN3@ByteSize:
  0004d	68 fd 00 00 00	 push	 253			; 000000fdH
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@MGPCODI@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@
  00057	6a 03		 push	 3
  00059	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  0005c	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  00061	89 45 b4	 mov	 DWORD PTR tv88[ebp], eax
  00064	8b 4d b4	 mov	 ecx, DWORD PTR tv88[ebp]
  00067	89 4d b0	 mov	 DWORD PTR tv85[ebp], ecx
  0006a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00071	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00074	83 ca 01	 or	 edx, 1
  00077	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@HCOJOCJH@CHECK?5failed?3?5?$CIresult?$CJ?5?$DM?$DN?5?$CIstat@
  0007f	8b 4d b0	 mov	 ecx, DWORD PTR tv85[ebp]
  00082	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00087	50		 push	 eax
  00088	8d 4d c3	 lea	 ecx, DWORD PTR $T2[ebp]
  0008b	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN4@ByteSize:
  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  0009a	83 e0 01	 and	 eax, 1
  0009d	74 0c		 je	 SHORT $LN7@ByteSize
  0009f	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  000a3	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  000a6	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN7@ByteSize:

; 254  :     return static_cast<int>(result);

  000ab	8b 45 b8	 mov	 eax, DWORD PTR _result$[ebp]

; 255  :   }

  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b8	59		 pop	 ecx
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bc	33 cd		 xor	 ecx, ebp
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ByteSize@MessageLite@protobuf@google@@QBEHXZ$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@ByteSize
  0000c	83 65 c4 fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN6@ByteSize:
  00018	c3		 ret	 0
__ehhandler$?ByteSize@MessageLite@protobuf@google@@QBEHXZ:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ByteSize@MessageLite@protobuf@google@@QBEHXZ
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ByteSize@MessageLite@protobuf@google@@QBEHXZ ENDP	; google::protobuf::MessageLite::ByteSize
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ PROC ; google::protobuf::MessageLite::GetMaybeArenaPointer, COMDAT
; _this$ = ecx

; 116  :   virtual void* GetMaybeArenaPointer() const { return GetArena(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00012	ff d0		 call	 eax
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?GetMaybeArenaPointer@MessageLite@protobuf@google@@UBEPAXXZ ENDP ; google::protobuf::MessageLite::GetMaybeArenaPointer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ PROC ; google::protobuf::MessageLite::GetArena, COMDAT
; _this$ = ecx

; 106  :   virtual ::google::protobuf::Arena* GetArena() const { return NULL; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?GetArena@MessageLite@protobuf@google@@UBEPAVArena@23@XZ ENDP ; google::protobuf::MessageLite::GetArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ??1MessageLite@protobuf@google@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1MessageLite@protobuf@google@@UAE@XZ PROC		; google::protobuf::MessageLite::~MessageLite, COMDAT
; _this$ = ecx

; 86   :   virtual ~MessageLite() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1MessageLite@protobuf@google@@UAE@XZ ENDP		; google::protobuf::MessageLite::~MessageLite
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\message_lite.h
;	COMDAT ??0MessageLite@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MessageLite@protobuf@google@@QAE@XZ PROC		; google::protobuf::MessageLite::MessageLite, COMDAT
; _this$ = ecx

; 85   :   inline MessageLite() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7MessageLite@protobuf@google@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0MessageLite@protobuf@google@@QAE@XZ ENDP		; google::protobuf::MessageLite::MessageLite
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ PROC ; google::protobuf::internal::InternalMetadataWithArena::~InternalMetadataWithArena, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1InternalMetadataWithArena@internal@protobuf@google@@QAE@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArena::~InternalMetadataWithArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?default_instance@InternalMetadataWithArena@internal@protobuf@google@@SAABVUnknownFieldSet@34@XZ
_TEXT	SEGMENT
?default_instance@InternalMetadataWithArena@internal@protobuf@google@@SAABVUnknownFieldSet@34@XZ PROC ; google::protobuf::internal::InternalMetadataWithArena::default_instance, COMDAT

; 189  :   static const UnknownFieldSet& default_instance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 190  :     return *UnknownFieldSet::default_instance();

  00003	e8 00 00 00 00	 call	 ?default_instance@UnknownFieldSet@protobuf@google@@SAPBV123@XZ ; google::protobuf::UnknownFieldSet::default_instance

; 191  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?default_instance@InternalMetadataWithArena@internal@protobuf@google@@SAABVUnknownFieldSet@34@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArena::default_instance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?DoMergeFrom@InternalMetadataWithArena@internal@protobuf@google@@QAEXABVUnknownFieldSet@34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?DoMergeFrom@InternalMetadataWithArena@internal@protobuf@google@@QAEXABVUnknownFieldSet@34@@Z PROC ; google::protobuf::internal::InternalMetadataWithArena::DoMergeFrom, COMDAT
; _this$ = ecx

; 181  :   void DoMergeFrom(const UnknownFieldSet& other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  :     mutable_unknown_fields()->MergeFrom(other);

  00007	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields
  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 ?MergeFrom@UnknownFieldSet@protobuf@google@@QAEXABV123@@Z ; google::protobuf::UnknownFieldSet::MergeFrom

; 183  :   }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?DoMergeFrom@InternalMetadataWithArena@internal@protobuf@google@@QAEXABVUnknownFieldSet@34@@Z ENDP ; google::protobuf::internal::InternalMetadataWithArena::DoMergeFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ??0InternalMetadataWithArena@internal@protobuf@google@@QAE@PAVArena@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_arena$ = 8						; size = 4
??0InternalMetadataWithArena@internal@protobuf@google@@QAE@PAVArena@23@@Z PROC ; google::protobuf::internal::InternalMetadataWithArena::InternalMetadataWithArena, COMDAT
; _this$ = ecx

; 174  :   explicit InternalMetadataWithArena(Arena* arena)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 175  :       : InternalMetadataWithArenaBase(arena) {}

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0InternalMetadataWithArena@internal@protobuf@google@@QAE@PAVArena@23@@Z ENDP ; google::protobuf::internal::InternalMetadataWithArena::InternalMetadataWithArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?mutable_unknown_fields_slow@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@AAEPAVUnknownFieldSet@34@XZ
_TEXT	SEGMENT
tv84 = -16						; size = 4
_container$ = -12					; size = 4
_my_arena$ = -8						; size = 4
_this$ = -4						; size = 4
?mutable_unknown_fields_slow@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@AAEPAVUnknownFieldSet@34@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields_slow, COMDAT
; _this$ = ecx

; 159  :   GOOGLE_ATTRIBUTE_NOINLINE T* mutable_unknown_fields_slow() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN9@mutable_un
  00013	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN7@mutable_un
$LN9@mutable_un:
  0001c	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN7@mutable_un:

; 91   :     if (GOOGLE_PREDICT_FALSE(have_unknown_fields())) {

  00023	0f b6 55 f0	 movzx	 edx, BYTE PTR tv84[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 12		 je	 SHORT $LN15@mutable_un

; 149  :     return reinterpret_cast<U*>(

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 92   :       return PtrValue<Container>()->arena;

  00033	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00036	89 55 f8	 mov	 DWORD PTR _my_arena$[ebp], edx
  00039	eb 0d		 jmp	 SHORT $LN3@mutable_un

; 93   :     } else {

  0003b	eb 0b		 jmp	 SHORT $LN3@mutable_un
$LN15@mutable_un:

; 149  :     return reinterpret_cast<U*>(

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 94   :       return PtrValue<Arena>();

  00045	89 4d f8	 mov	 DWORD PTR _my_arena$[ebp], ecx
$LN3@mutable_un:

; 160  :     Arena* my_arena = arena();
; 161  :     Container* container = Arena::Create<Container>(my_arena);

  00048	8b 55 f8	 mov	 edx, DWORD PTR _my_arena$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$Create@UContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@@Arena@protobuf@google@@SAPAUContainer@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@12@PAV012@@Z ; google::protobuf::Arena::Create<google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::Container>
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f4	 mov	 DWORD PTR _container$[ebp], eax

; 162  :     ptr_ = reinterpret_cast<void*>(

  00057	8b 45 f4	 mov	 eax, DWORD PTR _container$[ebp]
  0005a	83 c8 01	 or	 eax, 1
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 163  :         reinterpret_cast<intptr_t>(container) | kTagContainer);
; 164  :     container->arena = my_arena;

  00062	8b 55 f4	 mov	 edx, DWORD PTR _container$[ebp]
  00065	8b 45 f8	 mov	 eax, DWORD PTR _my_arena$[ebp]
  00068	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 165  :     return &(container->unknown_fields);

  0006b	8b 45 f4	 mov	 eax, DWORD PTR _container$[ebp]

; 166  :   }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?mutable_unknown_fields_slow@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@AAEPAVUnknownFieldSet@34@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields_slow
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?PtrTag@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?PtrTag@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEHXZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrTag, COMDAT
; _this$ = ecx

; 144  :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE int PtrTag() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	83 e0 01	 and	 eax, 1

; 146  :   }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?PtrTag@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@ABEHXZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::PtrTag
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T1 = -12						; size = 4
tv132 = -8						; size = 4
tv87 = -4						; size = 4
_other$ = 8						; size = 4
?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom, COMDAT
; _this$ = ecx

; 114  :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE void MergeFrom(const Derived& other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN6@MergeFrom
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN4@MergeFrom
$LN6@MergeFrom:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN4@MergeFrom:

; 115  :     if (other.have_unknown_fields()) {

  00023	0f b6 55 fc	 movzx	 edx, BYTE PTR tv87[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 4c		 je	 SHORT $LN1@MergeFrom

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00033	74 09		 je	 SHORT $LN16@MergeFrom
  00035	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv132[ebp], 1
  0003c	eb 07		 jmp	 SHORT $LN14@MergeFrom
$LN16@MergeFrom:
  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv132[ebp], 0
$LN14@MergeFrom:

; 75   :     if (GOOGLE_PREDICT_FALSE(have_unknown_fields())) {

  00045	0f b6 55 f8	 movzx	 edx, BYTE PTR tv132[ebp]
  00049	85 d2		 test	 edx, edx
  0004b	74 0f		 je	 SHORT $LN22@MergeFrom

; 149  :     return reinterpret_cast<U*>(

  0004d	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 76   :       return PtrValue<Container>()->unknown_fields;

  00055	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  00058	eb 0a		 jmp	 SHORT $LN10@MergeFrom

; 77   :     } else {

  0005a	eb 08		 jmp	 SHORT $LN10@MergeFrom
$LN22@MergeFrom:

; 190  :     return *UnknownFieldSet::default_instance();

  0005c	e8 00 00 00 00	 call	 ?default_instance@UnknownFieldSet@protobuf@google@@SAPBV123@XZ ; google::protobuf::UnknownFieldSet::default_instance

; 78   :       return Derived::default_instance();

  00061	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN10@MergeFrom:

; 182  :     mutable_unknown_fields()->MergeFrom(other);

  00064	8b 55 f4	 mov	 edx, DWORD PTR $T1[ebp]
  00067	52		 push	 edx
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields
  00070	8b c8		 mov	 ecx, eax
  00072	e8 00 00 00 00	 call	 ?MergeFrom@UnknownFieldSet@protobuf@google@@QAEXABV123@@Z ; google::protobuf::UnknownFieldSet::MergeFrom
$LN1@MergeFrom:

; 116  :       static_cast<Derived*>(this)->DoMergeFrom(other.unknown_fields());
; 117  :     }
; 118  :   }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
?MergeFrom@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEXABVInternalMetadataWithArena@234@@Z ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::MergeFrom
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?have_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?have_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBE_NXZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::have_unknown_fields, COMDAT
; _this$ = ecx

; 98   :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE bool have_unknown_fields() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN3@have_unkno
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN4@have_unkno
$LN3@have_unkno:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@have_unkno:
  00023	8a 45 fc	 mov	 al, BYTE PTR tv67[ebp]

; 100  :   }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?have_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBE_NXZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::have_unknown_fields
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?arena@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEPAVArena@34@XZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?arena@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEPAVArena@34@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::arena, COMDAT
; _this$ = ecx

; 90   :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE Arena* arena() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN7@arena
  00013	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN5@arena
$LN7@arena:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@arena:

; 91   :     if (GOOGLE_PREDICT_FALSE(have_unknown_fields())) {

  00023	0f b6 55 f8	 movzx	 edx, BYTE PTR tv76[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 0f		 je	 SHORT $LN13@arena

; 149  :     return reinterpret_cast<U*>(

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 92   :       return PtrValue<Container>()->arena;

  00033	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00036	eb 0a		 jmp	 SHORT $LN1@arena

; 93   :     } else {

  00038	eb 08		 jmp	 SHORT $LN1@arena
$LN13@arena:

; 149  :     return reinterpret_cast<U*>(

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 02		 mov	 eax, DWORD PTR [edx]
  0003f	83 e0 fe	 and	 eax, -2			; fffffffeH
$LN1@arena:

; 94   :       return PtrValue<Arena>();
; 95   :     }
; 96   :   }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?arena@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEPAVArena@34@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::arena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields, COMDAT
; _this$ = ecx

; 82   :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE T* mutable_unknown_fields() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN7@mutable_un
  00013	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN5@mutable_un
$LN7@mutable_un:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@mutable_un:

; 83   :     if (GOOGLE_PREDICT_TRUE(have_unknown_fields())) {

  00023	0f b6 55 f8	 movzx	 edx, BYTE PTR tv76[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 0c		 je	 SHORT $LN2@mutable_un

; 149  :     return reinterpret_cast<U*>(

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	83 e0 fe	 and	 eax, -2			; fffffffeH

; 84   :       return &PtrValue<Container>()->unknown_fields;

  00033	eb 0a		 jmp	 SHORT $LN1@mutable_un

; 85   :     } else {

  00035	eb 08		 jmp	 SHORT $LN1@mutable_un
$LN2@mutable_un:

; 86   :       return mutable_unknown_fields_slow();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?mutable_unknown_fields_slow@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@AAEPAVUnknownFieldSet@34@XZ ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields_slow
$LN1@mutable_un:

; 87   :     }
; 88   :   }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?mutable_unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAEPAVUnknownFieldSet@34@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::mutable_unknown_fields
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ?unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEABVUnknownFieldSet@34@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv75 = -4						; size = 4
?unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEABVUnknownFieldSet@34@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::unknown_fields, COMDAT
; _this$ = ecx

; 74   :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE const T& unknown_fields() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00011	74 09		 je	 SHORT $LN7@unknown_fi
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN5@unknown_fi
$LN7@unknown_fi:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN5@unknown_fi:

; 75   :     if (GOOGLE_PREDICT_FALSE(have_unknown_fields())) {

  00023	0f b6 55 fc	 movzx	 edx, BYTE PTR tv75[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 0c		 je	 SHORT $LN13@unknown_fi

; 149  :     return reinterpret_cast<U*>(

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	83 e0 fe	 and	 eax, -2			; fffffffeH

; 76   :       return PtrValue<Container>()->unknown_fields;

  00033	eb 07		 jmp	 SHORT $LN1@unknown_fi

; 77   :     } else {

  00035	eb 05		 jmp	 SHORT $LN1@unknown_fi
$LN13@unknown_fi:

; 190  :     return *UnknownFieldSet::default_instance();

  00037	e8 00 00 00 00	 call	 ?default_instance@UnknownFieldSet@protobuf@google@@SAPBV123@XZ ; google::protobuf::UnknownFieldSet::default_instance
$LN1@unknown_fi:

; 78   :       return Derived::default_instance();
; 79   :     }
; 80   :   }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?unknown_fields@?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QBEABVUnknownFieldSet@34@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::unknown_fields
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
tv77 = -40						; size = 4
_this$4 = -36						; size = 4
$T5 = -32						; size = 4
tv128 = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>, COMDAT
; _this$ = ecx

; 67   :   ~InternalMetadataWithArenaBase() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00030	74 09		 je	 SHORT $LN8@InternalMe
  00032	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00039	eb 07		 jmp	 SHORT $LN6@InternalMe
$LN8@InternalMe:
  0003b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN6@InternalMe:

; 68   :     if (have_unknown_fields() && arena() == NULL) {

  00042	0f b6 55 e8	 movzx	 edx, BYTE PTR tv82[ebp]
  00046	85 d2		 test	 edx, edx
  00048	0f 84 ad 00 00
	00		 je	 $LN2@InternalMe

; 145  :     return reinterpret_cast<intptr_t>(ptr_) & kPtrTagMask;

  0004e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	83 e1 01	 and	 ecx, 1

; 99   :     return PtrTag() == kTagContainer;

  00056	74 09		 je	 SHORT $LN18@InternalMe
  00058	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  0005f	eb 07		 jmp	 SHORT $LN16@InternalMe
$LN18@InternalMe:
  00061	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$LN16@InternalMe:

; 91   :     if (GOOGLE_PREDICT_FALSE(have_unknown_fields())) {

  00068	0f b6 55 e4	 movzx	 edx, BYTE PTR tv128[ebp]
  0006c	85 d2		 test	 edx, edx
  0006e	74 12		 je	 SHORT $LN24@InternalMe

; 149  :     return reinterpret_cast<U*>(

  00070	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 92   :       return PtrValue<Container>()->arena;

  00078	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007b	89 55 e0	 mov	 DWORD PTR $T5[ebp], edx
  0007e	eb 0d		 jmp	 SHORT $LN12@InternalMe

; 93   :     } else {

  00080	eb 0b		 jmp	 SHORT $LN12@InternalMe
$LN24@InternalMe:

; 149  :     return reinterpret_cast<U*>(

  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 94   :       return PtrValue<Arena>();

  0008a	89 4d e0	 mov	 DWORD PTR $T5[ebp], ecx
$LN12@InternalMe:

; 68   :     if (have_unknown_fields() && arena() == NULL) {

  0008d	83 7d e0 00	 cmp	 DWORD PTR $T5[ebp], 0
  00091	75 68		 jne	 SHORT $LN2@InternalMe

; 149  :     return reinterpret_cast<U*>(

  00093	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00096	8b 02		 mov	 eax, DWORD PTR [edx]
  00098	83 e0 fe	 and	 eax, -2			; fffffffeH

; 69   :       delete PtrValue<Container>();

  0009b	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0009e	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  000a1	89 4d ec	 mov	 DWORD PTR $T6[ebp], ecx
  000a4	83 7d ec 00	 cmp	 DWORD PTR $T6[ebp], 0
  000a8	74 4a		 je	 SHORT $LN4@InternalMe
  000aa	8b 55 d0	 mov	 edx, DWORD PTR $T2[ebp]
  000ad	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  000b0	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  000b3	89 45 dc	 mov	 DWORD PTR _this$4[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  000b6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 259  :   if (fields_ != NULL) {

  000bd	8b 4d dc	 mov	 ecx, DWORD PTR _this$4[ebp]
  000c0	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000c3	74 08		 je	 SHORT $LN35@InternalMe

; 260  :     ClearFallback();

  000c5	8b 4d dc	 mov	 ecx, DWORD PTR _this$4[ebp]
  000c8	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN35@InternalMe:

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  000cd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	ba 01 00 00 00	 mov	 edx, 1
  000d9	83 e2 01	 and	 edx, 1
  000dc	74 0e		 je	 SHORT $LN29@InternalMe
  000de	6a 08		 push	 8
  000e0	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e9	83 c4 08	 add	 esp, 8
$LN29@InternalMe:
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR $T6[ebp]
  000ef	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h

; 69   :       delete PtrValue<Container>();

  000f2	eb 07		 jmp	 SHORT $LN2@InternalMe
$LN4@InternalMe:
  000f4	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN2@InternalMe:

; 70   :     }
; 71   :     ptr_ = NULL;

  000fb	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000fe	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 72   :   }

  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@XZ ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::~InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\metadata.h
;	COMDAT ??0?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@PAVArena@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_arena$ = 8						; size = 4
??0?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@PAVArena@23@@Z PROC ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>, COMDAT
; _this$ = ecx

; 65   :   explicit InternalMetadataWithArenaBase(Arena* arena) : ptr_(arena) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _arena$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$InternalMetadataWithArenaBase@VUnknownFieldSet@protobuf@google@@VInternalMetadataWithArena@internal@23@@internal@protobuf@google@@QAE@PAVArena@23@@Z ENDP ; google::protobuf::internal::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>::InternalMetadataWithArenaBase<google::protobuf::UnknownFieldSet,google::protobuf::internal::InternalMetadataWithArena>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ?Clear@UnknownFieldSet@protobuf@google@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@UnknownFieldSet@protobuf@google@@QAEXXZ PROC	; google::protobuf::UnknownFieldSet::Clear, COMDAT
; _this$ = ecx

; 258  : inline void UnknownFieldSet::Clear() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 259  :   if (fields_ != NULL) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 08		 je	 SHORT $LN1@Clear

; 260  :     ClearFallback();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN1@Clear:

; 261  :   }
; 262  : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?Clear@UnknownFieldSet@protobuf@google@@QAEXXZ ENDP	; google::protobuf::UnknownFieldSet::Clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ??1UnknownFieldSet@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1UnknownFieldSet@protobuf@google@@QAE@XZ PROC		; google::protobuf::UnknownFieldSet::~UnknownFieldSet, COMDAT
; _this$ = ecx

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1UnknownFieldSet@protobuf@google@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 259  :   if (fields_ != NULL) {

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	74 08		 je	 SHORT $LN2@UnknownFie

; 260  :     ClearFallback();

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?ClearFallback@UnknownFieldSet@protobuf@google@@AAEXXZ ; google::protobuf::UnknownFieldSet::ClearFallback
$LN2@UnknownFie:

; 254  : inline UnknownFieldSet::~UnknownFieldSet() { Clear(); }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1UnknownFieldSet@protobuf@google@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1UnknownFieldSet@protobuf@google@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1UnknownFieldSet@protobuf@google@@QAE@XZ ENDP		; google::protobuf::UnknownFieldSet::~UnknownFieldSet
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\unknown_field_set.h
;	COMDAT ??0UnknownFieldSet@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0UnknownFieldSet@protobuf@google@@QAE@XZ PROC		; google::protobuf::UnknownFieldSet::UnknownFieldSet, COMDAT
; _this$ = ecx

; 252  : inline UnknownFieldSet::UnknownFieldSet() : fields_(NULL) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0UnknownFieldSet@protobuf@google@@QAE@XZ ENDP		; google::protobuf::UnknownFieldSet::UnknownFieldSet
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?ToCachedSize@internal@protobuf@google@@YAHI@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?ToCachedSize@internal@protobuf@google@@YAHI@Z PROC	; google::protobuf::internal::ToCachedSize, COMDAT

; 163  : inline int ToCachedSize(size_t size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 164  :   return static_cast<int>(size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]

; 165  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?ToCachedSize@internal@protobuf@google@@YAHI@Z ENDP	; google::protobuf::internal::ToCachedSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?get@?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; google::protobuf::internal::ExplicitlyConstructed<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get, COMDAT
; _this$ = ecx

; 106  :       get() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 107  :     return reinterpret_cast<const T&>(union_);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 108  :   }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?get@?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; google::protobuf::internal::ExplicitlyConstructed<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::get
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\generated_message_util.h
;	COMDAT ?GetEmptyStringAlreadyInited@internal@protobuf@google@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?GetEmptyStringAlreadyInited@internal@protobuf@google@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; google::protobuf::internal::GetEmptyStringAlreadyInited, COMDAT

; 133  : LIBPROTOBUF_EXPORT inline const ::std::string& GetEmptyStringAlreadyInited() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 134  :   return fixed_address_empty_string.get();

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string

; 135  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?GetEmptyStringAlreadyInited@internal@protobuf@google@@YAABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; google::protobuf::internal::GetEmptyStringAlreadyInited
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\once.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\atomicops_internals_x86_msvc.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\once.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\callback.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\once.h
;	COMDAT ?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z
_TEXT	SEGMENT
_func$2 = -32						; size = 12
_value$3 = -20						; size = 4
_ptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_once$ = 8						; size = 4
_init_func$ = 12					; size = 4
?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z PROC	; google::protobuf::GoogleOnceInit, COMDAT

; 125  : inline void GoogleOnceInit(ProtobufOnceType* once, void (*init_func)()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 126  :   if (internal::Acquire_Load(once) != ONCE_STATE_DONE) {

  00025	8b 45 08	 mov	 eax, DWORD PTR _once$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR _ptr$[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\atomicops_internals_x86_msvc.h

; 80   :   Atomic32 value = *ptr;

  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	89 55 ec	 mov	 DWORD PTR _value$3[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\once.h

; 126  :   if (internal::Acquire_Load(once) != ONCE_STATE_DONE) {

  00033	83 7d ec 02	 cmp	 DWORD PTR _value$3[ebp], 2
  00037	74 3e		 je	 SHORT $LN1@GoogleOnce
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\callback.h

; 72   :   Closure() {}

  00039	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _func$2[ebp], OFFSET ??_7Closure@protobuf@google@@6B@

; 124  :     : function_(function), self_deleting_(self_deleting) {}

  00040	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _func$2[ebp], OFFSET ??_7FunctionClosure0@internal@protobuf@google@@6B@
  00047	8b 45 0c	 mov	 eax, DWORD PTR _init_func$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR _func$2[ebp+4], eax
  0004d	c6 45 e8 00	 mov	 BYTE PTR _func$2[ebp+8], 0
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\once.h

; 127  :     internal::FunctionClosure0 func(init_func, false);

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 128  :     GoogleOnceInitImpl(once, &func);

  00058	8d 4d e0	 lea	 ecx, DWORD PTR _func$2[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 08	 mov	 edx, DWORD PTR _once$[ebp]
  0005f	52		 push	 edx
  00060	e8 00 00 00 00	 call	 ?GoogleOnceInitImpl@protobuf@google@@YAXPAHPAVClosure@12@@Z ; google::protobuf::GoogleOnceInitImpl
  00065	83 c4 08	 add	 esp, 8

; 129  :   }

  00068	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006f	8d 4d e0	 lea	 ecx, DWORD PTR _func$2[ebp]
  00072	e8 00 00 00 00	 call	 ??1FunctionClosure0@internal@protobuf@google@@UAE@XZ ; google::protobuf::internal::FunctionClosure0::~FunctionClosure0
$LN1@GoogleOnce:

; 130  : }

  00077	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00081	59		 pop	 ecx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _func$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1FunctionClosure0@internal@protobuf@google@@UAE@XZ ; google::protobuf::internal::FunctionClosure0::~FunctionClosure0
__ehhandler$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GoogleOnceInit@protobuf@google@@YAXPAHP6AXXZ@Z ENDP	; google::protobuf::GoogleOnceInit
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Tmp$ = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::swap<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f4	 mov	 DWORD PTR __Tmp$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@X@std@@YAXAAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::swap<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 4
_this$ = -84						; size = 4
tv94 = -80						; size = 4
tv152 = -76						; size = 4
tv90 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -61						; size = 1
$T5 = -60						; size = 4
$T6 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_initial_value$ = 8					; size = 4
?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena, COMDAT
; _this$ = ecx

; 302  :   GOOGLE_ATTRIBUTE_NOINLINE void CreateInstanceNoArena(const ::std::string* initial_value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 303  :     GOOGLE_DCHECK(initial_value != NULL);

  00032	83 7d 08 00	 cmp	 DWORD PTR _initial_value$[ebp], 0
  00036	74 02		 je	 SHORT $LN3@CreateInst
  00038	eb 43		 jmp	 SHORT $LN4@CreateInst
$LN3@CreateInst:
  0003a	68 2f 01 00 00	 push	 303			; 0000012fH
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0FL@GKGAFMDK@g?3?2?M?x?$LK?$PM?2?$LP?$KK?$LH?$KC?$LF?D?D?$KD?$LP?i?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD?D@
  00044	6a 03		 push	 3
  00046	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  00049	e8 00 00 00 00	 call	 ??0LogMessage@internal@protobuf@google@@QAE@W4LogLevel@23@PBDH@Z ; google::protobuf::internal::LogMessage::LogMessage
  0004e	89 45 b4	 mov	 DWORD PTR tv152[ebp], eax
  00051	8b 45 b4	 mov	 eax, DWORD PTR tv152[ebp]
  00054	89 45 b0	 mov	 DWORD PTR tv94[ebp], eax
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005e	8b 4d c4	 mov	 ecx, DWORD PTR $T5[ebp]
  00061	83 c9 01	 or	 ecx, 1
  00064	89 4d c4	 mov	 DWORD PTR $T5[ebp], ecx
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@ENGJCHJ@CHECK?5failed?3?5initial_value?5?$CB?$DN?5@
  0006c	8b 4d b0	 mov	 ecx, DWORD PTR tv94[ebp]
  0006f	e8 00 00 00 00	 call	 ??6LogMessage@internal@protobuf@google@@QAEAAV0123@PBD@Z ; google::protobuf::internal::LogMessage::operator<<
  00074	50		 push	 eax
  00075	8d 4d c3	 lea	 ecx, DWORD PTR $T4[ebp]
  00078	e8 00 00 00 00	 call	 ??4LogFinisher@internal@protobuf@google@@QAEXAAVLogMessage@123@@Z ; google::protobuf::internal::LogFinisher::operator=
$LN4@CreateInst:
  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b 55 c4	 mov	 edx, DWORD PTR $T5[ebp]
  00087	83 e2 01	 and	 edx, 1
  0008a	74 0c		 je	 SHORT $LN9@CreateInst
  0008c	83 65 c4 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00090	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  00093	e8 00 00 00 00	 call	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN9@CreateInst:

; 304  :     ptr_ = new ::std::string(*initial_value);

  00098	6a 1c		 push	 28			; 0000001cH
  0009a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009f	83 c4 04	 add	 esp, 4
  000a2	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
  000a5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ac	83 7d bc 00	 cmp	 DWORD PTR $T3[ebp], 0
  000b0	74 11		 je	 SHORT $LN5@CreateInst
  000b2	8b 45 08	 mov	 eax, DWORD PTR _initial_value$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d bc	 mov	 ecx, DWORD PTR $T3[ebp]
  000b9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000be	89 45 b8	 mov	 DWORD PTR tv90[ebp], eax
  000c1	eb 07		 jmp	 SHORT $LN6@CreateInst
$LN5@CreateInst:
  000c3	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN6@CreateInst:
  000ca	8b 4d b8	 mov	 ecx, DWORD PTR tv90[ebp]
  000cd	89 4d a8	 mov	 DWORD PTR $T2[ebp], ecx
  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d7	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  000da	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]
  000dd	89 02		 mov	 DWORD PTR [edx], eax

; 305  :   }

  000df	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e9	59		 pop	 ecx
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ed	33 cd		 xor	 ecx, ebp
  000ef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN8@CreateInst
  0000c	83 65 c4 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  00010	8d 4d c8	 lea	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1LogMessage@internal@protobuf@google@@QAE@XZ ; google::protobuf::internal::LogMessage::~LogMessage
$LN8@CreateInst:
  00018	c3		 ret	 0
__unwindfunclet$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00019	6a 1c		 push	 28			; 0000001cH
  0001b	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
  00027	c3		 ret	 0
__ehhandler$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?IsDefault@ArenaStringPtr@internal@protobuf@google@@QBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
_default_value$ = 8					; size = 4
?IsDefault@ArenaStringPtr@internal@protobuf@google@@QBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::ArenaStringPtr::IsDefault, COMDAT
; _this$ = ecx

; 287  :   inline bool IsDefault(const ::std::string* default_value) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 288  :     return ptr_ == default_value;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _default_value$[ebp]
  00011	75 09		 jne	 SHORT $LN3@IsDefault
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN4@IsDefault
$LN3@IsDefault:
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsDefault:
  00023	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 289  :   }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?IsDefault@ArenaStringPtr@internal@protobuf@google@@QBE_NPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::IsDefault
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_default_value$ = 8					; size = 4
?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::ArenaStringPtr::ClearToEmptyNoArena, COMDAT
; _this$ = ecx

; 262  :   inline void ClearToEmptyNoArena(const ::std::string* default_value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 263  :     if (ptr_ == default_value) {

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	3b 4d 08	 cmp	 ecx, DWORD PTR _default_value$[ebp]
  00030	75 02		 jne	 SHORT $LN2@ClearToEmp

; 264  :       // Nothing: already equal to default (which is the empty string).
; 265  :     } else {

  00032	eb 20		 jmp	 SHORT $LN1@ClearToEmp
$LN2@ClearToEmp:

; 266  :       ptr_->clear();

  00034	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2870 : 		{	// erase all

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2871 : 		_Eos(0);

  00043	6a 00		 push	 0
  00045	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@ClearToEmp:
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 268  :   }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ClearToEmptyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::ClearToEmptyNoArena
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
tv71 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_default_value$ = 8					; size = 4
?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::ArenaStringPtr::DestroyNoArena, COMDAT
; _this$ = ecx

; 256  :   inline void DestroyNoArena(const ::std::string* default_value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 257  :     if (ptr_ != default_value) {

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	3b 4d 08	 cmp	 ecx, DWORD PTR _default_value$[ebp]
  00030	74 63		 je	 SHORT $LN1@DestroyNoA

; 258  :       delete ptr_;

  00032	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  0003a	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  0003d	89 4d f0	 mov	 DWORD PTR $T4[ebp], ecx
  00040	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  00044	74 48		 je	 SHORT $LN4@DestroyNoA
  00046	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  00049	89 55 e8	 mov	 DWORD PTR tv71[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2460 : 		_Tidy_deallocate();

  00053	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00056	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0005b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1949 : 		_Free_proxy();

  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00062	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00067	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	83 e0 01	 and	 eax, 1
  00076	74 0e		 je	 SHORT $LN7@DestroyNoA
  00078	6a 1c		 push	 28			; 0000001cH
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00083	83 c4 08	 add	 esp, 8
$LN7@DestroyNoA:
  00086	8b 55 f0	 mov	 edx, DWORD PTR $T4[ebp]
  00089	89 55 e8	 mov	 DWORD PTR tv71[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 258  :       delete ptr_;

  0008c	eb 07		 jmp	 SHORT $LN1@DestroyNoA
$LN4@DestroyNoA:
  0008e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN1@DestroyNoA:

; 259  :     }
; 260  :   }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DestroyNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::DestroyNoArena
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?MutableNoArena@ArenaStringPtr@internal@protobuf@google@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV56@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_default_value$ = 8					; size = 4
?MutableNoArena@ArenaStringPtr@internal@protobuf@google@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV56@@Z PROC ; google::protobuf::internal::ArenaStringPtr::MutableNoArena, COMDAT
; _this$ = ecx

; 227  :   inline ::std::string* MutableNoArena(const ::std::string* default_value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  :     if (ptr_ == default_value) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	3b 4d 08	 cmp	 ecx, DWORD PTR _default_value$[ebp]
  0000f	75 0c		 jne	 SHORT $LN2@MutableNoA

; 229  :       CreateInstanceNoArena(default_value);

  00011	8b 55 08	 mov	 edx, DWORD PTR _default_value$[ebp]
  00014	52		 push	 edx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?CreateInstanceNoArena@ArenaStringPtr@internal@protobuf@google@@AAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; google::protobuf::internal::ArenaStringPtr::CreateInstanceNoArena
$LN2@MutableNoA:

; 230  :     }
; 231  :     return ptr_;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]

; 232  :   }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?MutableNoArena@ArenaStringPtr@internal@protobuf@google@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBV56@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::MutableNoArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?GetNoArena@ArenaStringPtr@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNoArena@ArenaStringPtr@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; google::protobuf::internal::ArenaStringPtr::GetNoArena, COMDAT
; _this$ = ecx

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetNoArena@ArenaStringPtr@internal@protobuf@google@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; google::protobuf::internal::ArenaStringPtr::GetNoArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?SetNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QAV56@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
tv81 = -16						; size = 4
$T3 = -12						; size = 4
tv89 = -8						; size = 4
_this$ = -4						; size = 4
_default_value$ = 8					; size = 4
_value$ = 12						; size = 4
?SetNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QAV56@@Z PROC ; google::protobuf::internal::ArenaStringPtr::SetNoArena, COMDAT
; _this$ = ecx

; 214  :   void SetNoArena(const ::std::string* default_value, ::std::string&& value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  :     return ptr_ == default_value;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	3b 4d 08	 cmp	 ecx, DWORD PTR _default_value$[ebp]
  00011	75 09		 jne	 SHORT $LN9@SetNoArena
  00013	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  0001a	eb 07		 jmp	 SHORT $LN7@SetNoArena
$LN9@SetNoArena:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN7@SetNoArena:

; 215  :     if (IsDefault(default_value)) {

  00023	0f b6 55 f8	 movzx	 edx, BYTE PTR tv89[ebp]
  00027	85 d2		 test	 edx, edx
  00029	74 3b		 je	 SHORT $LN2@SetNoArena

; 216  :       ptr_ = new ::std::string(std::move(value));

  0002b	6a 1c		 push	 28			; 0000001cH
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	83 c4 04	 add	 esp, 4
  00035	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  00038	83 7d f4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0003c	74 17		 je	 SHORT $LN5@SetNoArena
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00041	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 216  :       ptr_ = new ::std::string(std::move(value));

  00044	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00047	51		 push	 ecx
  00048	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00050	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  00053	eb 07		 jmp	 SHORT $LN6@SetNoArena
$LN5@SetNoArena:
  00055	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN6@SetNoArena:
  0005c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv81[ebp]
  00062	89 02		 mov	 DWORD PTR [edx], eax

; 217  :     } else {

  00064	eb 14		 jmp	 SHORT $LN1@SetNoArena
$LN2@SetNoArena:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00069	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 218  :       *ptr_ = std::move(value);

  0006c	8b 55 e8	 mov	 edx, DWORD PTR $T1[ebp]
  0006f	52		 push	 edx
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN1@SetNoArena:

; 219  :     }
; 220  :   }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
?SetNoArena@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$QAV56@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::SetNoArena
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?UnsafeSetDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_default_value$ = 8					; size = 4
?UnsafeSetDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; google::protobuf::internal::ArenaStringPtr::UnsafeSetDefault, COMDAT
; _this$ = ecx

; 191  :   inline void UnsafeSetDefault(const ::std::string* default_value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :     // Casting away 'const' is safe here: accessors ensure that ptr_ is only
; 193  :     // returned as a const if it is equal to default_value.
; 194  :     ptr_ = const_cast< ::std::string* >(default_value);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _default_value$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 195  :   }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?UnsafeSetDefault@ArenaStringPtr@internal@protobuf@google@@QAEXPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::UnsafeSetDefault
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
;	COMDAT ?Swap@ArenaStringPtr@internal@protobuf@google@@QAEXPAU1234@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Tmp$2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
__Left$ = -4						; size = 4
_other$ = 8						; size = 4
?Swap@ArenaStringPtr@internal@protobuf@google@@QAEXPAU1234@@Z PROC ; google::protobuf::internal::ArenaStringPtr::Swap, COMDAT
; _this$ = ecx

; 146  :   GOOGLE_ATTRIBUTE_ALWAYS_INLINE void Swap(ArenaStringPtr* other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 147  :     std::swap(ptr_, other->ptr_);

  00009	8b 45 08	 mov	 eax, DWORD PTR _other$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	89 4d fc	 mov	 DWORD PTR __Left$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00015	8b 55 fc	 mov	 edx, DWORD PTR __Left$[ebp]
  00018	89 55 f0	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00020	89 4d e8	 mov	 DWORD PTR __Tmp$2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00023	8b 55 f8	 mov	 edx, DWORD PTR __Right$[ebp]
  00026	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Left$[ebp]
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00033	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  00036	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  00039	8b 4d f8	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003c	8b 55 e4	 mov	 edx, DWORD PTR $T1[ebp]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	89 01		 mov	 DWORD PTR [ecx], eax
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 148  :   }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?Swap@ArenaStringPtr@internal@protobuf@google@@QAEXPAU1234@@Z ENDP ; google::protobuf::internal::ArenaStringPtr::Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\atomicops_internals_x86_msvc.h
;	COMDAT ?Acquire_Load@internal@protobuf@google@@YAHPDH@Z
_TEXT	SEGMENT
_value$ = -4						; size = 4
_ptr$ = 8						; size = 4
?Acquire_Load@internal@protobuf@google@@YAHPDH@Z PROC	; google::protobuf::internal::Acquire_Load, COMDAT

; 79   : inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 80   :   Atomic32 value = *ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR _value$[ebp], ecx

; 81   :   return value;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _value$[ebp]

; 82   : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?Acquire_Load@internal@protobuf@google@@YAHPDH@Z ENDP	; google::protobuf::internal::Acquire_Load
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z
_TEXT	SEGMENT
_kMax2ByteVarint$1 = -88				; size = 4
_kMax1ByteVarint$2 = -84				; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -60						; size = 4
$T9 = -56						; size = 4
$T10 = -52						; size = 4
$T11 = -48						; size = 4
$T12 = -44						; size = 4
$T13 = -40						; size = 4
$T14 = -36						; size = 4
_first_byte_or_zero$ = -32				; size = 4
tv155 = -28						; size = 4
_tag$ = -24						; size = 4
_tag$15 = -20						; size = 4
_tag$16 = -16						; size = 4
_this$ = -12						; size = 4
$T17 = -5						; size = 1
_at_or_below_cutoff$18 = -4				; size = 1
$T19 = -3						; size = 1
tv168 = -2						; size = 1
tv87 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_cutoff$ = 12						; size = 4
??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z PROC ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>, COMDAT
; _this$ = ecx

; 1065 :     uint32 cutoff) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1066 :   // In performance-sensitive code we can expect cutoff to be a compile-time
; 1067 :   // constant, and things like "cutoff >= kMax1ByteVarint" to be evaluated at
; 1068 :   // compile time.
; 1069 :   uint32 first_byte_or_zero = 0;

  00009	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _first_byte_or_zero$[ebp], 0

; 1070 :   if (GOOGLE_PREDICT_TRUE(buffer_ < buffer_end_)) {

  00010	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001b	0f 83 ae 01 00
	00		 jae	 $LN2@ReadTagWit

; 1071 :     // Hot case: buffer_ non_empty, buffer_[0] in [1, 128).
; 1072 :     // TODO(gpike): Is it worth rearranging this? E.g., if the number of fields
; 1073 :     // is large enough then is it better to check for the two-byte case first?
; 1074 :     first_byte_or_zero = buffer_[0];

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	6b c8 00	 imul	 ecx, eax, 0
  00029	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00032	89 4d e0	 mov	 DWORD PTR _first_byte_or_zero$[ebp], ecx

; 1075 :     if (static_cast<int8>(buffer_[0]) > 0) {

  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	6b c2 00	 imul	 eax, edx, 0
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	0f be 04 02	 movsx	 eax, BYTE PTR [edx+eax]
  00046	85 c0		 test	 eax, eax
  00048	0f 8e 88 00 00
	00		 jle	 $LN3@ReadTagWit

; 1076 :       const uint32 kMax1ByteVarint = 0x7f;

  0004e	c7 45 ac 7f 00
	00 00		 mov	 DWORD PTR _kMax1ByteVarint$2[ebp], 127 ; 0000007fH

; 1077 :       uint32 tag = buffer_[0];

  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	6b d1 00	 imul	 edx, ecx, 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00066	89 55 f0	 mov	 DWORD PTR _tag$16[ebp], edx

; 1078 :       if (update_last_tag) {

  00069	33 c0		 xor	 eax, eax
  0006b	74 09		 je	 SHORT $LN4@ReadTagWit

; 1079 :         last_tag_ = tag;

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	8b 55 f0	 mov	 edx, DWORD PTR _tag$16[ebp]
  00073	89 51 14	 mov	 DWORD PTR [ecx+20], edx
$LN4@ReadTagWit:

; 1333 :   buffer_ += amount;

  00076	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	83 c1 01	 add	 ecx, 1
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00081	89 0a		 mov	 DWORD PTR [edx], ecx

; 1082 :       return std::make_pair(tag, cutoff >= kMax1ByteVarint || tag <= cutoff);

  00083	83 7d 0c 7f	 cmp	 DWORD PTR _cutoff$[ebp], 127 ; 0000007fH
  00087	73 0e		 jae	 SHORT $LN9@ReadTagWit
  00089	8b 45 f0	 mov	 eax, DWORD PTR _tag$16[ebp]
  0008c	3b 45 0c	 cmp	 eax, DWORD PTR _cutoff$[ebp]
  0008f	76 06		 jbe	 SHORT $LN9@ReadTagWit
  00091	c6 45 ff 00	 mov	 BYTE PTR tv87[ebp], 0
  00095	eb 04		 jmp	 SHORT $LN10@ReadTagWit
$LN9@ReadTagWit:
  00097	c6 45 ff 01	 mov	 BYTE PTR tv87[ebp], 1
$LN10@ReadTagWit:
  0009b	8a 4d ff	 mov	 cl, BYTE PTR tv87[ebp]
  0009e	88 4d fd	 mov	 BYTE PTR $T19[ebp], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  000a1	8d 55 fd	 lea	 edx, DWORD PTR $T19[ebp]
  000a4	89 55 d4	 mov	 DWORD PTR $T12[ebp], edx
  000a7	8d 45 f0	 lea	 eax, DWORD PTR _tag$16[ebp]
  000aa	89 45 dc	 mov	 DWORD PTR $T14[ebp], eax
  000ad	8b 4d dc	 mov	 ecx, DWORD PTR $T14[ebp]
  000b0	89 4d d8	 mov	 DWORD PTR $T13[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  000b3	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  000b6	8b 45 d8	 mov	 eax, DWORD PTR $T13[ebp]
  000b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bb	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  000bd	8b 55 d4	 mov	 edx, DWORD PTR $T12[ebp]
  000c0	89 55 d0	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  000c3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c6	8b 4d d0	 mov	 ecx, DWORD PTR $T11[ebp]
  000c9	8a 11		 mov	 dl, BYTE PTR [ecx]
  000cb	88 50 04	 mov	 BYTE PTR [eax+4], dl
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1082 :       return std::make_pair(tag, cutoff >= kMax1ByteVarint || tag <= cutoff);

  000ce	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d1	e9 60 01 00 00	 jmp	 $LN1@ReadTagWit
$LN3@ReadTagWit:

; 1083 :     }
; 1084 :     // Other hot case: cutoff >= 0x80, buffer_ has at least two bytes available,
; 1085 :     // and tag is two bytes.  The latter is tested by bitwise-and-not of the
; 1086 :     // first byte and the second byte.
; 1087 :     if (cutoff >= 0x80 &&
; 1088 :         GOOGLE_PREDICT_TRUE(buffer_ + 1 < buffer_end_) &&

  000d6	81 7d 0c 80 00
	00 00		 cmp	 DWORD PTR _cutoff$[ebp], 128 ; 00000080H
  000dd	0f 82 ec 00 00
	00		 jb	 $LN2@ReadTagWit
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e8	83 c1 01	 add	 ecx, 1
  000eb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ee	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  000f1	0f 83 d8 00 00
	00		 jae	 $LN2@ReadTagWit
  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00102	8b 02		 mov	 eax, DWORD PTR [edx]
  00104	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00108	ba 01 00 00 00	 mov	 edx, 1
  0010d	c1 e2 00	 shl	 edx, 0
  00110	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	0f b6 14 10	 movzx	 edx, BYTE PTR [eax+edx]
  00119	f7 d2		 not	 edx
  0011b	23 ca		 and	 ecx, edx
  0011d	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00123	0f 8c a6 00 00
	00		 jl	 $LN2@ReadTagWit

; 1089 :         GOOGLE_PREDICT_TRUE((buffer_[0] & ~buffer_[1]) >= 0x80)) {
; 1090 :       const uint32 kMax2ByteVarint = (0x7f << 7) + 0x7f;

  00129	c7 45 a8 ff 3f
	00 00		 mov	 DWORD PTR _kMax2ByteVarint$1[ebp], 16383 ; 00003fffH

; 1091 :       uint32 tag = (1u << 7) * buffer_[1] + (buffer_[0] - 0x80);

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	c1 e0 00	 shl	 eax, 0
  00138	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013d	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  00141	c1 e0 07	 shl	 eax, 7
  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	6b d1 00	 imul	 edx, ecx, 0
  0014c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00151	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00155	8d 44 10 80	 lea	 eax, DWORD PTR [eax+edx-128]
  00159	89 45 ec	 mov	 DWORD PTR _tag$15[ebp], eax

; 1092 :       if (update_last_tag) {

  0015c	33 c9		 xor	 ecx, ecx
  0015e	74 09		 je	 SHORT $LN6@ReadTagWit

; 1093 :         last_tag_ = tag;

  00160	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00163	8b 45 ec	 mov	 eax, DWORD PTR _tag$15[ebp]
  00166	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN6@ReadTagWit:

; 1333 :   buffer_ += amount;

  00169	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016e	83 c2 02	 add	 edx, 2
  00171	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00174	89 10		 mov	 DWORD PTR [eax], edx

; 1094 :       }
; 1095 :       Advance(2);
; 1096 :       // It might make sense to test for tag == 0 now, but it is so rare that
; 1097 :       // that we don't bother.  A varint-encoded 0 should be one byte unless
; 1098 :       // the encoder lost its mind.  The second part of the return value of
; 1099 :       // this function is allowed to be either true or false if the tag is 0,
; 1100 :       // so we don't have to check for tag == 0.  We may need to check whether
; 1101 :       // it exceeds cutoff.
; 1102 :       bool at_or_below_cutoff = cutoff >= kMax2ByteVarint || tag <= cutoff;

  00176	81 7d 0c ff 3f
	00 00		 cmp	 DWORD PTR _cutoff$[ebp], 16383 ; 00003fffH
  0017d	73 11		 jae	 SHORT $LN11@ReadTagWit
  0017f	8b 4d ec	 mov	 ecx, DWORD PTR _tag$15[ebp]
  00182	3b 4d 0c	 cmp	 ecx, DWORD PTR _cutoff$[ebp]
  00185	76 09		 jbe	 SHORT $LN11@ReadTagWit
  00187	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv155[ebp], 0
  0018e	eb 07		 jmp	 SHORT $LN12@ReadTagWit
$LN11@ReadTagWit:
  00190	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv155[ebp], 1
$LN12@ReadTagWit:
  00197	8a 55 e4	 mov	 dl, BYTE PTR tv155[ebp]
  0019a	88 55 fc	 mov	 BYTE PTR _at_or_below_cutoff$18[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0019d	8d 45 fc	 lea	 eax, DWORD PTR _at_or_below_cutoff$18[ebp]
  001a0	89 45 c4	 mov	 DWORD PTR $T8[ebp], eax
  001a3	8d 4d ec	 lea	 ecx, DWORD PTR _tag$15[ebp]
  001a6	89 4d cc	 mov	 DWORD PTR $T10[ebp], ecx
  001a9	8b 55 cc	 mov	 edx, DWORD PTR $T10[ebp]
  001ac	89 55 c8	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  001af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001b2	8b 4d c8	 mov	 ecx, DWORD PTR $T9[ebp]
  001b5	8b 11		 mov	 edx, DWORD PTR [ecx]
  001b7	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  001b9	8b 45 c4	 mov	 eax, DWORD PTR $T8[ebp]
  001bc	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  001bf	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001c2	8b 55 c0	 mov	 edx, DWORD PTR $T7[ebp]
  001c5	8a 02		 mov	 al, BYTE PTR [edx]
  001c7	88 41 04	 mov	 BYTE PTR [ecx+4], al
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1103 :       return std::make_pair(tag, at_or_below_cutoff);

  001ca	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001cd	eb 67		 jmp	 SHORT $LN1@ReadTagWit
$LN2@ReadTagWit:

; 1104 :     }
; 1105 :   }
; 1106 :   // Slow path
; 1107 :   const uint32 tag = ReadTagFallback(first_byte_or_zero);

  001cf	8b 4d e0	 mov	 ecx, DWORD PTR _first_byte_or_zero$[ebp]
  001d2	51		 push	 ecx
  001d3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	e8 00 00 00 00	 call	 ?ReadTagFallback@CodedInputStream@io@protobuf@google@@AAEII@Z ; google::protobuf::io::CodedInputStream::ReadTagFallback
  001db	89 45 e8	 mov	 DWORD PTR _tag$[ebp], eax

; 1108 :   if (update_last_tag) {

  001de	33 d2		 xor	 edx, edx
  001e0	74 09		 je	 SHORT $LN7@ReadTagWit

; 1109 :     last_tag_ = tag;

  001e2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	8b 4d e8	 mov	 ecx, DWORD PTR _tag$[ebp]
  001e8	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN7@ReadTagWit:

; 1111 :   return std::make_pair(tag, static_cast<uint32>(tag - 1) < cutoff);

  001eb	8b 55 e8	 mov	 edx, DWORD PTR _tag$[ebp]
  001ee	83 ea 01	 sub	 edx, 1
  001f1	3b 55 0c	 cmp	 edx, DWORD PTR _cutoff$[ebp]
  001f4	73 06		 jae	 SHORT $LN13@ReadTagWit
  001f6	c6 45 fe 01	 mov	 BYTE PTR tv168[ebp], 1
  001fa	eb 04		 jmp	 SHORT $LN14@ReadTagWit
$LN13@ReadTagWit:
  001fc	c6 45 fe 00	 mov	 BYTE PTR tv168[ebp], 0
$LN14@ReadTagWit:
  00200	8a 45 fe	 mov	 al, BYTE PTR tv168[ebp]
  00203	88 45 fb	 mov	 BYTE PTR $T17[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00206	8d 4d fb	 lea	 ecx, DWORD PTR $T17[ebp]
  00209	89 4d b4	 mov	 DWORD PTR $T4[ebp], ecx
  0020c	8d 55 e8	 lea	 edx, DWORD PTR _tag$[ebp]
  0020f	89 55 bc	 mov	 DWORD PTR $T6[ebp], edx
  00212	8b 45 bc	 mov	 eax, DWORD PTR $T6[ebp]
  00215	89 45 b8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 172  : 		: first(_STD forward<_Other1>(_Val1)),

  00218	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0021b	8b 55 b8	 mov	 edx, DWORD PTR $T5[ebp]
  0021e	8b 02		 mov	 eax, DWORD PTR [edx]
  00220	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00222	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp]
  00225	89 4d b0	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 173  : 				second(_STD forward<_Other2>(_Val2))

  00228	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0022b	8b 45 b0	 mov	 eax, DWORD PTR $T3[ebp]
  0022e	8a 08		 mov	 cl, BYTE PTR [eax]
  00230	88 4a 04	 mov	 BYTE PTR [edx+4], cl
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h

; 1111 :   return std::make_pair(tag, static_cast<uint32>(tag - 1) < cutoff);

  00233	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@ReadTagWit:

; 1112 : }

  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c2 08 00	 ret	 8
??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ENDP ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?IsDefaultSerializationDeterministic@CodedOutputStream@io@protobuf@google@@SA_NXZ
_TEXT	SEGMENT
?IsDefaultSerializationDeterministic@CodedOutputStream@io@protobuf@google@@SA_NXZ PROC ; google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic, COMDAT

; 872  :   static bool IsDefaultSerializationDeterministic() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 873  :     return default_serialization_deterministic_;

  00003	a0 00 00 00 00	 mov	 al, BYTE PTR ?default_serialization_deterministic_@CodedOutputStream@io@protobuf@google@@0_NA ; google::protobuf::io::CodedOutputStream::default_serialization_deterministic_

; 874  :   }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?IsDefaultSerializationDeterministic@CodedOutputStream@io@protobuf@google@@SA_NXZ ENDP ; google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?VarintSize32SignExtended@CodedOutputStream@io@protobuf@google@@SAIH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_value$ = 8						; size = 4
?VarintSize32SignExtended@CodedOutputStream@io@protobuf@google@@SAIH@Z PROC ; google::protobuf::io::CodedOutputStream::VarintSize32SignExtended, COMDAT

; 1302 : inline size_t CodedOutputStream::VarintSize32SignExtended(int32 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1303 :   if (value < 0) {

  00004	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  00008	7d 09		 jge	 SHORT $LN2@VarintSize

; 1304 :     return 10;     // TODO(kenton):  Make this a symbolic constant.

  0000a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0000f	eb 28		 jmp	 SHORT $LN1@VarintSize

; 1305 :   } else {

  00011	eb 26		 jmp	 SHORT $LN1@VarintSize
$LN2@VarintSize:

; 1295 :   if (value < (1 << 7)) {

  00013	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  0001a	73 0b		 jae	 SHORT $LN6@VarintSize

; 1296 :     return 1;

  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00023	eb 11		 jmp	 SHORT $LN5@VarintSize

; 1297 :   } else  {

  00025	eb 0f		 jmp	 SHORT $LN5@VarintSize
$LN6@VarintSize:

; 1298 :     return VarintSize32Fallback(value);

  00027	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
$LN5@VarintSize:

; 1306 :     return VarintSize32(static_cast<uint32>(value));

  00036	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
$LN1@VarintSize:

; 1307 :   }
; 1308 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?VarintSize32SignExtended@CodedOutputStream@io@protobuf@google@@SAIH@Z ENDP ; google::protobuf::io::CodedOutputStream::VarintSize32SignExtended
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?VarintSize32@CodedOutputStream@io@protobuf@google@@SAII@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?VarintSize32@CodedOutputStream@io@protobuf@google@@SAII@Z PROC ; google::protobuf::io::CodedOutputStream::VarintSize32, COMDAT

; 1294 : inline size_t CodedOutputStream::VarintSize32(uint32 value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1295 :   if (value < (1 << 7)) {

  00003	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  0000a	73 09		 jae	 SHORT $LN2@VarintSize

; 1296 :     return 1;

  0000c	b8 01 00 00 00	 mov	 eax, 1
  00011	eb 0e		 jmp	 SHORT $LN1@VarintSize

; 1297 :   } else  {

  00013	eb 0c		 jmp	 SHORT $LN1@VarintSize
$LN2@VarintSize:

; 1298 :     return VarintSize32Fallback(value);

  00015	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?VarintSize32Fallback@CodedOutputStream@io@protobuf@google@@CAII@Z ; google::protobuf::io::CodedOutputStream::VarintSize32Fallback
  0001e	83 c4 04	 add	 esp, 4
$LN1@VarintSize:

; 1299 :   }
; 1300 : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?VarintSize32@CodedOutputStream@io@protobuf@google@@SAII@Z ENDP ; google::protobuf::io::CodedOutputStream::VarintSize32
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?WriteTagToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z
_TEXT	SEGMENT
_target$ = -8						; size = 4
_value$ = -4						; size = 4
_value$ = 8						; size = 4
_target$ = 12						; size = 4
?WriteTagToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z PROC ; google::protobuf::io::CodedOutputStream::WriteTagToArray, COMDAT

; 1290 :     uint32 value, uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1291 :   return WriteVarint32ToArray(value, target);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _target$[ebp], eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR _value$[ebp], ecx
$LN4@WriteTagTo:

; 1197 :   while (value >= 0x80) {

  00012	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00019	72 22		 jb	 SHORT $LN5@WriteTagTo

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0001b	8b 55 fc	 mov	 edx, DWORD PTR _value$[ebp]
  0001e	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00024	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00027	88 10		 mov	 BYTE PTR [eax], dl

; 1199 :     value >>= 7;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _value$[ebp]
  0002c	c1 e9 07	 shr	 ecx, 7
  0002f	89 4d fc	 mov	 DWORD PTR _value$[ebp], ecx

; 1200 :     ++target;

  00032	8b 55 f8	 mov	 edx, DWORD PTR _target$[ebp]
  00035	83 c2 01	 add	 edx, 1
  00038	89 55 f8	 mov	 DWORD PTR _target$[ebp], edx

; 1201 :   }

  0003b	eb d5		 jmp	 SHORT $LN4@WriteTagTo
$LN5@WriteTagTo:

; 1202 :   *target = static_cast<uint8>(value);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00040	8a 4d fc	 mov	 cl, BYTE PTR _value$[ebp]
  00043	88 08		 mov	 BYTE PTR [eax], cl

; 1203 :   return target + 1;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _target$[ebp]
  00048	83 c0 01	 add	 eax, 1

; 1292 : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?WriteTagToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z ENDP ; google::protobuf::io::CodedOutputStream::WriteTagToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?WriteVarint32SignExtendedToArray@CodedOutputStream@io@protobuf@google@@SAPAEHPAE@Z
_TEXT	SEGMENT
_value$ = -12						; size = 8
_target$ = -4						; size = 4
_value$ = 8						; size = 4
_target$ = 12						; size = 4
?WriteVarint32SignExtendedToArray@CodedOutputStream@io@protobuf@google@@SAPAEHPAE@Z PROC ; google::protobuf::io::CodedOutputStream::WriteVarint32SignExtendedToArray, COMDAT

; 1222 :     int32 value, uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1223 :   return WriteVarint64ToArray(static_cast<uint64>(value), target);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax
  0000c	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000f	99		 cdq
  00010	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
  00013	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx
$LN4@WriteVarin:

; 1208 :   while (value >= 0x80) {

  00016	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp+4], 0
  0001a	77 09		 ja	 SHORT $LN7@WriteVarin
  0001c	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00023	72 2c		 jb	 SHORT $LN5@WriteVarin
$LN7@WriteVarin:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _value$[ebp]
  00028	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  0002e	8b 55 fc	 mov	 edx, DWORD PTR _target$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 1210 :     value >>= 7;

  00033	8b 45 f4	 mov	 eax, DWORD PTR _value$[ebp]
  00036	8b 55 f8	 mov	 edx, DWORD PTR _value$[ebp+4]
  00039	b1 07		 mov	 cl, 7
  0003b	e8 00 00 00 00	 call	 __aullshr
  00040	89 45 f4	 mov	 DWORD PTR _value$[ebp], eax
  00043	89 55 f8	 mov	 DWORD PTR _value$[ebp+4], edx

; 1211 :     ++target;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 fc	 mov	 DWORD PTR _target$[ebp], eax

; 1212 :   }

  0004f	eb c5		 jmp	 SHORT $LN4@WriteVarin
$LN5@WriteVarin:

; 1213 :   *target = static_cast<uint8>(value);

  00051	8a 4d f4	 mov	 cl, BYTE PTR _value$[ebp]
  00054	8b 55 fc	 mov	 edx, DWORD PTR _target$[ebp]
  00057	88 0a		 mov	 BYTE PTR [edx], cl

; 1214 :   return target + 1;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _target$[ebp]
  0005c	83 c0 01	 add	 eax, 1

; 1224 : }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?WriteVarint32SignExtendedToArray@CodedOutputStream@io@protobuf@google@@SAPAEHPAE@Z ENDP ; google::protobuf::io::CodedOutputStream::WriteVarint32SignExtendedToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?WriteVarint64ToArray@CodedOutputStream@io@protobuf@google@@SAPAE_KPAE@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
_target$ = 16						; size = 4
?WriteVarint64ToArray@CodedOutputStream@io@protobuf@google@@SAPAE_KPAE@Z PROC ; google::protobuf::io::CodedOutputStream::WriteVarint64ToArray, COMDAT

; 1207 :                                                       uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@WriteVarin:

; 1208 :   while (value >= 0x80) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp+4], 0
  00007	77 09		 ja	 SHORT $LN5@WriteVarin
  00009	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  00010	72 2b		 jb	 SHORT $LN3@WriteVarin
$LN5@WriteVarin:

; 1209 :     *target = static_cast<uint8>(value | 0x80);

  00012	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00015	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  0001a	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  0001d	88 01		 mov	 BYTE PTR [ecx], al

; 1210 :     value >>= 7;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00022	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp+4]
  00025	b1 07		 mov	 cl, 7
  00027	e8 00 00 00 00	 call	 __aullshr
  0002c	89 45 08	 mov	 DWORD PTR _value$[ebp], eax
  0002f	89 55 0c	 mov	 DWORD PTR _value$[ebp+4], edx

; 1211 :     ++target;

  00032	8b 55 10	 mov	 edx, DWORD PTR _target$[ebp]
  00035	83 c2 01	 add	 edx, 1
  00038	89 55 10	 mov	 DWORD PTR _target$[ebp], edx

; 1212 :   }

  0003b	eb c6		 jmp	 SHORT $LN2@WriteVarin
$LN3@WriteVarin:

; 1213 :   *target = static_cast<uint8>(value);

  0003d	8a 45 08	 mov	 al, BYTE PTR _value$[ebp]
  00040	8b 4d 10	 mov	 ecx, DWORD PTR _target$[ebp]
  00043	88 01		 mov	 BYTE PTR [ecx], al

; 1214 :   return target + 1;

  00045	8b 45 10	 mov	 eax, DWORD PTR _target$[ebp]
  00048	83 c0 01	 add	 eax, 1

; 1215 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?WriteVarint64ToArray@CodedOutputStream@io@protobuf@google@@SAPAE_KPAE@Z ENDP ; google::protobuf::io::CodedOutputStream::WriteVarint64ToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?WriteVarint32ToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_target$ = 12						; size = 4
?WriteVarint32ToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z PROC ; google::protobuf::io::CodedOutputStream::WriteVarint32ToArray, COMDAT

; 1196 :                                                       uint8* target) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@WriteVarin:

; 1197 :   while (value >= 0x80) {

  00003	81 7d 08 80 00
	00 00		 cmp	 DWORD PTR _value$[ebp], 128 ; 00000080H
  0000a	72 21		 jb	 SHORT $LN3@WriteVarin

; 1198 :     *target = static_cast<uint8>(value | 0x80);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000f	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00017	88 01		 mov	 BYTE PTR [ecx], al

; 1199 :     value >>= 7;

  00019	8b 55 08	 mov	 edx, DWORD PTR _value$[ebp]
  0001c	c1 ea 07	 shr	 edx, 7
  0001f	89 55 08	 mov	 DWORD PTR _value$[ebp], edx

; 1200 :     ++target;

  00022	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	89 45 0c	 mov	 DWORD PTR _target$[ebp], eax

; 1201 :   }

  0002b	eb d6		 jmp	 SHORT $LN2@WriteVarin
$LN3@WriteVarin:

; 1202 :   *target = static_cast<uint8>(value);

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _target$[ebp]
  00030	8a 55 08	 mov	 dl, BYTE PTR _value$[ebp]
  00033	88 11		 mov	 BYTE PTR [ecx], dl

; 1203 :   return target + 1;

  00035	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  00038	83 c0 01	 add	 eax, 1

; 1204 : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?WriteVarint32ToArray@CodedOutputStream@io@protobuf@google@@SAPAEIPAE@Z ENDP ; google::protobuf::io::CodedOutputStream::WriteVarint32ToArray
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?Advance@CodedInputStream@io@protobuf@google@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_amount$ = 8						; size = 4
?Advance@CodedInputStream@io@protobuf@google@@AAEXH@Z PROC ; google::protobuf::io::CodedInputStream::Advance, COMDAT
; _this$ = ecx

; 1332 : inline void CodedInputStream::Advance(int amount) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :   buffer_ += amount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	03 4d 08	 add	 ecx, DWORD PTR _amount$[ebp]
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	89 0a		 mov	 DWORD PTR [edx], ecx

; 1334 : }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?Advance@CodedInputStream@io@protobuf@google@@AAEXH@Z ENDP ; google::protobuf::io::CodedInputStream::Advance
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?ReadTagWithCutoffNoLastTag@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@I_N@std@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_cutoff$ = 12						; size = 4
?ReadTagWithCutoffNoLastTag@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@I_N@std@@I@Z PROC ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffNoLastTag, COMDAT
; _this$ = ecx

; 1058 :     uint32 cutoff) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1059 :   return ReadTagWithCutoffImplementation<false>(cutoff);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _cutoff$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??$ReadTagWithCutoffImplementation@$0A@@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@I_N@std@@I@Z ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffImplementation<0>
  00017	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1060 : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?ReadTagWithCutoffNoLastTag@CodedInputStream@io@protobuf@google@@QAE?AU?$pair@I_N@std@@I@Z ENDP ; google::protobuf::io::CodedInputStream::ReadTagWithCutoffNoLastTag
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
_v$1 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z PROC ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt, COMDAT
; _this$ = ecx

; 946  : inline bool CodedInputStream::ReadVarintSizeAsInt(int* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 947  :   if (GOOGLE_PREDICT_TRUE(buffer_ < buffer_end_)) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00014	73 2d		 jae	 SHORT $LN2@ReadVarint

; 948  :     int v = *buffer_;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001e	89 55 f8	 mov	 DWORD PTR _v$1[ebp], edx

; 949  :     if (v < 0x80) {

  00021	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _v$1[ebp], 128 ; 00000080H
  00028	7d 19		 jge	 SHORT $LN2@ReadVarint

; 950  :       *value = v;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _v$1[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx

; 1333 :   buffer_ += amount;

  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 02		 mov	 eax, DWORD PTR [edx]
  00037	83 c0 01	 add	 eax, 1
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	89 01		 mov	 DWORD PTR [ecx], eax

; 951  :       Advance(1);
; 952  :       return true;

  0003f	b0 01		 mov	 al, 1
  00041	eb 28		 jmp	 SHORT $LN1@ReadVarint
$LN2@ReadVarint:

; 953  :     }
; 954  :   }
; 955  :   *value = ReadVarintSizeAsIntFallback();

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?ReadVarintSizeAsIntFallback@CodedInputStream@io@protobuf@google@@AAEHXZ ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsIntFallback
  0004b	8b 55 08	 mov	 edx, DWORD PTR _value$[ebp]
  0004e	89 02		 mov	 DWORD PTR [edx], eax

; 956  :   return *value >= 0;

  00050	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00053	83 38 00	 cmp	 DWORD PTR [eax], 0
  00056	7c 09		 jl	 SHORT $LN5@ReadVarint
  00058	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0005f	eb 07		 jmp	 SHORT $LN6@ReadVarint
$LN5@ReadVarint:
  00061	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN6@ReadVarint:
  00068	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
$LN1@ReadVarint:

; 957  : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 04 00	 ret	 4
?ReadVarintSizeAsInt@CodedInputStream@io@protobuf@google@@QAE_NPAH@Z ENDP ; google::protobuf::io::CodedInputStream::ReadVarintSizeAsInt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z
_TEXT	SEGMENT
_p$ = -20						; size = 16
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z PROC ; google::protobuf::io::CodedInputStream::ReadVarint64, COMDAT
; _this$ = ecx

; 935  : inline bool CodedInputStream::ReadVarint64(uint64* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 936  :   if (GOOGLE_PREDICT_TRUE(buffer_ < buffer_end_) && *buffer_ < 0x80) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00014	73 32		 jae	 SHORT $LN2@ReadVarint
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0001e	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00024	7d 22		 jge	 SHORT $LN2@ReadVarint

; 937  :     *value = *buffer_;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0002e	99		 cdq
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00032	89 01		 mov	 DWORD PTR [ecx], eax
  00034	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 1333 :   buffer_ += amount;

  00037	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003a	8b 02		 mov	 eax, DWORD PTR [edx]
  0003c	83 c0 01	 add	 eax, 1
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 01		 mov	 DWORD PTR [ecx], eax

; 938  :     Advance(1);
; 939  :     return true;

  00044	b0 01		 mov	 al, 1
  00046	eb 1d		 jmp	 SHORT $LN1@ReadVarint
$LN2@ReadVarint:

; 940  :   }
; 941  :   std::pair<uint64, bool> p = ReadVarint64Fallback();

  00048	8d 55 ec	 lea	 edx, DWORD PTR _p$[ebp]
  0004b	52		 push	 edx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?ReadVarint64Fallback@CodedInputStream@io@protobuf@google@@AAE?AU?$pair@_K_N@std@@XZ ; google::protobuf::io::CodedInputStream::ReadVarint64Fallback

; 942  :   *value = p.first;

  00054	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _p$[ebp]
  0005a	89 08		 mov	 DWORD PTR [eax], ecx
  0005c	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp+4]
  0005f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 943  :   return p.second;

  00062	8a 45 f4	 mov	 al, BYTE PTR _p$[ebp+8]
$LN1@ReadVarint:

; 944  : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?ReadVarint64@CodedInputStream@io@protobuf@google@@QAE_NPA_K@Z ENDP ; google::protobuf::io::CodedInputStream::ReadVarint64
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\io\coded_stream.h
;	COMDAT ?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z
_TEXT	SEGMENT
_result$ = -20						; size = 8
tv78 = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z PROC ; google::protobuf::io::CodedInputStream::ReadVarint32, COMDAT
; _this$ = ecx

; 920  : inline bool CodedInputStream::ReadVarint32(uint32* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 921  :   uint32 v = 0;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _v$[ebp], 0

; 922  :   if (GOOGLE_PREDICT_TRUE(buffer_ < buffer_end_)) {

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0001b	73 2d		 jae	 SHORT $LN2@ReadVarint

; 923  :     v = *buffer_;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00025	89 55 f8	 mov	 DWORD PTR _v$[ebp], edx

; 924  :     if (v < 0x80) {

  00028	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _v$[ebp], 128	; 00000080H
  0002f	73 19		 jae	 SHORT $LN2@ReadVarint

; 925  :       *value = v;

  00031	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _v$[ebp]
  00037	89 08		 mov	 DWORD PTR [eax], ecx

; 1333 :   buffer_ += amount;

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	83 c0 01	 add	 eax, 1
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax

; 926  :       Advance(1);
; 927  :       return true;

  00046	b0 01		 mov	 al, 1
  00048	eb 3b		 jmp	 SHORT $LN1@ReadVarint
$LN2@ReadVarint:

; 928  :     }
; 929  :   }
; 930  :   int64 result = ReadVarint32Fallback(v);

  0004a	8b 55 f8	 mov	 edx, DWORD PTR _v$[ebp]
  0004d	52		 push	 edx
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?ReadVarint32Fallback@CodedInputStream@io@protobuf@google@@AAE_JI@Z ; google::protobuf::io::CodedInputStream::ReadVarint32Fallback
  00056	89 45 ec	 mov	 DWORD PTR _result$[ebp], eax
  00059	89 55 f0	 mov	 DWORD PTR _result$[ebp+4], edx

; 931  :   *value = static_cast<uint32>(result);

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _result$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 932  :   return result >= 0;

  00064	83 7d f0 00	 cmp	 DWORD PTR _result$[ebp+4], 0
  00068	7c 11		 jl	 SHORT $LN5@ReadVarint
  0006a	7f 06		 jg	 SHORT $LN9@ReadVarint
  0006c	83 7d ec 00	 cmp	 DWORD PTR _result$[ebp], 0
  00070	72 09		 jb	 SHORT $LN5@ReadVarint
$LN9@ReadVarint:
  00072	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00079	eb 07		 jmp	 SHORT $LN6@ReadVarint
$LN5@ReadVarint:
  0007b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN6@ReadVarint:
  00082	8a 45 f4	 mov	 al, BYTE PTR tv78[ebp]
$LN1@ReadVarint:

; 933  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?ReadVarint32@CodedInputStream@io@protobuf@google@@QAE_NPAI@Z ENDP ; google::protobuf::io::CodedInputStream::ReadVarint32
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z PROC ; google::protobuf::internal::FunctionClosure0::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1FunctionClosure0@internal@protobuf@google@@UAE@XZ ; google::protobuf::internal::FunctionClosure0::~FunctionClosure0
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GFunctionClosure0@internal@protobuf@google@@UAEPAXI@Z ENDP ; google::protobuf::internal::FunctionClosure0::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\callback.h
;	COMDAT ?Run@FunctionClosure0@internal@protobuf@google@@UAEXXZ
_TEXT	SEGMENT
tv78 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_needs_delete$ = -1					; size = 1
?Run@FunctionClosure0@internal@protobuf@google@@UAEXXZ PROC ; google::protobuf::internal::FunctionClosure0::Run, COMDAT
; _this$ = ecx

; 127  :   void Run() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 128  :     bool needs_delete = self_deleting_;  // read in case callback deletes

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8a 48 08	 mov	 cl, BYTE PTR [eax+8]
  0000f	88 4d ff	 mov	 BYTE PTR _needs_delete$[ebp], cl

; 129  :     function_();

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00018	ff d0		 call	 eax

; 130  :     if (needs_delete) delete this;

  0001a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _needs_delete$[ebp]
  0001e	85 c9		 test	 ecx, ecx
  00020	74 2c		 je	 SHORT $LN1@Run
  00022	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00025	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx
  00028	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0002e	83 7d f4 00	 cmp	 DWORD PTR $T2[ebp], 0
  00032	74 13		 je	 SHORT $LN4@Run
  00034	6a 01		 push	 1
  00036	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	ff d0		 call	 eax
  00042	89 45 ec	 mov	 DWORD PTR tv78[ebp], eax
  00045	eb 07		 jmp	 SHORT $LN1@Run
$LN4@Run:
  00047	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN1@Run:

; 131  :   }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?Run@FunctionClosure0@internal@protobuf@google@@UAEXXZ ENDP ; google::protobuf::internal::FunctionClosure0::Run
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\callback.h
;	COMDAT ??0FunctionClosure0@internal@protobuf@google@@QAE@P6AXXZ_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_function$ = 8						; size = 4
_self_deleting$ = 12					; size = 1
??0FunctionClosure0@internal@protobuf@google@@QAE@P6AXXZ_N@Z PROC ; google::protobuf::internal::FunctionClosure0::FunctionClosure0, COMDAT
; _this$ = ecx

; 123  :   FunctionClosure0(FunctionType function, bool self_deleting)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 72   :   Closure() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Closure@protobuf@google@@6B@

; 124  :     : function_(function), self_deleting_(self_deleting) {}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7FunctionClosure0@internal@protobuf@google@@6B@
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 45 08	 mov	 eax, DWORD PTR _function$[ebp]
  0001f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	8a 55 0c	 mov	 dl, BYTE PTR _self_deleting$[ebp]
  00028	88 51 08	 mov	 BYTE PTR [ecx+8], dl
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
??0FunctionClosure0@internal@protobuf@google@@QAE@P6AXXZ_N@Z ENDP ; google::protobuf::internal::FunctionClosure0::FunctionClosure0
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GClosure@protobuf@google@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GClosure@protobuf@google@@UAEPAXI@Z PROC		; google::protobuf::Closure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Closure@protobuf@google@@UAE@XZ ; google::protobuf::Closure::~Closure
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 04		 push	 4
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GClosure@protobuf@google@@UAEPAXI@Z ENDP		; google::protobuf::Closure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\stubs\callback.h
;	COMDAT ??0Closure@protobuf@google@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Closure@protobuf@google@@QAE@XZ PROC			; google::protobuf::Closure::Closure, COMDAT
; _this$ = ecx

; 72   :   Closure() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Closure@protobuf@google@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0Closure@protobuf@google@@QAE@XZ ENDP			; google::protobuf::Closure::Closure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTCPNetworkEngine@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTCPNetworkEngine@@UAEPAXI@Z PROC			; CTCPNetworkEngine::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTCPNetworkEngine@@UAE@XZ ; CTCPNetworkEngine::~CTCPNetworkEngine
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 11		 je	 SHORT $LN2@scalar
  00017	68 78 81 00 00	 push	 33144			; 00008178H
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00025	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_GCTCPNetworkEngine@@UAEPAXI@Z ENDP			; CTCPNetworkEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_ThreadLock$ = -84					; size = 12
_nIndex$2 = -72						; size = 4
$T3 = -68						; size = 4
_nStorCount$4 = -64					; size = 4
$T5 = -60						; size = 4
_nBufferCount$ = -56					; size = 4
_nIndex$6 = -52						; size = 4
$T7 = -48						; size = 4
_nActiveCount$ = -44					; size = 4
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_i$8 = -32						; size = 4
_i$9 = -28						; size = 4
_i$10 = -24						; size = 4
_this$ = -20						; size = 4
$T11 = -16						; size = 1
$T12 = -15						; size = 1
$T13 = -14						; size = 1
_hasFind$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_pTCPNetworkItem$ = 8					; size = 4
?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z PROC ; CTCPNetworkEngine::FreeNetworkItem, COMDAT
; _this$ = ecx

; 2398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2399 :     // 效验参数
; 2400 :     ASSERT(pTCPNetworkItem != NULL);

  00028	83 7d 08 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  0002c	75 14		 jne	 SHORT $LN17@FreeNetwor
  0002e	68 60 09 00 00	 push	 2400			; 00000960H
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00038	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0003d	85 c0		 test	 eax, eax
  0003f	74 01		 je	 SHORT $LN17@FreeNetwor
  00041	cc		 int	 3
$LN17@FreeNetwor:

; 2401 : 
; 2402 :     // 释放对象
; 2403 :     CWHDataLocker ThreadLock(m_ItemLocked, true);

  00042	6a 01		 push	 1
  00044	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	81 c1 28 40 00
	00		 add	 ecx, 16424		; 00004028H
  0004d	51		 push	 ecx
  0004e	8d 4d ac	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  0005e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 82 70 40 00
	00		 mov	 eax, DWORD PTR [edx+16496]
  00067	89 45 d4	 mov	 DWORD PTR _nActiveCount$[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2405 :     for (INT i = 0; i < nActiveCount; i++)

  0006a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$10[ebp], 0
  00071	eb 09		 jmp	 SHORT $LN4@FreeNetwor
$LN2@FreeNetwor:
  00073	8b 4d e8	 mov	 ecx, DWORD PTR _i$10[ebp]
  00076	83 c1 01	 add	 ecx, 1
  00079	89 4d e8	 mov	 DWORD PTR _i$10[ebp], ecx
$LN4@FreeNetwor:
  0007c	8b 55 e8	 mov	 edx, DWORD PTR _i$10[ebp]
  0007f	3b 55 d4	 cmp	 edx, DWORD PTR _nActiveCount$[ebp]
  00082	7d 79		 jge	 SHORT $LN3@FreeNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00084	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  00087	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2407 :         if (pTCPNetworkItem == m_NetworkItemActive[i])

  00088	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00091	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
  00096	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2407 :         if (pTCPNetworkItem == m_NetworkItemActive[i])

  00099	8b 4d d0	 mov	 ecx, DWORD PTR $T7[ebp]
  0009c	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  0009f	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000a1	75 55		 jne	 SHORT $LN11@FreeNetwor

; 2408 :         {
; 2409 :             m_NetworkItemActive.RemoveAt(i);

  000a3	6a 01		 push	 1
  000a5	8b 45 e8	 mov	 eax, DWORD PTR _i$10[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  000b2	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAt

; 2410 :             m_NetworkItemBuffer.Add(pTCPNetworkItem);

  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  000c0	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  000c3	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  000c6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000c9	89 45 cc	 mov	 DWORD PTR _nIndex$6[ebp], eax

; 107  : 	SetAtGrow(nIndex,newElement);

  000cc	8d 4d 08	 lea	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 cc	 mov	 edx, DWORD PTR _nIndex$6[ebp]
  000d3	52		 push	 edx
  000d4	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2411 :             return true;

  000dc	c6 45 f2 01	 mov	 BYTE PTR $T13[ebp], 1
  000e0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e7	8d 4d ac	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000f0	8a 45 f2	 mov	 al, BYTE PTR $T13[ebp]
  000f3	e9 15 01 00 00	 jmp	 $LN1@FreeNetwor
$LN11@FreeNetwor:

; 2412 :         }
; 2413 :     }

  000f8	e9 76 ff ff ff	 jmp	 $LN2@FreeNetwor
$LN3@FreeNetwor:

; 2414 : 
; 2415 : 	bool hasFind = false;

  000fd	c6 45 f3 00	 mov	 BYTE PTR _hasFind$[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00101	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b 88 5c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16476]
  0010a	89 4d c8	 mov	 DWORD PTR _nBufferCount$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2417 : 	for (INT i = 0; i < nBufferCount; i++)

  0010d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$9[ebp], 0
  00114	eb 09		 jmp	 SHORT $LN7@FreeNetwor
$LN5@FreeNetwor:
  00116	8b 55 e4	 mov	 edx, DWORD PTR _i$9[ebp]
  00119	83 c2 01	 add	 edx, 1
  0011c	89 55 e4	 mov	 DWORD PTR _i$9[ebp], edx
$LN7@FreeNetwor:
  0011f	8b 45 e4	 mov	 eax, DWORD PTR _i$9[ebp]
  00122	3b 45 c8	 cmp	 eax, DWORD PTR _nBufferCount$[ebp]
  00125	7d 27		 jge	 SHORT $LN6@FreeNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00127	8b 4d e4	 mov	 ecx, DWORD PTR _i$9[ebp]
  0012a	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2419 : 		if (pTCPNetworkItem == m_NetworkItemBuffer[i])

  0012b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00134	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
  00139	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2419 : 		if (pTCPNetworkItem == m_NetworkItemBuffer[i])

  0013c	8b 55 c4	 mov	 edx, DWORD PTR $T5[ebp]
  0013f	8b 45 08	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  00142	3b 02		 cmp	 eax, DWORD PTR [edx]
  00144	75 06		 jne	 SHORT $LN12@FreeNetwor

; 2420 : 		{
; 2421 : 			hasFind = true;

  00146	c6 45 f3 01	 mov	 BYTE PTR _hasFind$[ebp], 1

; 2422 : 			break;

  0014a	eb 02		 jmp	 SHORT $LN6@FreeNetwor
$LN12@FreeNetwor:

; 2423 : 		}
; 2424 : 	}

  0014c	eb c8		 jmp	 SHORT $LN5@FreeNetwor
$LN6@FreeNetwor:

; 2425 : 
; 2426 : 	if (hasFind == false) {

  0014e	0f b6 4d f3	 movzx	 ecx, BYTE PTR _hasFind$[ebp]
  00152	85 c9		 test	 ecx, ecx
  00154	75 6f		 jne	 SHORT $LN13@FreeNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00156	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00159	8b 82 84 40 00
	00		 mov	 eax, DWORD PTR [edx+16516]
  0015f	89 45 c0	 mov	 DWORD PTR _nStorCount$4[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2428 : 		for (INT i = 0; i < nStorCount; i++)

  00162	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  00169	eb 09		 jmp	 SHORT $LN10@FreeNetwor
$LN8@FreeNetwor:
  0016b	8b 4d e0	 mov	 ecx, DWORD PTR _i$8[ebp]
  0016e	83 c1 01	 add	 ecx, 1
  00171	89 4d e0	 mov	 DWORD PTR _i$8[ebp], ecx
$LN10@FreeNetwor:
  00174	8b 55 e0	 mov	 edx, DWORD PTR _i$8[ebp]
  00177	3b 55 c0	 cmp	 edx, DWORD PTR _nStorCount$4[ebp]
  0017a	7d 47		 jge	 SHORT $LN9@FreeNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0017c	8b 45 e0	 mov	 eax, DWORD PTR _i$8[ebp]
  0017f	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2430 : 			if (pTCPNetworkItem == m_NetworkItemStorage[i])

  00180	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00183	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00189	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
  0018e	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2430 : 			if (pTCPNetworkItem == m_NetworkItemStorage[i])

  00191	8b 4d bc	 mov	 ecx, DWORD PTR $T3[ebp]
  00194	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  00197	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00199	75 26		 jne	 SHORT $LN15@FreeNetwor

; 2431 : 			{
; 2432 : 				m_NetworkItemBuffer.Add(pTCPNetworkItem);

  0019b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0019e	05 4c 40 00 00	 add	 eax, 16460		; 0000404cH
  001a3	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  001a6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  001ac	89 55 b8	 mov	 DWORD PTR _nIndex$2[ebp], edx

; 107  : 	SetAtGrow(nIndex,newElement);

  001af	8d 45 08	 lea	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  001b2	50		 push	 eax
  001b3	8b 4d b8	 mov	 ecx, DWORD PTR _nIndex$2[ebp]
  001b6	51		 push	 ecx
  001b7	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2433 : 				break;

  001bf	eb 02		 jmp	 SHORT $LN9@FreeNetwor
$LN15@FreeNetwor:

; 2434 : 			}
; 2435 : 		}

  001c1	eb a8		 jmp	 SHORT $LN8@FreeNetwor
$LN9@FreeNetwor:

; 2436 : 	}
; 2437 : 	else

  001c3	eb 19		 jmp	 SHORT $LN14@FreeNetwor
$LN13@FreeNetwor:

; 2438 : 	{
; 2439 : 		return true;

  001c5	c6 45 f1 01	 mov	 BYTE PTR $T12[ebp], 1
  001c9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001d0	8d 4d ac	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  001d9	8a 45 f1	 mov	 al, BYTE PTR $T12[ebp]
  001dc	eb 2f		 jmp	 SHORT $LN1@FreeNetwor
$LN14@FreeNetwor:

; 2440 : 	}
; 2441 : 
; 2442 :     // 释放失败
; 2443 :     ASSERT(FALSE);

  001de	33 d2		 xor	 edx, edx
  001e0	75 14		 jne	 SHORT $LN18@FreeNetwor
  001e2	68 8b 09 00 00	 push	 2443			; 0000098bH
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001ec	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001f1	85 c0		 test	 eax, eax
  001f3	74 01		 je	 SHORT $LN18@FreeNetwor
  001f5	cc		 int	 3
$LN18@FreeNetwor:

; 2444 : 
; 2445 :     return false;

  001f6	c6 45 f0 00	 mov	 BYTE PTR $T11[ebp], 0
  001fa	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00201	8d 4d ac	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00204	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0020a	8a 45 f0	 mov	 al, BYTE PTR $T11[ebp]
$LN1@FreeNetwor:

; 2446 : }

  0020d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00210	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00217	59		 pop	 ecx
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z ENDP ; CTCPNetworkEngine::FreeNetworkItem
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z
_TEXT	SEGMENT
_ThreadLock$ = -48					; size = 12
$T2 = -36						; size = 4
_pTCPNetworkItem$ = -32					; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_wIndex$ = 8						; size = 2
?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z PROC ; CTCPNetworkEngine::GetNetworkItem, COMDAT
; _this$ = ecx

; 2381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2382 :     // 锁定对象
; 2383 :     CWHDataLocker ThreadLock(m_ItemLocked, true);

  00028	6a 01		 push	 1
  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	05 28 40 00 00	 add	 eax, 16424		; 00004028H
  00032	50		 push	 eax
  00033	8d 4d d0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 91 84 40 00
	00		 mov	 edx, DWORD PTR [ecx+16516]
  0004c	89 55 ec	 mov	 DWORD PTR $T5[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2386 :     ASSERT(wIndex < m_NetworkItemStorage.GetCount());

  0004f	0f b7 45 08	 movzx	 eax, WORD PTR _wIndex$[ebp]
  00053	3b 45 ec	 cmp	 eax, DWORD PTR $T5[ebp]
  00056	7c 14		 jl	 SHORT $LN4@GetNetwork
  00058	68 52 09 00 00	 push	 2386			; 00000952H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00062	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00067	85 c0		 test	 eax, eax
  00069	74 01		 je	 SHORT $LN4@GetNetwork
  0006b	cc		 int	 3
$LN4@GetNetwork:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  0006c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0006f	8b 82 84 40 00
	00		 mov	 eax, DWORD PTR [edx+16516]
  00075	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2387 :     if (wIndex >= m_NetworkItemStorage.GetCount())

  00078	0f b7 4d 08	 movzx	 ecx, WORD PTR _wIndex$[ebp]
  0007c	3b 4d e8	 cmp	 ecx, DWORD PTR $T4[ebp]
  0007f	7c 1c		 jl	 SHORT $LN13@GetNetwork

; 2388 :         return NULL;

  00081	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
  00088	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008f	8d 4d d0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00098	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  0009b	eb 31		 jmp	 SHORT $LN1@GetNetwork
$LN13@GetNetwork:

; 2391 :     CTCPNetworkItem * pTCPNetworkItem = m_NetworkItemStorage[wIndex];

  0009d	0f b7 55 08	 movzx	 edx, WORD PTR _wIndex$[ebp]
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000a1	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2391 :     CTCPNetworkItem * pTCPNetworkItem = m_NetworkItemStorage[wIndex];

  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000ab	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2391 :     CTCPNetworkItem * pTCPNetworkItem = m_NetworkItemStorage[wIndex];

  000b0	8b 00		 mov	 eax, DWORD PTR [eax]
  000b2	89 45 e0	 mov	 DWORD PTR _pTCPNetworkItem$[ebp], eax

; 2392 : 
; 2393 :     return pTCPNetworkItem;

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  000b8	89 4d dc	 mov	 DWORD PTR $T2[ebp], ecx
  000bb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c2	8d 4d d0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000cb	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@GetNetwork:

; 2394 : }

  000ce	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d8	59		 pop	 ecx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ENDP ; CTCPNetworkEngine::GetNetworkItem
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ
_TEXT	SEGMENT
_ThreadLock$ = -120					; size = 12
$T2 = -108						; size = 4
$T3 = -104						; size = 4
_nIndex$4 = -100					; size = 4
_nIndex$5 = -96						; size = 4
$T6 = -92						; size = 4
tv193 = -88						; size = 4
$T7 = -84						; size = 4
tv182 = -80						; size = 4
tv65 = -76						; size = 4
$T8 = -72						; size = 4
_nIndex$9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
_this$ = -56						; size = 4
_this$ = -52						; size = 4
tv149 = -48						; size = 4
$T12 = -44						; size = 4
tv145 = -40						; size = 4
_this$ = -36						; size = 4
_nItemPostion$13 = -32					; size = 4
_pTCPNetworkItem$ = -28					; size = 4
_this$ = -24						; size = 4
_wStorageCount$14 = -20					; size = 2
__$EHRec$ = -16						; size = 16
?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ PROC ; CTCPNetworkEngine::ActiveNetworkItem, COMDAT
; _this$ = ecx

; 2334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 68	 sub	 esp, 104		; 00000068H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2335 :     // 锁定队列
; 2336 :     CWHDataLocker ThreadLock(m_ItemLocked, true);

  0002f	6a 01		 push	 1
  00031	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	05 28 40 00 00	 add	 eax, 16424		; 00004028H
  00039	50		 push	 eax
  0003a	8d 4d 88	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 2337 : 
; 2338 :     // 获取对象
; 2339 :     CTCPNetworkItem * pTCPNetworkItem = NULL;

  0004a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkItem$[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00051	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 91 5c 40 00
	00		 mov	 edx, DWORD PTR [ecx+16476]
  0005a	89 55 c4	 mov	 DWORD PTR $T11[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2340 :     if (m_NetworkItemBuffer.GetCount() > 0)

  0005d	83 7d c4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00061	7e 64		 jle	 SHORT $LN2@ActiveNetw
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00063	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 88 5c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16476]
  0006c	89 4d c0	 mov	 DWORD PTR $T10[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2342 :         INT_PTR nItemPostion = m_NetworkItemBuffer.GetCount() - 1;

  0006f	8b 55 c0	 mov	 edx, DWORD PTR $T10[ebp]
  00072	83 ea 01	 sub	 edx, 1
  00075	89 55 e0	 mov	 DWORD PTR _nItemPostion$13[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00078	8b 45 e0	 mov	 eax, DWORD PTR _nItemPostion$13[ebp]
  0007b	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2343 :         pTCPNetworkItem = m_NetworkItemBuffer[nItemPostion];

  0007c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00085	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2343 :         pTCPNetworkItem = m_NetworkItemBuffer[nItemPostion];

  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008c	89 4d e4	 mov	 DWORD PTR _pTCPNetworkItem$[ebp], ecx

; 2344 :         m_NetworkItemBuffer.RemoveAt(nItemPostion);

  0008f	6a 01		 push	 1
  00091	8b 55 e0	 mov	 edx, DWORD PTR _nItemPostion$13[ebp]
  00094	52		 push	 edx
  00095	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  0009e	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAt

; 2345 :         m_NetworkItemActive.Add(pTCPNetworkItem);

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	05 60 40 00 00	 add	 eax, 16480		; 00004060H
  000ab	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  000ae	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000b4	89 55 bc	 mov	 DWORD PTR _nIndex$9[ebp], edx

; 107  : 	SetAtGrow(nIndex,newElement);

  000b7	8d 45 e4	 lea	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  000ba	50		 push	 eax
  000bb	8b 4d bc	 mov	 ecx, DWORD PTR _nIndex$9[ebp]
  000be	51		 push	 ecx
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
$LN2@ActiveNetw:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2349 :     if (pTCPNetworkItem == NULL)

  000c7	83 7d e4 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  000cb	0f 85 52 01 00
	00		 jne	 $LN14@ActiveNetw
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000d1	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000d4	8b 82 84 40 00
	00		 mov	 eax, DWORD PTR [edx+16516]
  000da	89 45 b8	 mov	 DWORD PTR $T8[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2351 :         WORD wStorageCount = (WORD)m_NetworkItemStorage.GetCount();

  000dd	66 8b 4d b8	 mov	 cx, WORD PTR $T8[ebp]
  000e1	66 89 4d ec	 mov	 WORD PTR _wStorageCount$14[ebp], cx

; 2352 :         if (wStorageCount < m_wMaxConnect)

  000e5	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	0f b7 82 10 40
	00 00		 movzx	 eax, WORD PTR [edx+16400]
  000ef	0f b7 4d ec	 movzx	 ecx, WORD PTR _wStorageCount$14[ebp]
  000f3	3b c8		 cmp	 ecx, eax
  000f5	0f 8d 28 01 00
	00		 jge	 $LN14@ActiveNetw

; 2353 :         {
; 2354 :             try

  000fb	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 2355 :             {
; 2356 :                 // 创建对象
; 2357 :                 pTCPNetworkItem = new CTCPNetworkItem(wStorageCount, this);

  000ff	68 d8 40 01 00	 push	 82136			; 000140d8H
  00104	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00109	83 c4 04	 add	 esp, 4
  0010c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0010f	8b 55 b4	 mov	 edx, DWORD PTR tv65[ebp]
  00112	89 55 d4	 mov	 DWORD PTR $T12[ebp], edx
  00115	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00119	83 7d d4 00	 cmp	 DWORD PTR $T12[ebp], 0
  0011d	74 34		 je	 SHORT $LN10@ActiveNetw
  0011f	83 7d e8 00	 cmp	 DWORD PTR _this$[ebp], 0
  00123	74 0b		 je	 SHORT $LN8@ActiveNetw
  00125	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00128	83 c0 08	 add	 eax, 8
  0012b	89 45 d8	 mov	 DWORD PTR tv145[ebp], eax
  0012e	eb 07		 jmp	 SHORT $LN9@ActiveNetw
$LN8@ActiveNetw:
  00130	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
$LN9@ActiveNetw:
  00137	8b 4d d8	 mov	 ecx, DWORD PTR tv145[ebp]
  0013a	51		 push	 ecx
  0013b	0f b7 55 ec	 movzx	 edx, WORD PTR _wStorageCount$14[ebp]
  0013f	52		 push	 edx
  00140	8b 4d d4	 mov	 ecx, DWORD PTR $T12[ebp]
  00143	e8 00 00 00 00	 call	 ??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z ; CTCPNetworkItem::CTCPNetworkItem
  00148	89 45 b0	 mov	 DWORD PTR tv182[ebp], eax
  0014b	8b 45 b0	 mov	 eax, DWORD PTR tv182[ebp]
  0014e	89 45 d0	 mov	 DWORD PTR tv149[ebp], eax
  00151	eb 07		 jmp	 SHORT $LN11@ActiveNetw
$LN10@ActiveNetw:
  00153	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv149[ebp], 0
$LN11@ActiveNetw:
  0015a	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  0015d	89 4d ac	 mov	 DWORD PTR $T7[ebp], ecx
  00160	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00164	8b 55 ac	 mov	 edx, DWORD PTR $T7[ebp]
  00167	89 55 e4	 mov	 DWORD PTR _pTCPNetworkItem$[ebp], edx

; 2358 :                 if (pTCPNetworkItem == NULL)

  0016a	83 7d e4 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  0016e	75 3c		 jne	 SHORT $LN6@ActiveNetw

; 2359 :                 {
; 2360 :                     ASSERT(FALSE);

  00170	33 c0		 xor	 eax, eax
  00172	75 19		 jne	 SHORT $LN12@ActiveNetw
  00174	68 38 09 00 00	 push	 2360			; 00000938H
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0017e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00183	89 45 a8	 mov	 DWORD PTR tv193[ebp], eax
  00186	83 7d a8 00	 cmp	 DWORD PTR tv193[ebp], 0
  0018a	74 01		 je	 SHORT $LN12@ActiveNetw
  0018c	cc		 int	 3
$LN12@ActiveNetw:

; 2361 :                     return NULL;

  0018d	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
  00194	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0019b	8d 4d 88	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  001a4	8b 45 a4	 mov	 eax, DWORD PTR $T6[ebp]
  001a7	e9 ae 00 00 00	 jmp	 $LN1@ActiveNetw
$LN6@ActiveNetw:

; 2362 :                 }
; 2363 : 
; 2364 :                 // 插入数组
; 2365 :                 m_NetworkItemActive.Add(pTCPNetworkItem);

  001ac	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001af	81 c2 60 40 00
	00		 add	 edx, 16480		; 00004060H
  001b5	89 55 cc	 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  001b8	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001be	89 4d a0	 mov	 DWORD PTR _nIndex$5[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  001c1	8d 55 e4	 lea	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  001c4	52		 push	 edx
  001c5	8b 45 a0	 mov	 eax, DWORD PTR _nIndex$5[ebp]
  001c8	50		 push	 eax
  001c9	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2366 :                 m_NetworkItemStorage.Add(pTCPNetworkItem);

  001d1	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d4	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
  001da	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  001dd	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  001e0	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001e3	89 45 9c	 mov	 DWORD PTR _nIndex$4[ebp], eax

; 107  : 	SetAtGrow(nIndex,newElement);

  001e6	8d 4d e4	 lea	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  001e9	51		 push	 ecx
  001ea	8b 55 9c	 mov	 edx, DWORD PTR _nIndex$4[ebp]
  001ed	52		 push	 edx
  001ee	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2367 :             }

  001f6	eb 2b		 jmp	 SHORT $LN14@ActiveNetw
__catch$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$0:

; 2368 :             catch (...)
; 2369 :             {
; 2370 :                 ASSERT(FALSE);

  001f8	33 c0		 xor	 eax, eax
  001fa	75 14		 jne	 SHORT $LN13@ActiveNetw
  001fc	68 42 09 00 00	 push	 2370			; 00000942H
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00206	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0020b	85 c0		 test	 eax, eax
  0020d	74 01		 je	 SHORT $LN13@ActiveNetw
  0020f	cc		 int	 3
$LN13@ActiveNetw:

; 2371 :                 return NULL;

  00210	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
  00217	b8 00 00 00 00	 mov	 eax, $LN19@ActiveNetw
  0021c	c3		 ret	 0

; 2372 :             }

  0021d	b8 00 00 00 00	 mov	 eax, $LN14@ActiveNetw
  00222	c3		 ret	 0
$LN14@ActiveNetw:
  00223	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0022a	eb 15		 jmp	 SHORT $LN18@ActiveNetw
$LN19@ActiveNetw:

; 2371 :                 return NULL;

  0022c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	8d 4d 88	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0023c	8b 45 98	 mov	 eax, DWORD PTR $T3[ebp]
  0023f	eb 19		 jmp	 SHORT $LN1@ActiveNetw
$LN18@ActiveNetw:

; 2373 :         }
; 2374 :     }
; 2375 : 
; 2376 :     return pTCPNetworkItem;

  00241	8b 55 e4	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  00244	89 55 94	 mov	 DWORD PTR $T2[ebp], edx
  00247	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0024e	8d 4d 88	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00251	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00257	8b 45 94	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@ActiveNetw:

; 2377 : }

  0025a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0025d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00264	59		 pop	 ecx
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$2:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ$3:
  00009	68 d8 40 01 00	 push	 82136			; 000140d8H
  0000e	8b 45 d4	 mov	 eax, DWORD PTR $T12[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	c3		 ret	 0
__ehhandler$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ:
  0001b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00022	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00025	33 c8		 xor	 ecx, eax
  00027	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ
  00031	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ ENDP ; CTCPNetworkEngine::ActiveNetworkItem
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z
_TEXT	SEGMENT
_pszString$1 = -800					; size = 4
_this$ = -796						; size = 4
_SocketAddr$ = -792					; size = 16
_szString$2 = -776					; size = 512
_pszString$3 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_m_AutoServicPort$ = 8					; size = 2
?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z PROC		; CTCPNetworkEngine::CreateSocket, COMDAT
; _this$ = ecx

; 2288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 03 00
	00		 sub	 esp, 800		; 00000320H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 8d e4 fc ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 2289 :     //建立网络
; 2290 :     SOCKADDR_IN SocketAddr;
; 2291 :     ZeroMemory(&SocketAddr,sizeof(SocketAddr));

  00019	33 c0		 xor	 eax, eax
  0001b	89 85 e8 fc ff
	ff		 mov	 DWORD PTR _SocketAddr$[ebp], eax
  00021	89 85 ec fc ff
	ff		 mov	 DWORD PTR _SocketAddr$[ebp+4], eax
  00027	89 85 f0 fc ff
	ff		 mov	 DWORD PTR _SocketAddr$[ebp+8], eax
  0002d	89 85 f4 fc ff
	ff		 mov	 DWORD PTR _SocketAddr$[ebp+12], eax

; 2292 : 
; 2293 :     //建立网络
; 2294 :     SocketAddr.sin_family=AF_INET;

  00033	b9 02 00 00 00	 mov	 ecx, 2
  00038	66 89 8d e8 fc
	ff ff		 mov	 WORD PTR _SocketAddr$[ebp], cx

; 2295 :     SocketAddr.sin_addr.s_addr=INADDR_ANY;

  0003f	c7 85 ec fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _SocketAddr$[ebp+4], 0

; 2296 :     SocketAddr.sin_port=htons(m_AutoServicPort);

  00049	0f b7 55 08	 movzx	 edx, WORD PTR _m_AutoServicPort$[ebp]
  0004d	52		 push	 edx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00054	66 89 85 ea fc
	ff ff		 mov	 WORD PTR _SocketAddr$[ebp+2], ax

; 2297 :     m_hServerSocket=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,0,WSA_FLAG_OVERLAPPED);

  0005b	6a 01		 push	 1
  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	6a 06		 push	 6
  00063	6a 01		 push	 1
  00065	6a 02		 push	 2
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  0006d	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 81 1c 40 00
	00		 mov	 DWORD PTR [ecx+16412], eax

; 2298 : 
; 2299 :     //错误判断
; 2300 :     if (m_hServerSocket==INVALID_SOCKET) 

  00079	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0007f	83 ba 1c 40 00
	00 ff		 cmp	 DWORD PTR [edx+16412], -1
  00086	75 24		 jne	 SHORT $LN2@CreateSock

; 2301 :     {
; 2302 :         LPCTSTR pszString=TEXT("系统资源不足或者 TCP/IP 协议没有安装，网络启动失败");

  00088	c7 85 e0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _pszString$1[ebp], OFFSET ??_C@_0DD@KAEGCGFA@?O?$LF?M?$LD?W?J?T?$LE?$LC?$LL?W?c?$LL?r?U?$NP?5TCP?1IP?5?P?$KN?R?i?C?$LL?S@

; 2303 :         g_TraceServiceManager.TraceString(pszString,TraceLevel_Exception);

  00092	6a 03		 push	 3
  00094	8b 85 e0 fc ff
	ff		 mov	 eax, DWORD PTR _pszString$1[ebp]
  0009a	50		 push	 eax
  0009b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  000a0	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 2304 :         return false;

  000a5	32 c0		 xor	 al, al
  000a7	e9 44 01 00 00	 jmp	 $LN1@CreateSock
$LN2@CreateSock:

; 2305 :     }
; 2306 : 
; 2307 :     //绑定链接
; 2308 :     if(::bind(m_hServerSocket,(SOCKADDR *)&SocketAddr,sizeof(SocketAddr))==SOCKET_ERROR)

  000ac	6a 10		 push	 16			; 00000010H
  000ae	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR _SocketAddr$[ebp]
  000b4	51		 push	 ecx
  000b5	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000bb	8b 82 1c 40 00
	00		 mov	 eax, DWORD PTR [edx+16412]
  000c1	50		 push	 eax
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  000c8	83 f8 ff	 cmp	 eax, -1
  000cb	75 7d		 jne	 SHORT $LN3@CreateSock

; 2309 :     {
; 2310 : 		TCHAR pszString[MAX_PATH]=TEXT("");

  000cd	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_00CNPNBAHC@@
  000d3	88 8d f8 fe ff
	ff		 mov	 BYTE PTR _pszString$3[ebp], cl
  000d9	68 03 01 00 00	 push	 259			; 00000103H
  000de	6a 00		 push	 0
  000e0	8d 95 f9 fe ff
	ff		 lea	 edx, DWORD PTR _pszString$3[ebp+1]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 _memset
  000ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2311 : 		_sntprintf(pszString, CountArray(pszString), TEXT("网络绑定错误,启动失败.占用端口：%d"), m_AutoServicPort);

  000ef	0f b7 45 08	 movzx	 eax, WORD PTR _m_AutoServicPort$[ebp]
  000f3	50		 push	 eax
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FEECEEMH@?M?x?B?g?$LA?s?$LG?$KI?$LE?m?N?s?0?F?t?$LG?$KP?J?$KH?$LA?$NM?4?U?$LM?S?C?$LG?K?$LP?Z?$KD@
  000f9	68 04 01 00 00	 push	 260			; 00000104H
  000fe	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR _pszString$3[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 __snprintf
  0010a	83 c4 10	 add	 esp, 16			; 00000010H

; 2312 :         g_TraceServiceManager.TraceString(pszString,TraceLevel_Exception);

  0010d	6a 03		 push	 3
  0010f	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pszString$3[ebp]
  00115	52		 push	 edx
  00116	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0011b	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 2313 :         closesocket(m_hServerSocket);

  00120	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00126	8b 88 1c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16412]
  0012c	51		 push	 ecx
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 2314 :         m_hServerSocket = INVALID_SOCKET;

  00133	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00139	c7 82 1c 40 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+16412], -1

; 2315 :         return false;

  00143	32 c0		 xor	 al, al
  00145	e9 a6 00 00 00	 jmp	 $LN1@CreateSock
$LN3@CreateSock:

; 2316 :     }
; 2317 : 
; 2318 :     //监听端口
; 2319 :     if (listen(m_hServerSocket,200)==SOCKET_ERROR)

  0014a	68 c8 00 00 00	 push	 200			; 000000c8H
  0014f	8b 85 e4 fc ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00155	8b 88 1c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16412]
  0015b	51		 push	 ecx
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8
  00162	83 f8 ff	 cmp	 eax, -1
  00165	0f 85 83 00 00
	00		 jne	 $LN4@CreateSock

; 2320 :     {
; 2321 :         TCHAR szString[512]=TEXT("");

  0016b	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  00171	88 95 f8 fc ff
	ff		 mov	 BYTE PTR _szString$2[ebp], dl
  00177	68 ff 01 00 00	 push	 511			; 000001ffH
  0017c	6a 00		 push	 0
  0017e	8d 85 f9 fc ff
	ff		 lea	 eax, DWORD PTR _szString$2[ebp+1]
  00184	50		 push	 eax
  00185	e8 00 00 00 00	 call	 _memset
  0018a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2322 :         _sntprintf(szString,CountArray(szString),TEXT("端口正被其他服务占用，监听 %ld 端口失败"),m_wServicePort);

  0018d	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00193	0f b7 91 12 40
	00 00		 movzx	 edx, WORD PTR [ecx+16402]
  0019a	52		 push	 edx
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@ELCMGMJI@?$LG?K?$LP?Z?U?$PN?$LB?$LL?F?d?K?$PL?$LH?$PO?N?q?U?$LM?S?C?$KD?$KM?$LM?$OA?L?$PN?5?$CFld?5@
  001a0	68 00 02 00 00	 push	 512			; 00000200H
  001a5	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _szString$2[ebp]
  001ab	50		 push	 eax
  001ac	e8 00 00 00 00	 call	 __snprintf
  001b1	83 c4 10	 add	 esp, 16			; 00000010H

; 2323 :         g_TraceServiceManager.TraceString(szString,TraceLevel_Exception);

  001b4	6a 03		 push	 3
  001b6	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _szString$2[ebp]
  001bc	51		 push	 ecx
  001bd	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  001c2	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 2324 :         closesocket(m_hServerSocket);

  001c7	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001cd	8b 82 1c 40 00
	00		 mov	 eax, DWORD PTR [edx+16412]
  001d3	50		 push	 eax
  001d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 2325 :         m_hServerSocket = INVALID_SOCKET;

  001da	8b 8d e4 fc ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	c7 81 1c 40 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+16412], -1

; 2326 :         return false;

  001ea	32 c0		 xor	 al, al
  001ec	eb 02		 jmp	 SHORT $LN1@CreateSock
$LN4@CreateSock:

; 2327 :     }
; 2328 : 
; 2329 :     return true;

  001ee	b0 01		 mov	 al, 1
$LN1@CreateSock:

; 2330 : }

  001f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001f3	33 cd		 xor	 ecx, ebp
  001f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 04 00	 ret	 4
?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z ENDP		; CTCPNetworkEngine::CreateSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?WebAttestation@CTCPNetworkEngine@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?WebAttestation@CTCPNetworkEngine@@AAE_NXZ PROC		; CTCPNetworkEngine::WebAttestation, COMDAT
; _this$ = ecx

; 2206 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2207 :     // return true;	// added by lrq 2013-12-10
; 2208 : 
; 2209 :     // // 获取目录
; 2210 :     // TCHAR szPath[MAX_PATH]=TEXT("");
; 2211 :     // GetCurrentDirectory(sizeof(szPath),szPath);
; 2212 : 
; 2213 :     // // 读取配置
; 2214 :     // TCHAR szFileName[MAX_PATH]=TEXT("");;
; 2215 :     // _sntprintf(szFileName,CountArray(szFileName),TEXT("%s\\Validate.ini"),szPath);
; 2216 : 
; 2217 :     // // 变量定义
; 2218 :     // DWORD dwClientID=0L;
; 2219 :     // TCHAR szClientName[32]=TEXT("");
; 2220 :     // TCHAR szClientValidate[33]=TEXT("");
; 2221 : 
; 2222 :     // // 读取验证
; 2223 :     // dwClientID=GetPrivateProfileInt(TEXT("Data"),TEXT("ClientID"),0,szFileName);
; 2224 :     // GetPrivateProfileString(TEXT("Data"),TEXT("ClientName"),TEXT(""),szClientName,sizeof(szClientName),szFileName);
; 2225 :     // GetPrivateProfileString(TEXT("Data"),TEXT("ClientValidate"),TEXT(""),szClientValidate,sizeof(szClientValidate),szFileName);
; 2226 : 
; 2227 :     // // 变量定义
; 2228 :     // CInternetSession Seccion;
; 2229 :     // CStdioFile * pInternetFile=NULL;
; 2230 : 
; 2231 :     // try
; 2232 :     // {
; 2233 :     // 	// 构造验证
; 2234 :     // 	TCHAR szAttestation[512]=TEXT("");
; 2235 :     // 	_sntprintf(szAttestation,CountArray(szAttestation),TEXT("http:// www.gamexx.net.com/Attestation.html?Version=66&ClientID=%ld&ClientName=%s&Validate=%s"),
; 2236 :     // 		dwClientID,szClientName,szClientValidate);
; 2237 : 
; 2238 :     // 	// 执行验证
; 2239 :     // 	TCHAR szResult[1024]=TEXT("");
; 2240 :     // 	pInternetFile=Seccion.OpenURL(szAttestation);
; 2241 :     // 	UINT uReadCount=pInternetFile->Read(szResult,sizeof(szResult));
; 2242 :     // 	szResult[__min(uReadCount,CountArray(szResult)-1)]=0;
; 2243 : 
; 2244 :     // 	// 停止判断
; 2245 :     // 	if ((uReadCount>=2)&&(szResult[0]==TEXT('0'))&&(szResult[1]==TEXT(';')))
; 2246 :     // 	{
; 2247 :     // 		// 设置变量
; 2248 :     // 		m_bValidate=false;
; 2249 :     // 		m_bNormalRun=false;
; 2250 : 
; 2251 :     // 		// 提示信息
; 2252 :     // 		g_TraceServiceManager.TraceString(TEXT("您的服务器组件没有得到合法授权，请联系“疯石游戏” http:// www.gamexx.net"),TraceLevel_Exception);
; 2253 : 
; 2254 :     // 		return false;
; 2255 :     // 	}
; 2256 : 
; 2257 :     // 	// 验证判断
; 2258 :     // 	if ((uReadCount>(UINT)lstrlen(szClientValidate))&&(memcmp(szClientValidate,szResult,lstrlen(szClientValidate)*sizeof(TCHAR))==0))
; 2259 :     // 	{
; 2260 :     // 		// 设置变量
; 2261 :     // 		m_bValidate=true;
; 2262 :     // 		m_bNormalRun=true;
; 2263 : 
; 2264 :     // 		return true;
; 2265 :     // 	}
; 2266 :     // 	else
; 2267 :     // 	{
; 2268 :     // 		// 设置变量
; 2269 :     // 		m_bValidate=false;
; 2270 :     // 		m_bNormalRun=true;
; 2271 : 
; 2272 :     // 		return false;
; 2273 :     // 	}
; 2274 : 
; 2275 :     // 	return true;
; 2276 :     // }
; 2277 :     // catch (...) {}
; 2278 : 
; 2279 :     // 设置变量
; 2280 :     m_bValidate = true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 2281 :     m_bNormalRun = true;

  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	c6 41 0d 01	 mov	 BYTE PTR [ecx+13], 1

; 2282 : 
; 2283 :     return true;

  00015	b0 01		 mov	 al, 1

; 2284 : }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?WebAttestation@CTCPNetworkEngine@@AAE_NXZ ENDP		; CTCPNetworkEngine::WebAttestation
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?DetectSocket@CTCPNetworkEngine@@AAE_NXZ
_TEXT	SEGMENT
_data$ = -8						; size = 4
_this$ = -4						; size = 4
?DetectSocket@CTCPNetworkEngine@@AAE_NXZ PROC		; CTCPNetworkEngine::DetectSocket, COMDAT
; _this$ = ecx

; 2198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2199 :     // 发送请求
; 2200 :     void* data = NULL;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _data$[ebp], 0

; 2201 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_DETECT_SOCKET, data, 0);

  00010	6a 00		 push	 0
  00012	8b 45 f8	 mov	 eax, DWORD PTR _data$[ebp]
  00015	50		 push	 eax
  00016	6a 06		 push	 6
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 82 c0 40 00
	00		 mov	 eax, DWORD PTR [edx+16576]
  0002a	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0002d	ff d2		 call	 edx

; 2202 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?DetectSocket@CTCPNetworkEngine@@AAE_NXZ ENDP		; CTCPNetworkEngine::DetectSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventSocketRead@CTCPNetworkEngine@@UAE_NUTCP_Command@@PAXGPAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_dwSocketID$ = -24					; size = 4
_dwThancferred$1 = -20					; size = 4
_pTCPNetworkItem$2 = -16				; size = 4
_pOverLapped$3 = -12					; size = 4
_hCompletionPort$4 = -8					; size = 4
_this$ = -4						; size = 4
_Command$ = 8						; size = 4
_pData$ = 12						; size = 4
_wDataSize$ = 16					; size = 2
_pTCPNetworkItem$ = 20					; size = 4
?OnEventSocketRead@CTCPNetworkEngine@@UAE_NUTCP_Command@@PAXGPAVCTCPNetworkItem@@@Z PROC ; CTCPNetworkEngine::OnEventSocketRead, COMDAT
; _this$ = ecx

; 2165 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2166 :     // 效验数据
; 2167 :     ASSERT(pTCPNetworkItem != NULL);

  00009	83 7d 14 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  0000d	75 14		 jne	 SHORT $LN6@OnEventSoc
  0000f	68 77 08 00 00	 push	 2167			; 00000877H
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN6@OnEventSoc
  00022	cc		 int	 3
$LN6@OnEventSoc:

; 2168 :     ASSERT(m_pITCPNetworkEngineEvent != NULL);

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 b9 1c 40 00
	00 00		 cmp	 DWORD PTR [ecx+16412], 0
  0002d	75 14		 jne	 SHORT $LN7@OnEventSoc
  0002f	68 78 08 00 00	 push	 2168			; 00000878H
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00039	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0003e	85 c0		 test	 eax, eax
  00040	74 01		 je	 SHORT $LN7@OnEventSoc
  00042	cc		 int	 3
$LN7@OnEventSoc:

; 2169 : 
; 2170 :     // 运行判断
; 2171 :     if (m_bNormalRun == false)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 54		 jne	 SHORT $LN14@OnEventSoc

; 2172 :     {
; 2173 :         // 创建对象
; 2174 :         HANDLE hCompletionPort = NULL;

  0004e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hCompletionPort$4[ebp], 0

; 2175 :         hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, 1);

  00055	6a 01		 push	 1
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a ff		 push	 -1
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  00063	89 45 f8	 mov	 DWORD PTR _hCompletionPort$4[ebp], eax
$LN2@OnEventSoc:

; 2176 : 
; 2177 :         // 进入循环
; 2178 :         while (true)

  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	85 d2		 test	 edx, edx
  0006d	74 2f		 je	 SHORT $LN3@OnEventSoc

; 2179 :         {
; 2180 :             DWORD dwThancferred = 0;

  0006f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _dwThancferred$1[ebp], 0

; 2181 :             OVERLAPPED * pOverLapped = NULL;

  00076	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pOverLapped$3[ebp], 0

; 2182 :             CTCPNetworkItem * pTCPNetworkItem = NULL;

  0007d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkItem$2[ebp], 0

; 2183 :             GetQueuedCompletionStatus(hCompletionPort, &dwThancferred, (PULONG_PTR)&pTCPNetworkItem, &pOverLapped, INFINITE);

  00084	6a ff		 push	 -1
  00086	8d 45 f4	 lea	 eax, DWORD PTR _pOverLapped$3[ebp]
  00089	50		 push	 eax
  0008a	8d 4d f0	 lea	 ecx, DWORD PTR _pTCPNetworkItem$2[ebp]
  0008d	51		 push	 ecx
  0008e	8d 55 ec	 lea	 edx, DWORD PTR _dwThancferred$1[ebp]
  00091	52		 push	 edx
  00092	8b 45 f8	 mov	 eax, DWORD PTR _hCompletionPort$4[ebp]
  00095	50		 push	 eax
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueuedCompletionStatus@20

; 2184 :         }

  0009c	eb c8		 jmp	 SHORT $LN2@OnEventSoc
$LN3@OnEventSoc:

; 2185 : 
; 2186 :         return false;

  0009e	32 c0		 xor	 al, al
  000a0	eb 54		 jmp	 SHORT $LN1@OnEventSoc
$LN14@OnEventSoc:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  000a2	8b 4d 14	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  000a5	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000a9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000af	0f b7 c2	 movzx	 eax, dx
  000b2	c1 e0 10	 shl	 eax, 16			; 00000010H
  000b5	8b 4d 14	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  000b8	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  000bc	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000c2	0f b7 ca	 movzx	 ecx, dx
  000c5	0b c8		 or	 ecx, eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2190 :     DWORD dwSocketID = pTCPNetworkItem->GetIdentifierID();

  000c7	89 4d e8	 mov	 DWORD PTR _dwSocketID$[ebp], ecx

; 2191 :     m_pITCPNetworkEngineEvent->OnEventTCPNetworkRead(dwSocketID, Command, pData, wDataSize);

  000ca	0f b7 55 10	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  000ce	52		 push	 edx
  000cf	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _Command$[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 e8	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  000da	52		 push	 edx
  000db	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000de	8b 88 1c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16412]
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000e9	8b 8a 1c 40 00
	00		 mov	 ecx, DWORD PTR [edx+16412]
  000ef	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  000f2	ff d2		 call	 edx

; 2192 : 
; 2193 :     return true;

  000f4	b0 01		 mov	 al, 1
$LN1@OnEventSoc:

; 2194 : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 10 00	 ret	 16			; 00000010H
?OnEventSocketRead@CTCPNetworkEngine@@UAE_NUTCP_Command@@PAXGPAVCTCPNetworkItem@@@Z ENDP ; CTCPNetworkEngine::OnEventSocketRead
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_dwSocketID$2 = -32					; size = 4
_dwClientIP$3 = -28					; size = 4
_dwActiveTime$4 = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pTCPNetworkItem$ = 8					; size = 4
?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z PROC ; CTCPNetworkEngine::OnEventSocketShut, COMDAT
; _this$ = ecx

; 2142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 10	 sub	 esp, 16			; 00000010H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2143 :     // 效验参数
; 2144 :     ASSERT(pTCPNetworkItem != NULL);

  0002f	83 7d 08 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  00033	75 14		 jne	 SHORT $LN4@OnEventSoc
  00035	68 60 08 00 00	 push	 2144			; 00000860H
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0003f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00044	85 c0		 test	 eax, eax
  00046	74 01		 je	 SHORT $LN4@OnEventSoc
  00048	cc		 int	 3
$LN4@OnEventSoc:

; 2145 :     ASSERT(m_pITCPNetworkEngineEvent != NULL);

  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 b9 1c 40 00
	00 00		 cmp	 DWORD PTR [ecx+16412], 0
  00053	75 14		 jne	 SHORT $LN5@OnEventSoc
  00055	68 61 08 00 00	 push	 2145			; 00000861H
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0005f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00064	85 c0		 test	 eax, eax
  00066	74 01		 je	 SHORT $LN5@OnEventSoc
  00068	cc		 int	 3
$LN5@OnEventSoc:

; 2146 : 
; 2147 :     try

  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 201  :     inline DWORD GetClientIP() { return m_dwClientIP; }

  00070	8b 45 08	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  00073	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00076	89 4d e4	 mov	 DWORD PTR _dwClientIP$3[ebp], ecx

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  00079	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  0007c	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00080	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00085	0f b7 c8	 movzx	 ecx, ax
  00088	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0008b	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  0008e	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00092	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00097	0f b7 d0	 movzx	 edx, ax
  0009a	0b d1		 or	 edx, ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2151 :         DWORD dwSocketID = pTCPNetworkItem->GetIdentifierID();

  0009c	89 55 e0	 mov	 DWORD PTR _dwSocketID$2[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 203  :     inline DWORD GetActiveTime() { return m_dwActiveTime; }

  0009f	8b 45 08	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  000a2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a5	89 4d e8	 mov	 DWORD PTR _dwActiveTime$4[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2153 :         m_pITCPNetworkEngineEvent->OnEventTCPNetworkShut(dwSocketID, dwClientIP, dwActiveTime);

  000a8	8b 55 e8	 mov	 edx, DWORD PTR _dwActiveTime$4[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 e4	 mov	 eax, DWORD PTR _dwClientIP$3[ebp]
  000af	50		 push	 eax
  000b0	8b 4d e0	 mov	 ecx, DWORD PTR _dwSocketID$2[ebp]
  000b3	51		 push	 ecx
  000b4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000b7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	8b 88 1c 40 00
	00		 mov	 ecx, DWORD PTR [eax+16412]
  000c0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c2	8b 8a 1c 40 00
	00		 mov	 ecx, DWORD PTR [edx+16412]
  000c8	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000cb	ff d2		 call	 edx

; 2154 : 
; 2155 :         // 释放连接
; 2156 :         FreeNetworkItem(pTCPNetworkItem);

  000cd	8b 45 08	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  000d0	50		 push	 eax
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	83 e9 08	 sub	 ecx, 8
  000d7	e8 00 00 00 00	 call	 ?FreeNetworkItem@CTCPNetworkEngine@@IAE_NPAVCTCPNetworkItem@@@Z ; CTCPNetworkEngine::FreeNetworkItem

; 2157 :     }

  000dc	eb 06		 jmp	 SHORT $LN6@OnEventSoc
__catch$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$0:

; 2158 :     catch (...) {}

  000de	b8 00 00 00 00	 mov	 eax, $LN9@OnEventSoc
  000e3	c3		 ret	 0
$LN6@OnEventSoc:
  000e4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000eb	eb 07		 jmp	 SHORT __tryend$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$1
$LN9@OnEventSoc:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
  000ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z$1:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2159 : 
; 2160 :     return true;

  000f4	b0 01		 mov	 al, 1

; 2161 : }

  000f6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00100	59		 pop	 ecx
  00101	5f		 pop	 edi
  00102	5e		 pop	 esi
  00103	5b		 pop	 ebx
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventSocketShut@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z ENDP ; CTCPNetworkEngine::OnEventSocketShut
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventSocketBind@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_dwSocketID$ = -12					; size = 4
_dwClientIP$ = -8					; size = 4
_this$ = -4						; size = 4
_pTCPNetworkItem$ = 8					; size = 4
?OnEventSocketBind@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z PROC ; CTCPNetworkEngine::OnEventSocketBind, COMDAT
; _this$ = ecx

; 2127 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2128 :     // 效验数据
; 2129 :     ASSERT(pTCPNetworkItem != NULL);

  00009	83 7d 08 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  0000d	75 14		 jne	 SHORT $LN3@OnEventSoc
  0000f	68 51 08 00 00	 push	 2129			; 00000851H
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN3@OnEventSoc
  00022	cc		 int	 3
$LN3@OnEventSoc:

; 2130 :     ASSERT(m_pITCPNetworkEngineEvent != NULL);

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 b9 1c 40 00
	00 00		 cmp	 DWORD PTR [ecx+16412], 0
  0002d	75 14		 jne	 SHORT $LN4@OnEventSoc
  0002f	68 52 08 00 00	 push	 2130			; 00000852H
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00039	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0003e	85 c0		 test	 eax, eax
  00040	74 01		 je	 SHORT $LN4@OnEventSoc
  00042	cc		 int	 3
$LN4@OnEventSoc:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 201  :     inline DWORD GetClientIP() { return m_dwClientIP; }

  00043	8b 45 08	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	89 4d f8	 mov	 DWORD PTR _dwClientIP$[ebp], ecx

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  0004c	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  0004f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00053	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00058	0f b7 c8	 movzx	 ecx, ax
  0005b	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  00061	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00065	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0006a	0f b7 d0	 movzx	 edx, ax
  0006d	0b d1		 or	 edx, ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2134 :     DWORD dwSocketID = pTCPNetworkItem->GetIdentifierID();

  0006f	89 55 f4	 mov	 DWORD PTR _dwSocketID$[ebp], edx

; 2135 :     m_pITCPNetworkEngineEvent->OnEventTCPNetworkBind(dwSocketID, dwClientIP);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _dwClientIP$[ebp]
  00075	50		 push	 eax
  00076	8b 4d f4	 mov	 ecx, DWORD PTR _dwSocketID$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	8b 82 1c 40 00
	00		 mov	 eax, DWORD PTR [edx+16412]
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 10		 mov	 edx, DWORD PTR [eax]
  00088	8b 89 1c 40 00
	00		 mov	 ecx, DWORD PTR [ecx+16412]
  0008e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00091	ff d0		 call	 eax

; 2136 : 
; 2137 :     return true;

  00093	b0 01		 mov	 al, 1

; 2138 : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 04 00	 ret	 4
?OnEventSocketBind@CTCPNetworkEngine@@UAE_NPAVCTCPNetworkItem@@@Z ENDP ; CTCPNetworkEngine::OnEventSocketBind
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z
_TEXT	SEGMENT
_ThreadLock$2 = -216					; size = 12
_ThreadLock$3 = -204					; size = 12
_ThreadLock$4 = -192					; size = 12
_SocketThreadLock$5 = -180				; size = 12
_SocketThreadLock$6 = -168				; size = 12
_ThreadLock$7 = -156					; size = 12
_ItemThreadLock$8 = -144				; size = 12
_ThreadLock$9 = -132					; size = 12
_dwNowTime$10 = -120					; size = 4
$T11 = -116						; size = 4
$T12 = -112						; size = 4
$T13 = -108						; size = 4
tv333 = -104						; size = 4
tv434 = -100						; size = 4
tv433 = -96						; size = 4
_pCloseSocket$14 = -92					; size = 4
_pShutDownSocket$15 = -88				; size = 4
_pTCPNetworkItem$16 = -84				; size = 4
_pTCPNetworkItem$17 = -80				; size = 4
_pTCPNetworkItem$18 = -76				; size = 4
_pTCPNetworkItem$19 = -72				; size = 4
$T20 = -68						; size = 2
$T21 = -66						; size = 2
$T22 = -64						; size = 2
$T23 = -62						; size = 2
_i$24 = -60						; size = 4
_pAllowBatchSend$25 = -56				; size = 4
_i$26 = -52						; size = 4
tv65 = -48						; size = 4
_pTCPNetworkItem$27 = -44				; size = 4
_pBatchSendRequest$28 = -40				; size = 4
_pSendDataRequest$29 = -36				; size = 4
$T30 = -30						; size = 1
$T31 = -29						; size = 1
$T32 = -28						; size = 1
$T33 = -27						; size = 1
$T34 = -26						; size = 1
$T35 = -25						; size = 1
$T36 = -24						; size = 1
$T37 = -23						; size = 1
$T38 = -22						; size = 1
tv262 = -21						; size = 1
_this$ = -20						; size = 4
_pTCPNetworkItem$39 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_wIdentifier$ = 8					; size = 2
_pData$ = 12						; size = 4
_wDataSize$ = 16					; size = 2
?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z PROC ; CTCPNetworkEngine::OnAsynchronismEngineData, COMDAT
; _this$ = ecx

; 1959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1960 :     switch (wIdentifier)

  0002b	0f b7 45 08	 movzx	 eax, WORD PTR _wIdentifier$[ebp]
  0002f	89 45 d0	 mov	 DWORD PTR tv65[ebp], eax
  00032	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  00035	83 e9 01	 sub	 ecx, 1
  00038	89 4d d0	 mov	 DWORD PTR tv65[ebp], ecx
  0003b	83 7d d0 05	 cmp	 DWORD PTR tv65[ebp], 5
  0003f	0f 87 27 06 00
	00		 ja	 $LN2@OnAsynchro
  00045	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  00048	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN121@OnAsynchro[edx*4]
$LN12@OnAsynchro:

; 1961 :     {
; 1962 :         case ASYNCHRONISM_SEND_DATA:		// 发送请求
; 1963 :         {
; 1964 :             // 效验数据
; 1965 :             tagSendDataRequest * pSendDataRequest = (tagSendDataRequest *)pData;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  00052	89 45 dc	 mov	 DWORD PTR _pSendDataRequest$29[ebp], eax

; 1966 :             ASSERT(wDataSize >= (sizeof(tagSendDataRequest) - sizeof(pSendDataRequest->cbSendBuffer)));

  00055	0f b7 4d 10	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00059	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0005c	73 14		 jae	 SHORT $LN32@OnAsynchro
  0005e	68 ae 07 00 00	 push	 1966			; 000007aeH
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00068	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0006d	85 c0		 test	 eax, eax
  0006f	74 01		 je	 SHORT $LN32@OnAsynchro
  00071	cc		 int	 3
$LN32@OnAsynchro:

; 1967 :             ASSERT(wDataSize == (pSendDataRequest->wDataSize + sizeof(tagSendDataRequest) - sizeof(pSendDataRequest->cbSendBuffer)));

  00072	0f b7 45 10	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00076	8b 4d dc	 mov	 ecx, DWORD PTR _pSendDataRequest$29[ebp]
  00079	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  0007d	83 c2 0a	 add	 edx, 10			; 0000000aH
  00080	3b c2		 cmp	 eax, edx
  00082	74 14		 je	 SHORT $LN33@OnAsynchro
  00084	68 af 07 00 00	 push	 1967			; 000007afH
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0008e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00093	85 c0		 test	 eax, eax
  00095	74 01		 je	 SHORT $LN33@OnAsynchro
  00097	cc		 int	 3
$LN33@OnAsynchro:

; 1968 : 
; 1969 :             // 获取对象
; 1970 :             CTCPNetworkItem * pTCPNetworkItem = GetNetworkItem(pSendDataRequest->wIndex);

  00098	8b 4d dc	 mov	 ecx, DWORD PTR _pSendDataRequest$29[ebp]
  0009b	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0009e	52		 push	 edx
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	83 e9 04	 sub	 ecx, 4
  000a5	e8 00 00 00 00	 call	 ?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ; CTCPNetworkEngine::GetNetworkItem
  000aa	89 45 b8	 mov	 DWORD PTR _pTCPNetworkItem$19[ebp], eax

; 1971 :             if (pTCPNetworkItem == NULL)

  000ad	83 7d b8 00	 cmp	 DWORD PTR _pTCPNetworkItem$19[ebp], 0
  000b1	75 07		 jne	 SHORT $LN56@OnAsynchro

; 1972 :                 return false;

  000b3	32 c0		 xor	 al, al
  000b5	e9 cc 05 00 00	 jmp	 $LN1@OnAsynchro
$LN56@OnAsynchro:

; 1975 :             CWHDataLocker SocketThreadLock(pTCPNetworkItem->GetCriticalSection());

  000ba	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  000bc	8b 45 b8	 mov	 eax, DWORD PTR _pTCPNetworkItem$19[ebp]
  000bf	83 c0 18	 add	 eax, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1975 :             CWHDataLocker SocketThreadLock(pTCPNetworkItem->GetCriticalSection());

  000c2	50		 push	 eax
  000c3	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$6[ebp]
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  000cf	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1976 :             pTCPNetworkItem->SendData(pSendDataRequest->cbSendBuffer, pSendDataRequest->wDataSize, pSendDataRequest->wMainCmdID,

  000d6	8b 4d dc	 mov	 ecx, DWORD PTR _pSendDataRequest$29[ebp]
  000d9	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  000dd	52		 push	 edx
  000de	8b 45 dc	 mov	 eax, DWORD PTR _pSendDataRequest$29[ebp]
  000e1	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  000e5	51		 push	 ecx
  000e6	8b 55 dc	 mov	 edx, DWORD PTR _pSendDataRequest$29[ebp]
  000e9	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  000ed	50		 push	 eax
  000ee	8b 4d dc	 mov	 ecx, DWORD PTR _pSendDataRequest$29[ebp]
  000f1	0f b7 51 08	 movzx	 edx, WORD PTR [ecx+8]
  000f5	52		 push	 edx
  000f6	8b 45 dc	 mov	 eax, DWORD PTR _pSendDataRequest$29[ebp]
  000f9	83 c0 0a	 add	 eax, 10			; 0000000aH
  000fc	50		 push	 eax
  000fd	8b 4d b8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$19[ebp]
  00100	e8 00 00 00 00	 call	 ?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z ; CTCPNetworkItem::SendData

; 1977 :                 pSendDataRequest->wSubCmdID, pSendDataRequest->wRountID);
; 1978 : 
; 1979 :             return true;

  00105	c6 45 ea 01	 mov	 BYTE PTR $T38[ebp], 1
  00109	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00110	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$6[ebp]
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0011c	8a 45 ea	 mov	 al, BYTE PTR $T38[ebp]
  0011f	e9 62 05 00 00	 jmp	 $LN1@OnAsynchro
$LN14@OnAsynchro:

; 1980 :         }
; 1981 :         case ASYNCHRONISM_SEND_BATCH:		// 群发请求
; 1982 :         {
; 1983 :             // 效验数据
; 1984 :             tagBatchSendRequest * pBatchSendRequest = (tagBatchSendRequest *)pData;

  00124	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  00127	89 4d d8	 mov	 DWORD PTR _pBatchSendRequest$28[ebp], ecx

; 1985 :             ASSERT(wDataSize >= (sizeof(tagBatchSendRequest) - sizeof(pBatchSendRequest->cbSendBuffer)));

  0012a	0f b7 55 10	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  0012e	83 fa 08	 cmp	 edx, 8
  00131	73 14		 jae	 SHORT $LN34@OnAsynchro
  00133	68 c1 07 00 00	 push	 1985			; 000007c1H
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0013d	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00142	85 c0		 test	 eax, eax
  00144	74 01		 je	 SHORT $LN34@OnAsynchro
  00146	cc		 int	 3
$LN34@OnAsynchro:

; 1986 :             ASSERT(wDataSize == (pBatchSendRequest->wDataSize + sizeof(tagBatchSendRequest) - sizeof(pBatchSendRequest->cbSendBuffer)));

  00147	0f b7 4d 10	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  0014b	8b 55 d8	 mov	 edx, DWORD PTR _pBatchSendRequest$28[ebp]
  0014e	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00152	83 c0 08	 add	 eax, 8
  00155	3b c8		 cmp	 ecx, eax
  00157	74 14		 je	 SHORT $LN35@OnAsynchro
  00159	68 c2 07 00 00	 push	 1986			; 000007c2H
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00163	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00168	85 c0		 test	 eax, eax
  0016a	74 01		 je	 SHORT $LN35@OnAsynchro
  0016c	cc		 int	 3
$LN35@OnAsynchro:

; 1987 : 
; 1988 :             // 获取活动项
; 1989 :             CWHDataLocker ItemThreadLock(m_ItemLocked);

  0016d	6a 01		 push	 1
  0016f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00172	81 c2 24 40 00
	00		 add	 edx, 16420		; 00004024H
  00178	52		 push	 edx
  00179	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ItemThreadLock$8[ebp]
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00185	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1990 :             m_TempNetworkItemArray.Copy(m_NetworkItemActive);

  0018c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	05 5c 40 00 00	 add	 eax, 16476		; 0000405cH
  00194	50		 push	 eax
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	81 c1 84 40 00
	00		 add	 ecx, 16516		; 00004084H
  0019e	e8 00 00 00 00	 call	 ?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Copy

; 1991 :             ItemThreadLock.UnLock();

  001a3	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ItemThreadLock$8[ebp]
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UnLock@CWHDataLocker@@QAEXXZ

; 1994 :             for (INT_PTR i = 0; i < m_TempNetworkItemArray.GetCount(); i++)

  001af	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _i$26[ebp], 0
  001b6	eb 09		 jmp	 SHORT $LN6@OnAsynchro
$LN4@OnAsynchro:
  001b8	8b 4d cc	 mov	 ecx, DWORD PTR _i$26[ebp]
  001bb	83 c1 01	 add	 ecx, 1
  001be	89 4d cc	 mov	 DWORD PTR _i$26[ebp], ecx
$LN6@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  001c1	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001c4	8b 82 94 40 00
	00		 mov	 eax, DWORD PTR [edx+16532]
  001ca	89 45 94	 mov	 DWORD PTR $T13[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1994 :             for (INT_PTR i = 0; i < m_TempNetworkItemArray.GetCount(); i++)

  001cd	8b 4d cc	 mov	 ecx, DWORD PTR _i$26[ebp]
  001d0	3b 4d 94	 cmp	 ecx, DWORD PTR $T13[ebp]
  001d3	0f 8d a4 00 00
	00		 jge	 $LN5@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  001d9	8b 55 cc	 mov	 edx, DWORD PTR _i$26[ebp]
  001dc	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1997 :                 CTCPNetworkItem * pTCPNetworkItem = m_TempNetworkItemArray[i];

  001dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	81 c1 84 40 00
	00		 add	 ecx, 16516		; 00004084H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  001e6	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1997 :                 CTCPNetworkItem * pTCPNetworkItem = m_TempNetworkItemArray[i];

  001eb	8b 00		 mov	 eax, DWORD PTR [eax]
  001ed	89 45 d4	 mov	 DWORD PTR _pTCPNetworkItem$27[ebp], eax

; 1998 :                 CWHDataLocker SocketThreadLock(pTCPNetworkItem->GetCriticalSection());

  001f0	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  001f2	8b 4d d4	 mov	 ecx, DWORD PTR _pTCPNetworkItem$27[ebp]
  001f5	83 c1 18	 add	 ecx, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1998 :                 CWHDataLocker SocketThreadLock(pTCPNetworkItem->GetCriticalSection());

  001f8	51		 push	 ecx
  001f9	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$5[ebp]
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00205	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 218  :     inline bool IsAllowBatch() { return m_bAllowBatch; }

  00209	8b 55 d4	 mov	 edx, DWORD PTR _pTCPNetworkItem$27[ebp]
  0020c	8a 42 47	 mov	 al, BYTE PTR [edx+71]
  0020f	88 45 e9	 mov	 BYTE PTR $T37[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2001 :                 if (pTCPNetworkItem->IsAllowBatch() && pTCPNetworkItem->GetBatchMask() == pBatchSendRequest->cbBatchMask)

  00212	0f b6 4d e9	 movzx	 ecx, BYTE PTR $T37[ebp]
  00216	85 c9		 test	 ecx, ecx
  00218	74 4e		 je	 SHORT $LN15@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 226  :     inline BYTE GetBatchMask() { return m_bBatchMask; }

  0021a	8b 55 d4	 mov	 edx, DWORD PTR _pTCPNetworkItem$27[ebp]
  0021d	8a 42 48	 mov	 al, BYTE PTR [edx+72]
  00220	88 45 e8	 mov	 BYTE PTR $T36[ebp], al
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2001 :                 if (pTCPNetworkItem->IsAllowBatch() && pTCPNetworkItem->GetBatchMask() == pBatchSendRequest->cbBatchMask)

  00223	0f b6 4d e8	 movzx	 ecx, BYTE PTR $T36[ebp]
  00227	8b 55 d8	 mov	 edx, DWORD PTR _pBatchSendRequest$28[ebp]
  0022a	0f b6 42 06	 movzx	 eax, BYTE PTR [edx+6]
  0022e	3b c8		 cmp	 ecx, eax
  00230	75 36		 jne	 SHORT $LN15@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  00232	8b 4d d4	 mov	 ecx, DWORD PTR _pTCPNetworkItem$27[ebp]
  00235	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00239	66 89 55 c2	 mov	 WORD PTR $T23[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2003 :                     pTCPNetworkItem->SendData(pBatchSendRequest->cbSendBuffer, pBatchSendRequest->wDataSize, pBatchSendRequest->wMainCmdID,

  0023d	0f b7 45 c2	 movzx	 eax, WORD PTR $T23[ebp]
  00241	50		 push	 eax
  00242	8b 4d d8	 mov	 ecx, DWORD PTR _pBatchSendRequest$28[ebp]
  00245	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00249	52		 push	 edx
  0024a	8b 45 d8	 mov	 eax, DWORD PTR _pBatchSendRequest$28[ebp]
  0024d	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00250	51		 push	 ecx
  00251	8b 55 d8	 mov	 edx, DWORD PTR _pBatchSendRequest$28[ebp]
  00254	0f b7 42 04	 movzx	 eax, WORD PTR [edx+4]
  00258	50		 push	 eax
  00259	8b 4d d8	 mov	 ecx, DWORD PTR _pBatchSendRequest$28[ebp]
  0025c	83 c1 07	 add	 ecx, 7
  0025f	51		 push	 ecx
  00260	8b 4d d4	 mov	 ecx, DWORD PTR _pTCPNetworkItem$27[ebp]
  00263	e8 00 00 00 00	 call	 ?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z ; CTCPNetworkItem::SendData
$LN15@OnAsynchro:

; 2004 :                         pBatchSendRequest->wSubCmdID, pTCPNetworkItem->GetRountID());
; 2005 :                 }
; 2006 :             }

  00268	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0026c	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$5[ebp]
  00272	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00278	e9 3b ff ff ff	 jmp	 $LN4@OnAsynchro
$LN5@OnAsynchro:

; 2007 : 
; 2008 :             return true;

  0027d	c6 45 e7 01	 mov	 BYTE PTR $T35[ebp], 1
  00281	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00288	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ItemThreadLock$8[ebp]
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00294	8a 45 e7	 mov	 al, BYTE PTR $T35[ebp]
  00297	e9 ea 03 00 00	 jmp	 $LN1@OnAsynchro
$LN16@OnAsynchro:

; 2009 :         }
; 2010 :         case ASYNCHRONISM_SHUT_DOWN:		// 安全关闭
; 2011 :         {
; 2012 :             // 效验数据
; 2013 :             ASSERT(wDataSize == sizeof(tagShutDownSocket));

  0029c	0f b7 55 10	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  002a0	83 fa 04	 cmp	 edx, 4
  002a3	74 14		 je	 SHORT $LN36@OnAsynchro
  002a5	68 dd 07 00 00	 push	 2013			; 000007ddH
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  002af	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  002b4	85 c0		 test	 eax, eax
  002b6	74 01		 je	 SHORT $LN36@OnAsynchro
  002b8	cc		 int	 3
$LN36@OnAsynchro:

; 2014 :             tagShutDownSocket * pShutDownSocket = (tagShutDownSocket *)pData;

  002b9	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  002bc	89 4d a8	 mov	 DWORD PTR _pShutDownSocket$15[ebp], ecx

; 2015 : 
; 2016 :             // 获取对象
; 2017 :             CTCPNetworkItem * pTCPNetworkItem = GetNetworkItem(pShutDownSocket->wIndex);

  002bf	8b 55 a8	 mov	 edx, DWORD PTR _pShutDownSocket$15[ebp]
  002c2	0f b7 02	 movzx	 eax, WORD PTR [edx]
  002c5	50		 push	 eax
  002c6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002c9	83 e9 04	 sub	 ecx, 4
  002cc	e8 00 00 00 00	 call	 ?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ; CTCPNetworkEngine::GetNetworkItem
  002d1	89 45 b4	 mov	 DWORD PTR _pTCPNetworkItem$18[ebp], eax

; 2018 :             if (pTCPNetworkItem == NULL)

  002d4	83 7d b4 00	 cmp	 DWORD PTR _pTCPNetworkItem$18[ebp], 0
  002d8	75 07		 jne	 SHORT $LN79@OnAsynchro

; 2019 :                 return false;

  002da	32 c0		 xor	 al, al
  002dc	e9 a5 03 00 00	 jmp	 $LN1@OnAsynchro
$LN79@OnAsynchro:

; 2022 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  002e1	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  002e3	8b 4d b4	 mov	 ecx, DWORD PTR _pTCPNetworkItem$18[ebp]
  002e6	83 c1 18	 add	 ecx, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2022 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  002e9	51		 push	 ecx
  002ea	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$4[ebp]
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  002f6	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 2023 :             pTCPNetworkItem->ShutDownSocket(pShutDownSocket->wRountID);

  002fd	8b 55 a8	 mov	 edx, DWORD PTR _pShutDownSocket$15[ebp]
  00300	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00304	50		 push	 eax
  00305	8b 4d b4	 mov	 ecx, DWORD PTR _pTCPNetworkItem$18[ebp]
  00308	e8 00 00 00 00	 call	 ?ShutDownSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::ShutDownSocket

; 2024 : 
; 2025 :             return true;

  0030d	c6 45 e6 01	 mov	 BYTE PTR $T34[ebp], 1
  00311	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00318	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$4[ebp]
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00324	8a 45 e6	 mov	 al, BYTE PTR $T34[ebp]
  00327	e9 5a 03 00 00	 jmp	 $LN1@OnAsynchro
$LN18@OnAsynchro:

; 2026 :         }
; 2027 :         case ASYNCHRONISM_ALLOW_BATCH:		// 允许群发
; 2028 :         {
; 2029 :             // 效验数据
; 2030 :             ASSERT(wDataSize == sizeof(tagAllowBatchSend));

  0032c	0f b7 4d 10	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00330	83 f9 06	 cmp	 ecx, 6
  00333	74 14		 je	 SHORT $LN37@OnAsynchro
  00335	68 ee 07 00 00	 push	 2030			; 000007eeH
  0033a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0033f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00344	85 c0		 test	 eax, eax
  00346	74 01		 je	 SHORT $LN37@OnAsynchro
  00348	cc		 int	 3
$LN37@OnAsynchro:

; 2031 :             tagAllowBatchSend * pAllowBatchSend = (tagAllowBatchSend *)pData;

  00349	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  0034c	89 45 c8	 mov	 DWORD PTR _pAllowBatchSend$25[ebp], eax

; 2032 : 
; 2033 :             // 获取对象
; 2034 :             CTCPNetworkItem * pTCPNetworkItem = GetNetworkItem(pAllowBatchSend->wIndex);

  0034f	8b 4d c8	 mov	 ecx, DWORD PTR _pAllowBatchSend$25[ebp]
  00352	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00355	52		 push	 edx
  00356	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00359	83 e9 04	 sub	 ecx, 4
  0035c	e8 00 00 00 00	 call	 ?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ; CTCPNetworkEngine::GetNetworkItem
  00361	89 45 b0	 mov	 DWORD PTR _pTCPNetworkItem$17[ebp], eax

; 2035 :             if (pTCPNetworkItem == NULL)

  00364	83 7d b0 00	 cmp	 DWORD PTR _pTCPNetworkItem$17[ebp], 0
  00368	75 07		 jne	 SHORT $LN84@OnAsynchro

; 2036 :                 return false;

  0036a	32 c0		 xor	 al, al
  0036c	e9 15 03 00 00	 jmp	 $LN1@OnAsynchro
$LN84@OnAsynchro:

; 2039 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00371	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  00373	8b 45 b0	 mov	 eax, DWORD PTR _pTCPNetworkItem$17[ebp]
  00376	83 c0 18	 add	 eax, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2039 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00379	50		 push	 eax
  0037a	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00386	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 2040 :             pTCPNetworkItem->AllowBatchSend(pAllowBatchSend->wRountID, pAllowBatchSend->cbAllowBatch ? true : false, pAllowBatchSend->cbBatchMask);

  0038d	8b 4d c8	 mov	 ecx, DWORD PTR _pAllowBatchSend$25[ebp]
  00390	0f b6 51 05	 movzx	 edx, BYTE PTR [ecx+5]
  00394	85 d2		 test	 edx, edx
  00396	74 06		 je	 SHORT $LN38@OnAsynchro
  00398	c6 45 eb 01	 mov	 BYTE PTR tv262[ebp], 1
  0039c	eb 04		 jmp	 SHORT $LN39@OnAsynchro
$LN38@OnAsynchro:
  0039e	c6 45 eb 00	 mov	 BYTE PTR tv262[ebp], 0
$LN39@OnAsynchro:
  003a2	8b 45 c8	 mov	 eax, DWORD PTR _pAllowBatchSend$25[ebp]
  003a5	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  003a9	51		 push	 ecx
  003aa	0f b6 55 eb	 movzx	 edx, BYTE PTR tv262[ebp]
  003ae	52		 push	 edx
  003af	8b 45 c8	 mov	 eax, DWORD PTR _pAllowBatchSend$25[ebp]
  003b2	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  003b6	51		 push	 ecx
  003b7	8b 4d b0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$17[ebp]
  003ba	e8 00 00 00 00	 call	 ?AllowBatchSend@CTCPNetworkItem@@QAE_NG_NE@Z ; CTCPNetworkItem::AllowBatchSend

; 2041 : 
; 2042 :             return true;

  003bf	c6 45 e5 01	 mov	 BYTE PTR $T33[ebp], 1
  003c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ca	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  003d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  003d6	8a 45 e5	 mov	 al, BYTE PTR $T33[ebp]
  003d9	e9 a8 02 00 00	 jmp	 $LN1@OnAsynchro
$LN20@OnAsynchro:

; 2043 :         }
; 2044 :         case ASYNCHRONISM_CLOSE_SOCKET:		// 关闭连接
; 2045 :         {
; 2046 :             // 效验数据
; 2047 :             ASSERT(wDataSize == sizeof(tagCloseSocket));

  003de	0f b7 55 10	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  003e2	83 fa 04	 cmp	 edx, 4
  003e5	74 14		 je	 SHORT $LN40@OnAsynchro
  003e7	68 ff 07 00 00	 push	 2047			; 000007ffH
  003ec	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  003f1	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  003f6	85 c0		 test	 eax, eax
  003f8	74 01		 je	 SHORT $LN40@OnAsynchro
  003fa	cc		 int	 3
$LN40@OnAsynchro:

; 2048 :             tagCloseSocket * pCloseSocket = (tagCloseSocket *)pData;

  003fb	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  003fe	89 4d a4	 mov	 DWORD PTR _pCloseSocket$14[ebp], ecx

; 2049 : 
; 2050 :             // 获取对象
; 2051 :             CTCPNetworkItem * pTCPNetworkItem = GetNetworkItem(pCloseSocket->wIndex);

  00401	8b 55 a4	 mov	 edx, DWORD PTR _pCloseSocket$14[ebp]
  00404	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00407	50		 push	 eax
  00408	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0040b	83 e9 04	 sub	 ecx, 4
  0040e	e8 00 00 00 00	 call	 ?GetNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@G@Z ; CTCPNetworkEngine::GetNetworkItem
  00413	89 45 ac	 mov	 DWORD PTR _pTCPNetworkItem$16[ebp], eax

; 2052 :             if (pTCPNetworkItem == NULL)

  00416	83 7d ac 00	 cmp	 DWORD PTR _pTCPNetworkItem$16[ebp], 0
  0041a	75 07		 jne	 SHORT $LN89@OnAsynchro

; 2053 :                 return false;

  0041c	32 c0		 xor	 al, al
  0041e	e9 63 02 00 00	 jmp	 $LN1@OnAsynchro
$LN89@OnAsynchro:

; 2056 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00423	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  00425	8b 4d ac	 mov	 ecx, DWORD PTR _pTCPNetworkItem$16[ebp]
  00428	83 c1 18	 add	 ecx, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2056 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  0042b	51		 push	 ecx
  0042c	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00432	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00438	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 2057 :             pTCPNetworkItem->CloseSocket(pCloseSocket->wRountID);

  0043f	8b 55 a4	 mov	 edx, DWORD PTR _pCloseSocket$14[ebp]
  00442	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  00446	50		 push	 eax
  00447	8b 4d ac	 mov	 ecx, DWORD PTR _pTCPNetworkItem$16[ebp]
  0044a	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 2058 : 
; 2059 :             return true;

  0044f	c6 45 e4 01	 mov	 BYTE PTR $T32[ebp], 1
  00453	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0045a	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00460	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00466	8a 45 e4	 mov	 al, BYTE PTR $T32[ebp]
  00469	e9 18 02 00 00	 jmp	 $LN1@OnAsynchro
$LN22@OnAsynchro:

; 2060 :         }
; 2061 :         case ASYNCHRONISM_DETECT_SOCKET:	// 检测连接
; 2062 :         {
; 2063 :             // 获取活动项
; 2064 :             CWHDataLocker ThreadLock(m_ItemLocked);

  0046e	6a 01		 push	 1
  00470	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00473	81 c1 24 40 00
	00		 add	 ecx, 16420		; 00004024H
  00479	51		 push	 ecx
  0047a	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$7[ebp]
  00480	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00486	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 2065 :             m_TempNetworkItemArray.Copy(m_NetworkItemActive);

  0048d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00490	81 c2 5c 40 00
	00		 add	 edx, 16476		; 0000405cH
  00496	52		 push	 edx
  00497	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0049a	81 c1 84 40 00
	00		 add	 ecx, 16516		; 00004084H
  004a0	e8 00 00 00 00	 call	 ?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Copy

; 2066 :             ThreadLock.UnLock();

  004a5	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$7[ebp]
  004ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?UnLock@CWHDataLocker@@QAEXXZ
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h

; 536  :             return _time64(_Time);

  004b1	6a 00		 push	 0
  004b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  004b9	83 c4 04	 add	 esp, 4
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2069 :             DWORD dwNowTime = (DWORD)time(NULL);

  004bc	89 45 88	 mov	 DWORD PTR _dwNowTime$10[ebp], eax

; 2070 :             for (INT_PTR i = 0; i < m_TempNetworkItemArray.GetCount(); i++)

  004bf	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _i$24[ebp], 0
  004c6	eb 09		 jmp	 SHORT $LN9@OnAsynchro
$LN7@OnAsynchro:
  004c8	8b 45 c4	 mov	 eax, DWORD PTR _i$24[ebp]
  004cb	83 c0 01	 add	 eax, 1
  004ce	89 45 c4	 mov	 DWORD PTR _i$24[ebp], eax
$LN9@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  004d1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004d4	8b 91 94 40 00
	00		 mov	 edx, DWORD PTR [ecx+16532]
  004da	89 55 90	 mov	 DWORD PTR $T12[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2070 :             for (INT_PTR i = 0; i < m_TempNetworkItemArray.GetCount(); i++)

  004dd	8b 45 c4	 mov	 eax, DWORD PTR _i$24[ebp]
  004e0	3b 45 90	 cmp	 eax, DWORD PTR $T12[ebp]
  004e3	0f 8d 67 01 00
	00		 jge	 $LN8@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  004e9	8b 4d c4	 mov	 ecx, DWORD PTR _i$24[ebp]
  004ec	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2073 :                 CTCPNetworkItem * pTCPNetworkItem = m_TempNetworkItemArray[i];

  004ed	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004f0	81 c1 84 40 00
	00		 add	 ecx, 16516		; 00004084H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  004f6	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2073 :                 CTCPNetworkItem * pTCPNetworkItem = m_TempNetworkItemArray[i];

  004fb	8b 10		 mov	 edx, DWORD PTR [eax]
  004fd	89 55 f0	 mov	 DWORD PTR _pTCPNetworkItem$39[ebp], edx

; 2074 :                 CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00500	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  00502	8b 45 f0	 mov	 eax, DWORD PTR _pTCPNetworkItem$39[ebp]
  00505	83 c0 18	 add	 eax, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2074 :                 CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00508	50		 push	 eax
  00509	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$9[ebp]
  0050f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00515	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 222  :     inline bool IsValidSocket() { return (m_hSocketHandle != INVALID_SOCKET); }

  00519	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  0051c	83 79 14 ff	 cmp	 DWORD PTR [ecx+20], -1
  00520	74 09		 je	 SHORT $LN101@OnAsynchro
  00522	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv433[ebp], 1
  00529	eb 07		 jmp	 SHORT $LN99@OnAsynchro
$LN101@OnAsynchro:
  0052b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv433[ebp], 0
$LN99@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2077 :                 if (pTCPNetworkItem->IsValidSocket() == false) continue;

  00532	0f b6 55 a0	 movzx	 edx, BYTE PTR tv433[ebp]
  00536	85 d2		 test	 edx, edx
  00538	75 15		 jne	 SHORT $LN23@OnAsynchro
  0053a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0053e	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$9[ebp]
  00544	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0054a	e9 79 ff ff ff	 jmp	 $LN7@OnAsynchro
$LN23@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 220  :     inline bool IsAllowSendData() { return m_dwRecvPacketCount > 0L; }

  0054f	8b 45 f0	 mov	 eax, DWORD PTR _pTCPNetworkItem$39[ebp]
  00552	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  00559	76 09		 jbe	 SHORT $LN105@OnAsynchro
  0055b	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR tv434[ebp], 1
  00562	eb 07		 jmp	 SHORT $LN103@OnAsynchro
$LN105@OnAsynchro:
  00564	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR tv434[ebp], 0
$LN103@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2080 :                 if (pTCPNetworkItem->IsAllowSendData())

  0056b	0f b6 4d 9c	 movzx	 ecx, BYTE PTR tv434[ebp]
  0056f	85 c9		 test	 ecx, ecx
  00571	74 76		 je	 SHORT $LN24@OnAsynchro

; 2081 :                 {
; 2082 :                     switch (pTCPNetworkItem->m_wSurvivalTime)

  00573	8b 55 f0	 mov	 edx, DWORD PTR _pTCPNetworkItem$39[ebp]
  00576	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  0057a	89 45 98	 mov	 DWORD PTR tv333[ebp], eax
  0057d	83 7d 98 00	 cmp	 DWORD PTR tv333[ebp], 0
  00581	74 08		 je	 SHORT $LN26@OnAsynchro
  00583	83 7d 98 01	 cmp	 DWORD PTR tv333[ebp], 1
  00587	74 1c		 je	 SHORT $LN27@OnAsynchro
  00589	eb 4a		 jmp	 SHORT $LN28@OnAsynchro
$LN26@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  0058b	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  0058e	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00592	66 89 55 c0	 mov	 WORD PTR $T22[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2086 :                             pTCPNetworkItem->CloseSocket(pTCPNetworkItem->GetRountID());

  00596	0f b7 45 c0	 movzx	 eax, WORD PTR $T22[ebp]
  0059a	50		 push	 eax
  0059b	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  0059e	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 2087 :                             break;

  005a3	eb 42		 jmp	 SHORT $LN10@OnAsynchro
$LN27@OnAsynchro:

; 2088 :                         }
; 2089 :                         case DANGER_QUOTIETY:	// 危险系数
; 2090 :                         {
; 2091 :                             pTCPNetworkItem->m_wSurvivalTime--;

  005a5	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  005a8	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  005ac	66 83 ea 01	 sub	 dx, 1
  005b0	8b 45 f0	 mov	 eax, DWORD PTR _pTCPNetworkItem$39[ebp]
  005b3	66 89 50 10	 mov	 WORD PTR [eax+16], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  005b7	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  005ba	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  005be	66 89 55 be	 mov	 WORD PTR $T21[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2092 :                             pTCPNetworkItem->SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pTCPNetworkItem->GetRountID());

  005c2	0f b7 45 be	 movzx	 eax, WORD PTR $T21[ebp]
  005c6	50		 push	 eax
  005c7	6a 01		 push	 1
  005c9	6a 00		 push	 0
  005cb	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  005ce	e8 00 00 00 00	 call	 ?SendData@CTCPNetworkItem@@QAE_NGGG@Z ; CTCPNetworkItem::SendData

; 2093 :                             break;

  005d3	eb 12		 jmp	 SHORT $LN10@OnAsynchro
$LN28@OnAsynchro:

; 2094 :                         }
; 2095 :                         default:				// 默认处理
; 2096 :                         {
; 2097 :                             pTCPNetworkItem->m_wSurvivalTime--;

  005d5	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  005d8	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  005dc	66 83 ea 01	 sub	 dx, 1
  005e0	8b 45 f0	 mov	 eax, DWORD PTR _pTCPNetworkItem$39[ebp]
  005e3	66 89 50 10	 mov	 WORD PTR [eax+16], dx
$LN10@OnAsynchro:

; 2098 :                             break;
; 2099 :                         }
; 2100 :                     }
; 2101 :                 }
; 2102 :                 else	// 特殊连接

  005e7	eb 52		 jmp	 SHORT $LN25@OnAsynchro
$LN24@OnAsynchro:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 203  :     inline DWORD GetActiveTime() { return m_dwActiveTime; }

  005e9	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  005ec	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  005ef	89 55 8c	 mov	 DWORD PTR $T11[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2104 :                     if ((pTCPNetworkItem->GetActiveTime() + 4) <= dwNowTime)

  005f2	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  005f5	83 c0 04	 add	 eax, 4
  005f8	3b 45 88	 cmp	 eax, DWORD PTR _dwNowTime$10[ebp]
  005fb	77 3e		 ja	 SHORT $LN25@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 224  :     inline bool IsRecvIng() { return m_bRecvIng; }

  005fd	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  00600	8a 51 45	 mov	 dl, BYTE PTR [ecx+69]
  00603	88 55 e3	 mov	 BYTE PTR $T31[ebp], dl
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2106 :                         if (!pTCPNetworkItem->IsRecvIng())

  00606	0f b6 45 e3	 movzx	 eax, BYTE PTR $T31[ebp]
  0060a	85 c0		 test	 eax, eax
  0060c	75 18		 jne	 SHORT $LN30@OnAsynchro
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  0060e	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  00611	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00615	66 89 55 bc	 mov	 WORD PTR $T20[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 2108 :                             pTCPNetworkItem->CloseSocket(pTCPNetworkItem->GetRountID());

  00619	0f b7 45 bc	 movzx	 eax, WORD PTR $T20[ebp]
  0061d	50		 push	 eax
  0061e	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$39[ebp]
  00621	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket
$LN30@OnAsynchro:

; 2109 :                         }
; 2110 :                         continue;

  00626	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0062a	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$9[ebp]
  00630	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00636	e9 8d fe ff ff	 jmp	 $LN7@OnAsynchro
$LN25@OnAsynchro:

; 2111 :                     }
; 2112 :                 }
; 2113 :             }

  0063b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0063f	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$9[ebp]
  00645	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0064b	e9 78 fe ff ff	 jmp	 $LN7@OnAsynchro
$LN8@OnAsynchro:

; 2114 : 
; 2115 :             return true;

  00650	c6 45 e2 01	 mov	 BYTE PTR $T30[ebp], 1
  00654	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0065b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$7[ebp]
  00661	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00667	8a 45 e2	 mov	 al, BYTE PTR $T30[ebp]
  0066a	eb 1a		 jmp	 SHORT $LN1@OnAsynchro
$LN2@OnAsynchro:

; 2116 :         }
; 2117 :     }
; 2118 : 
; 2119 :     // 效验数据
; 2120 :     ASSERT(FALSE);

  0066c	33 c9		 xor	 ecx, ecx
  0066e	75 14		 jne	 SHORT $LN41@OnAsynchro
  00670	68 48 08 00 00	 push	 2120			; 00000848H
  00675	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0067a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0067f	85 c0		 test	 eax, eax
  00681	74 01		 je	 SHORT $LN41@OnAsynchro
  00683	cc		 int	 3
$LN41@OnAsynchro:

; 2121 : 
; 2122 :     return false;

  00684	32 c0		 xor	 al, al
$LN1@OnAsynchro:

; 2123 : }

  00686	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00689	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00690	59		 pop	 ecx
  00691	8b e5		 mov	 esp, ebp
  00693	5d		 pop	 ebp
  00694	c2 0c 00	 ret	 12			; 0000000cH
  00697	90		 npad	 1
$LN121@OnAsynchro:
  00698	00 00 00 00	 DD	 $LN12@OnAsynchro
  0069c	00 00 00 00	 DD	 $LN14@OnAsynchro
  006a0	00 00 00 00	 DD	 $LN16@OnAsynchro
  006a4	00 00 00 00	 DD	 $LN18@OnAsynchro
  006a8	00 00 00 00	 DD	 $LN20@OnAsynchro
  006ac	00 00 00 00	 DD	 $LN22@OnAsynchro
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$0:
  00000	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$6[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$1:
  0000c	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _ItemThreadLock$8[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$2:
  00018	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _SocketThreadLock$5[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$3:
  00024	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$4[ebp]
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$4:
  00030	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$5:
  0003c	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$6:
  00048	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$7[ebp]
  0004e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z$7:
  00054	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _ThreadLock$9[ebp]
  0005a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z:
  00060	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00064	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00067	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0006d	33 c8		 xor	 ecx, eax
  0006f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00074	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z
  00079	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnAsynchronismEngineData@CTCPNetworkEngine@@UAE_NGPAXG@Z ENDP ; CTCPNetworkEngine::OnAsynchronismEngineData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?OnAsynchronismEngineConclude@CTCPNetworkEngine@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnAsynchronismEngineConclude@CTCPNetworkEngine@@UAE_NXZ PROC ; CTCPNetworkEngine::OnAsynchronismEngineConclude, COMDAT
; _this$ = ecx

; 482  :     virtual bool OnAsynchronismEngineConclude() { return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?OnAsynchronismEngineConclude@CTCPNetworkEngine@@UAE_NXZ ENDP ; CTCPNetworkEngine::OnAsynchronismEngineConclude
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?OnAsynchronismEngineStart@CTCPNetworkEngine@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnAsynchronismEngineStart@CTCPNetworkEngine@@UAE_NXZ PROC ; CTCPNetworkEngine::OnAsynchronismEngineStart, COMDAT
; _this$ = ecx

; 480  :     virtual bool OnAsynchronismEngineStart() { return true; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?OnAsynchronismEngineStart@CTCPNetworkEngine@@UAE_NXZ ENDP ; CTCPNetworkEngine::OnAsynchronismEngineStart
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z
_TEXT	SEGMENT
_ThreadLock$ = -36					; size = 12
_pAllowBatchSend$ = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwSocketID$ = 8					; size = 4
_cbAllowBatch$ = 12					; size = 1
_cbBatchMask$ = 16					; size = 1
?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z PROC	; CTCPNetworkEngine::AllowBatchSend, COMDAT
; _this$ = ecx

; 1942 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1943 :     // 缓冲锁定
; 1944 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  00032	50		 push	 eax
  00033	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1945 :     tagAllowBatchSend * pAllowBatchSend = (tagAllowBatchSend *)m_cbBuffer;

  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00049	89 4d e8	 mov	 DWORD PTR _pAllowBatchSend$[ebp], ecx

; 1946 : 
; 1947 :     // 构造数据
; 1948 :     pAllowBatchSend->cbAllowBatch = cbAllowBatch;

  0004c	8b 55 e8	 mov	 edx, DWORD PTR _pAllowBatchSend$[ebp]
  0004f	8a 45 0c	 mov	 al, BYTE PTR _cbAllowBatch$[ebp]
  00052	88 42 05	 mov	 BYTE PTR [edx+5], al

; 1949 :     pAllowBatchSend->cbBatchMask = cbBatchMask;

  00055	8b 4d e8	 mov	 ecx, DWORD PTR _pAllowBatchSend$[ebp]
  00058	8a 55 10	 mov	 dl, BYTE PTR _cbBatchMask$[ebp]
  0005b	88 51 04	 mov	 BYTE PTR [ecx+4], dl

; 1950 :     pAllowBatchSend->wIndex = SOCKET_INDEX(dwSocketID);

  0005e	8b 45 08	 mov	 eax, DWORD PTR _dwSocketID$[ebp]
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00066	8b 4d e8	 mov	 ecx, DWORD PTR _pAllowBatchSend$[ebp]
  00069	66 89 01	 mov	 WORD PTR [ecx], ax

; 1951 :     pAllowBatchSend->wRountID = SOCKET_ROUNTID(dwSocketID);

  0006c	8b 55 08	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  0006f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00072	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00078	8b 45 e8	 mov	 eax, DWORD PTR _pAllowBatchSend$[ebp]
  0007b	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 1952 : 
; 1953 :     // 发送请求
; 1954 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_ALLOW_BATCH, m_cbBuffer, sizeof(tagAllowBatchSend));

  0007f	6a 06		 push	 6
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00087	51		 push	 ecx
  00088	6a 04		 push	 4
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00093	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00096	8b 82 c0 40 00
	00		 mov	 eax, DWORD PTR [edx+16576]
  0009c	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0009f	ff d2		 call	 edx
  000a1	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  000a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ab	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000b4	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]

; 1955 : }

  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AllowBatchSend@CTCPNetworkEngine@@UAE_NK_NE@Z ENDP	; CTCPNetworkEngine::AllowBatchSend
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z
_TEXT	SEGMENT
_ThreadLock$ = -36					; size = 12
_pShutDownSocket$ = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwSocketID$ = 8					; size = 4
?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z PROC	; CTCPNetworkEngine::ShutDownSocket, COMDAT
; _this$ = ecx

; 1927 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1928 :     // 缓冲锁定
; 1929 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  00032	50		 push	 eax
  00033	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1930 :     tagShutDownSocket * pShutDownSocket = (tagShutDownSocket *)m_cbBuffer;

  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00049	89 4d e8	 mov	 DWORD PTR _pShutDownSocket$[ebp], ecx

; 1931 : 
; 1932 :     // 构造数据
; 1933 :     pShutDownSocket->wIndex = SOCKET_INDEX(dwSocketID);

  0004c	8b 55 08	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  0004f	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00055	8b 45 e8	 mov	 eax, DWORD PTR _pShutDownSocket$[ebp]
  00058	66 89 10	 mov	 WORD PTR [eax], dx

; 1934 :     pShutDownSocket->wRountID = SOCKET_ROUNTID(dwSocketID);

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _dwSocketID$[ebp]
  0005e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00061	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00067	8b 55 e8	 mov	 edx, DWORD PTR _pShutDownSocket$[ebp]
  0006a	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1935 : 
; 1936 :     // 发送请求
; 1937 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_SHUT_DOWN, m_cbBuffer, sizeof(tagShutDownSocket));

  0006e	6a 04		 push	 4
  00070	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00073	83 c0 0f	 add	 eax, 15			; 0000000fH
  00076	50		 push	 eax
  00077	6a 03		 push	 3
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00082	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 82 c0 40 00
	00		 mov	 eax, DWORD PTR [edx+16576]
  0008b	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0008e	ff d2		 call	 edx
  00090	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  00093	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009a	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000a3	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]

; 1938 : }

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ShutDownSocket@CTCPNetworkEngine@@UAE_NK@Z ENDP	; CTCPNetworkEngine::ShutDownSocket
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z
_TEXT	SEGMENT
_ThreadLock$ = -36					; size = 12
_pCloseSocket$ = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwSocketID$ = 8					; size = 4
?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z PROC		; CTCPNetworkEngine::CloseSocket, COMDAT
; _this$ = ecx

; 1912 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1913 :     // 缓冲锁定
; 1914 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  00032	50		 push	 eax
  00033	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1915 :     tagCloseSocket * pCloseSocket = (tagCloseSocket *)m_cbBuffer;

  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00049	89 4d e8	 mov	 DWORD PTR _pCloseSocket$[ebp], ecx

; 1916 : 
; 1917 :     // 构造数据
; 1918 :     pCloseSocket->wIndex = SOCKET_INDEX(dwSocketID);

  0004c	8b 55 08	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  0004f	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00055	8b 45 e8	 mov	 eax, DWORD PTR _pCloseSocket$[ebp]
  00058	66 89 10	 mov	 WORD PTR [eax], dx

; 1919 :     pCloseSocket->wRountID = SOCKET_ROUNTID(dwSocketID);

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _dwSocketID$[ebp]
  0005e	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00061	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00067	8b 55 e8	 mov	 edx, DWORD PTR _pCloseSocket$[ebp]
  0006a	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1920 : 
; 1921 :     // 发送请求
; 1922 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_CLOSE_SOCKET, m_cbBuffer, sizeof(tagCloseSocket));

  0006e	6a 04		 push	 4
  00070	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00073	83 c0 0f	 add	 eax, 15			; 0000000fH
  00076	50		 push	 eax
  00077	6a 05		 push	 5
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00082	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 82 c0 40 00
	00		 mov	 eax, DWORD PTR [edx+16576]
  0008b	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0008e	ff d2		 call	 edx
  00090	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  00093	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009a	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000a3	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]

; 1923 : }

  000a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b0	59		 pop	 ecx
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CloseSocket@CTCPNetworkEngine@@UAE_NK@Z ENDP		; CTCPNetworkEngine::CloseSocket
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z
_TEXT	SEGMENT
_ThreadLock$ = -40					; size = 12
_this$ = -28						; size = 4
_pBatchSendRequest$ = -24				; size = 4
_wSendSize$ = -20					; size = 2
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_wMainCmdID$ = 8					; size = 2
_wSubCmdID$ = 12					; size = 2
_pData$ = 16						; size = 4
_wDataSize$ = 20					; size = 2
_cbBatchMask$ = 24					; size = 1
?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z PROC	; CTCPNetworkEngine::SendDataBatch, COMDAT
; _this$ = ecx

; 1884 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1885 :     // 效验数据
; 1886 :     ASSERT((wDataSize + sizeof(TCP_Head)) <= SOCKET_TCP_PACKET);

  00028	0f b7 45 14	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0002c	83 c0 08	 add	 eax, 8
  0002f	3d f8 3f 00 00	 cmp	 eax, 16376		; 00003ff8H
  00034	76 14		 jbe	 SHORT $LN5@SendDataBa
  00036	68 5e 07 00 00	 push	 1886			; 0000075eH
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00040	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00045	85 c0		 test	 eax, eax
  00047	74 01		 je	 SHORT $LN5@SendDataBa
  00049	cc		 int	 3
$LN5@SendDataBa:

; 1887 :     if ((wDataSize + sizeof(TCP_Head)) > SOCKET_TCP_PACKET)

  0004a	0f b7 55 14	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  0004e	83 c2 08	 add	 edx, 8
  00051	81 fa f8 3f 00
	00		 cmp	 edx, 16376		; 00003ff8H
  00057	76 07		 jbe	 SHORT $LN2@SendDataBa

; 1888 :         return false;

  00059	32 c0		 xor	 al, al
  0005b	e9 cd 00 00 00	 jmp	 $LN1@SendDataBa
$LN2@SendDataBa:

; 1889 : 
; 1890 :     // 缓冲锁定
; 1891 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00060	6a 01		 push	 1
  00062	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00065	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  0006a	50		 push	 eax
  0006b	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1892 :     tagBatchSendRequest * pBatchSendRequest = (tagBatchSendRequest *)m_cbBuffer;

  0007b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00081	89 4d e8	 mov	 DWORD PTR _pBatchSendRequest$[ebp], ecx

; 1893 : 
; 1894 :     // 构造数据
; 1895 :     pBatchSendRequest->wMainCmdID = wMainCmdID;

  00084	8b 55 e8	 mov	 edx, DWORD PTR _pBatchSendRequest$[ebp]
  00087	66 8b 45 08	 mov	 ax, WORD PTR _wMainCmdID$[ebp]
  0008b	66 89 02	 mov	 WORD PTR [edx], ax

; 1896 :     pBatchSendRequest->wSubCmdID = wSubCmdID;

  0008e	8b 4d e8	 mov	 ecx, DWORD PTR _pBatchSendRequest$[ebp]
  00091	66 8b 55 0c	 mov	 dx, WORD PTR _wSubCmdID$[ebp]
  00095	66 89 51 02	 mov	 WORD PTR [ecx+2], dx

; 1897 :     pBatchSendRequest->wDataSize = wDataSize;

  00099	8b 45 e8	 mov	 eax, DWORD PTR _pBatchSendRequest$[ebp]
  0009c	66 8b 4d 14	 mov	 cx, WORD PTR _wDataSize$[ebp]
  000a0	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1898 :     pBatchSendRequest->cbBatchMask = cbBatchMask;

  000a4	8b 55 e8	 mov	 edx, DWORD PTR _pBatchSendRequest$[ebp]
  000a7	8a 45 18	 mov	 al, BYTE PTR _cbBatchMask$[ebp]
  000aa	88 42 06	 mov	 BYTE PTR [edx+6], al

; 1899 :     if (wDataSize > 0)

  000ad	0f b7 4d 14	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  000b1	85 c9		 test	 ecx, ecx
  000b3	7e 32		 jle	 SHORT $LN3@SendDataBa

; 1900 :     {
; 1901 :         ASSERT(pData != NULL);

  000b5	83 7d 10 00	 cmp	 DWORD PTR _pData$[ebp], 0
  000b9	75 14		 jne	 SHORT $LN6@SendDataBa
  000bb	68 6d 07 00 00	 push	 1901			; 0000076dH
  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000c5	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000ca	85 c0		 test	 eax, eax
  000cc	74 01		 je	 SHORT $LN6@SendDataBa
  000ce	cc		 int	 3
$LN6@SendDataBa:

; 1902 :         CopyMemory(pBatchSendRequest->cbSendBuffer, pData, wDataSize);

  000cf	0f b7 45 14	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  000d3	50		 push	 eax
  000d4	8b 4d 10	 mov	 ecx, DWORD PTR _pData$[ebp]
  000d7	51		 push	 ecx
  000d8	8b 55 e8	 mov	 edx, DWORD PTR _pBatchSendRequest$[ebp]
  000db	83 c2 07	 add	 edx, 7
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _memcpy
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendDataBa:

; 1903 :     }
; 1904 : 
; 1905 :     // 发送请求
; 1906 :     WORD wSendSize = sizeof(tagBatchSendRequest) - sizeof(pBatchSendRequest->cbSendBuffer) + wDataSize;

  000e7	0f b7 45 14	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  000eb	83 c0 08	 add	 eax, 8
  000ee	66 89 45 ec	 mov	 WORD PTR _wSendSize$[ebp], ax

; 1907 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_SEND_BATCH, m_cbBuffer, wSendSize);

  000f2	0f b7 4d ec	 movzx	 ecx, WORD PTR _wSendSize$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000fa	83 c2 0f	 add	 edx, 15			; 0000000fH
  000fd	52		 push	 edx
  000fe	6a 02		 push	 2
  00100	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00109	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	8b 90 c0 40 00
	00		 mov	 edx, DWORD PTR [eax+16576]
  00112	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00115	ff d0		 call	 eax
  00117	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  0011a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00121	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0012a	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]
$LN1@SendDataBa:

; 1908 : }

  0012d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00130	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00137	59		 pop	 ecx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendDataBatch@CTCPNetworkEngine@@UAE_NGGPAXGE@Z ENDP	; CTCPNetworkEngine::SendDataBatch
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z
_TEXT	SEGMENT
_ThreadLock$ = -40					; size = 12
_this$ = -28						; size = 4
_pSendDataRequest$ = -24				; size = 4
_wSendSize$ = -20					; size = 2
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwSocketID$ = 8					; size = 4
_wMainCmdID$ = 12					; size = 2
_wSubCmdID$ = 16					; size = 2
_pData$ = 20						; size = 4
_wDataSize$ = 24					; size = 2
?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z PROC	; CTCPNetworkEngine::SendData, COMDAT
; _this$ = ecx

; 1854 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1855 :     // 效益数据
; 1856 :     ASSERT((wDataSize + sizeof(TCP_Head)) <= SOCKET_TCP_PACKET);

  00028	0f b7 45 18	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0002c	83 c0 08	 add	 eax, 8
  0002f	3d f8 3f 00 00	 cmp	 eax, 16376		; 00003ff8H
  00034	76 14		 jbe	 SHORT $LN5@SendData
  00036	68 40 07 00 00	 push	 1856			; 00000740H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00040	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00045	85 c0		 test	 eax, eax
  00047	74 01		 je	 SHORT $LN5@SendData
  00049	cc		 int	 3
$LN5@SendData:

; 1857 :     if ((wDataSize + sizeof(TCP_Head)) > SOCKET_TCP_PACKET)

  0004a	0f b7 55 18	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  0004e	83 c2 08	 add	 edx, 8
  00051	81 fa f8 3f 00
	00		 cmp	 edx, 16376		; 00003ff8H
  00057	76 07		 jbe	 SHORT $LN2@SendData

; 1858 :         return false;

  00059	32 c0		 xor	 al, al
  0005b	e9 fd 00 00 00	 jmp	 $LN1@SendData
$LN2@SendData:

; 1859 : 
; 1860 :     // 缓冲锁定
; 1861 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00060	6a 01		 push	 1
  00062	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00065	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  0006a	50		 push	 eax
  0006b	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1862 :     tagSendDataRequest * pSendDataRequest = (tagSendDataRequest *)m_cbBuffer;

  0007b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00081	89 4d e8	 mov	 DWORD PTR _pSendDataRequest$[ebp], ecx

; 1863 : 
; 1864 :     // 构造数据
; 1865 :     pSendDataRequest->wDataSize = wDataSize;

  00084	8b 55 e8	 mov	 edx, DWORD PTR _pSendDataRequest$[ebp]
  00087	66 8b 45 18	 mov	 ax, WORD PTR _wDataSize$[ebp]
  0008b	66 89 42 08	 mov	 WORD PTR [edx+8], ax

; 1866 :     pSendDataRequest->wSubCmdID = wSubCmdID;

  0008f	8b 4d e8	 mov	 ecx, DWORD PTR _pSendDataRequest$[ebp]
  00092	66 8b 55 10	 mov	 dx, WORD PTR _wSubCmdID$[ebp]
  00096	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1867 :     pSendDataRequest->wMainCmdID = wMainCmdID;

  0009a	8b 45 e8	 mov	 eax, DWORD PTR _pSendDataRequest$[ebp]
  0009d	66 8b 4d 0c	 mov	 cx, WORD PTR _wMainCmdID$[ebp]
  000a1	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1868 :     pSendDataRequest->wIndex = SOCKET_INDEX(dwSocketID);

  000a5	8b 55 08	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  000a8	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000ae	8b 45 e8	 mov	 eax, DWORD PTR _pSendDataRequest$[ebp]
  000b1	66 89 10	 mov	 WORD PTR [eax], dx

; 1869 :     pSendDataRequest->wRountID = SOCKET_ROUNTID(dwSocketID);

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _dwSocketID$[ebp]
  000b7	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000ba	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000c0	8b 55 e8	 mov	 edx, DWORD PTR _pSendDataRequest$[ebp]
  000c3	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1870 :     if (wDataSize > 0)

  000c7	0f b7 45 18	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  000cb	85 c0		 test	 eax, eax
  000cd	7e 48		 jle	 SHORT $LN3@SendData

; 1871 :     {
; 1872 :         ASSERT(pData != NULL);

  000cf	83 7d 14 00	 cmp	 DWORD PTR _pData$[ebp], 0
  000d3	75 14		 jne	 SHORT $LN6@SendData
  000d5	68 50 07 00 00	 push	 1872			; 00000750H
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000df	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000e4	85 c0		 test	 eax, eax
  000e6	74 01		 je	 SHORT $LN6@SendData
  000e8	cc		 int	 3
$LN6@SendData:

; 1873 : 		ZeroMemory(pSendDataRequest->cbSendBuffer, sizeof(pSendDataRequest->cbSendBuffer));

  000e9	68 f8 3f 00 00	 push	 16376			; 00003ff8H
  000ee	6a 00		 push	 0
  000f0	8b 55 e8	 mov	 edx, DWORD PTR _pSendDataRequest$[ebp]
  000f3	83 c2 0a	 add	 edx, 10			; 0000000aH
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _memset
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 :         CopyMemory(pSendDataRequest->cbSendBuffer, pData, wDataSize);

  000ff	0f b7 45 18	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00103	50		 push	 eax
  00104	8b 4d 14	 mov	 ecx, DWORD PTR _pData$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 e8	 mov	 edx, DWORD PTR _pSendDataRequest$[ebp]
  0010b	83 c2 0a	 add	 edx, 10			; 0000000aH
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 _memcpy
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendData:

; 1875 :     }
; 1876 : 
; 1877 :     // 发送请求
; 1878 :     WORD wSendSize = sizeof(tagSendDataRequest) - sizeof(pSendDataRequest->cbSendBuffer) + wDataSize;

  00117	0f b7 45 18	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0011b	83 c0 0a	 add	 eax, 10			; 0000000aH
  0011e	66 89 45 ec	 mov	 WORD PTR _wSendSize$[ebp], ax

; 1879 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_SEND_DATA, m_cbBuffer, wSendSize);

  00122	0f b7 4d ec	 movzx	 ecx, WORD PTR _wSendSize$[ebp]
  00126	51		 push	 ecx
  00127	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0012a	83 c2 0f	 add	 edx, 15			; 0000000fH
  0012d	52		 push	 edx
  0012e	6a 01		 push	 1
  00130	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00133	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00139	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	8b 90 c0 40 00
	00		 mov	 edx, DWORD PTR [eax+16576]
  00142	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00145	ff d0		 call	 eax
  00147	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  0014a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00151	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0015a	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]
$LN1@SendData:

; 1880 : }

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CTCPNetworkEngine@@UAE_NKGGPAXG@Z ENDP	; CTCPNetworkEngine::SendData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendData@CTCPNetworkEngine@@UAE_NKGG@Z
_TEXT	SEGMENT
_ThreadLock$ = -40					; size = 12
_this$ = -28						; size = 4
_pSendDataRequest$ = -24				; size = 4
_wSendSize$ = -20					; size = 2
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwSocketID$ = 8					; size = 4
_wMainCmdID$ = 12					; size = 2
_wSubCmdID$ = 16					; size = 2
?SendData@CTCPNetworkEngine@@UAE_NKGG@Z PROC		; CTCPNetworkEngine::SendData, COMDAT
; _this$ = ecx

; 1835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1836 :     // 缓冲锁定
; 1837 :     CWHDataLocker ThreadLock(m_BufferLocked);

  00028	6a 01		 push	 1
  0002a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	05 9c 40 00 00	 add	 eax, 16540		; 0000409cH
  00032	50		 push	 eax
  00033	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1838 :     tagSendDataRequest * pSendDataRequest = (tagSendDataRequest *)m_cbBuffer;

  00043	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 0f	 add	 ecx, 15			; 0000000fH
  00049	89 4d e8	 mov	 DWORD PTR _pSendDataRequest$[ebp], ecx

; 1839 : 
; 1840 :     // 构造数据
; 1841 :     pSendDataRequest->wDataSize = 0;

  0004c	33 d2		 xor	 edx, edx
  0004e	8b 45 e8	 mov	 eax, DWORD PTR _pSendDataRequest$[ebp]
  00051	66 89 50 08	 mov	 WORD PTR [eax+8], dx

; 1842 :     pSendDataRequest->wSubCmdID = wSubCmdID;

  00055	8b 4d e8	 mov	 ecx, DWORD PTR _pSendDataRequest$[ebp]
  00058	66 8b 55 10	 mov	 dx, WORD PTR _wSubCmdID$[ebp]
  0005c	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 1843 :     pSendDataRequest->wMainCmdID = wMainCmdID;

  00060	8b 45 e8	 mov	 eax, DWORD PTR _pSendDataRequest$[ebp]
  00063	66 8b 4d 0c	 mov	 cx, WORD PTR _wMainCmdID$[ebp]
  00067	66 89 48 04	 mov	 WORD PTR [eax+4], cx

; 1844 :     pSendDataRequest->wIndex = SOCKET_INDEX(dwSocketID);

  0006b	8b 55 08	 mov	 edx, DWORD PTR _dwSocketID$[ebp]
  0006e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00074	8b 45 e8	 mov	 eax, DWORD PTR _pSendDataRequest$[ebp]
  00077	66 89 10	 mov	 WORD PTR [eax], dx

; 1845 :     pSendDataRequest->wRountID = SOCKET_ROUNTID(dwSocketID);

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _dwSocketID$[ebp]
  0007d	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00080	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00086	8b 55 e8	 mov	 edx, DWORD PTR _pSendDataRequest$[ebp]
  00089	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 1846 : 
; 1847 :     // 发送请求
; 1848 :     WORD wSendSize = sizeof(tagSendDataRequest) - sizeof(pSendDataRequest->cbSendBuffer);

  0008d	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00092	66 89 45 ec	 mov	 WORD PTR _wSendSize$[ebp], ax

; 1849 :     return m_AsynchronismEngine.PostAsynchronismData(ASYNCHRONISM_SEND_DATA, m_cbBuffer, wSendSize);

  00096	0f b7 4d ec	 movzx	 ecx, WORD PTR _wSendSize$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	83 c2 0f	 add	 edx, 15			; 0000000fH
  000a1	52		 push	 edx
  000a2	6a 01		 push	 1
  000a4	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 90 c0 40 00
	00		 mov	 edx, DWORD PTR [eax+16576]
  000b6	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b9	ff d0		 call	 eax
  000bb	88 45 f3	 mov	 BYTE PTR $T2[ebp], al
  000be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c5	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000ce	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]

; 1850 : }

  000d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000db	59		 pop	 ecx
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CTCPNetworkEngine@@UAE_NKGG@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CTCPNetworkEngine@@UAE_NKGG@Z ENDP		; CTCPNetworkEngine::SendData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SetServiceParameter@CTCPNetworkEngine@@UAE_NGGPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wServicePort$ = 8					; size = 2
_wMaxConnect$ = 12					; size = 2
_pszCompilation$ = 16					; size = 4
?SetServiceParameter@CTCPNetworkEngine@@UAE_NGGPBD@Z PROC ; CTCPNetworkEngine::SetServiceParameter, COMDAT
; _this$ = ecx

; 1786 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :     // 状态效验
; 1788 :     ASSERT(m_bService == false);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 14		 je	 SHORT $LN4@SetService
  00012	68 fc 06 00 00	 push	 1788			; 000006fcH
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN4@SetService
  00025	cc		 int	 3
$LN4@SetService:

; 1789 :     if (m_bService == true)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0002d	83 f9 01	 cmp	 ecx, 1
  00030	75 04		 jne	 SHORT $LN2@SetService

; 1790 :         return false;

  00032	32 c0		 xor	 al, al
  00034	eb 3a		 jmp	 SHORT $LN1@SetService
$LN2@SetService:

; 1791 : 
; 1792 :     // 设置变量
; 1793 :     ASSERT(wServicePort != 0);

  00036	0f b7 55 08	 movzx	 edx, WORD PTR _wServicePort$[ebp]
  0003a	85 d2		 test	 edx, edx
  0003c	75 14		 jne	 SHORT $LN5@SetService
  0003e	68 01 07 00 00	 push	 1793			; 00000701H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00048	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004d	85 c0		 test	 eax, eax
  0004f	74 01		 je	 SHORT $LN5@SetService
  00051	cc		 int	 3
$LN5@SetService:

; 1794 :     m_wMaxConnect = wMaxConnect;

  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	66 8b 55 0c	 mov	 dx, WORD PTR _wMaxConnect$[ebp]
  00059	66 89 91 10 40
	00 00		 mov	 WORD PTR [ecx+16400], dx

; 1795 :     m_wServicePort = wServicePort;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	66 8b 4d 08	 mov	 cx, WORD PTR _wServicePort$[ebp]
  00067	66 89 88 12 40
	00 00		 mov	 WORD PTR [eax+16402], cx

; 1796 : 
; 1797 :     return true;

  0006e	b0 01		 mov	 al, 1
$LN1@SetService:

; 1798 : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 0c 00	 ret	 12			; 0000000cH
?SetServiceParameter@CTCPNetworkEngine@@UAE_NGGPBD@Z ENDP ; CTCPNetworkEngine::SetServiceParameter
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SetTCPNetworkEngineEvent@CTCPNetworkEngine@@UAE_NPAUIUnknownEx@@@Z
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_pIUnknownEx$ = 8					; size = 4
?SetTCPNetworkEngineEvent@CTCPNetworkEngine@@UAE_NPAUIUnknownEx@@@Z PROC ; CTCPNetworkEngine::SetTCPNetworkEngineEvent, COMDAT
; _this$ = ecx

; 1814 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1815 :     // 状态效验
; 1816 :     ASSERT(m_bService == false);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00010	85 c9		 test	 ecx, ecx
  00012	74 14		 je	 SHORT $LN5@SetTCPNetw
  00014	68 18 07 00 00	 push	 1816			; 00000718H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00023	85 c0		 test	 eax, eax
  00025	74 01		 je	 SHORT $LN5@SetTCPNetw
  00027	cc		 int	 3
$LN5@SetTCPNetw:

; 1817 :     if (m_bService == true)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0002f	83 f9 01	 cmp	 ecx, 1
  00032	75 04		 jne	 SHORT $LN2@SetTCPNetw

; 1818 :         return false;

  00034	32 c0		 xor	 al, al
  00036	eb 5f		 jmp	 SHORT $LN1@SetTCPNetw
$LN2@SetTCPNetw:

; 1819 : 
; 1820 :     // 查询接口
; 1821 :     m_pITCPNetworkEngineEvent = QUERY_OBJECT_PTR_INTERFACE(pIUnknownEx, ITCPNetworkEngineEvent);

  00038	83 7d 08 00	 cmp	 DWORD PTR _pIUnknownEx$[ebp], 0
  0003c	75 09		 jne	 SHORT $LN6@SetTCPNetw
  0003e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  00045	eb 1a		 jmp	 SHORT $LN7@SetTCPNetw
$LN6@SetTCPNetw:
  00047	68 00 01 01 06	 push	 100729088		; 06010100H
  0004c	68 00 00 00 00	 push	 OFFSET ?IID_ITCPNetworkEngineEvent@@3U_GUID@@B
  00051	8b 55 08	 mov	 edx, DWORD PTR _pIUnknownEx$[ebp]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	8b 4d 08	 mov	 ecx, DWORD PTR _pIUnknownEx$[ebp]
  00059	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005c	ff d2		 call	 edx
  0005e	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
$LN7@SetTCPNetw:
  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  00067	89 88 24 40 00
	00		 mov	 DWORD PTR [eax+16420], ecx

; 1822 : 
; 1823 :     // 错误判断
; 1824 :     if (m_pITCPNetworkEngineEvent == NULL)

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00070	83 ba 24 40 00
	00 00		 cmp	 DWORD PTR [edx+16420], 0
  00077	75 1c		 jne	 SHORT $LN3@SetTCPNetw

; 1825 :     {
; 1826 :         ASSERT(FALSE);

  00079	33 c0		 xor	 eax, eax
  0007b	75 14		 jne	 SHORT $LN8@SetTCPNetw
  0007d	68 22 07 00 00	 push	 1826			; 00000722H
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00087	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0008c	85 c0		 test	 eax, eax
  0008e	74 01		 je	 SHORT $LN8@SetTCPNetw
  00090	cc		 int	 3
$LN8@SetTCPNetw:

; 1827 :         return false;

  00091	32 c0		 xor	 al, al
  00093	eb 02		 jmp	 SHORT $LN1@SetTCPNetw
$LN3@SetTCPNetw:

; 1828 :     }
; 1829 : 
; 1830 :     return true;

  00095	b0 01		 mov	 al, 1
$LN1@SetTCPNetw:

; 1831 : }

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?SetTCPNetworkEngineEvent@CTCPNetworkEngine@@UAE_NPAUIUnknownEx@@@Z ENDP ; CTCPNetworkEngine::SetTCPNetworkEngineEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?GetCurrentPort@CTCPNetworkEngine@@UAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCurrentPort@CTCPNetworkEngine@@UAEGXZ PROC		; CTCPNetworkEngine::GetCurrentPort, COMDAT
; _this$ = ecx

; 1808 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1809 :     return m_wServicePort;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 80 12 40
	00 00		 mov	 ax, WORD PTR [eax+16402]

; 1810 : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetCurrentPort@CTCPNetworkEngine@@UAEGXZ ENDP		; CTCPNetworkEngine::GetCurrentPort
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?GetServicePort@CTCPNetworkEngine@@UAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetServicePort@CTCPNetworkEngine@@UAEGXZ PROC		; CTCPNetworkEngine::GetServicePort, COMDAT
; _this$ = ecx

; 1802 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1803 :     return m_wServicePort;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 80 12 40
	00 00		 mov	 ax, WORD PTR [eax+16402]

; 1804 : }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?GetServicePort@CTCPNetworkEngine@@UAEGXZ ENDP		; CTCPNetworkEngine::GetServicePort
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
_TEXT	SEGMENT
$T2 = -64						; size = 4
tv173 = -60						; size = 4
$T3 = -56						; size = 4
_nCount$ = -52						; size = 4
$T4 = -48						; size = 4
_i$5 = -44						; size = 4
_pTCPNetworkItem$ = -40					; size = 4
_i$6 = -36						; size = 4
_i$7 = -32						; size = 4
_pSocketThread$8 = -28					; size = 4
_this$ = -24						; size = 4
$T9 = -18						; size = 2
__$EHRec$ = -16						; size = 16
?ConcludeService@CTCPNetworkEngine@@UAE_NXZ PROC	; CTCPNetworkEngine::ConcludeService, COMDAT
; _this$ = ecx

; 1727 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 30	 sub	 esp, 48			; 00000030H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1728 :     // 设置变量
; 1729 :     m_bService = false;

  0002f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c6 40 0e 00	 mov	 BYTE PTR [eax+14], 0

; 1730 : 
; 1731 :     // 检测线程
; 1732 :     m_SocketDetectThread.ConcludeThread(INFINITE);

  00036	6a ff		 push	 -1
  00038	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  00041	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 82 2c 81 00
	00		 mov	 eax, DWORD PTR [edx+33068]
  0004a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0004d	ff d2		 call	 edx

; 1733 : 
; 1734 :     // 应答线程
; 1735 :     if (m_hServerSocket != INVALID_SOCKET)

  0004f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 b8 1c 40 00
	00 ff		 cmp	 DWORD PTR [eax+16412], -1
  00059	74 1d		 je	 SHORT $LN11@ConcludeSe

; 1736 :     {
; 1737 :         closesocket(m_hServerSocket);

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	8b 91 1c 40 00
	00		 mov	 edx, DWORD PTR [ecx+16412]
  00064	52		 push	 edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 1738 :         m_hServerSocket = INVALID_SOCKET;

  0006b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 80 1c 40 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+16412], -1
$LN11@ConcludeSe:

; 1739 :     }
; 1740 :     m_SocketAcceptThread.ConcludeThread(INFINITE);

  00078	6a ff		 push	 -1
  0007a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  00083	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00086	8b 82 48 81 00
	00		 mov	 eax, DWORD PTR [edx+33096]
  0008c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0008f	ff d2		 call	 edx

; 1741 : 
; 1742 :     // 异步引擎
; 1743 :     m_AsynchronismEngine.ConcludeService();

  00091	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  0009a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 90 c0 40 00
	00		 mov	 edx, DWORD PTR [eax+16576]
  000a3	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000a6	ff d0		 call	 eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000a8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 91 74 81 00
	00		 mov	 edx, DWORD PTR [ecx+33140]
  000b1	89 55 cc	 mov	 DWORD PTR _nCount$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1747 :     if (m_hCompletionPort != NULL)

  000b4	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	83 b8 20 40 00
	00 00		 cmp	 DWORD PTR [eax+16416], 0
  000be	74 32		 je	 SHORT $LN12@ConcludeSe

; 1748 :     {
; 1749 :         for (INT_PTR i = 0; i < nCount; i++) PostQueuedCompletionStatus(m_hCompletionPort, 0, NULL, NULL);

  000c0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  000c7	eb 09		 jmp	 SHORT $LN4@ConcludeSe
$LN2@ConcludeSe:
  000c9	8b 4d d4	 mov	 ecx, DWORD PTR _i$5[ebp]
  000cc	83 c1 01	 add	 ecx, 1
  000cf	89 4d d4	 mov	 DWORD PTR _i$5[ebp], ecx
$LN4@ConcludeSe:
  000d2	8b 55 d4	 mov	 edx, DWORD PTR _i$5[ebp]
  000d5	3b 55 cc	 cmp	 edx, DWORD PTR _nCount$[ebp]
  000d8	7d 18		 jge	 SHORT $LN12@ConcludeSe
  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	6a 00		 push	 0
  000e0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b 88 20 40 00
	00		 mov	 ecx, DWORD PTR [eax+16416]
  000e9	51		 push	 ecx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQueuedCompletionStatus@16
  000f0	eb d7		 jmp	 SHORT $LN2@ConcludeSe
$LN12@ConcludeSe:

; 1750 :     }
; 1751 :     for (INT_PTR i = 0; i < nCount; i++)

  000f2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 0
  000f9	eb 09		 jmp	 SHORT $LN7@ConcludeSe
$LN5@ConcludeSe:
  000fb	8b 55 e0	 mov	 edx, DWORD PTR _i$7[ebp]
  000fe	83 c2 01	 add	 edx, 1
  00101	89 55 e0	 mov	 DWORD PTR _i$7[ebp], edx
$LN7@ConcludeSe:
  00104	8b 45 e0	 mov	 eax, DWORD PTR _i$7[ebp]
  00107	3b 45 cc	 cmp	 eax, DWORD PTR _nCount$[ebp]
  0010a	0f 8d af 00 00
	00		 jge	 $LN6@ConcludeSe
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00110	8b 4d e0	 mov	 ecx, DWORD PTR _i$7[ebp]
  00113	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1753 :         CTCPNetworkThreadReadWrite * pSocketThread = m_SocketRWThreadArray[i];

  00114	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0011d	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1753 :         CTCPNetworkThreadReadWrite * pSocketThread = m_SocketRWThreadArray[i];

  00122	8b 10		 mov	 edx, DWORD PTR [eax]
  00124	89 55 e4	 mov	 DWORD PTR _pSocketThread$8[ebp], edx

; 1754 :         ASSERT(pSocketThread != NULL);

  00127	83 7d e4 00	 cmp	 DWORD PTR _pSocketThread$8[ebp], 0
  0012b	75 14		 jne	 SHORT $LN16@ConcludeSe
  0012d	68 da 06 00 00	 push	 1754			; 000006daH
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00137	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0013c	85 c0		 test	 eax, eax
  0013e	74 01		 je	 SHORT $LN16@ConcludeSe
  00140	cc		 int	 3
$LN16@ConcludeSe:

; 1755 :         pSocketThread->ConcludeThread(INFINITE);

  00141	6a ff		 push	 -1
  00143	8b 4d e4	 mov	 ecx, DWORD PTR _pSocketThread$8[ebp]
  00146	8b 11		 mov	 edx, DWORD PTR [ecx]
  00148	8b 4d e4	 mov	 ecx, DWORD PTR _pSocketThread$8[ebp]
  0014b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0014e	ff d0		 call	 eax

; 1756 :         SafeDelete(pSocketThread);

  00150	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00157	8b 4d e4	 mov	 ecx, DWORD PTR _pSocketThread$8[ebp]
  0015a	89 4d c8	 mov	 DWORD PTR $T3[ebp], ecx
  0015d	8b 55 c8	 mov	 edx, DWORD PTR $T3[ebp]
  00160	89 55 d0	 mov	 DWORD PTR $T4[ebp], edx
  00163	83 7d d0 00	 cmp	 DWORD PTR $T4[ebp], 0
  00167	74 13		 je	 SHORT $LN17@ConcludeSe
  00169	6a 01		 push	 1
  0016b	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0016e	8b 10		 mov	 edx, DWORD PTR [eax]
  00170	8b 4d d0	 mov	 ecx, DWORD PTR $T4[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	ff d0		 call	 eax
  00177	89 45 c4	 mov	 DWORD PTR tv173[ebp], eax
  0017a	eb 07		 jmp	 SHORT $LN18@ConcludeSe
$LN17@ConcludeSe:
  0017c	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv173[ebp], 0
$LN18@ConcludeSe:
  00183	eb 1e		 jmp	 SHORT $LN20@ConcludeSe
__catch$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$0:
  00185	33 c9		 xor	 ecx, ecx
  00187	75 14		 jne	 SHORT $LN19@ConcludeSe
  00189	68 dc 06 00 00	 push	 1756			; 000006dcH
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00193	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00198	85 c0		 test	 eax, eax
  0019a	74 01		 je	 SHORT $LN19@ConcludeSe
  0019c	cc		 int	 3
$LN19@ConcludeSe:
  0019d	b8 00 00 00 00	 mov	 eax, $LN23@ConcludeSe
  001a2	c3		 ret	 0
$LN20@ConcludeSe:
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001aa	eb 07		 jmp	 SHORT __tryend$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$1
$LN23@ConcludeSe:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
  001ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ$1:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1756 :         SafeDelete(pSocketThread);

  001b3	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pSocketThread$8[ebp], 0

; 1757 :     }

  001ba	e9 3c ff ff ff	 jmp	 $LN5@ConcludeSe
$LN6@ConcludeSe:

; 1758 :     m_SocketRWThreadArray.RemoveAll();

  001bf	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c2	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
  001c8	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXXZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::RemoveAll

; 1759 : 
; 1760 :     // 完成端口
; 1761 :     if (m_hCompletionPort != NULL)

  001cd	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001d0	83 b8 20 40 00
	00 00		 cmp	 DWORD PTR [eax+16416], 0
  001d7	74 1d		 je	 SHORT $LN14@ConcludeSe

; 1762 :     {
; 1763 :         CloseHandle(m_hCompletionPort);

  001d9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001dc	8b 91 20 40 00
	00		 mov	 edx, DWORD PTR [ecx+16416]
  001e2	52		 push	 edx
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 1764 :         m_hCompletionPort = NULL;

  001e9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	c7 80 20 40 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+16416], 0
$LN14@ConcludeSe:

; 1765 :     }
; 1766 : 
; 1767 :     // 关闭连接
; 1768 :     CTCPNetworkItem * pTCPNetworkItem = NULL;

  001f6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkItem$[ebp], 0

; 1769 :     for (INT_PTR i = 0; i < m_NetworkItemActive.GetCount(); i++)

  001fd	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  00204	eb 09		 jmp	 SHORT $LN10@ConcludeSe
$LN8@ConcludeSe:
  00206	8b 4d dc	 mov	 ecx, DWORD PTR _i$6[ebp]
  00209	83 c1 01	 add	 ecx, 1
  0020c	89 4d dc	 mov	 DWORD PTR _i$6[ebp], ecx
$LN10@ConcludeSe:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  0020f	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00212	8b 82 70 40 00
	00		 mov	 eax, DWORD PTR [edx+16496]
  00218	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1769 :     for (INT_PTR i = 0; i < m_NetworkItemActive.GetCount(); i++)

  0021b	8b 4d dc	 mov	 ecx, DWORD PTR _i$6[ebp]
  0021e	3b 4d c0	 cmp	 ecx, DWORD PTR $T2[ebp]
  00221	7d 39		 jge	 SHORT $LN9@ConcludeSe
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00223	8b 55 dc	 mov	 edx, DWORD PTR _i$6[ebp]
  00226	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1771 :         pTCPNetworkItem = m_NetworkItemActive[i];

  00227	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00230	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1771 :         pTCPNetworkItem = m_NetworkItemActive[i];

  00235	8b 00		 mov	 eax, DWORD PTR [eax]
  00237	89 45 d8	 mov	 DWORD PTR _pTCPNetworkItem$[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  0023a	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  0023d	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00241	66 89 55 ee	 mov	 WORD PTR $T9[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1772 :         pTCPNetworkItem->CloseSocket(pTCPNetworkItem->GetRountID());

  00245	0f b7 45 ee	 movzx	 eax, WORD PTR $T9[ebp]
  00249	50		 push	 eax
  0024a	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  0024d	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1773 :         pTCPNetworkItem->ResumeData();

  00252	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  00255	e8 00 00 00 00	 call	 ?ResumeData@CTCPNetworkItem@@QAEKXZ ; CTCPNetworkItem::ResumeData

; 1774 :     }

  0025a	eb aa		 jmp	 SHORT $LN8@ConcludeSe
$LN9@ConcludeSe:

; 1775 : 
; 1776 :     // 重置数据
; 1777 :     m_NetworkItemBuffer.Append(m_NetworkItemActive);

  0025c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  00265	51		 push	 ecx
  00266	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  0026f	e8 00 00 00 00	 call	 ?Append@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABV1@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Append

; 1778 :     m_NetworkItemActive.RemoveAll();

  00274	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00277	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  0027d	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAll

; 1779 :     m_TempNetworkItemArray.RemoveAll();

  00282	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00285	81 c1 88 40 00
	00		 add	 ecx, 16520		; 00004088H
  0028b	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAll

; 1780 : 
; 1781 :     return true;

  00290	b0 01		 mov	 al, 1

; 1782 : }

  00292	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00295	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0029c	59		 pop	 ecx
  0029d	5f		 pop	 edi
  0029e	5e		 pop	 esi
  0029f	5b		 pop	 ebx
  002a0	8b e5		 mov	 esp, ebp
  002a2	5d		 pop	 ebp
  002a3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ConcludeService@CTCPNetworkEngine@@UAE_NXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ConcludeService@CTCPNetworkEngine@@UAE_NXZ ENDP	; CTCPNetworkEngine::ConcludeService
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?StartService@CTCPNetworkEngine@@UAE_NXZ
_TEXT	SEGMENT
_SystemInfo$ = -368					; size = 36
_nIndex$2 = -332					; size = 4
$T3 = -328						; size = 4
_pIUnknownEx$ = -324					; size = 4
_pszString$4 = -320					; size = 4
_dwThreadCount$ = -316					; size = 4
_this$ = -312						; size = 4
_pNetworkRSThread$5 = -308				; size = 4
tv231 = -304						; size = 4
$T6 = -300						; size = 4
_pNetworkRSThread$7 = -296				; size = 4
_i$8 = -292						; size = 4
_i$9 = -288						; size = 4
_m_AutoServicPort$ = -284				; size = 2
_this$ = -280						; size = 4
_pszServicePort$10 = -276				; size = 260
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?StartService@CTCPNetworkEngine@@UAE_NXZ PROC		; CTCPNetworkEngine::StartService, COMDAT
; _this$ = ecx

; 1608 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?StartService@CTCPNetworkEngine@@UAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1609 :     // 状态效验
; 1610 :     ASSERT(m_bService == false);

  00031	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00037	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 14		 je	 SHORT $LN27@StartServi
  0003f	68 4a 06 00 00	 push	 1610			; 0000064aH
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00049	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004e	85 c0		 test	 eax, eax
  00050	74 01		 je	 SHORT $LN27@StartServi
  00052	cc		 int	 3
$LN27@StartServi:

; 1611 :     if (m_bService == true)

  00053	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00059	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  0005d	83 f9 01	 cmp	 ecx, 1
  00060	75 07		 jne	 SHORT $LN10@StartServi

; 1612 :         return false;

  00062	32 c0		 xor	 al, al
  00064	e9 e7 04 00 00	 jmp	 $LN1@StartServi
$LN10@StartServi:

; 1613 : 
; 1614 :     // 效验参数
; 1615 : 	ASSERT(m_wMaxConnect!=0);

  00069	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0006f	0f b7 82 10 40
	00 00		 movzx	 eax, WORD PTR [edx+16400]
  00076	85 c0		 test	 eax, eax
  00078	75 14		 jne	 SHORT $LN28@StartServi
  0007a	68 4f 06 00 00	 push	 1615			; 0000064fH
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00084	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00089	85 c0		 test	 eax, eax
  0008b	74 01		 je	 SHORT $LN28@StartServi
  0008d	cc		 int	 3
$LN28@StartServi:

; 1616 : 	if (m_wMaxConnect==0) return false;

  0008e	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00094	0f b7 82 10 40
	00 00		 movzx	 eax, WORD PTR [edx+16400]
  0009b	85 c0		 test	 eax, eax
  0009d	75 07		 jne	 SHORT $LN11@StartServi
  0009f	32 c0		 xor	 al, al
  000a1	e9 aa 04 00 00	 jmp	 $LN1@StartServi
$LN11@StartServi:

; 1617 : 
; 1618 :     // 系统信息
; 1619 :     SYSTEM_INFO SystemInfo;
; 1620 :     GetSystemInfo(&SystemInfo);

  000a6	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _SystemInfo$[ebp]
  000ac	51		 push	 ecx
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemInfo@4

; 1621 :     DWORD dwThreadCount = SystemInfo.dwNumberOfProcessors;

  000b3	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _SystemInfo$[ebp+20]
  000b9	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _dwThreadCount$[ebp], edx

; 1622 : 
; 1623 :     // 完成端口
; 1624 :     m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, SystemInfo.dwNumberOfProcessors);

  000bf	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _SystemInfo$[ebp+20]
  000c5	50		 push	 eax
  000c6	6a 00		 push	 0
  000c8	6a 00		 push	 0
  000ca	6a ff		 push	 -1
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16
  000d2	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	89 81 20 40 00
	00		 mov	 DWORD PTR [ecx+16416], eax

; 1625 :     if (m_hCompletionPort == NULL)

  000de	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000e4	83 ba 20 40 00
	00 00		 cmp	 DWORD PTR [edx+16416], 0
  000eb	75 07		 jne	 SHORT $LN12@StartServi

; 1626 :     {
; 1627 :         return false;

  000ed	32 c0		 xor	 al, al
  000ef	e9 5c 04 00 00	 jmp	 $LN1@StartServi
$LN12@StartServi:

; 1628 :     }
; 1629 : 
; 1630 :     // 自动随机端口
; 1631 : 	WORD m_AutoServicPort = 3000;

  000f4	b8 b8 0b 00 00	 mov	 eax, 3000		; 00000bb8H
  000f9	66 89 85 e4 fe
	ff ff		 mov	 WORD PTR _m_AutoServicPort$[ebp], ax

; 1632 :     if(m_wServicePort == 0)

  00100	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00106	0f b7 91 12 40
	00 00		 movzx	 edx, WORD PTR [ecx+16402]
  0010d	85 d2		 test	 edx, edx
  0010f	0f 85 13 01 00
	00		 jne	 $LN13@StartServi
$LN2@StartServi:

; 1633 :     {
; 1634 : 		while(TRUE)

  00115	b8 01 00 00 00	 mov	 eax, 1
  0011a	85 c0		 test	 eax, eax
  0011c	0f 84 04 01 00
	00		 je	 $LN3@StartServi

; 1635 : 		{
; 1636 : 			if(m_AutoServicPort != PORT_LOGON && m_AutoServicPort != PORT_CENTER && m_AutoServicPort != PORT_MANAGER)

  00122	0f b7 8d e4 fe
	ff ff		 movzx	 ecx, WORD PTR _m_AutoServicPort$[ebp]
  00129	81 f9 72 17 00
	00		 cmp	 ecx, 6002		; 00001772H
  0012f	0f 84 a7 00 00
	00		 je	 $LN15@StartServi
  00135	0f b7 95 e4 fe
	ff ff		 movzx	 edx, WORD PTR _m_AutoServicPort$[ebp]
  0013c	81 fa 75 17 00
	00		 cmp	 edx, 6005		; 00001775H
  00142	0f 84 94 00 00
	00		 je	 $LN15@StartServi
  00148	0f b7 85 e4 fe
	ff ff		 movzx	 eax, WORD PTR _m_AutoServicPort$[ebp]
  0014f	3d ac 21 00 00	 cmp	 eax, 8620		; 000021acH
  00154	0f 84 82 00 00
	00		 je	 $LN15@StartServi

; 1637 : 			{
; 1638 : 				if(CreateSocket(m_AutoServicPort))

  0015a	0f b7 8d e4 fe
	ff ff		 movzx	 ecx, WORD PTR _m_AutoServicPort$[ebp]
  00161	51		 push	 ecx
  00162	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z ; CTCPNetworkEngine::CreateSocket
  0016d	0f b6 d0	 movzx	 edx, al
  00170	85 d2		 test	 edx, edx
  00172	74 68		 je	 SHORT $LN15@StartServi

; 1639 : 				{
; 1640 : 					m_wServicePort = m_AutoServicPort;

  00174	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0017a	66 8b 8d e4 fe
	ff ff		 mov	 cx, WORD PTR _m_AutoServicPort$[ebp]
  00181	66 89 88 12 40
	00 00		 mov	 WORD PTR [eax+16402], cx

; 1641 : 					// 输出端口
; 1642 : 					TCHAR pszServicePort[MAX_PATH]=TEXT("");

  00188	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  0018e	88 95 ec fe ff
	ff		 mov	 BYTE PTR _pszServicePort$10[ebp], dl
  00194	68 03 01 00 00	 push	 259			; 00000103H
  00199	6a 00		 push	 0
  0019b	8d 85 ed fe ff
	ff		 lea	 eax, DWORD PTR _pszServicePort$10[ebp+1]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 _memset
  001a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1643 : 				#ifdef UNICODE
; 1644 : 					wsprintfW(pszServicePort,L"未指定网络端口，将随机分配",m_AutoServicPort);
; 1645 : 				#else
; 1646 : 					wsprintfA(pszServicePort, "未指定网络端口，将随机分配", m_AutoServicPort);

  001aa	0f b7 8d e4 fe
	ff ff		 movzx	 ecx, WORD PTR _m_AutoServicPort$[ebp]
  001b1	51		 push	 ecx
  001b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@FJOHAJKD@?N?$LE?V?$LI?$LG?$KI?M?x?B?g?$LG?K?$LP?Z?$KD?$KM?$LN?$KL?K?f?$LL?z?$LH?V?E?d@
  001b7	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _pszServicePort$10[ebp]
  001bd	52		 push	 edx
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  001c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1647 : 				#endif // !UNICODE
; 1648 : 					g_TraceServiceManager.TraceString(pszServicePort,TraceLevel_Exception);

  001c7	6a 03		 push	 3
  001c9	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _pszServicePort$10[ebp]
  001cf	50		 push	 eax
  001d0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  001d5	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1649 : 					break;

  001da	eb 4a		 jmp	 SHORT $LN3@StartServi
$LN15@StartServi:

; 1650 : 				}
; 1651 : 			}
; 1652 : 			if(m_AutoServicPort >= 9000)

  001dc	0f b7 8d e4 fe
	ff ff		 movzx	 ecx, WORD PTR _m_AutoServicPort$[ebp]
  001e3	81 f9 28 23 00
	00		 cmp	 ecx, 9000		; 00002328H
  001e9	7c 24		 jl	 SHORT $LN17@StartServi

; 1653 : 			{
; 1654 : 				LPCTSTR pszString=TEXT("尝试了众多的端口号，监听操作失败");

  001eb	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _pszString$4[ebp], OFFSET ??_C@_0CB@DMDLLPEB@?$LD?$KC?J?T?A?K?V?Z?$LG?$OA?$LF?D?$LG?K?$LP?Z?$LK?E?$KD?$KM?$LM?$OA?L?$PN?$LC?Y?W?w?J?$KH?$LA@

; 1655 : 				g_TraceServiceManager.TraceString(pszString, TraceLevel_Exception);

  001f5	6a 03		 push	 3
  001f7	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _pszString$4[ebp]
  001fd	52		 push	 edx
  001fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00203	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1656 : 				return false;

  00208	32 c0		 xor	 al, al
  0020a	e9 41 03 00 00	 jmp	 $LN1@StartServi
$LN17@StartServi:

; 1657 : 			}
; 1658 : 			m_AutoServicPort++;

  0020f	66 8b 85 e4 fe
	ff ff		 mov	 ax, WORD PTR _m_AutoServicPort$[ebp]
  00216	66 83 c0 01	 add	 ax, 1
  0021a	66 89 85 e4 fe
	ff ff		 mov	 WORD PTR _m_AutoServicPort$[ebp], ax

; 1659 : 		}

  00221	e9 ef fe ff ff	 jmp	 $LN2@StartServi
$LN3@StartServi:

; 1660 : 	}
; 1661 :     else

  00226	eb 35		 jmp	 SHORT $LN14@StartServi
$LN13@StartServi:

; 1662 :     {
; 1663 :         m_AutoServicPort = m_wServicePort;

  00228	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	66 8b 91 12 40
	00 00		 mov	 dx, WORD PTR [ecx+16402]
  00235	66 89 95 e4 fe
	ff ff		 mov	 WORD PTR _m_AutoServicPort$[ebp], dx

; 1664 :         if (!CreateSocket(m_AutoServicPort))

  0023c	0f b7 85 e4 fe
	ff ff		 movzx	 eax, WORD PTR _m_AutoServicPort$[ebp]
  00243	50		 push	 eax
  00244	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	e8 00 00 00 00	 call	 ?CreateSocket@CTCPNetworkEngine@@AAE_NG@Z ; CTCPNetworkEngine::CreateSocket
  0024f	0f b6 c8	 movzx	 ecx, al
  00252	85 c9		 test	 ecx, ecx
  00254	75 07		 jne	 SHORT $LN14@StartServi

; 1665 :     {
; 1666 :         return false;

  00256	32 c0		 xor	 al, al
  00258	e9 f3 02 00 00	 jmp	 $LN1@StartServi
$LN14@StartServi:

; 1667 :     }
; 1668 :     }
; 1669 : 
; 1670 :     // 异步引擎
; 1671 :     IUnknownEx * pIUnknownEx = QUERY_ME_INTERFACE(IUnknownEx);

  0025d	68 00 01 01 06	 push	 100729088		; 06010100H
  00262	68 00 00 00 00	 push	 OFFSET ?IID_IUnknownEx@@3U_GUID@@B
  00267	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0026d	8b 02		 mov	 eax, DWORD PTR [edx]
  0026f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00275	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00278	ff d2		 call	 edx
  0027a	89 85 bc fe ff
	ff		 mov	 DWORD PTR _pIUnknownEx$[ebp], eax

; 1672 :     if (m_AsynchronismEngine.SetAsynchronismSink(pIUnknownEx) == false)

  00280	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pIUnknownEx$[ebp]
  00286	50		 push	 eax
  00287	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0028d	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00293	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00299	8b 82 c0 40 00
	00		 mov	 eax, DWORD PTR [edx+16576]
  0029f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  002a2	ff d2		 call	 edx
  002a4	0f b6 c0	 movzx	 eax, al
  002a7	85 c0		 test	 eax, eax
  002a9	75 1f		 jne	 SHORT $LN19@StartServi

; 1673 :     {
; 1674 :         ASSERT(FALSE);

  002ab	33 c9		 xor	 ecx, ecx
  002ad	75 14		 jne	 SHORT $LN29@StartServi
  002af	68 8a 06 00 00	 push	 1674			; 0000068aH
  002b4	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  002b9	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  002be	85 c0		 test	 eax, eax
  002c0	74 01		 je	 SHORT $LN29@StartServi
  002c2	cc		 int	 3
$LN29@StartServi:

; 1675 :         return false;

  002c3	32 c0		 xor	 al, al
  002c5	e9 86 02 00 00	 jmp	 $LN1@StartServi
$LN19@StartServi:

; 1676 :     }
; 1677 : 
; 1678 :     // 网页验证
; 1679 :     WebAttestation();

  002ca	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	e8 00 00 00 00	 call	 ?WebAttestation@CTCPNetworkEngine@@AAE_NXZ ; CTCPNetworkEngine::WebAttestation

; 1680 : 
; 1681 :     // 启动服务
; 1682 :     if (m_AsynchronismEngine.StartService() == false)

  002d5	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002db	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  002e1	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002e7	8b 90 c0 40 00
	00		 mov	 edx, DWORD PTR [eax+16576]
  002ed	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  002f0	ff d0		 call	 eax
  002f2	0f b6 c8	 movzx	 ecx, al
  002f5	85 c9		 test	 ecx, ecx
  002f7	75 1f		 jne	 SHORT $LN20@StartServi

; 1683 :     {
; 1684 :         ASSERT(FALSE);

  002f9	33 d2		 xor	 edx, edx
  002fb	75 14		 jne	 SHORT $LN30@StartServi
  002fd	68 94 06 00 00	 push	 1684			; 00000694H
  00302	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00307	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0030c	85 c0		 test	 eax, eax
  0030e	74 01		 je	 SHORT $LN30@StartServi
  00310	cc		 int	 3
$LN30@StartServi:

; 1685 :         return false;

  00311	32 c0		 xor	 al, al
  00313	e9 38 02 00 00	 jmp	 $LN1@StartServi
$LN20@StartServi:

; 1686 :     }
; 1687 : 
; 1688 :     // 读写线程
; 1689 :     for (DWORD i = 0; i < dwThreadCount; i++)

  00318	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  00322	eb 0f		 jmp	 SHORT $LN6@StartServi
$LN4@StartServi:
  00324	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _i$8[ebp]
  0032a	83 c1 01	 add	 ecx, 1
  0032d	89 8d dc fe ff
	ff		 mov	 DWORD PTR _i$8[ebp], ecx
$LN6@StartServi:
  00333	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _i$8[ebp]
  00339	3b 95 c4 fe ff
	ff		 cmp	 edx, DWORD PTR _dwThreadCount$[ebp]
  0033f	0f 83 c1 00 00
	00		 jae	 $LN5@StartServi

; 1690 :     {
; 1691 :         CTCPNetworkThreadReadWrite * pNetworkRSThread = new CTCPNetworkThreadReadWrite();

  00345	6a 14		 push	 20			; 00000014H
  00347	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0034c	83 c4 04	 add	 esp, 4
  0034f	89 85 d4 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  00355	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0035c	83 bd d4 fe ff
	ff 00		 cmp	 DWORD PTR $T6[ebp], 0
  00363	74 13		 je	 SHORT $LN31@StartServi
  00365	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  0036b	e8 00 00 00 00	 call	 ??0CTCPNetworkThreadReadWrite@@QAE@XZ ; CTCPNetworkThreadReadWrite::CTCPNetworkThreadReadWrite
  00370	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  00376	eb 0a		 jmp	 SHORT $LN32@StartServi
$LN31@StartServi:
  00378	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv231[ebp], 0
$LN32@StartServi:
  00382	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv231[ebp]
  00388	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0038e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00395	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  0039b	89 8d cc fe ff
	ff		 mov	 DWORD PTR _pNetworkRSThread$5[ebp], ecx

; 1692 :         if (pNetworkRSThread->InitThread(m_hCompletionPort) == false)

  003a1	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003a7	8b 82 20 40 00
	00		 mov	 eax, DWORD PTR [edx+16416]
  003ad	50		 push	 eax
  003ae	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _pNetworkRSThread$5[ebp]
  003b4	e8 00 00 00 00	 call	 ?InitThread@CTCPNetworkThreadReadWrite@@QAE_NPAX@Z ; CTCPNetworkThreadReadWrite::InitThread
  003b9	0f b6 c8	 movzx	 ecx, al
  003bc	85 c9		 test	 ecx, ecx
  003be	75 07		 jne	 SHORT $LN21@StartServi

; 1693 :             return false;

  003c0	32 c0		 xor	 al, al
  003c2	e9 89 01 00 00	 jmp	 $LN1@StartServi
$LN21@StartServi:

; 1694 :         m_SocketRWThreadArray.Add(pNetworkRSThread);

  003c7	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003cd	81 c2 64 81 00
	00		 add	 edx, 33124		; 00008164H
  003d3	89 95 c8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  003d9	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003df	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  003e2	89 8d b4 fe ff
	ff		 mov	 DWORD PTR _nIndex$2[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  003e8	8d 95 cc fe ff
	ff		 lea	 edx, DWORD PTR _pNetworkRSThread$5[ebp]
  003ee	52		 push	 edx
  003ef	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _nIndex$2[ebp]
  003f5	50		 push	 eax
  003f6	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003fc	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1695 :     }

  00401	e9 1e ff ff ff	 jmp	 $LN4@StartServi
$LN5@StartServi:

; 1696 : 
; 1697 :     // 应答线程
; 1698 :     if (m_SocketAcceptThread.InitThread(m_hCompletionPort, m_hServerSocket, this) == false)

  00406	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0040c	51		 push	 ecx
  0040d	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00413	8b 82 1c 40 00
	00		 mov	 eax, DWORD PTR [edx+16412]
  00419	50		 push	 eax
  0041a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00420	8b 91 20 40 00
	00		 mov	 edx, DWORD PTR [ecx+16416]
  00426	52		 push	 edx
  00427	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0042d	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  00433	e8 00 00 00 00	 call	 ?InitThread@CTCPNetworkThreadAccept@@QAE_NPAXIPAVCTCPNetworkEngine@@@Z ; CTCPNetworkThreadAccept::InitThread
  00438	0f b6 c0	 movzx	 eax, al
  0043b	85 c0		 test	 eax, eax
  0043d	75 07		 jne	 SHORT $LN22@StartServi

; 1699 :         return false;

  0043f	32 c0		 xor	 al, al
  00441	e9 0a 01 00 00	 jmp	 $LN1@StartServi
$LN22@StartServi:

; 1700 : 
; 1701 :     // 读写线程
; 1702 :     for (DWORD i = 0; i < dwThreadCount; i++)

  00446	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$9[ebp], 0
  00450	eb 0f		 jmp	 SHORT $LN9@StartServi
$LN7@StartServi:
  00452	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _i$9[ebp]
  00458	83 c1 01	 add	 ecx, 1
  0045b	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _i$9[ebp], ecx
$LN9@StartServi:
  00461	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _i$9[ebp]
  00467	3b 95 c4 fe ff
	ff		 cmp	 edx, DWORD PTR _dwThreadCount$[ebp]
  0046d	73 60		 jae	 SHORT $LN8@StartServi
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0046f	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$9[ebp]
  00475	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1704 :         CTCPNetworkThreadReadWrite * pNetworkRSThread = m_SocketRWThreadArray[i];

  00476	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0047c	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00482	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1704 :         CTCPNetworkThreadReadWrite * pNetworkRSThread = m_SocketRWThreadArray[i];

  00487	8b 08		 mov	 ecx, DWORD PTR [eax]
  00489	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _pNetworkRSThread$7[ebp], ecx

; 1705 :         ASSERT(pNetworkRSThread != NULL);

  0048f	83 bd d8 fe ff
	ff 00		 cmp	 DWORD PTR _pNetworkRSThread$7[ebp], 0
  00496	75 14		 jne	 SHORT $LN33@StartServi
  00498	68 a9 06 00 00	 push	 1705			; 000006a9H
  0049d	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  004a2	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  004a7	85 c0		 test	 eax, eax
  004a9	74 01		 je	 SHORT $LN33@StartServi
  004ab	cc		 int	 3
$LN33@StartServi:

; 1706 :         if (pNetworkRSThread->StartThread() == false)

  004ac	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _pNetworkRSThread$7[ebp]
  004b2	8b 10		 mov	 edx, DWORD PTR [eax]
  004b4	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _pNetworkRSThread$7[ebp]
  004ba	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  004bd	ff d0		 call	 eax
  004bf	0f b6 c8	 movzx	 ecx, al
  004c2	85 c9		 test	 ecx, ecx
  004c4	75 07		 jne	 SHORT $LN23@StartServi

; 1707 :             return false;

  004c6	32 c0		 xor	 al, al
  004c8	e9 83 00 00 00	 jmp	 $LN1@StartServi
$LN23@StartServi:

; 1708 :     }

  004cd	eb 83		 jmp	 SHORT $LN7@StartServi
$LN8@StartServi:

; 1709 : 
; 1710 :     // 检测线程
; 1711 :     m_SocketDetectThread.InitThread(this, m_dwDetectTime);

  004cf	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004d5	8b 82 14 40 00
	00		 mov	 eax, DWORD PTR [edx+16404]
  004db	50		 push	 eax
  004dc	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004e2	51		 push	 ecx
  004e3	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004e9	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  004ef	e8 00 00 00 00	 call	 ?InitThread@CTCPNetworkThreadDetect@@QAE_NPAVCTCPNetworkEngine@@K@Z ; CTCPNetworkThreadDetect::InitThread

; 1712 :     if (m_SocketDetectThread.StartThread() == false)

  004f4	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004fa	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  00500	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00506	8b 82 2c 81 00
	00		 mov	 eax, DWORD PTR [edx+33068]
  0050c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0050f	ff d2		 call	 edx
  00511	0f b6 c0	 movzx	 eax, al
  00514	85 c0		 test	 eax, eax
  00516	75 04		 jne	 SHORT $LN24@StartServi

; 1713 :         return false;

  00518	32 c0		 xor	 al, al
  0051a	eb 34		 jmp	 SHORT $LN1@StartServi
$LN24@StartServi:

; 1714 : 
; 1715 :     // 应答线程
; 1716 :     if (m_SocketAcceptThread.StartThread() == false)

  0051c	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00522	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  00528	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0052e	8b 82 48 81 00
	00		 mov	 eax, DWORD PTR [edx+33096]
  00534	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00537	ff d2		 call	 edx
  00539	0f b6 c0	 movzx	 eax, al
  0053c	85 c0		 test	 eax, eax
  0053e	75 04		 jne	 SHORT $LN25@StartServi

; 1717 :         return false;

  00540	32 c0		 xor	 al, al
  00542	eb 0c		 jmp	 SHORT $LN1@StartServi
$LN25@StartServi:

; 1718 : 
; 1719 :     // 设置变量
; 1720 :     m_bService = true;

  00544	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0054a	c6 41 0e 01	 mov	 BYTE PTR [ecx+14], 1

; 1721 : 
; 1722 :     return true;

  0054e	b0 01		 mov	 al, 1
$LN1@StartServi:

; 1723 : }

  00550	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00553	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0055a	59		 pop	 ecx
  0055b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0055e	33 cd		 xor	 ecx, ebp
  00560	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00565	8b e5		 mov	 esp, ebp
  00567	5d		 pop	 ebp
  00568	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?StartService@CTCPNetworkEngine@@UAE_NXZ$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$?StartService@CTCPNetworkEngine@@UAE_NXZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 98 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-360]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?StartService@CTCPNetworkEngine@@UAE_NXZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?StartService@CTCPNetworkEngine@@UAE_NXZ ENDP		; CTCPNetworkEngine::StartService
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z
_TEXT	SEGMENT
tv235 = -56						; size = 4
tv218 = -52						; size = 4
tv201 = -48						; size = 4
tv168 = -44						; size = 4
tv223 = -40						; size = 4
tv234 = -36						; size = 4
tv138 = -32						; size = 4
tv206 = -28						; size = 4
tv217 = -24						; size = 4
tv189 = -20						; size = 4
tv200 = -16						; size = 4
tv162 = -12						; size = 4
tv170 = -8						; size = 4
_this$ = -4						; size = 4
_Guid$ = 8						; size = 4
_dwQueryVer$ = 12					; size = 4
?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z PROC ; CTCPNetworkEngine::QueryInterface, COMDAT
; _this$ = ecx

; 1598 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00009	6a 10		 push	 16			; 00000010H
  0000b	68 00 00 00 00	 push	 OFFSET ?IID_IServiceModule@@3U_GUID@@B
  00010	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memcmp
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	89 45 d4	 mov	 DWORD PTR tv168[ebp], eax
  0001f	83 7d d4 00	 cmp	 DWORD PTR tv168[ebp], 0
  00023	75 09		 jne	 SHORT $LN15@QueryInter
  00025	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv170[ebp], 1
  0002c	eb 07		 jmp	 SHORT $LN13@QueryInter
$LN15@QueryInter:
  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv170[ebp], 0
$LN13@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00035	83 7d f8 00	 cmp	 DWORD PTR tv170[ebp], 0
  00039	74 09		 je	 SHORT $LN11@QueryInter
  0003b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv162[ebp], 1
  00042	eb 07		 jmp	 SHORT $LN9@QueryInter
$LN11@QueryInter:
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv162[ebp], 0
$LN9@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1599 :     QUERYINTERFACE(IServiceModule, Guid, dwQueryVer);

  0004b	0f b6 4d f4	 movzx	 ecx, BYTE PTR tv162[ebp]
  0004f	85 c9		 test	 ecx, ecx
  00051	74 20		 je	 SHORT $LN2@QueryInter
  00053	68 00 01 01 06	 push	 100729088		; 06010100H
  00058	8b 55 0c	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  00061	83 c4 08	 add	 esp, 8
  00064	0f b6 c0	 movzx	 eax, al
  00067	85 c0		 test	 eax, eax
  00069	74 08		 je	 SHORT $LN2@QueryInter
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	e9 52 01 00 00	 jmp	 $LN1@QueryInter
$LN2@QueryInter:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00073	6a 10		 push	 16			; 00000010H
  00075	68 00 00 00 00	 push	 OFFSET ?IID_ITCPNetworkEngine@@3U_GUID@@B
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _Guid$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _memcmp
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	89 45 d0	 mov	 DWORD PTR tv201[ebp], eax
  00089	83 7d d0 00	 cmp	 DWORD PTR tv201[ebp], 0
  0008d	75 09		 jne	 SHORT $LN45@QueryInter
  0008f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv200[ebp], 1
  00096	eb 07		 jmp	 SHORT $LN43@QueryInter
$LN45@QueryInter:
  00098	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv200[ebp], 0
$LN43@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  0009f	83 7d f0 00	 cmp	 DWORD PTR tv200[ebp], 0
  000a3	74 09		 je	 SHORT $LN41@QueryInter
  000a5	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv189[ebp], 1
  000ac	eb 07		 jmp	 SHORT $LN39@QueryInter
$LN41@QueryInter:
  000ae	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv189[ebp], 0
$LN39@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1600 :     QUERYINTERFACE(ITCPNetworkEngine, Guid, dwQueryVer);

  000b5	0f b6 55 ec	 movzx	 edx, BYTE PTR tv189[ebp]
  000b9	85 d2		 test	 edx, edx
  000bb	74 20		 je	 SHORT $LN3@QueryInter
  000bd	68 00 01 01 06	 push	 100729088		; 06010100H
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  000cb	83 c4 08	 add	 esp, 8
  000ce	0f b6 c8	 movzx	 ecx, al
  000d1	85 c9		 test	 ecx, ecx
  000d3	74 08		 je	 SHORT $LN3@QueryInter
  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	e9 e8 00 00 00	 jmp	 $LN1@QueryInter
$LN3@QueryInter:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  000dd	6a 10		 push	 16			; 00000010H
  000df	68 00 00 00 00	 push	 OFFSET ?IID_IAsynchronismEngineSink@@3U_GUID@@B
  000e4	8b 55 08	 mov	 edx, DWORD PTR _Guid$[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 _memcmp
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f0	89 45 cc	 mov	 DWORD PTR tv218[ebp], eax
  000f3	83 7d cc 00	 cmp	 DWORD PTR tv218[ebp], 0
  000f7	75 09		 jne	 SHORT $LN75@QueryInter
  000f9	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv217[ebp], 1
  00100	eb 07		 jmp	 SHORT $LN73@QueryInter
$LN75@QueryInter:
  00102	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv217[ebp], 0
$LN73@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00109	83 7d e8 00	 cmp	 DWORD PTR tv217[ebp], 0
  0010d	74 09		 je	 SHORT $LN71@QueryInter
  0010f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv206[ebp], 1
  00116	eb 07		 jmp	 SHORT $LN69@QueryInter
$LN71@QueryInter:
  00118	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv206[ebp], 0
$LN69@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1601 :     QUERYINTERFACE(IAsynchronismEngineSink, Guid, dwQueryVer);

  0011f	0f b6 45 e4	 movzx	 eax, BYTE PTR tv206[ebp]
  00123	85 c0		 test	 eax, eax
  00125	74 35		 je	 SHORT $LN4@QueryInter
  00127	68 00 01 01 06	 push	 100729088		; 06010100H
  0012c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwQueryVer$[ebp]
  0012f	51		 push	 ecx
  00130	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  00135	83 c4 08	 add	 esp, 8
  00138	0f b6 d0	 movzx	 edx, al
  0013b	85 d2		 test	 edx, edx
  0013d	74 1d		 je	 SHORT $LN4@QueryInter
  0013f	83 7d fc 00	 cmp	 DWORD PTR _this$[ebp], 0
  00143	74 0b		 je	 SHORT $LN7@QueryInter
  00145	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00148	83 c0 04	 add	 eax, 4
  0014b	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0014e	eb 07		 jmp	 SHORT $LN8@QueryInter
$LN7@QueryInter:
  00150	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv138[ebp], 0
$LN8@QueryInter:
  00157	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  0015a	eb 69		 jmp	 SHORT $LN1@QueryInter
$LN4@QueryInter:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0015c	6a 10		 push	 16			; 00000010H
  0015e	68 00 00 00 00	 push	 OFFSET ?IID_IUnknownEx@@3U_GUID@@B
  00163	8b 4d 08	 mov	 ecx, DWORD PTR _Guid$[ebp]
  00166	51		 push	 ecx
  00167	e8 00 00 00 00	 call	 _memcmp
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016f	89 45 c8	 mov	 DWORD PTR tv235[ebp], eax
  00172	83 7d c8 00	 cmp	 DWORD PTR tv235[ebp], 0
  00176	75 09		 jne	 SHORT $LN105@QueryInter
  00178	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv234[ebp], 1
  0017f	eb 07		 jmp	 SHORT $LN103@QueryInter
$LN105@QueryInter:
  00181	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv234[ebp], 0
$LN103@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00188	83 7d dc 00	 cmp	 DWORD PTR tv234[ebp], 0
  0018c	74 09		 je	 SHORT $LN101@QueryInter
  0018e	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv223[ebp], 1
  00195	eb 07		 jmp	 SHORT $LN99@QueryInter
$LN101@QueryInter:
  00197	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv223[ebp], 0
$LN99@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1602 :     QUERYINTERFACE_IUNKNOWNEX(ITCPNetworkEngine, Guid, dwQueryVer);

  0019e	0f b6 55 d8	 movzx	 edx, BYTE PTR tv223[ebp]
  001a2	85 d2		 test	 edx, edx
  001a4	74 1d		 je	 SHORT $LN5@QueryInter
  001a6	68 00 01 01 06	 push	 100729088		; 06010100H
  001ab	8b 45 0c	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  001b4	83 c4 08	 add	 esp, 8
  001b7	0f b6 c8	 movzx	 ecx, al
  001ba	85 c9		 test	 ecx, ecx
  001bc	74 05		 je	 SHORT $LN5@QueryInter
  001be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	eb 02		 jmp	 SHORT $LN1@QueryInter
$LN5@QueryInter:

; 1603 :     return NULL;

  001c3	33 c0		 xor	 eax, eax
$LN1@QueryInter:

; 1604 : }

  001c5	8b e5		 mov	 esp, ebp
  001c7	5d		 pop	 ebp
  001c8	c2 08 00	 ret	 8
?QueryInterface@CTCPNetworkEngine@@UAEPAXABU_GUID@@K@Z ENDP ; CTCPNetworkEngine::QueryInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?Release@CTCPNetworkEngine@@UAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?Release@CTCPNetworkEngine@@UAEXXZ PROC			; CTCPNetworkEngine::Release, COMDAT
; _this$ = ecx

; 434  :     virtual VOID Release() { delete this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
  00015	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00019	74 14		 je	 SHORT $LN3@Release
  0001b	6a 01		 push	 1
  0001d	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00025	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  00028	ff d2		 call	 edx
  0002a	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0002d	eb 07		 jmp	 SHORT $LN1@Release
$LN3@Release:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN1@Release:
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Release@CTCPNetworkEngine@@UAEXXZ ENDP			; CTCPNetworkEngine::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1CTCPNetworkEngine@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTCPNetworkEngine@@UAE@XZ PROC			; CTCPNetworkEngine::~CTCPNetworkEngine, COMDAT
; _this$ = ecx

; 1592 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTCPNetworkEngine@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkEngine@@6BITCPNetworkEngine@@@
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@
  00039	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], OFFSET ??_7CTCPNetworkEngine@@6BITCPNetworkItemSink@@@

; 1593 : 	google::protobuf::ShutdownProtobufLibrary();

  00043	e8 00 00 00 00	 call	 ?ShutdownProtobufLibrary@protobuf@google@@YAXXZ ; google::protobuf::ShutdownProtobufLibrary

; 1594 : }

  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
  00051	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
  00056	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  0005f	e8 00 00 00 00	 call	 ??1CTCPNetworkThreadAccept@@UAE@XZ ; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  0006d	e8 00 00 00 00	 call	 ??1CTCPNetworkThreadDetect@@UAE@XZ ; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect
  00072	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  0007b	e8 00 00 00 00	 call	 ??1CAsynchronismEngine@@UAE@XZ ; CAsynchronismEngine::~CAsynchronismEngine
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	81 c1 9c 40 00
	00		 add	 ecx, 16540		; 0000409cH
  00089	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	81 c1 88 40 00
	00		 add	 ecx, 16520		; 00004088H
  00097	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
  000a5	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000aa	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  000b3	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000b8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  000c1	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	81 c1 28 40 00
	00		 add	 ecx, 16424		; 00004028H
  000cf	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CTCPNetworkEngine@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTCPNetworkEngine@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTCPNetworkEngine@@UAE@XZ ENDP			; CTCPNetworkEngine::~CTCPNetworkEngine
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0CTCPNetworkEngine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTCPNetworkEngine@@QAE@XZ PROC			; CTCPNetworkEngine::CTCPNetworkEngine, COMDAT
; _this$ = ecx

; 1568 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTCPNetworkEngine@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  0003a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ITCPNetworkEngine@@6B@
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IUnknownEx@@6B@
  00055	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00058	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7IAsynchronismEngineSink@@6B@
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	83 c0 08	 add	 eax, 8
  00064	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
  00067	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ITCPNetworkItemSink@@6B@
  00070	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00073	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7CTCPNetworkEngine@@6BITCPNetworkEngine@@@
  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7CTCPNetworkEngine@@6BIAsynchronismEngineSink@@@
  00083	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_7CTCPNetworkEngine@@6BITCPNetworkItemSink@@@
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 28 40 00
	00		 add	 ecx, 16424		; 00004028H
  00096	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  000ab	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000b0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  000bd	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000c2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
  000cf	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000d4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	81 c1 88 40 00
	00		 add	 ecx, 16520		; 00004088H
  000e1	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  000e6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000ea	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	81 c1 9c 40 00
	00		 add	 ecx, 16540		; 0000409cH
  000f3	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection
  000f8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000fc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  00105	e8 00 00 00 00	 call	 ??0CAsynchronismEngine@@QAE@XZ ; CAsynchronismEngine::CAsynchronismEngine
  0010a	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0010e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  00117	e8 00 00 00 00	 call	 ??0CTCPNetworkThreadDetect@@QAE@XZ ; CTCPNetworkThreadDetect::CTCPNetworkThreadDetect
  0011c	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  00129	e8 00 00 00 00	 call	 ??0CTCPNetworkThreadAccept@@QAE@XZ ; CTCPNetworkThreadAccept::CTCPNetworkThreadAccept
  0012e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00132	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
  0013b	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
  00140	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9

; 1569 :     // 验证变量
; 1570 :     m_bValidate = false;

  00144	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00147	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 1571 :     m_bNormalRun = true;

  0014b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 1572 : 
; 1573 :     // 辅助变量
; 1574 :     m_bService = false;

  00152	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	c6 41 0e 00	 mov	 BYTE PTR [ecx+14], 0

; 1575 :     ZeroMemory(m_cbBuffer, sizeof(m_cbBuffer));

  00159	68 00 40 00 00	 push	 16384			; 00004000H
  0015e	6a 00		 push	 0
  00160	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00163	83 c2 0f	 add	 edx, 15			; 0000000fH
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 _memset
  0016c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1576 : 
; 1577 :     // 配置变量
; 1578 :     m_wMaxConnect = 0;

  0016f	33 c0		 xor	 eax, eax
  00171	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	66 89 81 10 40
	00 00		 mov	 WORD PTR [ecx+16400], ax

; 1579 :     m_wServicePort = 0;

  0017b	33 d2		 xor	 edx, edx
  0017d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00180	66 89 90 12 40
	00 00		 mov	 WORD PTR [eax+16402], dx

; 1580 :     m_dwDetectTime = 10000L;

  00187	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	c7 81 14 40 00
	00 10 27 00 00	 mov	 DWORD PTR [ecx+16404], 10000 ; 00002710H

; 1581 : 
; 1582 :     // 内核变量
; 1583 :     m_hCompletionPort = NULL;

  00194	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00197	c7 82 20 40 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+16416], 0

; 1584 :     m_hServerSocket = INVALID_SOCKET;

  001a1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a4	c7 80 1c 40 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+16412], -1

; 1585 :     m_pITCPNetworkEngineEvent = NULL;

  001ae	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b1	c7 81 24 40 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+16420], 0

; 1586 : 	GOOGLE_PROTOBUF_VERIFY_VERSION;

  001bb	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001c0	68 90 ce 2d 00	 push	 3002000			; 002dce90H
  001c5	68 90 ce 2d 00	 push	 3002000			; 002dce90H
  001ca	e8 00 00 00 00	 call	 ?VerifyVersion@internal@protobuf@google@@YAXHHPBD@Z ; google::protobuf::internal::VerifyVersion
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1587 :     return;
; 1588 : }

  001d2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001d9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 28 40 00
	00		 add	 ecx, 16424		; 00004028H
  00009	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$1:
  0000e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 4c 40 00
	00		 add	 ecx, 16460		; 0000404cH
  00017	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$2:
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	81 c1 60 40 00
	00		 add	 ecx, 16480		; 00004060H
  00025	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$3:
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	81 c1 74 40 00
	00		 add	 ecx, 16500		; 00004074H
  00033	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$4:
  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 88 40 00
	00		 add	 ecx, 16520		; 00004088H
  00041	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$5:
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	81 c1 9c 40 00
	00		 add	 ecx, 16540		; 0000409cH
  0004f	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$6:
  00054	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	81 c1 c0 40 00
	00		 add	 ecx, 16576		; 000040c0H
  0005d	e9 00 00 00 00	 jmp	 ??1CAsynchronismEngine@@UAE@XZ ; CAsynchronismEngine::~CAsynchronismEngine
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$7:
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	81 c1 2c 81 00
	00		 add	 ecx, 33068		; 0000812cH
  0006b	e9 00 00 00 00	 jmp	 ??1CTCPNetworkThreadDetect@@UAE@XZ ; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$8:
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	81 c1 48 81 00
	00		 add	 ecx, 33096		; 00008148H
  00079	e9 00 00 00 00	 jmp	 ??1CTCPNetworkThreadAccept@@UAE@XZ ; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept
__unwindfunclet$??0CTCPNetworkEngine@@QAE@XZ$9:
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	81 c1 64 81 00
	00		 add	 ecx, 33124		; 00008164H
  00087	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
__ehhandler$??0CTCPNetworkEngine@@QAE@XZ:
  0008c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00090	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00093	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00096	33 c8		 xor	 ecx, eax
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTCPNetworkEngine@@QAE@XZ
  000a2	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTCPNetworkEngine@@QAE@XZ ENDP			; CTCPNetworkEngine::CTCPNetworkEngine
; Function compile flags: /Odtp
;	COMDAT ??_G?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAEPAXI@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?AllocMemory@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv79 = -20						; size = 4
tv78 = -16						; size = 4
_pNewData$3 = -12					; size = 4
_nGrowCount$4 = -8					; size = 4
_this$ = -4						; size = 4
_nNewCount$ = 8						; size = 4
?AllocMemory@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::AllocMemory, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 	//效验参数
; 415  : 	ASSERT(nNewCount>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewCount$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN5@AllocMemor
  0000f	68 9f 01 00 00	 push	 415			; 0000019fH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN5@AllocMemor
  00022	cc		 int	 3
$LN5@AllocMemor:

; 416  : 
; 417  : 	if (nNewCount>m_nMaxCount)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  00029	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002c	0f 8e dd 00 00
	00		 jle	 $LN1@AllocMemor

; 418  : 	{
; 419  : 		//计算数目
; 420  : 		INT_PTR nGrowCount=m_nGrowCount;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	89 4d f8	 mov	 DWORD PTR _nGrowCount$4[ebp], ecx

; 421  : 		if (nGrowCount==0)

  0003b	83 7d f8 00	 cmp	 DWORD PTR _nGrowCount$4[ebp], 0
  0003f	75 45		 jne	 SHORT $LN3@AllocMemor

; 422  : 		{
; 423  : 			nGrowCount=m_nElementCount/8;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00047	99		 cdq
  00048	83 e2 07	 and	 edx, 7
  0004b	03 c2		 add	 eax, edx
  0004d	c1 f8 03	 sar	 eax, 3
  00050	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 424  : 			nGrowCount=(nGrowCount<4)?4:((nGrowCount>1024)?1024:nGrowCount);

  00053	83 7d f8 04	 cmp	 DWORD PTR _nGrowCount$4[ebp], 4
  00057	7d 09		 jge	 SHORT $LN8@AllocMemor
  00059	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
  00060	eb 1e		 jmp	 SHORT $LN9@AllocMemor
$LN8@AllocMemor:
  00062	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nGrowCount$4[ebp], 1024 ; 00000400H
  00069	7e 09		 jle	 SHORT $LN6@AllocMemor
  0006b	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR tv78[ebp], 1024 ; 00000400H
  00072	eb 06		 jmp	 SHORT $LN7@AllocMemor
$LN6@AllocMemor:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _nGrowCount$4[ebp]
  00077	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
$LN7@AllocMemor:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  0007d	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
$LN9@AllocMemor:
  00080	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00083	89 55 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], edx
$LN3@AllocMemor:

; 425  : 		}
; 426  : 		nNewCount+=nGrowCount;

  00086	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  00089	03 45 f8	 add	 eax, DWORD PTR _nGrowCount$4[ebp]
  0008c	89 45 08	 mov	 DWORD PTR _nNewCount$[ebp], eax

; 427  : 
; 428  : 		//申请内存
; 429  : 		TYPE * pNewData=(TYPE *) new BYTE[nNewCount*sizeof(TYPE)];

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _nNewCount$[ebp]
  00092	c1 e1 02	 shl	 ecx, 2
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000a1	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  000a4	89 55 f4	 mov	 DWORD PTR _pNewData$3[ebp], edx

; 430  : 		memcpy(pNewData,m_pData,m_nElementCount*sizeof(TYPE));

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ad	c1 e1 02	 shl	 ecx, 2
  000b0	51		 push	 ecx
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$3[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		memset(pNewData+m_nElementCount,0,(nNewCount-m_nElementCount)*sizeof(TYPE));

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  000ca	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000cd	c1 e0 02	 shl	 eax, 2
  000d0	50		 push	 eax
  000d1	6a 00		 push	 0
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d9	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  000dc	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _memset
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		delete [] (BYTE *)m_pData;

  000e8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ee	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  000f1	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000fa	83 c4 04	 add	 esp, 4

; 433  : 
; 434  : 		//设置变量
; 435  : 		m_pData=pNewData;

  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  00103	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 436  : 		m_nMaxCount=nNewCount;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  0010c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@AllocMemor:

; 437  : 	}
; 438  : 
; 439  : 	return;
; 440  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
?AllocMemory@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::AllocMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??A?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::operator[], COMDAT
; _this$ = ecx

; 114  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	return ElementAt(nIndex);

  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt

; 116  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAll@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXXZ PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::RemoveAll, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if (m_nElementCount>0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 44		 jle	 SHORT $LN1@RemoveAll

; 381  : 	{
; 382  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7d 02		 jge	 SHORT $LN3@RemoveAll
  0002f	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 383  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	c1 e2 02	 shl	 edx, 2
  0003a	52		 push	 edx
  0003b	6a 00		 push	 0
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 		m_nElementCount=0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN1@RemoveAll:

; 385  : 	}
; 386  : 
; 387  : 	return;
; 388  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?RemoveAll@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXXZ ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetAtGrow, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	//效验参数
; 289  : 	ASSERT(nIndex>=0);

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7d 14		 jge	 SHORT $LN5@SetAtGrow
  0000d	68 21 01 00 00	 push	 289			; 00000121H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN5@SetAtGrow
  00020	cc		 int	 3
$LN5@SetAtGrow:

; 290  : 	if (nIndex<0) AfxThrowInvalidArgException();

  00021	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00025	7d 05		 jge	 SHORT $LN2@SetAtGrow
  00027	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@SetAtGrow:

; 291  : 
; 292  : 	//设置元素
; 293  : 	if (nIndex>=m_nElementCount) SetSize(m_nElementCount+1);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00032	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00035	7c 12		 jl	 SHORT $LN3@SetAtGrow
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003d	83 c1 01	 add	 ecx, 1
  00040	51		 push	 ecx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetSize@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetSize
$LN3@SetAtGrow:

; 294  : 	m_pData[nIndex]=newElement;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00052	8b 55 0c	 mov	 edx, DWORD PTR _newElement$[ebp]
  00055	8b 12		 mov	 edx, DWORD PTR [edx]
  00057	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@SetAtGrow:

; 295  : 
; 296  : 	return;
; 297  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetSize@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Where$ = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
?SetSize@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetSize, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	//效验参数
; 254  : 	ASSERT(nNewSize>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN13@SetSize
  0000f	68 fe 00 00 00	 push	 254			; 000000feH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN13@SetSize
  00022	cc		 int	 3
$LN13@SetSize:

; 255  : 	if (nNewSize<0)	AfxThrowInvalidArgException();

  00023	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00027	7d 05		 jge	 SHORT $LN8@SetSize
  00029	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN8@SetSize:

; 256  : 	
; 257  : 	//设置大小
; 258  : 	AllocMemory(nNewSize);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::AllocMemory

; 259  : 	if (nNewSize>m_nElementCount)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00040	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00043	7e 35		 jle	 SHORT $LN9@SetSize

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
  0004e	eb 09		 jmp	 SHORT $LN4@SetSize
$LN2@SetSize:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@SetSize:
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR _nNewSize$[ebp]
  0005f	7d 17		 jge	 SHORT $LN3@SetSize
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0006a	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0006d	89 55 f0	 mov	 DWORD PTR __Where$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Where$[ebp]
  00073	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00076	eb d8		 jmp	 SHORT $LN2@SetSize
$LN3@SetSize:

; 262  : 	}
; 263  : 	else if (nNewSize<m_nElementCount)

  00078	eb 4d		 jmp	 SHORT $LN10@SetSize
$LN9@SetSize:
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00080	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00083	7d 42		 jge	 SHORT $LN10@SetSize

; 264  : 	{
; 265  : 		for (INT_PTR i=nNewSize;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00085	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00088	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
  0008b	eb 09		 jmp	 SHORT $LN7@SetSize
$LN5@SetSize:
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN7@SetSize:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0009c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0009f	7d 02		 jge	 SHORT $LN6@SetSize
  000a1	eb ea		 jmp	 SHORT $LN5@SetSize
$LN6@SetSize:

; 266  : 		memset(m_pData+nNewSize,0,(m_nElementCount-nNewSize)*sizeof(TYPE));

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a9	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  000ac	c1 e2 02	 shl	 edx, 2
  000af	52		 push	 edx
  000b0	6a 00		 push	 0
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000bb	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memset
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetSize:

; 267  : 	}
; 268  : 	m_nElementCount=nNewSize;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000cd	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN12@SetSize:

; 269  : 
; 270  : 	return;
; 271  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
?SetSize@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	ASSERT((nIndex>=0)&&(nIndex<m_nElementCount));

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN4@ElementAt
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00016	7c 14		 jl	 SHORT $LN5@ElementAt
$LN4@ElementAt:
  00018	68 e9 00 00 00	 push	 233			; 000000e9H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00022	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00027	85 c0		 test	 eax, eax
  00029	74 01		 je	 SHORT $LN5@ElementAt
  0002b	cc		 int	 3
$LN5@ElementAt:

; 234  : 	if ((nIndex<0)&&(nIndex>=m_nElementCount)) AfxThrowInvalidArgException();

  0002c	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00030	7d 10		 jge	 SHORT $LN2@ElementAt
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00038	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0003b	7c 05		 jl	 SHORT $LN2@ElementAt
  0003d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@ElementAt:

; 235  : 	
; 236  : 	return m_pData[nIndex];

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0004b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$LN3@ElementAt:

; 237  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ElementAt@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEAAPAVCTCPNetworkThreadReadWrite@@H@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::ElementAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Add@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEHABQAVCTCPNetworkThreadReadWrite@@@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Add@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEHABQAVCTCPNetworkThreadReadWrite@@@Z PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::Add, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f8	 mov	 DWORD PTR _nIndex$[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00012	8b 55 08	 mov	 edx, DWORD PTR _newElement$[ebp]
  00015	52		 push	 edx
  00016	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEXHABQAVCTCPNetworkThreadReadWrite@@@Z ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::SetAtGrow

; 108  : 	return nIndex;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]

; 109  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Add@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAEHABQAVCTCPNetworkThreadReadWrite@@@Z ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?GetCount@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCount@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QBEHXZ PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::GetCount, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	return m_nElementCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 100  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCount@?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QBEHXZ ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::GetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@

; 144  : 	if (m_pData!=NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 3e		 je	 SHORT $LN6@CWHArray

; 145  : 	{
; 146  : 		for (INT_PTR i=0;i<m_nElementCount;i++)	(m_pData+i)->~TYPE();

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CWHArray
$LN2@CWHArray:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$2[ebp], edx
$LN4@CWHArray:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00033	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00036	7d 02		 jge	 SHORT $LN3@CWHArray
  00038	eb ea		 jmp	 SHORT $LN2@CWHArray
$LN3@CWHArray:

; 147  : 		delete [] (BYTE *)m_pData;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 148  : 		m_pData=NULL;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@CWHArray:

; 149  : 	}
; 150  : 
; 151  : 	return;
; 152  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@UAE@XZ ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::~CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??0?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAE@XZ PROC ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@6B@

; 132  : 	m_pData=NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 133  : 	m_nMaxCount=0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 134  : 	m_nGrowCount=0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 135  : 	m_nElementCount=0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 136  : 
; 137  : 	return;
; 138  : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$CWHArray@PAVCTCPNetworkThreadReadWrite@@ABQAV1@@@QAE@XZ ENDP ; CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>::CWHArray<CTCPNetworkThreadReadWrite *,CTCPNetworkThreadReadWrite * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAEPAXI@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv79 = -20						; size = 4
tv78 = -16						; size = 4
_pNewData$3 = -12					; size = 4
_nGrowCount$4 = -8					; size = 4
_this$ = -4						; size = 4
_nNewCount$ = 8						; size = 4
?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 	//效验参数
; 415  : 	ASSERT(nNewCount>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewCount$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN5@AllocMemor
  0000f	68 9f 01 00 00	 push	 415			; 0000019fH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN5@AllocMemor
  00022	cc		 int	 3
$LN5@AllocMemor:

; 416  : 
; 417  : 	if (nNewCount>m_nMaxCount)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  00029	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002c	0f 8e dd 00 00
	00		 jle	 $LN1@AllocMemor

; 418  : 	{
; 419  : 		//计算数目
; 420  : 		INT_PTR nGrowCount=m_nGrowCount;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	89 4d f8	 mov	 DWORD PTR _nGrowCount$4[ebp], ecx

; 421  : 		if (nGrowCount==0)

  0003b	83 7d f8 00	 cmp	 DWORD PTR _nGrowCount$4[ebp], 0
  0003f	75 45		 jne	 SHORT $LN3@AllocMemor

; 422  : 		{
; 423  : 			nGrowCount=m_nElementCount/8;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00047	99		 cdq
  00048	83 e2 07	 and	 edx, 7
  0004b	03 c2		 add	 eax, edx
  0004d	c1 f8 03	 sar	 eax, 3
  00050	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 424  : 			nGrowCount=(nGrowCount<4)?4:((nGrowCount>1024)?1024:nGrowCount);

  00053	83 7d f8 04	 cmp	 DWORD PTR _nGrowCount$4[ebp], 4
  00057	7d 09		 jge	 SHORT $LN8@AllocMemor
  00059	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
  00060	eb 1e		 jmp	 SHORT $LN9@AllocMemor
$LN8@AllocMemor:
  00062	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nGrowCount$4[ebp], 1024 ; 00000400H
  00069	7e 09		 jle	 SHORT $LN6@AllocMemor
  0006b	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR tv78[ebp], 1024 ; 00000400H
  00072	eb 06		 jmp	 SHORT $LN7@AllocMemor
$LN6@AllocMemor:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _nGrowCount$4[ebp]
  00077	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
$LN7@AllocMemor:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  0007d	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
$LN9@AllocMemor:
  00080	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00083	89 55 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], edx
$LN3@AllocMemor:

; 425  : 		}
; 426  : 		nNewCount+=nGrowCount;

  00086	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  00089	03 45 f8	 add	 eax, DWORD PTR _nGrowCount$4[ebp]
  0008c	89 45 08	 mov	 DWORD PTR _nNewCount$[ebp], eax

; 427  : 
; 428  : 		//申请内存
; 429  : 		TYPE * pNewData=(TYPE *) new BYTE[nNewCount*sizeof(TYPE)];

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _nNewCount$[ebp]
  00092	c1 e1 02	 shl	 ecx, 2
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000a1	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  000a4	89 55 f4	 mov	 DWORD PTR _pNewData$3[ebp], edx

; 430  : 		memcpy(pNewData,m_pData,m_nElementCount*sizeof(TYPE));

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ad	c1 e1 02	 shl	 ecx, 2
  000b0	51		 push	 ecx
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$3[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		memset(pNewData+m_nElementCount,0,(nNewCount-m_nElementCount)*sizeof(TYPE));

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  000ca	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000cd	c1 e0 02	 shl	 eax, 2
  000d0	50		 push	 eax
  000d1	6a 00		 push	 0
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d9	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  000dc	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _memset
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		delete [] (BYTE *)m_pData;

  000e8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ee	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  000f1	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000fa	83 c4 04	 add	 esp, 4

; 433  : 
; 434  : 		//设置变量
; 435  : 		m_pData=pNewData;

  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  00103	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 436  : 		m_nMaxCount=nNewCount;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  0010c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@AllocMemor:

; 437  : 	}
; 438  : 
; 439  : 	return;
; 440  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??A?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::operator[], COMDAT
; _this$ = ecx

; 114  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	return ElementAt(nIndex);

  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt

; 116  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAll, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if (m_nElementCount>0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 44		 jle	 SHORT $LN1@RemoveAll

; 381  : 	{
; 382  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7d 02		 jge	 SHORT $LN3@RemoveAll
  0002f	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 383  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	c1 e2 02	 shl	 edx, 2
  0003a	52		 push	 edx
  0003b	6a 00		 push	 0
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 		m_nElementCount=0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN1@RemoveAll:

; 385  : 	}
; 386  : 
; 387  : 	return;
; 388  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?RemoveAll@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXXZ ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z
_TEXT	SEGMENT
_nMoveCount$ = -12					; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_nCount$ = 12						; size = 4
?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAt, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 	//效验参数
; 362  : 	ASSERT(nIndex>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN9@RemoveAt
  0000f	68 6a 01 00 00	 push	 362			; 0000016aH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN9@RemoveAt
  00022	cc		 int	 3
$LN9@RemoveAt:

; 363  : 	ASSERT(nCount>=0);

  00023	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00027	7d 14		 jge	 SHORT $LN10@RemoveAt
  00029	68 6b 01 00 00	 push	 363			; 0000016bH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00033	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00038	85 c0		 test	 eax, eax
  0003a	74 01		 je	 SHORT $LN10@RemoveAt
  0003c	cc		 int	 3
$LN10@RemoveAt:

; 364  : 	ASSERT(nIndex+nCount<=m_nElementCount);

  0003d	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00040	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00049	7e 14		 jle	 SHORT $LN11@RemoveAt
  0004b	68 6c 01 00 00	 push	 364			; 0000016cH
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00055	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005a	85 c0		 test	 eax, eax
  0005c	74 01		 je	 SHORT $LN11@RemoveAt
  0005e	cc		 int	 3
$LN11@RemoveAt:

; 365  : 	if ((nIndex<0)||(nCount<0)||((nIndex+nCount>m_nElementCount))) AfxThrowInvalidArgException();

  0005f	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00063	7c 14		 jl	 SHORT $LN6@RemoveAt
  00065	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00069	7c 0e		 jl	 SHORT $LN6@RemoveAt
  0006b	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0006e	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00077	7e 05		 jle	 SHORT $LN5@RemoveAt
$LN6@RemoveAt:
  00079	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@RemoveAt:

; 366  : 
; 367  : 	//删除数据
; 368  : 	INT_PTR nMoveCount=m_nElementCount-(nIndex+nCount);

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00081	03 4d 0c	 add	 ecx, DWORD PTR _nCount$[ebp]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	2b c1		 sub	 eax, ecx
  0008c	89 45 f4	 mov	 DWORD PTR _nMoveCount$[ebp], eax

; 369  : 	for (INT_PTR i=0;i<nCount;i++) (m_pData+nIndex+i)->~TYPE();

  0008f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00096	eb 09		 jmp	 SHORT $LN4@RemoveAt
$LN2@RemoveAt:
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0009b	83 c1 01	 add	 ecx, 1
  0009e	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAt:
  000a1	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  000a4	3b 55 0c	 cmp	 edx, DWORD PTR _nCount$[ebp]
  000a7	7d 02		 jge	 SHORT $LN3@RemoveAt
  000a9	eb ed		 jmp	 SHORT $LN2@RemoveAt
$LN3@RemoveAt:

; 370  : 	if (nMoveCount>0) memmove(m_pData+nIndex,m_pData+nIndex+nCount,nMoveCount*sizeof(TYPE));

  000ab	83 7d f4 00	 cmp	 DWORD PTR _nMoveCount$[ebp], 0
  000af	7e 2f		 jle	 SHORT $LN7@RemoveAt
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _nMoveCount$[ebp]
  000b4	c1 e0 02	 shl	 eax, 2
  000b7	50		 push	 eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000be	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000c1	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _nCount$[ebp]
  000c7	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d1	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000d4	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _memmove
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RemoveAt:

; 371  : 	m_nElementCount-=nCount;

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000e6	2b 45 0c	 sub	 eax, DWORD PTR _nCount$[ebp]
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN8@RemoveAt:

; 372  : 
; 373  : 	return;
; 374  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
?RemoveAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHH@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	//效验参数
; 289  : 	ASSERT(nIndex>=0);

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7d 14		 jge	 SHORT $LN5@SetAtGrow
  0000d	68 21 01 00 00	 push	 289			; 00000121H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN5@SetAtGrow
  00020	cc		 int	 3
$LN5@SetAtGrow:

; 290  : 	if (nIndex<0) AfxThrowInvalidArgException();

  00021	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00025	7d 05		 jge	 SHORT $LN2@SetAtGrow
  00027	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@SetAtGrow:

; 291  : 
; 292  : 	//设置元素
; 293  : 	if (nIndex>=m_nElementCount) SetSize(m_nElementCount+1);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00032	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00035	7c 12		 jl	 SHORT $LN3@SetAtGrow
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003d	83 c1 01	 add	 ecx, 1
  00040	51		 push	 ecx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetSize@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetSize
$LN3@SetAtGrow:

; 294  : 	m_pData[nIndex]=newElement;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00052	8b 55 0c	 mov	 edx, DWORD PTR _newElement$[ebp]
  00055	8b 12		 mov	 edx, DWORD PTR [edx]
  00057	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@SetAtGrow:

; 295  : 
; 296  : 	return;
; 297  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetSize@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Where$ = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
?SetSize@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetSize, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	//效验参数
; 254  : 	ASSERT(nNewSize>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN13@SetSize
  0000f	68 fe 00 00 00	 push	 254			; 000000feH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN13@SetSize
  00022	cc		 int	 3
$LN13@SetSize:

; 255  : 	if (nNewSize<0)	AfxThrowInvalidArgException();

  00023	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00027	7d 05		 jge	 SHORT $LN8@SetSize
  00029	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN8@SetSize:

; 256  : 	
; 257  : 	//设置大小
; 258  : 	AllocMemory(nNewSize);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory

; 259  : 	if (nNewSize>m_nElementCount)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00040	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00043	7e 35		 jle	 SHORT $LN9@SetSize

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
  0004e	eb 09		 jmp	 SHORT $LN4@SetSize
$LN2@SetSize:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@SetSize:
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR _nNewSize$[ebp]
  0005f	7d 17		 jge	 SHORT $LN3@SetSize
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0006a	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0006d	89 55 f0	 mov	 DWORD PTR __Where$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Where$[ebp]
  00073	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00076	eb d8		 jmp	 SHORT $LN2@SetSize
$LN3@SetSize:

; 262  : 	}
; 263  : 	else if (nNewSize<m_nElementCount)

  00078	eb 4d		 jmp	 SHORT $LN10@SetSize
$LN9@SetSize:
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00080	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00083	7d 42		 jge	 SHORT $LN10@SetSize

; 264  : 	{
; 265  : 		for (INT_PTR i=nNewSize;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00085	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00088	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
  0008b	eb 09		 jmp	 SHORT $LN7@SetSize
$LN5@SetSize:
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN7@SetSize:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0009c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0009f	7d 02		 jge	 SHORT $LN6@SetSize
  000a1	eb ea		 jmp	 SHORT $LN5@SetSize
$LN6@SetSize:

; 266  : 		memset(m_pData+nNewSize,0,(m_nElementCount-nNewSize)*sizeof(TYPE));

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a9	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  000ac	c1 e2 02	 shl	 edx, 2
  000af	52		 push	 edx
  000b0	6a 00		 push	 0
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000bb	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memset
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetSize:

; 267  : 	}
; 268  : 	m_nElementCount=nNewSize;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000cd	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN12@SetSize:

; 269  : 
; 270  : 	return;
; 271  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
?SetSize@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	ASSERT((nIndex>=0)&&(nIndex<m_nElementCount));

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN4@ElementAt
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00016	7c 14		 jl	 SHORT $LN5@ElementAt
$LN4@ElementAt:
  00018	68 e9 00 00 00	 push	 233			; 000000e9H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00022	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00027	85 c0		 test	 eax, eax
  00029	74 01		 je	 SHORT $LN5@ElementAt
  0002b	cc		 int	 3
$LN5@ElementAt:

; 234  : 	if ((nIndex<0)&&(nIndex>=m_nElementCount)) AfxThrowInvalidArgException();

  0002c	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00030	7d 10		 jge	 SHORT $LN2@ElementAt
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00038	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0003b	7c 05		 jl	 SHORT $LN2@ElementAt
  0003d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@ElementAt:

; 235  : 	
; 236  : 	return m_pData[nIndex];

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0004b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$LN3@ElementAt:

; 237  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ElementAt@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEAAPAVCTCPNetworkItem@@H@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::ElementAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Append@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABV1@@Z
_TEXT	SEGMENT
_nOldCount$1 = -12					; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Src$ = 8						; size = 4
?Append@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABV1@@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Append, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  : 	//效验参数
; 194  : 	ASSERT(this!=&Src);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	3b 45 08	 cmp	 eax, DWORD PTR _Src$[ebp]
  00010	75 14		 jne	 SHORT $LN8@Append
  00012	68 c2 00 00 00	 push	 194			; 000000c2H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN8@Append
  00025	cc		 int	 3
$LN8@Append:

; 195  : 	if (this==&Src) AfxThrowInvalidArgException();

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	3b 55 08	 cmp	 edx, DWORD PTR _Src$[ebp]
  0002c	75 05		 jne	 SHORT $LN5@Append
  0002e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@Append:

; 196  : 
; 197  : 	//拷贝数组
; 198  : 	if (Src.m_nElementCount>0)

  00033	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  00036	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0003a	7e 6d		 jle	 SHORT $LN6@Append

; 199  : 	{
; 200  : 		INT_PTR nOldCount=m_nElementCount;

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	89 55 f4	 mov	 DWORD PTR _nOldCount$1[ebp], edx

; 201  : 		AllocMemory(m_nElementCount+Src.m_nElementCount);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004b	8b 55 08	 mov	 edx, DWORD PTR _Src$[ebp]
  0004e	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory

; 202  : 		for (INT_PTR i=0;i<Src.m_nElementCount;i++)	m_pData[m_nElementCount+i]=Src.m_pData[i];

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@Append
$LN2@Append:
  00063	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Append:
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00072	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00075	7d 20		 jge	 SHORT $LN3@Append
  00077	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00083	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  00086	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0008c	8b 75 f8	 mov	 esi, DWORD PTR _i$2[ebp]
  0008f	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00092	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00095	eb cc		 jmp	 SHORT $LN2@Append
$LN3@Append:

; 203  : 		m_nElementCount+=Src.m_nElementCount;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  000a0	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN6@Append:

; 204  : 	}
; 205  : 
; 206  : 	return m_nElementCount;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LN7@Append:

; 207  : }

  000af	5e		 pop	 esi
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?Append@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABV1@@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Append
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z
_TEXT	SEGMENT
_i$1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Src$ = 8						; size = 4
?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Copy, COMDAT
; _this$ = ecx

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 172  : 	//效验参数
; 173  : 	ASSERT(this!=&Src);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	3b 45 08	 cmp	 eax, DWORD PTR _Src$[ebp]
  00010	75 14		 jne	 SHORT $LN11@Copy
  00012	68 ad 00 00 00	 push	 173			; 000000adH
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN11@Copy
  00025	cc		 int	 3
$LN11@Copy:

; 174  : 	if (this==&Src) return;

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	3b 55 08	 cmp	 edx, DWORD PTR _Src$[ebp]
  0002c	75 05		 jne	 SHORT $LN8@Copy
  0002e	e9 95 00 00 00	 jmp	 $LN1@Copy
$LN8@Copy:

; 175  : 
; 176  : 	//拷贝数组
; 177  : 	AllocMemory(Src.m_nElementCount);

  00033	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  00036	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00039	51		 push	 ecx
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXH@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::AllocMemory

; 178  : 	if (m_nElementCount>0)

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00049	7e 3a		 jle	 SHORT $LN9@Copy

; 179  : 	{
; 180  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  0004b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00052	eb 09		 jmp	 SHORT $LN4@Copy
$LN2@Copy:
  00054	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  00057	83 c0 01	 add	 eax, 1
  0005a	89 45 f4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Copy:
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  00063	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00066	7d 02		 jge	 SHORT $LN3@Copy
  00068	eb ea		 jmp	 SHORT $LN2@Copy
$LN3@Copy:

; 181  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00070	c1 e1 02	 shl	 ecx, 2
  00073	51		 push	 ecx
  00074	6a 00		 push	 0
  00076	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _memset
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@Copy:

; 182  : 	}
; 183  : 	for (INT_PTR i=0;i<Src.m_nElementCount;i++)	m_pData[i]=Src.m_pData[i];

  00085	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  0008c	eb 09		 jmp	 SHORT $LN7@Copy
$LN5@Copy:
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00091	83 c1 01	 add	 ecx, 1
  00094	89 4d f8	 mov	 DWORD PTR _i$2[ebp], ecx
$LN7@Copy:
  00097	8b 55 08	 mov	 edx, DWORD PTR _Src$[ebp]
  0009a	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  0009d	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  000a0	7d 1a		 jge	 SHORT $LN6@Copy
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  000a5	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  000b1	8b 75 f8	 mov	 esi, DWORD PTR _i$2[ebp]
  000b4	8b 14 b2	 mov	 edx, DWORD PTR [edx+esi*4]
  000b7	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  000ba	eb d2		 jmp	 SHORT $LN5@Copy
$LN6@Copy:

; 184  : 	m_nElementCount=Src.m_nElementCount;

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  000c2	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000c5	89 50 10	 mov	 DWORD PTR [eax+16], edx
$LN1@Copy:

; 185  : 
; 186  : 	return;
; 187  : }

  000c8	5e		 pop	 esi
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?Copy@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXABV1@@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Add@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABQAVCTCPNetworkItem@@@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Add@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABQAVCTCPNetworkItem@@@Z PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Add, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f8	 mov	 DWORD PTR _nIndex$[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00012	8b 55 08	 mov	 edx, DWORD PTR _newElement$[ebp]
  00015	52		 push	 edx
  00016	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEXHABQAVCTCPNetworkItem@@@Z ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::SetAtGrow

; 108  : 	return nIndex;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]

; 109  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Add@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAEHABQAVCTCPNetworkItem@@@Z ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?GetCount@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCount@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QBEHXZ PROC ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::GetCount, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	return m_nElementCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 100  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCount@?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QBEHXZ ENDP ; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::GetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ PROC	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@

; 144  : 	if (m_pData!=NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 3e		 je	 SHORT $LN6@CWHArray

; 145  : 	{
; 146  : 		for (INT_PTR i=0;i<m_nElementCount;i++)	(m_pData+i)->~TYPE();

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CWHArray
$LN2@CWHArray:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$2[ebp], edx
$LN4@CWHArray:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00033	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00036	7d 02		 jge	 SHORT $LN3@CWHArray
  00038	eb ea		 jmp	 SHORT $LN2@CWHArray
$LN3@CWHArray:

; 147  : 		delete [] (BYTE *)m_pData;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 148  : 		m_pData=NULL;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@CWHArray:

; 149  : 	}
; 150  : 
; 151  : 	return;
; 152  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@UAE@XZ ENDP	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::~CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ PROC	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@6B@

; 132  : 	m_pData=NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 133  : 	m_nMaxCount=0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 134  : 	m_nGrowCount=0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 135  : 	m_nElementCount=0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 136  : 
; 137  : 	return;
; 138  : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$CWHArray@PAVCTCPNetworkItem@@ABQAV1@@@QAE@XZ ENDP	; CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>::CWHArray<CTCPNetworkItem *,CTCPNetworkItem * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTCPNetworkThreadDetect@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTCPNetworkThreadDetect@@UAEPAXI@Z PROC		; CTCPNetworkThreadDetect::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTCPNetworkThreadDetect@@UAE@XZ ; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTCPNetworkThreadDetect@@UAEPAXI@Z ENDP		; CTCPNetworkThreadDetect::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventThreadRun@CTCPNetworkThreadDetect@@EAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnEventThreadRun@CTCPNetworkThreadDetect@@EAE_NXZ PROC	; CTCPNetworkThreadDetect::OnEventThreadRun, COMDAT
; _this$ = ecx

; 1546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1547 :     // 效验参数
; 1548 :     ASSERT(m_pTCPNetworkEngine != NULL);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0000e	75 14		 jne	 SHORT $LN4@OnEventThr
  00010	68 0c 06 00 00	 push	 1548			; 0000060cH
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001f	85 c0		 test	 eax, eax
  00021	74 01		 je	 SHORT $LN4@OnEventThr
  00023	cc		 int	 3
$LN4@OnEventThr:

; 1549 : 
; 1550 :     // 设置间隔
; 1551 :     Sleep(200);

  00024	68 c8 00 00 00	 push	 200			; 000000c8H
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 1552 :     m_dwPileTime += 200L;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00032	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00035	05 c8 00 00 00	 add	 eax, 200		; 000000c8H
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1553 : 
; 1554 :     // 检测连接
; 1555 :     if (m_dwPileTime >= m_dwDetectTime)

  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00049	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0004c	72 15		 jb	 SHORT $LN2@OnEventThr

; 1556 :     {
; 1557 :         m_dwPileTime = 0L;

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00051	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 1558 :         m_pTCPNetworkEngine->DetectSocket();

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005e	e8 00 00 00 00	 call	 ?DetectSocket@CTCPNetworkEngine@@AAE_NXZ ; CTCPNetworkEngine::DetectSocket
$LN2@OnEventThr:

; 1559 :     }
; 1560 : 
; 1561 :     return true;

  00063	b0 01		 mov	 al, 1

; 1562 : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?OnEventThreadRun@CTCPNetworkThreadDetect@@EAE_NXZ ENDP	; CTCPNetworkThreadDetect::OnEventThreadRun
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?InitThread@CTCPNetworkThreadDetect@@QAE_NPAVCTCPNetworkEngine@@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pNetworkEngine$ = 8					; size = 4
_dwDetectTime$ = 12					; size = 4
?InitThread@CTCPNetworkThreadDetect@@QAE_NPAVCTCPNetworkEngine@@K@Z PROC ; CTCPNetworkThreadDetect::InitThread, COMDAT
; _this$ = ecx

; 1532 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1533 :     // 效验参数
; 1534 :     ASSERT(pNetworkEngine != NULL);

  00007	83 7d 08 00	 cmp	 DWORD PTR _pNetworkEngine$[ebp], 0
  0000b	75 14		 jne	 SHORT $LN3@InitThread
  0000d	68 fe 05 00 00	 push	 1534			; 000005feH
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN3@InitThread
  00020	cc		 int	 3
$LN3@InitThread:

; 1535 : 
; 1536 :     // 设置变量
; 1537 :     m_dwPileTime = 0L;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1538 :     m_dwDetectTime = dwDetectTime;

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _dwDetectTime$[ebp]
  00031	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1539 :     m_pTCPNetworkEngine = pNetworkEngine;

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 55 08	 mov	 edx, DWORD PTR _pNetworkEngine$[ebp]
  0003a	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1540 : 
; 1541 :     return true;

  0003d	b0 01		 mov	 al, 1

; 1542 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?InitThread@CTCPNetworkThreadDetect@@QAE_NPAVCTCPNetworkEngine@@K@Z ENDP ; CTCPNetworkThreadDetect::InitThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1CTCPNetworkThreadDetect@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTCPNetworkThreadDetect@@UAE@XZ PROC			; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect, COMDAT
; _this$ = ecx

; 1527 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadDetect@@6B@

; 1528 : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHThread@@MAE@XZ
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CTCPNetworkThreadDetect@@UAE@XZ ENDP			; CTCPNetworkThreadDetect::~CTCPNetworkThreadDetect
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0CTCPNetworkThreadDetect@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTCPNetworkThreadDetect@@QAE@XZ PROC			; CTCPNetworkThreadDetect::CTCPNetworkThreadDetect, COMDAT
; _this$ = ecx

; 1519 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHThread@@IAE@XZ
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadDetect@@6B@

; 1520 :     m_dwPileTime = 0L;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1521 :     m_dwDetectTime = 10000L;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 42 14 10 27
	00 00		 mov	 DWORD PTR [edx+20], 10000 ; 00002710H

; 1522 :     m_pTCPNetworkEngine = NULL;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 1523 : }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??0CTCPNetworkThreadDetect@@QAE@XZ ENDP			; CTCPNetworkThreadDetect::CTCPNetworkThreadDetect
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTCPNetworkThreadAccept@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTCPNetworkThreadAccept@@UAEPAXI@Z PROC		; CTCPNetworkThreadAccept::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTCPNetworkThreadAccept@@UAE@XZ ; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTCPNetworkThreadAccept@@UAEPAXI@Z ENDP		; CTCPNetworkThreadAccept::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
_TEXT	SEGMENT
_ThreadLock$2 = -80					; size = 12
tv169 = -68						; size = 4
$T3 = -64						; size = 4
tv164 = -60						; size = 4
tv158 = -56						; size = 4
_nBufferSize$4 = -52					; size = 4
_this$ = -48						; size = 4
_hConnectSocket$ = -44					; size = 4
_pTCPNetworkItem$ = -40					; size = 4
_SocketAddr$5 = -36					; size = 16
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ PROC	; CTCPNetworkThreadAccept::OnEventThreadRun, COMDAT
; _this$ = ecx

; 1460 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	53		 push	 ebx
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1461 :     // 效验参数
; 1462 :     ASSERT(m_hCompletionPort != NULL);

  00032	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00039	75 14		 jne	 SHORT $LN7@OnEventThr
  0003b	68 b6 05 00 00	 push	 1462			; 000005b6H
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00045	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004a	85 c0		 test	 eax, eax
  0004c	74 01		 je	 SHORT $LN7@OnEventThr
  0004e	cc		 int	 3
$LN7@OnEventThr:

; 1463 :     ASSERT(m_pTCPNetworkEngine != NULL);

  0004f	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  00052	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00056	75 14		 jne	 SHORT $LN8@OnEventThr
  00058	68 b7 05 00 00	 push	 1463			; 000005b7H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00062	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00067	85 c0		 test	 eax, eax
  00069	74 01		 je	 SHORT $LN8@OnEventThr
  0006b	cc		 int	 3
$LN8@OnEventThr:

; 1464 : 
; 1465 :     // 变量定义
; 1466 :     SOCKET hConnectSocket = INVALID_SOCKET;

  0006c	c7 45 d4 ff ff
	ff ff		 mov	 DWORD PTR _hConnectSocket$[ebp], -1

; 1467 :     CTCPNetworkItem * pTCPNetworkItem = NULL;

  00073	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkItem$[ebp], 0

; 1468 : 
; 1469 :     try

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1470 :     {
; 1471 :         // 监听连接
; 1472 :         SOCKADDR_IN	SocketAddr;
; 1473 :         INT nBufferSize = sizeof(SocketAddr);

  00081	c7 45 cc 10 00
	00 00		 mov	 DWORD PTR _nBufferSize$4[ebp], 16 ; 00000010H

; 1474 :         hConnectSocket = WSAAccept(m_hListenSocket, (SOCKADDR *)&SocketAddr, &nBufferSize, NULL, NULL);

  00088	6a 00		 push	 0
  0008a	6a 00		 push	 0
  0008c	8d 4d cc	 lea	 ecx, DWORD PTR _nBufferSize$4[ebp]
  0008f	51		 push	 ecx
  00090	8d 55 dc	 lea	 edx, DWORD PTR _SocketAddr$5[ebp]
  00093	52		 push	 edx
  00094	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0009a	51		 push	 ecx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAAccept@20
  000a1	89 45 d4	 mov	 DWORD PTR _hConnectSocket$[ebp], eax

; 1475 : 
; 1476 :         // 退出判断
; 1477 :         if (hConnectSocket == INVALID_SOCKET)

  000a4	83 7d d4 ff	 cmp	 DWORD PTR _hConnectSocket$[ebp], -1
  000a8	75 07		 jne	 SHORT $LN3@OnEventThr

; 1478 :             return false;

  000aa	32 c0		 xor	 al, al
  000ac	e9 e5 00 00 00	 jmp	 $LN6@OnEventThr
$LN3@OnEventThr:

; 1479 : 
; 1480 :         // 获取连接
; 1481 :         pTCPNetworkItem = m_pTCPNetworkEngine->ActiveNetworkItem();

  000b1	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  000b7	e8 00 00 00 00	 call	 ?ActiveNetworkItem@CTCPNetworkEngine@@IAEPAVCTCPNetworkItem@@XZ ; CTCPNetworkEngine::ActiveNetworkItem
  000bc	89 45 c8	 mov	 DWORD PTR tv158[ebp], eax
  000bf	8b 45 c8	 mov	 eax, DWORD PTR tv158[ebp]
  000c2	89 45 d8	 mov	 DWORD PTR _pTCPNetworkItem$[ebp], eax

; 1482 : 
; 1483 :         // 失败判断
; 1484 :         if (pTCPNetworkItem == NULL)

  000c5	83 7d d8 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  000c9	75 32		 jne	 SHORT $LN25@OnEventThr

; 1485 :         {
; 1486 :             ASSERT(FALSE);

  000cb	33 c9		 xor	 ecx, ecx
  000cd	75 19		 jne	 SHORT $LN9@OnEventThr
  000cf	68 ce 05 00 00	 push	 1486			; 000005ceH
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000d9	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000de	89 45 c4	 mov	 DWORD PTR tv164[ebp], eax
  000e1	83 7d c4 00	 cmp	 DWORD PTR tv164[ebp], 0
  000e5	74 01		 je	 SHORT $LN9@OnEventThr
  000e7	cc		 int	 3
$LN9@OnEventThr:

; 1487 :             throw TEXT("申请连接对象失败");

  000e8	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0BB@GIIMFCKJ@?I?j?G?k?A?$KM?$LN?S?$LG?T?O?s?J?$KH?$LA?$NM@
  000ef	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000f4	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN25@OnEventThr:

; 1491 :         CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  000fd	6a 01		 push	 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  000ff	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  00102	83 c1 18	 add	 ecx, 24			; 00000018H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1491 :         CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00105	51		 push	 ecx
  00106	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0010f	89 45 bc	 mov	 DWORD PTR tv169[ebp], eax
  00112	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 1492 : 
; 1493 :         // 绑定对象
; 1494 :         pTCPNetworkItem->Attach(hConnectSocket, SocketAddr.sin_addr.S_un.S_addr);

  00116	8b 55 e0	 mov	 edx, DWORD PTR _SocketAddr$5[ebp+4]
  00119	52		 push	 edx
  0011a	8b 45 d4	 mov	 eax, DWORD PTR _hConnectSocket$[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  00121	e8 00 00 00 00	 call	 ?Attach@CTCPNetworkItem@@QAEKIK@Z ; CTCPNetworkItem::Attach

; 1495 :         CreateIoCompletionPort((HANDLE)hConnectSocket, m_hCompletionPort, (ULONG_PTR)pTCPNetworkItem, 0);

  00126	6a 00		 push	 0
  00128	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  0012b	51		 push	 ecx
  0012c	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  0012f	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00132	50		 push	 eax
  00133	8b 4d d4	 mov	 ecx, DWORD PTR _hConnectSocket$[ebp]
  00136	51		 push	 ecx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateIoCompletionPort@16

; 1496 : 
; 1497 :         // 发起接收
; 1498 :         pTCPNetworkItem->RecvData();

  0013d	8b 4d d8	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  00140	e8 00 00 00 00	 call	 ?RecvData@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::RecvData

; 1499 :     }

  00145	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00149	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00152	eb 30		 jmp	 SHORT $LN11@OnEventThr
__catch$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$0:

; 1500 :     catch (...)
; 1501 :     {
; 1502 :         // 清理对象
; 1503 :         ASSERT(pTCPNetworkItem == NULL);

  00154	83 7d d8 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  00158	74 14		 je	 SHORT $LN10@OnEventThr
  0015a	68 df 05 00 00	 push	 1503			; 000005dfH
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00164	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00169	85 c0		 test	 eax, eax
  0016b	74 01		 je	 SHORT $LN10@OnEventThr
  0016d	cc		 int	 3
$LN10@OnEventThr:

; 1504 : 
; 1505 :         // 关闭连接
; 1506 :         if (hConnectSocket != INVALID_SOCKET)

  0016e	83 7d d4 ff	 cmp	 DWORD PTR _hConnectSocket$[ebp], -1
  00172	74 0a		 je	 SHORT $LN5@OnEventThr

; 1507 :         {
; 1508 :             closesocket(hConnectSocket);

  00174	8b 45 d4	 mov	 eax, DWORD PTR _hConnectSocket$[ebp]
  00177	50		 push	 eax
  00178	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
$LN5@OnEventThr:

; 1509 :         }
; 1510 :     }

  0017e	b8 00 00 00 00	 mov	 eax, $LN15@OnEventThr
  00183	c3		 ret	 0
$LN11@OnEventThr:
  00184	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0018b	eb 07		 jmp	 SHORT __tryend$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$1
$LN15@OnEventThr:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
  0018d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$1:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1511 : 
; 1512 :     return true;

  00194	b0 01		 mov	 al, 1
$LN6@OnEventThr:

; 1513 : }

  00196	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00199	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001a0	59		 pop	 ecx
  001a1	5f		 pop	 edi
  001a2	5e		 pop	 esi
  001a3	5b		 pop	 ebx
  001a4	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a7	33 cd		 xor	 ecx, ebp
  001a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ$2:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventThreadRun@CTCPNetworkThreadAccept@@EAE_NXZ ENDP	; CTCPNetworkThreadAccept::OnEventThreadRun
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?InitThread@CTCPNetworkThreadAccept@@QAE_NPAXIPAVCTCPNetworkEngine@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hCompletionPort$ = 8					; size = 4
_hListenSocket$ = 12					; size = 4
_pNetworkEngine$ = 16					; size = 4
?InitThread@CTCPNetworkThreadAccept@@QAE_NPAXIPAVCTCPNetworkEngine@@@Z PROC ; CTCPNetworkThreadAccept::InitThread, COMDAT
; _this$ = ecx

; 1444 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1445 :     // 效验参数
; 1446 :     ASSERT(pNetworkEngine != NULL);

  00007	83 7d 10 00	 cmp	 DWORD PTR _pNetworkEngine$[ebp], 0
  0000b	75 14		 jne	 SHORT $LN3@InitThread
  0000d	68 a6 05 00 00	 push	 1446			; 000005a6H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN3@InitThread
  00020	cc		 int	 3
$LN3@InitThread:

; 1447 :     ASSERT(hCompletionPort != NULL);

  00021	83 7d 08 00	 cmp	 DWORD PTR _hCompletionPort$[ebp], 0
  00025	75 14		 jne	 SHORT $LN4@InitThread
  00027	68 a7 05 00 00	 push	 1447			; 000005a7H
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00031	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00036	85 c0		 test	 eax, eax
  00038	74 01		 je	 SHORT $LN4@InitThread
  0003a	cc		 int	 3
$LN4@InitThread:

; 1448 :     ASSERT(hListenSocket != INVALID_SOCKET);

  0003b	83 7d 0c ff	 cmp	 DWORD PTR _hListenSocket$[ebp], -1
  0003f	75 14		 jne	 SHORT $LN5@InitThread
  00041	68 a8 05 00 00	 push	 1448			; 000005a8H
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0004b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00050	85 c0		 test	 eax, eax
  00052	74 01		 je	 SHORT $LN5@InitThread
  00054	cc		 int	 3
$LN5@InitThread:

; 1449 : 
; 1450 :     // 设置变量
; 1451 :     m_hListenSocket = hListenSocket;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _hListenSocket$[ebp]
  0005b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 1452 :     m_hCompletionPort = hCompletionPort;

  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	8b 45 08	 mov	 eax, DWORD PTR _hCompletionPort$[ebp]
  00064	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1453 :     m_pTCPNetworkEngine = pNetworkEngine;

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	8b 55 10	 mov	 edx, DWORD PTR _pNetworkEngine$[ebp]
  0006d	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 1454 : 
; 1455 :     return true;

  00070	b0 01		 mov	 al, 1

; 1456 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 0c 00	 ret	 12			; 0000000cH
?InitThread@CTCPNetworkThreadAccept@@QAE_NPAXIPAVCTCPNetworkEngine@@@Z ENDP ; CTCPNetworkThreadAccept::InitThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1CTCPNetworkThreadAccept@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTCPNetworkThreadAccept@@UAE@XZ PROC			; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept, COMDAT
; _this$ = ecx

; 1439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadAccept@@6B@

; 1440 : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHThread@@MAE@XZ
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CTCPNetworkThreadAccept@@UAE@XZ ENDP			; CTCPNetworkThreadAccept::~CTCPNetworkThreadAccept
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0CTCPNetworkThreadAccept@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTCPNetworkThreadAccept@@QAE@XZ PROC			; CTCPNetworkThreadAccept::CTCPNetworkThreadAccept, COMDAT
; _this$ = ecx

; 1431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHThread@@IAE@XZ
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadAccept@@6B@

; 1432 :     m_hCompletionPort = NULL;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1433 :     m_pTCPNetworkEngine = NULL;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1434 :     m_hListenSocket = INVALID_SOCKET;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 10 ff ff
	ff ff		 mov	 DWORD PTR [eax+16], -1

; 1435 : }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??0CTCPNetworkThreadAccept@@QAE@XZ ENDP			; CTCPNetworkThreadAccept::CTCPNetworkThreadAccept
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTCPNetworkThreadReadWrite@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTCPNetworkThreadReadWrite@@UAEPAXI@Z PROC		; CTCPNetworkThreadReadWrite::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTCPNetworkThreadReadWrite@@UAE@XZ ; CTCPNetworkThreadReadWrite::~CTCPNetworkThreadReadWrite
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTCPNetworkThreadReadWrite@@UAEPAXI@Z ENDP		; CTCPNetworkThreadReadWrite::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ
_TEXT	SEGMENT
_ThreadLock$2 = -76					; size = 12
_ThreadLock$3 = -64					; size = 12
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
_bSuccess$ = -40					; size = 4
_this$ = -36						; size = 4
_pSocketLapped$ = -32					; size = 4
_dwThancferred$ = -28					; size = 4
tv86 = -24						; size = 4
_pOverLapped$ = -20					; size = 4
_pTCPNetworkItem$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ PROC ; CTCPNetworkThreadReadWrite::OnEventThreadRun, COMDAT
; _this$ = ecx

; 1386 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1387 :     // 效验参数
; 1388 :     ASSERT(m_hCompletionPort != NULL);

  00028	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002f	75 14		 jne	 SHORT $LN9@OnEventThr
  00031	68 6c 05 00 00	 push	 1388			; 0000056cH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0003b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00040	85 c0		 test	 eax, eax
  00042	74 01		 je	 SHORT $LN9@OnEventThr
  00044	cc		 int	 3
$LN9@OnEventThr:

; 1389 : 
; 1390 :     // 变量定义
; 1391 :     DWORD dwThancferred = 0;

  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwThancferred$[ebp], 0

; 1392 :     OVERLAPPED * pOverLapped = NULL;

  0004c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pOverLapped$[ebp], 0

; 1393 :     CTCPNetworkItem * pTCPNetworkItem = NULL;

  00053	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pTCPNetworkItem$[ebp], 0

; 1394 : 
; 1395 :     // 完成端口
; 1396 :     BOOL bSuccess = GetQueuedCompletionStatus(m_hCompletionPort, &dwThancferred, (PULONG_PTR)&pTCPNetworkItem, &pOverLapped, INFINITE);

  0005a	6a ff		 push	 -1
  0005c	8d 55 ec	 lea	 edx, DWORD PTR _pOverLapped$[ebp]
  0005f	52		 push	 edx
  00060	8d 45 f0	 lea	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  00063	50		 push	 eax
  00064	8d 4d e4	 lea	 ecx, DWORD PTR _dwThancferred$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetQueuedCompletionStatus@20
  00075	89 45 d8	 mov	 DWORD PTR _bSuccess$[ebp], eax

; 1397 :     if ((bSuccess == FALSE) && (GetLastError() != ERROR_NETNAME_DELETED))

  00078	83 7d d8 00	 cmp	 DWORD PTR _bSuccess$[ebp], 0
  0007c	75 12		 jne	 SHORT $LN4@OnEventThr
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00084	83 f8 40	 cmp	 eax, 64			; 00000040H
  00087	74 07		 je	 SHORT $LN4@OnEventThr

; 1398 :         return false;

  00089	32 c0		 xor	 al, al
  0008b	e9 e0 00 00 00	 jmp	 $LN1@OnEventThr
$LN4@OnEventThr:

; 1399 : 
; 1400 :     // 退出判断
; 1401 :     if ((pTCPNetworkItem == NULL) && (pOverLapped == NULL))

  00090	83 7d f0 00	 cmp	 DWORD PTR _pTCPNetworkItem$[ebp], 0
  00094	75 0d		 jne	 SHORT $LN5@OnEventThr
  00096	83 7d ec 00	 cmp	 DWORD PTR _pOverLapped$[ebp], 0
  0009a	75 07		 jne	 SHORT $LN5@OnEventThr

; 1402 :         return false;

  0009c	32 c0		 xor	 al, al
  0009e	e9 cd 00 00 00	 jmp	 $LN1@OnEventThr
$LN5@OnEventThr:

; 1403 : 
; 1404 :     // 变量定义
; 1405 :     COverLapped * pSocketLapped = CONTAINING_RECORD(pOverLapped, COverLapped, m_OverLapped);

  000a3	8b 4d ec	 mov	 ecx, DWORD PTR _pOverLapped$[ebp]
  000a6	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  000a9	89 4d e0	 mov	 DWORD PTR _pSocketLapped$[ebp], ecx

; 1408 :     switch (pSocketLapped->GetOperationType())

  000ac	8b 55 cc	 mov	 edx, DWORD PTR $T4[ebp]
  000af	89 55 e8	 mov	 DWORD PTR tv86[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 70   :     enOperationType GetOperationType() { return m_OperationType; }

  000b2	8b 45 e0	 mov	 eax, DWORD PTR _pSocketLapped$[ebp]
  000b5	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b8	89 4d e8	 mov	 DWORD PTR tv86[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1408 :     switch (pSocketLapped->GetOperationType())

  000bb	83 7d e8 00	 cmp	 DWORD PTR tv86[ebp], 0
  000bf	74 0b		 je	 SHORT $LN6@OnEventThr
  000c1	83 7d e8 01	 cmp	 DWORD PTR tv86[ebp], 1
  000c5	74 56		 je	 SHORT $LN7@OnEventThr
  000c7	e9 a2 00 00 00	 jmp	 $LN2@OnEventThr
$LN6@OnEventThr:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  000cc	8b 55 f0	 mov	 edx, DWORD PTR _pTCPNetworkItem$[ebp]
  000cf	83 c2 18	 add	 edx, 24			; 00000018H
  000d2	89 55 d4	 mov	 DWORD PTR $T6[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1412 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  000d5	6a 01		 push	 1
  000d7	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  000da	50		 push	 eax
  000db	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  000e4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1413 :             pTCPNetworkItem->OnSendCompleted((COverLappedSend *)pSocketLapped, dwThancferred);

  000eb	8b 4d e4	 mov	 ecx, DWORD PTR _dwThancferred$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 e0	 mov	 edx, DWORD PTR _pSocketLapped$[ebp]
  000f2	52		 push	 edx
  000f3	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  000f6	e8 00 00 00 00	 call	 ?OnSendCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedSend@@K@Z ; CTCPNetworkItem::OnSendCompleted

; 1414 :             break;

  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0010b	eb 61		 jmp	 SHORT $LN2@OnEventThr

; 1415 :         }

  0010d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00114	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
$LN7@OnEventThr:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  0011d	8b 45 f0	 mov	 eax, DWORD PTR _pTCPNetworkItem$[ebp]
  00120	83 c0 18	 add	 eax, 24			; 00000018H
  00123	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1418 :             CWHDataLocker ThreadLock(pTCPNetworkItem->GetCriticalSection());

  00126	6a 01		 push	 1
  00128	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  0012b	51		 push	 ecx
  0012c	8d 4d b4	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00135	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1419 :             pTCPNetworkItem->OnRecvCompleted((COverLappedRecv *)pSocketLapped, dwThancferred);

  0013c	8b 55 e4	 mov	 edx, DWORD PTR _dwThancferred$[ebp]
  0013f	52		 push	 edx
  00140	8b 45 e0	 mov	 eax, DWORD PTR _pSocketLapped$[ebp]
  00143	50		 push	 eax
  00144	8b 4d f0	 mov	 ecx, DWORD PTR _pTCPNetworkItem$[ebp]
  00147	e8 00 00 00 00	 call	 ?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z ; CTCPNetworkItem::OnRecvCompleted

; 1420 :             break;

  0014c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00153	8d 4d b4	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0015c	eb 10		 jmp	 SHORT $LN2@OnEventThr

; 1421 :         }

  0015e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00165	8d 4d b4	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
$LN2@OnEventThr:

; 1422 :     }
; 1423 : 
; 1424 :     return true;

  0016e	b0 01		 mov	 al, 1
$LN1@OnEventThr:

; 1425 : }

  00170	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00173	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017a	59		 pop	 ecx
  0017b	8b e5		 mov	 esp, ebp
  0017d	5d		 pop	 ebp
  0017e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$3[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__unwindfunclet$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ$1:
  00009	8d 4d b4	 lea	 ecx, DWORD PTR _ThreadLock$2[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnEventThreadRun@CTCPNetworkThreadReadWrite@@EAE_NXZ ENDP ; CTCPNetworkThreadReadWrite::OnEventThreadRun
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?InitThread@CTCPNetworkThreadReadWrite@@QAE_NPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hCompletionPort$ = 8					; size = 4
?InitThread@CTCPNetworkThreadReadWrite@@QAE_NPAX@Z PROC	; CTCPNetworkThreadReadWrite::InitThread, COMDAT
; _this$ = ecx

; 1378 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1379 :     ASSERT(hCompletionPort != NULL);

  00007	83 7d 08 00	 cmp	 DWORD PTR _hCompletionPort$[ebp], 0
  0000b	75 14		 jne	 SHORT $LN3@InitThread
  0000d	68 63 05 00 00	 push	 1379			; 00000563H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN3@InitThread
  00020	cc		 int	 3
$LN3@InitThread:

; 1380 :     m_hCompletionPort = hCompletionPort;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 55 08	 mov	 edx, DWORD PTR _hCompletionPort$[ebp]
  00027	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 1381 :     return true;

  0002a	b0 01		 mov	 al, 1

; 1382 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?InitThread@CTCPNetworkThreadReadWrite@@QAE_NPAX@Z ENDP	; CTCPNetworkThreadReadWrite::InitThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1CTCPNetworkThreadReadWrite@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTCPNetworkThreadReadWrite@@UAE@XZ PROC		; CTCPNetworkThreadReadWrite::~CTCPNetworkThreadReadWrite, COMDAT
; _this$ = ecx

; 1373 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadReadWrite@@6B@

; 1374 : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHThread@@MAE@XZ
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CTCPNetworkThreadReadWrite@@UAE@XZ ENDP		; CTCPNetworkThreadReadWrite::~CTCPNetworkThreadReadWrite
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0CTCPNetworkThreadReadWrite@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTCPNetworkThreadReadWrite@@QAE@XZ PROC		; CTCPNetworkThreadReadWrite::CTCPNetworkThreadReadWrite, COMDAT
; _this$ = ecx

; 1367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHThread@@IAE@XZ
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkThreadReadWrite@@6B@

; 1368 :     m_hCompletionPort = NULL;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1369 : }

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0CTCPNetworkThreadReadWrite@@QAE@XZ ENDP		; CTCPNetworkThreadReadWrite::CTCPNetworkThreadReadWrite
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTCPNetworkItem@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTCPNetworkItem@@UAEPAXI@Z PROC			; CTCPNetworkItem::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTCPNetworkItem@@UAE@XZ ; CTCPNetworkItem::~CTCPNetworkItem
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 11		 je	 SHORT $LN2@scalar
  00017	68 d8 40 01 00	 push	 82136			; 000140d8H
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00025	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_GCTCPNetworkItem@@UAEPAXI@Z ENDP			; CTCPNetworkItem::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z
_TEXT	SEGMENT
_nIndex$2 = -100					; size = 4
tv216 = -96						; size = 4
$T3 = -92						; size = 4
tv166 = -88						; size = 4
tv229 = -84						; size = 4
_nIndex$4 = -80						; size = 4
$T5 = -76						; size = 4
_nActiveCount$6 = -72					; size = 4
$T7 = -68						; size = 4
_nActiveCount$8 = -64					; size = 4
$T9 = -60						; size = 4
_this$ = -56						; size = 4
tv184 = -52						; size = 4
$T10 = -48						; size = 4
_nFreeCount$11 = -44					; size = 4
_this$ = -40						; size = 4
_pOverLappedSend$12 = -36				; size = 4
_pOverLappedSend$13 = -32				; size = 4
_pOverLappedSend$14 = -28				; size = 4
_pOverLappedSend$15 = -24				; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_wPacketSize$ = 8					; size = 2
_flag$ = 12						; size = 1
?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z PROC ; CTCPNetworkItem::GetSendOverLapped, COMDAT
; _this$ = ecx

; 1009 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 54	 sub	 esp, 84			; 00000054H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1010 : 	if (flag == true) {

  0002f	0f b6 45 0c	 movzx	 eax, BYTE PTR _flag$[ebp]
  00033	83 f8 01	 cmp	 eax, 1
  00036	0f 85 b3 00 00
	00		 jne	 $LN2@GetSendOve

; 1011 : 		if (m_connectType == WEBSOCKET) {

  0003c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 79 40 03	 cmp	 DWORD PTR [ecx+64], 3
  00043	75 54		 jne	 SHORT $LN3@GetSendOve
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00045	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 82 9c 40 01
	00		 mov	 eax, DWORD PTR [edx+82076]
  0004e	89 45 c4	 mov	 DWORD PTR $T9[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1013 : 			if (m_OverLappedSendActive.GetCount() > 1)

  00051	83 7d c4 01	 cmp	 DWORD PTR $T9[ebp], 1
  00055	7e 40		 jle	 SHORT $LN5@GetSendOve
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 91 9c 40 01
	00		 mov	 edx, DWORD PTR [ecx+82076]
  00060	89 55 c0	 mov	 DWORD PTR _nActiveCount$8[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1016 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  00063	8b 45 c0	 mov	 eax, DWORD PTR _nActiveCount$8[ebp]
  00066	83 e8 01	 sub	 eax, 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00069	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1016 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00073	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1016 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d e0	 mov	 DWORD PTR _pOverLappedSend$13[ebp], ecx

; 1017 : 				if (sizeof(pOverLappedSend->m_cbBuffer) >= (pOverLappedSend->m_WSABuffer.len + wPacketSize))

  0007d	0f b7 55 08	 movzx	 edx, WORD PTR _wPacketSize$[ebp]
  00081	8b 45 e0	 mov	 eax, DWORD PTR _pOverLappedSend$13[ebp]
  00084	03 50 04	 add	 edx, DWORD PTR [eax+4]
  00087	81 fa 00 40 00
	00		 cmp	 edx, 16384		; 00004000H
  0008d	77 08		 ja	 SHORT $LN5@GetSendOve

; 1018 : 					return pOverLappedSend;

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _pOverLappedSend$13[ebp]
  00092	e9 e2 01 00 00	 jmp	 $LN1@GetSendOve
$LN5@GetSendOve:

; 1019 : 			}
; 1020 : 		}
; 1021 : 		else {

  00097	eb 56		 jmp	 SHORT $LN2@GetSendOve
$LN3@GetSendOve:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00099	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b 91 9c 40 01
	00		 mov	 edx, DWORD PTR [ecx+82076]
  000a2	89 55 bc	 mov	 DWORD PTR $T7[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1023 : 			if (m_OverLappedSendActive.GetCount() > 1)

  000a5	83 7d bc 01	 cmp	 DWORD PTR $T7[ebp], 1
  000a9	7e 44		 jle	 SHORT $LN2@GetSendOve
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000ab	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 88 9c 40 01
	00		 mov	 ecx, DWORD PTR [eax+82076]
  000b4	89 4d b8	 mov	 DWORD PTR _nActiveCount$6[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1026 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  000b7	8b 55 b8	 mov	 edx, DWORD PTR _nActiveCount$6[ebp]
  000ba	83 ea 01	 sub	 edx, 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000bd	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1026 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  000be	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000c7	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1026 : 				COverLappedSend * pOverLappedSend = m_OverLappedSendActive[nActiveCount - 1];

  000cc	8b 00		 mov	 eax, DWORD PTR [eax]
  000ce	89 45 dc	 mov	 DWORD PTR _pOverLappedSend$12[ebp], eax

; 1027 : 				if (sizeof(pOverLappedSend->m_cbBuffer) >= (pOverLappedSend->m_WSABuffer.len + wPacketSize + sizeof(DWORD) * 2))

  000d1	0f b7 4d 08	 movzx	 ecx, WORD PTR _wPacketSize$[ebp]
  000d5	8b 55 dc	 mov	 edx, DWORD PTR _pOverLappedSend$12[ebp]
  000d8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000db	8d 4c 08 08	 lea	 ecx, DWORD PTR [eax+ecx+8]
  000df	81 f9 00 40 00
	00		 cmp	 ecx, 16384		; 00004000H
  000e5	77 08		 ja	 SHORT $LN2@GetSendOve

; 1028 : 					return pOverLappedSend;

  000e7	8b 45 dc	 mov	 eax, DWORD PTR _pOverLappedSend$12[ebp]
  000ea	e9 8a 01 00 00	 jmp	 $LN1@GetSendOve
$LN2@GetSendOve:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000ef	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000f2	8b 82 d4 40 01
	00		 mov	 eax, DWORD PTR [edx+82132]
  000f8	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1035 :     if (m_OverLappedSendBuffer.GetCount() > 0)

  000fb	83 7d b4 00	 cmp	 DWORD PTR $T5[ebp], 0
  000ff	0f 8e 8a 00 00
	00		 jle	 $LN9@GetSendOve
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00105	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8b 91 d4 40 01
	00		 mov	 edx, DWORD PTR [ecx+82132]
  0010e	89 55 d4	 mov	 DWORD PTR _nFreeCount$11[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1039 :         COverLappedSend * pOverLappedSend = m_OverLappedSendBuffer[nFreeCount - 1];

  00111	8b 45 d4	 mov	 eax, DWORD PTR _nFreeCount$11[ebp]
  00114	83 e8 01	 sub	 eax, 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00117	50		 push	 eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1039 :         COverLappedSend * pOverLappedSend = m_OverLappedSendBuffer[nFreeCount - 1];

  00118	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00121	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1039 :         COverLappedSend * pOverLappedSend = m_OverLappedSendBuffer[nFreeCount - 1];

  00126	8b 08		 mov	 ecx, DWORD PTR [eax]
  00128	89 4d e4	 mov	 DWORD PTR _pOverLappedSend$14[ebp], ecx

; 1040 : 
; 1041 :         // 设置变量
; 1042 :         pOverLappedSend->m_WSABuffer.len = 0;

  0012b	8b 55 e4	 mov	 edx, DWORD PTR _pOverLappedSend$14[ebp]
  0012e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 1043 : 		ZeroMemory(pOverLappedSend->m_cbBuffer, sizeof(pOverLappedSend->m_cbBuffer));

  00135	68 00 40 00 00	 push	 16384			; 00004000H
  0013a	6a 00		 push	 0
  0013c	8b 45 e4	 mov	 eax, DWORD PTR _pOverLappedSend$14[ebp]
  0013f	83 c0 24	 add	 eax, 36			; 00000024H
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 _memset
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1044 :         m_OverLappedSendActive.Add(pOverLappedSend);

  0014b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014e	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  00154	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00157	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  0015a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0015d	89 45 b0	 mov	 DWORD PTR _nIndex$4[ebp], eax

; 107  : 	SetAtGrow(nIndex,newElement);

  00160	8d 4d e4	 lea	 ecx, DWORD PTR _pOverLappedSend$14[ebp]
  00163	51		 push	 ecx
  00164	8b 55 b0	 mov	 edx, DWORD PTR _nIndex$4[ebp]
  00167	52		 push	 edx
  00168	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1045 :         m_OverLappedSendBuffer.RemoveAt(nFreeCount - 1);

  00170	6a 01		 push	 1
  00172	8b 45 d4	 mov	 eax, DWORD PTR _nFreeCount$11[ebp]
  00175	83 e8 01	 sub	 eax, 1
  00178	50		 push	 eax
  00179	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
  00182	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAt

; 1046 : 
; 1047 :         return pOverLappedSend;

  00187	8b 45 e4	 mov	 eax, DWORD PTR _pOverLappedSend$14[ebp]
  0018a	e9 ea 00 00 00	 jmp	 $LN1@GetSendOve
$LN9@GetSendOve:

; 1048 :     }
; 1049 : 
; 1050 :     try

  0018f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1051 :     {
; 1052 :         // 创建对象
; 1053 :         COverLappedSend * pOverLappedSend = new COverLappedSend;

  00196	68 24 40 00 00	 push	 16420			; 00004024H
  0019b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001a0	83 c4 04	 add	 esp, 4
  001a3	89 45 ac	 mov	 DWORD PTR tv229[ebp], eax
  001a6	8b 4d ac	 mov	 ecx, DWORD PTR tv229[ebp]
  001a9	89 4d d0	 mov	 DWORD PTR $T10[ebp], ecx
  001ac	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  001b0	83 7d d0 00	 cmp	 DWORD PTR $T10[ebp], 0
  001b4	74 13		 je	 SHORT $LN12@GetSendOve
  001b6	8b 4d d0	 mov	 ecx, DWORD PTR $T10[ebp]
  001b9	e8 00 00 00 00	 call	 ??0COverLappedSend@@QAE@XZ ; COverLappedSend::COverLappedSend
  001be	89 45 a8	 mov	 DWORD PTR tv166[ebp], eax
  001c1	8b 55 a8	 mov	 edx, DWORD PTR tv166[ebp]
  001c4	89 55 cc	 mov	 DWORD PTR tv184[ebp], edx
  001c7	eb 07		 jmp	 SHORT $LN13@GetSendOve
$LN12@GetSendOve:
  001c9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
$LN13@GetSendOve:
  001d0	8b 45 cc	 mov	 eax, DWORD PTR tv184[ebp]
  001d3	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
  001d6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  001da	8b 4d a4	 mov	 ecx, DWORD PTR $T3[ebp]
  001dd	89 4d e8	 mov	 DWORD PTR _pOverLappedSend$15[ebp], ecx

; 1054 :         ASSERT(pOverLappedSend != NULL);

  001e0	83 7d e8 00	 cmp	 DWORD PTR _pOverLappedSend$15[ebp], 0
  001e4	75 19		 jne	 SHORT $LN14@GetSendOve
  001e6	68 1e 04 00 00	 push	 1054			; 0000041eH
  001eb	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001f0	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001f5	89 45 a0	 mov	 DWORD PTR tv216[ebp], eax
  001f8	83 7d a0 00	 cmp	 DWORD PTR tv216[ebp], 0
  001fc	74 01		 je	 SHORT $LN14@GetSendOve
  001fe	cc		 int	 3
$LN14@GetSendOve:

; 1055 : 
; 1056 :         // 设置变量
; 1057 :         pOverLappedSend->m_WSABuffer.len = 0;

  001ff	8b 45 e8	 mov	 eax, DWORD PTR _pOverLappedSend$15[ebp]
  00202	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1058 : 		ZeroMemory(pOverLappedSend->m_cbBuffer, sizeof(pOverLappedSend->m_cbBuffer));

  00209	68 00 40 00 00	 push	 16384			; 00004000H
  0020e	6a 00		 push	 0
  00210	8b 4d e8	 mov	 ecx, DWORD PTR _pOverLappedSend$15[ebp]
  00213	83 c1 24	 add	 ecx, 36			; 00000024H
  00216	51		 push	 ecx
  00217	e8 00 00 00 00	 call	 _memset
  0021c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1059 :         m_OverLappedSendActive.Add(pOverLappedSend);

  0021f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00222	81 c2 8c 40 01
	00		 add	 edx, 82060		; 0001408cH
  00228	89 55 c8	 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  0022b	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0022e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00231	89 4d 9c	 mov	 DWORD PTR _nIndex$2[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00234	8d 55 e8	 lea	 edx, DWORD PTR _pOverLappedSend$15[ebp]
  00237	52		 push	 edx
  00238	8b 45 9c	 mov	 eax, DWORD PTR _nIndex$2[ebp]
  0023b	50		 push	 eax
  0023c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023f	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1061 :         return pOverLappedSend;

  00244	8b 45 e8	 mov	 eax, DWORD PTR _pOverLappedSend$15[ebp]
  00247	eb 30		 jmp	 SHORT $LN1@GetSendOve
__catch$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$0:

; 1062 :     }
; 1063 :     catch (...) { ASSERT(FALSE); }

  00249	33 c9		 xor	 ecx, ecx
  0024b	75 14		 jne	 SHORT $LN15@GetSendOve
  0024d	68 27 04 00 00	 push	 1063			; 00000427H
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00257	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0025c	85 c0		 test	 eax, eax
  0025e	74 01		 je	 SHORT $LN15@GetSendOve
  00260	cc		 int	 3
$LN15@GetSendOve:
  00261	b8 00 00 00 00	 mov	 eax, $LN20@GetSendOve
  00266	c3		 ret	 0
  00267	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0026e	eb 07		 jmp	 SHORT __tryend$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$1
$LN20@GetSendOve:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
  00270	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$1:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1064 : 
; 1065 :     return NULL;

  00277	33 c0		 xor	 eax, eax
$LN1@GetSendOve:

; 1066 : }

  00279	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0027c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00283	59		 pop	 ecx
  00284	5f		 pop	 edi
  00285	5e		 pop	 esi
  00286	5b		 pop	 ebx
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z$2:
  00000	68 24 40 00 00	 push	 16420			; 00004024H
  00005	8b 45 d0	 mov	 eax, DWORD PTR $T10[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z ENDP ; CTCPNetworkItem::GetSendOverLapped
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendVerdict@CTCPNetworkItem@@AAE_NG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wRountID$ = 8						; size = 2
?SendVerdict@CTCPNetworkItem@@AAE_NG@Z PROC		; CTCPNetworkItem::SendVerdict, COMDAT
; _this$ = ecx

; 998  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 999  :     if ((m_wRountID != wRountID) || (m_bShutDown == true))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0000e	0f b7 55 08	 movzx	 edx, WORD PTR _wRountID$[ebp]
  00012	3b ca		 cmp	 ecx, edx
  00014	75 0c		 jne	 SHORT $LN3@SendVerdic
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  0001d	83 f9 01	 cmp	 ecx, 1
  00020	75 04		 jne	 SHORT $LN2@SendVerdic
$LN3@SendVerdic:

; 1000 :         return false;

  00022	32 c0		 xor	 al, al
  00024	eb 1b		 jmp	 SHORT $LN1@SendVerdic
$LN2@SendVerdic:

; 1001 :     if ((m_hSocketHandle == INVALID_SOCKET) || (m_dwRecvPacketCount == 0))

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  0002d	74 0c		 je	 SHORT $LN5@SendVerdic
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  00039	75 04		 jne	 SHORT $LN4@SendVerdic
$LN5@SendVerdic:

; 1002 :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 02		 jmp	 SHORT $LN1@SendVerdic
$LN4@SendVerdic:

; 1003 : 
; 1004 :     return true;

  0003f	b0 01		 mov	 al, 1
$LN1@SendVerdic:

; 1005 : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?SendVerdict@CTCPNetworkItem@@AAE_NG@Z ENDP		; CTCPNetworkItem::SendVerdict
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?MapRecvByte@CTCPNetworkItem@@AAEEE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbMap$ = -1						; size = 1
_cbData$ = 8						; size = 1
?MapRecvByte@CTCPNetworkItem@@AAEEE@Z PROC		; CTCPNetworkItem::MapRecvByte, COMDAT
; _this$ = ecx

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 991  : 	BYTE cbMap = g_RecvByteMap[cbData] - m_cbRecvRound;

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _cbData$[ebp]
  0000d	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?g_RecvByteMap@@3QBEB[eax]
  00014	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00017	0f b6 82 5d 40
	01 00		 movzx	 eax, BYTE PTR [edx+82013]
  0001e	2b c8		 sub	 ecx, eax
  00020	88 4d ff	 mov	 BYTE PTR _cbMap$[ebp], cl

; 992  : 	m_cbRecvRound += 3;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	0f b6 91 5d 40
	01 00		 movzx	 edx, BYTE PTR [ecx+82013]
  0002d	83 c2 03	 add	 edx, 3
  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	88 90 5d 40 01
	00		 mov	 BYTE PTR [eax+82013], dl

; 993  :     return cbMap;

  00039	8a 45 ff	 mov	 al, BYTE PTR _cbMap$[ebp]

; 994  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?MapRecvByte@CTCPNetworkItem@@AAEEE@Z ENDP		; CTCPNetworkItem::MapRecvByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?MapSendByte@CTCPNetworkItem@@AAEEE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_cbMap$ = -1						; size = 1
_cbData$ = 8						; size = 1
?MapSendByte@CTCPNetworkItem@@AAEEE@Z PROC		; CTCPNetworkItem::MapSendByte, COMDAT
; _this$ = ecx

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 983  : 	BYTE cbMap = g_SendByteMap[(BYTE)(cbData + m_cbSendRound)];

  00009	0f b6 45 08	 movzx	 eax, BYTE PTR _cbData$[ebp]
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	0f b6 91 5c 40
	01 00		 movzx	 edx, BYTE PTR [ecx+82012]
  00017	03 c2		 add	 eax, edx
  00019	0f b6 c0	 movzx	 eax, al
  0001c	8a 88 00 00 00
	00		 mov	 cl, BYTE PTR ?g_SendByteMap@@3QBEB[eax]
  00022	88 4d ff	 mov	 BYTE PTR _cbMap$[ebp], cl

; 984  : 	m_cbSendRound += 3;

  00025	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00028	0f b6 82 5c 40
	01 00		 movzx	 eax, BYTE PTR [edx+82012]
  0002f	83 c0 03	 add	 eax, 3
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	88 81 5c 40 01
	00		 mov	 BYTE PTR [ecx+82012], al

; 985  :     return cbMap;

  0003b	8a 45 ff	 mov	 al, BYTE PTR _cbMap$[ebp]

; 986  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?MapSendByte@CTCPNetworkItem@@AAEEE@Z ENDP		; CTCPNetworkItem::MapSendByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SeedRandMap@CTCPNetworkItem@@AAEGG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_dwHold$ = -4						; size = 4
_wSeed$ = 8						; size = 2
?SeedRandMap@CTCPNetworkItem@@AAEGG@Z PROC		; CTCPNetworkItem::SeedRandMap, COMDAT
; _this$ = ecx

; 975  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 976  :     DWORD dwHold = wSeed;

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _wSeed$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR _dwHold$[ebp], eax

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  00010	69 4d fc cf ad
	03 00		 imul	 ecx, DWORD PTR _dwHold$[ebp], 241103
  00017	81 c1 ed a6 26
	00		 add	 ecx, 2533101		; 0026a6edH
  0001d	89 4d fc	 mov	 DWORD PTR _dwHold$[ebp], ecx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _dwHold$[ebp]
  00023	c1 e8 10	 shr	 eax, 16			; 00000010H

; 978  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?SeedRandMap@CTCPNetworkItem@@AAEGG@Z ENDP		; CTCPNetworkItem::SeedRandMap
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
_pHead$ = -68						; size = 4
_pcbKey$2 = -64						; size = 4
$T3 = -60						; size = 4
_dwHold$4 = -56						; size = 4
_dwHold$5 = -52						; size = 4
_pdwXor$ = -48						; size = 4
_i$6 = -44						; size = 4
_dwXorKey$ = -40					; size = 4
_pwSeed$ = -36						; size = 4
_this$ = -32						; size = 4
$T7 = -28						; size = 2
$T8 = -26						; size = 2
_wEncrypCount$ = -24					; size = 2
_i$9 = -20						; size = 2
_wSnapCount$ = -16					; size = 2
_cbMap$10 = -9						; size = 1
_cbData$ = -8						; size = 1
_cbCheckCode$ = -1					; size = 1
_pcbDataBuffer$ = 8					; size = 4
_wDataSize$ = 12					; size = 2
?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z PROC	; CTCPNetworkItem::CrevasseBuffer, COMDAT
; _this$ = ecx

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 915  : 	//效验参数
; 916  : 	ASSERT(wDataSize >= sizeof(TCP_Head));

  00009	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0000d	83 f8 08	 cmp	 eax, 8
  00010	73 14		 jae	 SHORT $LN14@CrevasseBu
  00012	68 94 03 00 00	 push	 916			; 00000394H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN14@CrevasseBu
  00025	cc		 int	 3
$LN14@CrevasseBu:

; 917  : 	ASSERT(((TCP_Head *)pcbDataBuffer)->TCPInfo.wPacketSize == wDataSize);

  00026	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00029	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0002d	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00031	3b c1		 cmp	 eax, ecx
  00033	74 14		 je	 SHORT $LN15@CrevasseBu
  00035	68 95 03 00 00	 push	 917			; 00000395H
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0003f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00044	85 c0		 test	 eax, eax
  00046	74 01		 je	 SHORT $LN15@CrevasseBu
  00048	cc		 int	 3
$LN15@CrevasseBu:

; 918  : 
; 919  : 	//调整长度
; 920  : 	WORD wSnapCount = 0;

  00049	33 c0		 xor	 eax, eax
  0004b	66 89 45 f0	 mov	 WORD PTR _wSnapCount$[ebp], ax

; 921  : 	if ((wDataSize % sizeof(DWORD)) != 0)

  0004f	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00053	33 d2		 xor	 edx, edx
  00055	b9 04 00 00 00	 mov	 ecx, 4
  0005a	f7 f1		 div	 ecx
  0005c	85 d2		 test	 edx, edx
  0005e	74 2f		 je	 SHORT $LN8@CrevasseBu

; 922  : 	{
; 923  : 		wSnapCount = sizeof(DWORD) - wDataSize % sizeof(DWORD);

  00060	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00064	33 d2		 xor	 edx, edx
  00066	b9 04 00 00 00	 mov	 ecx, 4
  0006b	f7 f1		 div	 ecx
  0006d	b8 04 00 00 00	 mov	 eax, 4
  00072	2b c2		 sub	 eax, edx
  00074	66 89 45 f0	 mov	 WORD PTR _wSnapCount$[ebp], ax

; 924  : 		memset(pcbDataBuffer + wDataSize, 0, wSnapCount);

  00078	0f b7 4d f0	 movzx	 ecx, WORD PTR _wSnapCount$[ebp]
  0007c	51		 push	 ecx
  0007d	6a 00		 push	 0
  0007f	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  00083	03 55 08	 add	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 _memset
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@CrevasseBu:

; 925  : 	}
; 926  : 
; 927  : 	//提取密钥
; 928  : 	if (m_dwRecvPacketCount == 0)

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  00099	0f 85 96 00 00
	00		 jne	 $LN9@CrevasseBu

; 929  : 	{
; 930  : 		ASSERT(wDataSize >= (sizeof(TCP_Head) + sizeof(DWORD)));

  0009f	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  000a3	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  000a6	73 14		 jae	 SHORT $LN16@CrevasseBu
  000a8	68 a2 03 00 00	 push	 930			; 000003a2H
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000b2	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000b7	85 c0		 test	 eax, eax
  000b9	74 01		 je	 SHORT $LN16@CrevasseBu
  000bb	cc		 int	 3
$LN16@CrevasseBu:

; 931  : 		if (wDataSize < (sizeof(TCP_Head) + sizeof(DWORD))) throw TEXT("数据包解密长度错误");

  000bc	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  000c0	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000c3	73 15		 jae	 SHORT $LN10@CrevasseBu
  000c5	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0BD@DINLBKIB@?J?$PN?$LO?$NN?$LA?$PM?$LN?b?C?$NM?$LD?$KE?$LG?H?$LE?m?N?s@
  000cc	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000d1	8d 4d c4	 lea	 ecx, DWORD PTR $T3[ebp]
  000d4	51		 push	 ecx
  000d5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@CrevasseBu:

; 932  : 		m_dwRecvXorKey = *(DWORD *)(pcbDataBuffer + sizeof(TCP_Head));

  000da	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000dd	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  000e0	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e3	89 8a 64 40 01
	00		 mov	 DWORD PTR [edx+82020], ecx

; 933  : 		m_dwSendXorKey = m_dwRecvXorKey;

  000e9	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000ec	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	8b 88 64 40 01
	00		 mov	 ecx, DWORD PTR [eax+82020]
  000f5	89 8a 60 40 01
	00		 mov	 DWORD PTR [edx+82016], ecx

; 934  : 		MoveMemory(pcbDataBuffer + sizeof(TCP_Head), pcbDataBuffer + sizeof(TCP_Head) + sizeof(DWORD),

  000fb	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  000ff	83 ea 0c	 sub	 edx, 12			; 0000000cH
  00102	52		 push	 edx
  00103	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  00106	83 c0 0c	 add	 eax, 12			; 0000000cH
  00109	50		 push	 eax
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  0010d	83 c1 08	 add	 ecx, 8
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _memmove
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH

; 935  : 			wDataSize - sizeof(TCP_Head) - sizeof(DWORD));
; 936  : 		wDataSize -= sizeof(DWORD);

  00119	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  0011d	83 ea 04	 sub	 edx, 4
  00120	66 89 55 0c	 mov	 WORD PTR _wDataSize$[ebp], dx

; 937  : 		((TCP_Head *)pcbDataBuffer)->TCPInfo.wPacketSize -= sizeof(DWORD);

  00124	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  00127	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0012b	83 e9 04	 sub	 ecx, 4
  0012e	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00131	66 89 4a 02	 mov	 WORD PTR [edx+2], cx
$LN9@CrevasseBu:

; 938  : 	}
; 939  : 
; 940  : 	//解密数据
; 941  : 	DWORD dwXorKey = m_dwRecvXorKey;

  00135	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00138	8b 88 64 40 01
	00		 mov	 ecx, DWORD PTR [eax+82020]
  0013e	89 4d d8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 942  : 	DWORD * pdwXor = (DWORD *)(pcbDataBuffer + sizeof(TCP_Info));

  00141	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00144	83 c2 04	 add	 edx, 4
  00147	89 55 d0	 mov	 DWORD PTR _pdwXor$[ebp], edx

; 943  : 	WORD  * pwSeed = (WORD *)(pcbDataBuffer + sizeof(TCP_Info));

  0014a	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  0014d	83 c0 04	 add	 eax, 4
  00150	89 45 dc	 mov	 DWORD PTR _pwSeed$[ebp], eax

; 944  : 	WORD wEncrypCount = (wDataSize + wSnapCount - sizeof(TCP_Info)) / 4;

  00153	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00157	0f b7 55 f0	 movzx	 edx, WORD PTR _wSnapCount$[ebp]
  0015b	8d 44 11 fc	 lea	 eax, DWORD PTR [ecx+edx-4]
  0015f	c1 e8 02	 shr	 eax, 2
  00162	66 89 45 e8	 mov	 WORD PTR _wEncrypCount$[ebp], ax

; 945  : 	for (WORD i = 0; i < wEncrypCount; i++)

  00166	33 c9		 xor	 ecx, ecx
  00168	66 89 4d ec	 mov	 WORD PTR _i$9[ebp], cx
  0016c	eb 0c		 jmp	 SHORT $LN4@CrevasseBu
$LN2@CrevasseBu:
  0016e	66 8b 55 ec	 mov	 dx, WORD PTR _i$9[ebp]
  00172	66 83 c2 01	 add	 dx, 1
  00176	66 89 55 ec	 mov	 WORD PTR _i$9[ebp], dx
$LN4@CrevasseBu:
  0017a	0f b7 45 ec	 movzx	 eax, WORD PTR _i$9[ebp]
  0017e	0f b7 4d e8	 movzx	 ecx, WORD PTR _wEncrypCount$[ebp]
  00182	3b c1		 cmp	 eax, ecx
  00184	0f 8d ec 00 00
	00		 jge	 $LN3@CrevasseBu

; 946  : 	{
; 947  : 		if ((i == (wEncrypCount - 1)) && (wSnapCount > 0))

  0018a	0f b7 55 ec	 movzx	 edx, WORD PTR _i$9[ebp]
  0018e	0f b7 45 e8	 movzx	 eax, WORD PTR _wEncrypCount$[ebp]
  00192	83 e8 01	 sub	 eax, 1
  00195	3b d0		 cmp	 edx, eax
  00197	75 33		 jne	 SHORT $LN11@CrevasseBu
  00199	0f b7 4d f0	 movzx	 ecx, WORD PTR _wSnapCount$[ebp]
  0019d	85 c9		 test	 ecx, ecx
  0019f	7e 2b		 jle	 SHORT $LN11@CrevasseBu

; 948  : 		{
; 949  : 			BYTE * pcbKey = ((BYTE *)&m_dwRecvXorKey) + sizeof(DWORD) - wSnapCount;

  001a1	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	81 c2 68 40 01
	00		 add	 edx, 82024		; 00014068H
  001aa	0f b7 45 f0	 movzx	 eax, WORD PTR _wSnapCount$[ebp]
  001ae	2b d0		 sub	 edx, eax
  001b0	89 55 c0	 mov	 DWORD PTR _pcbKey$2[ebp], edx

; 950  : 			CopyMemory(pcbDataBuffer + wDataSize, pcbKey, wSnapCount);

  001b3	0f b7 4d f0	 movzx	 ecx, WORD PTR _wSnapCount$[ebp]
  001b7	51		 push	 ecx
  001b8	8b 55 c0	 mov	 edx, DWORD PTR _pcbKey$2[ebp]
  001bb	52		 push	 edx
  001bc	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  001c0	03 45 08	 add	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _memcpy
  001c9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@CrevasseBu:

; 951  : 		}
; 952  : 		dwXorKey = SeedRandMap(*pwSeed++);

  001cc	8b 4d dc	 mov	 ecx, DWORD PTR _pwSeed$[ebp]
  001cf	66 8b 11	 mov	 dx, WORD PTR [ecx]
  001d2	66 89 55 e6	 mov	 WORD PTR $T8[ebp], dx

; 976  :     DWORD dwHold = wSeed;

  001d6	0f b7 45 e6	 movzx	 eax, WORD PTR $T8[ebp]
  001da	89 45 cc	 mov	 DWORD PTR _dwHold$5[ebp], eax

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  001dd	69 4d cc cf ad
	03 00		 imul	 ecx, DWORD PTR _dwHold$5[ebp], 241103
  001e4	81 c1 ed a6 26
	00		 add	 ecx, 2533101		; 0026a6edH
  001ea	89 4d cc	 mov	 DWORD PTR _dwHold$5[ebp], ecx
  001ed	8b 55 cc	 mov	 edx, DWORD PTR _dwHold$5[ebp]
  001f0	c1 ea 10	 shr	 edx, 16			; 00000010H

; 951  : 		}
; 952  : 		dwXorKey = SeedRandMap(*pwSeed++);

  001f3	0f b7 c2	 movzx	 eax, dx
  001f6	89 45 d8	 mov	 DWORD PTR _dwXorKey$[ebp], eax
  001f9	8b 4d dc	 mov	 ecx, DWORD PTR _pwSeed$[ebp]
  001fc	83 c1 02	 add	 ecx, 2
  001ff	89 4d dc	 mov	 DWORD PTR _pwSeed$[ebp], ecx

; 953  : 		dwXorKey |= ((DWORD)SeedRandMap(*pwSeed++)) << 16;

  00202	8b 55 dc	 mov	 edx, DWORD PTR _pwSeed$[ebp]
  00205	66 8b 02	 mov	 ax, WORD PTR [edx]
  00208	66 89 45 e4	 mov	 WORD PTR $T7[ebp], ax

; 976  :     DWORD dwHold = wSeed;

  0020c	0f b7 4d e4	 movzx	 ecx, WORD PTR $T7[ebp]
  00210	89 4d c8	 mov	 DWORD PTR _dwHold$4[ebp], ecx

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  00213	69 55 c8 cf ad
	03 00		 imul	 edx, DWORD PTR _dwHold$4[ebp], 241103
  0021a	81 c2 ed a6 26
	00		 add	 edx, 2533101		; 0026a6edH
  00220	89 55 c8	 mov	 DWORD PTR _dwHold$4[ebp], edx
  00223	8b 45 c8	 mov	 eax, DWORD PTR _dwHold$4[ebp]
  00226	c1 e8 10	 shr	 eax, 16			; 00000010H

; 953  : 		dwXorKey |= ((DWORD)SeedRandMap(*pwSeed++)) << 16;

  00229	0f b7 c8	 movzx	 ecx, ax
  0022c	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0022f	0b 4d d8	 or	 ecx, DWORD PTR _dwXorKey$[ebp]
  00232	89 4d d8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx
  00235	8b 55 dc	 mov	 edx, DWORD PTR _pwSeed$[ebp]
  00238	83 c2 02	 add	 edx, 2
  0023b	89 55 dc	 mov	 DWORD PTR _pwSeed$[ebp], edx

; 954  : 		dwXorKey ^= g_dwPacketKey;

  0023e	8b 45 d8	 mov	 eax, DWORD PTR _dwXorKey$[ebp]
  00241	35 5a a5 5a a5	 xor	 eax, -1520786086	; a55aa55aH
  00246	89 45 d8	 mov	 DWORD PTR _dwXorKey$[ebp], eax

; 955  : 		*pdwXor++ ^= m_dwRecvXorKey;

  00249	8b 4d d0	 mov	 ecx, DWORD PTR _pdwXor$[ebp]
  0024c	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0024f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00251	33 82 64 40 01
	00		 xor	 eax, DWORD PTR [edx+82020]
  00257	8b 4d d0	 mov	 ecx, DWORD PTR _pdwXor$[ebp]
  0025a	89 01		 mov	 DWORD PTR [ecx], eax
  0025c	8b 55 d0	 mov	 edx, DWORD PTR _pdwXor$[ebp]
  0025f	83 c2 04	 add	 edx, 4
  00262	89 55 d0	 mov	 DWORD PTR _pdwXor$[ebp], edx

; 956  : 		m_dwRecvXorKey = dwXorKey;

  00265	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00268	8b 4d d8	 mov	 ecx, DWORD PTR _dwXorKey$[ebp]
  0026b	89 88 64 40 01
	00		 mov	 DWORD PTR [eax+82020], ecx

; 957  : 	}

  00271	e9 f8 fe ff ff	 jmp	 $LN2@CrevasseBu
$LN3@CrevasseBu:

; 958  : 
; 959  : 	//效验码与字节映射
; 960  : 	TCP_Head * pHead = (TCP_Head *)pcbDataBuffer;

  00276	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00279	89 55 bc	 mov	 DWORD PTR _pHead$[ebp], edx

; 961  : 	BYTE cbCheckCode = pHead->TCPInfo.cbCheckCode;

  0027c	8b 45 bc	 mov	 eax, DWORD PTR _pHead$[ebp]
  0027f	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  00282	88 4d ff	 mov	 BYTE PTR _cbCheckCode$[ebp], cl

; 962  : 	for (int i = sizeof(TCP_Info); i < wDataSize; i++)

  00285	c7 45 d4 04 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 4
  0028c	eb 09		 jmp	 SHORT $LN7@CrevasseBu
$LN5@CrevasseBu:
  0028e	8b 55 d4	 mov	 edx, DWORD PTR _i$6[ebp]
  00291	83 c2 01	 add	 edx, 1
  00294	89 55 d4	 mov	 DWORD PTR _i$6[ebp], edx
$LN7@CrevasseBu:
  00297	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0029b	39 45 d4	 cmp	 DWORD PTR _i$6[ebp], eax
  0029e	7d 5a		 jge	 SHORT $LN6@CrevasseBu

; 963  : 	{
; 964  : 		pcbDataBuffer[i] = MapRecvByte(pcbDataBuffer[i]);

  002a0	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  002a3	03 4d d4	 add	 ecx, DWORD PTR _i$6[ebp]
  002a6	8a 11		 mov	 dl, BYTE PTR [ecx]
  002a8	88 55 f8	 mov	 BYTE PTR _cbData$[ebp], dl

; 991  : 	BYTE cbMap = g_RecvByteMap[cbData] - m_cbRecvRound;

  002ab	0f b6 45 f8	 movzx	 eax, BYTE PTR _cbData$[ebp]
  002af	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR ?g_RecvByteMap@@3QBEB[eax]
  002b6	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  002b9	0f b6 82 5d 40
	01 00		 movzx	 eax, BYTE PTR [edx+82013]
  002c0	2b c8		 sub	 ecx, eax
  002c2	88 4d f7	 mov	 BYTE PTR _cbMap$10[ebp], cl

; 992  : 	m_cbRecvRound += 3;

  002c5	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002c8	0f b6 91 5d 40
	01 00		 movzx	 edx, BYTE PTR [ecx+82013]
  002cf	83 c2 03	 add	 edx, 3
  002d2	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  002d5	88 90 5d 40 01
	00		 mov	 BYTE PTR [eax+82013], dl

; 963  : 	{
; 964  : 		pcbDataBuffer[i] = MapRecvByte(pcbDataBuffer[i]);

  002db	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  002de	03 4d d4	 add	 ecx, DWORD PTR _i$6[ebp]
  002e1	8a 55 f7	 mov	 dl, BYTE PTR _cbMap$10[ebp]
  002e4	88 11		 mov	 BYTE PTR [ecx], dl

; 965  : 		cbCheckCode += pcbDataBuffer[i];

  002e6	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  002e9	03 45 d4	 add	 eax, DWORD PTR _i$6[ebp]
  002ec	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002ef	0f b6 55 ff	 movzx	 edx, BYTE PTR _cbCheckCode$[ebp]
  002f3	03 d1		 add	 edx, ecx
  002f5	88 55 ff	 mov	 BYTE PTR _cbCheckCode$[ebp], dl

; 966  : 	}

  002f8	eb 94		 jmp	 SHORT $LN5@CrevasseBu
$LN6@CrevasseBu:

; 967  : 	if (cbCheckCode != 0) throw TEXT("数据包效验码错误");

  002fa	0f b6 45 ff	 movzx	 eax, BYTE PTR _cbCheckCode$[ebp]
  002fe	85 c0		 test	 eax, eax
  00300	74 15		 je	 SHORT $LN12@CrevasseBu
  00302	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ??_C@_0BB@GKKJNMOA@?J?$PN?$LO?$NN?$LA?$PM?P?$KH?Q?i?B?k?$LE?m?N?s@
  00309	68 00 00 00 00	 push	 OFFSET __TI2PAD
  0030e	8d 4d b8	 lea	 ecx, DWORD PTR $T1[ebp]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@CrevasseBu:

; 968  : 	// 设置变量
; 969  : 	m_dwRecvPacketCount++;

  00317	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0031a	8b 82 58 40 01
	00		 mov	 eax, DWORD PTR [edx+82008]
  00320	83 c0 01	 add	 eax, 1
  00323	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00326	89 81 58 40 01
	00		 mov	 DWORD PTR [ecx+82008], eax

; 970  :     return wDataSize;

  0032c	66 8b 45 0c	 mov	 ax, WORD PTR _wDataSize$[ebp]
$LN13@CrevasseBu:

; 971  : }

  00330	8b e5		 mov	 esp, ebp
  00332	5d		 pop	 ebp
  00333	c2 08 00	 ret	 8
?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z ENDP	; CTCPNetworkItem::CrevasseBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z
_TEXT	SEGMENT
_dwHold$1 = -92						; size = 4
_dwHold$2 = -88						; size = 4
_i$3 = -84						; size = 4
_dwHold$4 = -80						; size = 4
_dwHold$5 = -76						; size = 4
$T6 = -72						; size = 2
$T7 = -70						; size = 2
_wEncrypCount$ = -68					; size = 2
_pdwXor$ = -64						; size = 4
_pHead$ = -60						; size = 4
_pwSeed$ = -56						; size = 4
_wSnapCount$ = -52					; size = 2
_cbMap$8 = -45						; size = 1
_cbData$ = -44						; size = 1
_wEncryptSize$ = -40					; size = 2
_this$ = -36						; size = 4
_i$9 = -32						; size = 2
_cbCheckCode$ = -25					; size = 1
_dwXorKey$ = -24					; size = 4
_Guid$10 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pcbDataBuffer$ = 8					; size = 4
_wDataSize$ = 12					; size = 2
_wBufferSize$ = 16					; size = 2
?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z PROC	; CTCPNetworkItem::EncryptBuffer, COMDAT
; _this$ = ecx

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 836  : 	//效验参数
; 837  : 	ASSERT(wDataSize >= sizeof(TCP_Head));

  00014	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00018	83 f8 08	 cmp	 eax, 8
  0001b	73 14		 jae	 SHORT $LN12@EncryptBuf
  0001d	68 45 03 00 00	 push	 837			; 00000345H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00027	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0002c	85 c0		 test	 eax, eax
  0002e	74 01		 je	 SHORT $LN12@EncryptBuf
  00030	cc		 int	 3
$LN12@EncryptBuf:

; 838  : 	ASSERT(wBufferSize >= (wDataSize + 2 * sizeof(DWORD)));

  00031	0f b7 55 10	 movzx	 edx, WORD PTR _wBufferSize$[ebp]
  00035	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00039	83 c0 08	 add	 eax, 8
  0003c	3b d0		 cmp	 edx, eax
  0003e	73 14		 jae	 SHORT $LN13@EncryptBuf
  00040	68 46 03 00 00	 push	 838			; 00000346H
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0004a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004f	85 c0		 test	 eax, eax
  00051	74 01		 je	 SHORT $LN13@EncryptBuf
  00053	cc		 int	 3
$LN13@EncryptBuf:

; 839  : 	ASSERT(wDataSize <= (sizeof(TCP_Head) + SOCKET_TCP_PACKET));

  00054	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  00058	81 fa 00 40 00
	00		 cmp	 edx, 16384		; 00004000H
  0005e	76 14		 jbe	 SHORT $LN14@EncryptBuf
  00060	68 47 03 00 00	 push	 839			; 00000347H
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0006a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0006f	85 c0		 test	 eax, eax
  00071	74 01		 je	 SHORT $LN14@EncryptBuf
  00073	cc		 int	 3
$LN14@EncryptBuf:

; 840  : 
; 841  : 	//调整长度
; 842  : 	WORD wEncryptSize = wDataSize - sizeof(TCP_Command), wSnapCount = 0;

  00074	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00078	83 e9 04	 sub	 ecx, 4
  0007b	66 89 4d d8	 mov	 WORD PTR _wEncryptSize$[ebp], cx
  0007f	33 d2		 xor	 edx, edx
  00081	66 89 55 cc	 mov	 WORD PTR _wSnapCount$[ebp], dx

; 843  : 	if ((wEncryptSize % sizeof(DWORD)) != 0)

  00085	0f b7 45 d8	 movzx	 eax, WORD PTR _wEncryptSize$[ebp]
  00089	33 d2		 xor	 edx, edx
  0008b	b9 04 00 00 00	 mov	 ecx, 4
  00090	f7 f1		 div	 ecx
  00092	85 d2		 test	 edx, edx
  00094	74 33		 je	 SHORT $LN8@EncryptBuf

; 844  : 	{
; 845  : 		wSnapCount = sizeof(DWORD) - wEncryptSize % sizeof(DWORD);

  00096	0f b7 45 d8	 movzx	 eax, WORD PTR _wEncryptSize$[ebp]
  0009a	33 d2		 xor	 edx, edx
  0009c	b9 04 00 00 00	 mov	 ecx, 4
  000a1	f7 f1		 div	 ecx
  000a3	b8 04 00 00 00	 mov	 eax, 4
  000a8	2b c2		 sub	 eax, edx
  000aa	66 89 45 cc	 mov	 WORD PTR _wSnapCount$[ebp], ax

; 846  : 		memset(pcbDataBuffer + sizeof(TCP_Info) + wEncryptSize, 0, wSnapCount);

  000ae	0f b7 4d cc	 movzx	 ecx, WORD PTR _wSnapCount$[ebp]
  000b2	51		 push	 ecx
  000b3	6a 00		 push	 0
  000b5	0f b7 55 d8	 movzx	 edx, WORD PTR _wEncryptSize$[ebp]
  000b9	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  000bc	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _memset
  000c6	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@EncryptBuf:

; 847  : 	}
; 848  : 
; 849  : 	//效验码与字节映射
; 850  : 	BYTE cbCheckCode = 0;

  000c9	c6 45 e7 00	 mov	 BYTE PTR _cbCheckCode$[ebp], 0

; 851  : 	for (WORD i = sizeof(TCP_Info); i < wDataSize; i++)

  000cd	ba 04 00 00 00	 mov	 edx, 4
  000d2	66 89 55 e0	 mov	 WORD PTR _i$9[ebp], dx
  000d6	eb 0c		 jmp	 SHORT $LN4@EncryptBuf
$LN2@EncryptBuf:
  000d8	66 8b 45 e0	 mov	 ax, WORD PTR _i$9[ebp]
  000dc	66 83 c0 01	 add	 ax, 1
  000e0	66 89 45 e0	 mov	 WORD PTR _i$9[ebp], ax
$LN4@EncryptBuf:
  000e4	0f b7 4d e0	 movzx	 ecx, WORD PTR _i$9[ebp]
  000e8	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  000ec	3b ca		 cmp	 ecx, edx
  000ee	7d 62		 jge	 SHORT $LN3@EncryptBuf

; 852  : 	{
; 853  : 		cbCheckCode += pcbDataBuffer[i];

  000f0	0f b7 45 e0	 movzx	 eax, WORD PTR _i$9[ebp]
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  000f7	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000fb	0f b6 45 e7	 movzx	 eax, BYTE PTR _cbCheckCode$[ebp]
  000ff	03 c2		 add	 eax, edx
  00101	88 45 e7	 mov	 BYTE PTR _cbCheckCode$[ebp], al

; 854  : 		pcbDataBuffer[i] = MapSendByte(pcbDataBuffer[i]);

  00104	0f b7 4d e0	 movzx	 ecx, WORD PTR _i$9[ebp]
  00108	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  0010b	8a 04 0a	 mov	 al, BYTE PTR [edx+ecx]
  0010e	88 45 d4	 mov	 BYTE PTR _cbData$[ebp], al

; 983  : 	BYTE cbMap = g_SendByteMap[(BYTE)(cbData + m_cbSendRound)];

  00111	0f b6 4d d4	 movzx	 ecx, BYTE PTR _cbData$[ebp]
  00115	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00118	0f b6 82 5c 40
	01 00		 movzx	 eax, BYTE PTR [edx+82012]
  0011f	03 c8		 add	 ecx, eax
  00121	0f b6 c9	 movzx	 ecx, cl
  00124	8a 91 00 00 00
	00		 mov	 dl, BYTE PTR ?g_SendByteMap@@3QBEB[ecx]
  0012a	88 55 d3	 mov	 BYTE PTR _cbMap$8[ebp], dl

; 984  : 	m_cbSendRound += 3;

  0012d	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00130	0f b6 88 5c 40
	01 00		 movzx	 ecx, BYTE PTR [eax+82012]
  00137	83 c1 03	 add	 ecx, 3
  0013a	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0013d	88 8a 5c 40 01
	00		 mov	 BYTE PTR [edx+82012], cl

; 854  : 		pcbDataBuffer[i] = MapSendByte(pcbDataBuffer[i]);

  00143	0f b7 45 e0	 movzx	 eax, WORD PTR _i$9[ebp]
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  0014a	8a 55 d3	 mov	 dl, BYTE PTR _cbMap$8[ebp]
  0014d	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 855  : 	}

  00150	eb 86		 jmp	 SHORT $LN2@EncryptBuf
$LN3@EncryptBuf:

; 856  : 
; 857  : 	//填写信息头
; 858  : 	TCP_Head * pHead = (TCP_Head *)pcbDataBuffer;

  00152	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  00155	89 45 c4	 mov	 DWORD PTR _pHead$[ebp], eax

; 859  : 	pHead->TCPInfo.cbCheckCode = ~cbCheckCode + 1;

  00158	0f b6 4d e7	 movzx	 ecx, BYTE PTR _cbCheckCode$[ebp]
  0015c	f7 d1		 not	 ecx
  0015e	83 c1 01	 add	 ecx, 1
  00161	8b 55 c4	 mov	 edx, DWORD PTR _pHead$[ebp]
  00164	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 860  : 	pHead->TCPInfo.wPacketSize = wDataSize;

  00167	8b 45 c4	 mov	 eax, DWORD PTR _pHead$[ebp]
  0016a	66 8b 4d 0c	 mov	 cx, WORD PTR _wDataSize$[ebp]
  0016e	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 861  : 	pHead->TCPInfo.cbDataKind = DK_MAPPED;

  00172	8b 55 c4	 mov	 edx, DWORD PTR _pHead$[ebp]
  00175	c6 02 01	 mov	 BYTE PTR [edx], 1

; 862  : 
; 863  : 	//创建密钥
; 864  : 	DWORD dwXorKey = m_dwSendXorKey;

  00178	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 88 60 40 01
	00		 mov	 ecx, DWORD PTR [eax+82016]
  00181	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 865  : 	if (m_dwSendPacketCount == 0)

  00184	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00187	83 ba 54 40 01
	00 00		 cmp	 DWORD PTR [edx+82004], 0
  0018e	0f 85 b8 00 00
	00		 jne	 $LN9@EncryptBuf

; 866  : 	{
; 867  : 		//生成第一次随机种子
; 868  : 		GUID Guid;
; 869  : 		CoCreateGuid(&Guid);

  00194	8d 45 ec	 lea	 eax, DWORD PTR _Guid$10[ebp]
  00197	50		 push	 eax
  00198	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateGuid@4

; 870  : 		dwXorKey = GetTickCount()*GetTickCount();

  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001a4	8b f0		 mov	 esi, eax
  001a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001ac	0f af f0	 imul	 esi, eax
  001af	89 75 e8	 mov	 DWORD PTR _dwXorKey$[ebp], esi

; 871  : 		dwXorKey ^= Guid.Data1;

  001b2	8b 4d e8	 mov	 ecx, DWORD PTR _dwXorKey$[ebp]
  001b5	33 4d ec	 xor	 ecx, DWORD PTR _Guid$10[ebp]
  001b8	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 872  : 		dwXorKey ^= Guid.Data2;

  001bb	0f b7 55 f0	 movzx	 edx, WORD PTR _Guid$10[ebp+4]
  001bf	33 55 e8	 xor	 edx, DWORD PTR _dwXorKey$[ebp]
  001c2	89 55 e8	 mov	 DWORD PTR _dwXorKey$[ebp], edx

; 873  : 		dwXorKey ^= Guid.Data3;

  001c5	0f b7 45 f2	 movzx	 eax, WORD PTR _Guid$10[ebp+6]
  001c9	33 45 e8	 xor	 eax, DWORD PTR _dwXorKey$[ebp]
  001cc	89 45 e8	 mov	 DWORD PTR _dwXorKey$[ebp], eax

; 874  : 		dwXorKey ^= *((DWORD *)Guid.Data4);

  001cf	8b 4d e8	 mov	 ecx, DWORD PTR _dwXorKey$[ebp]
  001d2	33 4d f4	 xor	 ecx, DWORD PTR _Guid$10[ebp+8]
  001d5	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 976  :     DWORD dwHold = wSeed;

  001d8	0f b7 55 e8	 movzx	 edx, WORD PTR _dwXorKey$[ebp]
  001dc	89 55 b4	 mov	 DWORD PTR _dwHold$5[ebp], edx

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  001df	69 45 b4 cf ad
	03 00		 imul	 eax, DWORD PTR _dwHold$5[ebp], 241103
  001e6	05 ed a6 26 00	 add	 eax, 2533101		; 0026a6edH
  001eb	89 45 b4	 mov	 DWORD PTR _dwHold$5[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR _dwHold$5[ebp]
  001f1	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 875  : 
; 876  : 		//随机映射种子
; 877  : 		dwXorKey = SeedRandMap((WORD)dwXorKey);

  001f4	0f b7 d1	 movzx	 edx, cx
  001f7	89 55 e8	 mov	 DWORD PTR _dwXorKey$[ebp], edx

; 878  : 		dwXorKey |= ((DWORD)SeedRandMap((WORD)(dwXorKey >> 16))) << 16;

  001fa	8b 45 e8	 mov	 eax, DWORD PTR _dwXorKey$[ebp]
  001fd	c1 e8 10	 shr	 eax, 16			; 00000010H

; 976  :     DWORD dwHold = wSeed;

  00200	0f b7 c8	 movzx	 ecx, ax
  00203	89 4d b0	 mov	 DWORD PTR _dwHold$4[ebp], ecx

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  00206	69 55 b0 cf ad
	03 00		 imul	 edx, DWORD PTR _dwHold$4[ebp], 241103
  0020d	81 c2 ed a6 26
	00		 add	 edx, 2533101		; 0026a6edH
  00213	89 55 b0	 mov	 DWORD PTR _dwHold$4[ebp], edx
  00216	8b 45 b0	 mov	 eax, DWORD PTR _dwHold$4[ebp]
  00219	c1 e8 10	 shr	 eax, 16			; 00000010H

; 878  : 		dwXorKey |= ((DWORD)SeedRandMap((WORD)(dwXorKey >> 16))) << 16;

  0021c	0f b7 c8	 movzx	 ecx, ax
  0021f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00222	0b 4d e8	 or	 ecx, DWORD PTR _dwXorKey$[ebp]
  00225	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 879  : 		dwXorKey ^= g_dwPacketKey;

  00228	8b 55 e8	 mov	 edx, DWORD PTR _dwXorKey$[ebp]
  0022b	81 f2 5a a5 5a
	a5		 xor	 edx, -1520786086	; a55aa55aH
  00231	89 55 e8	 mov	 DWORD PTR _dwXorKey$[ebp], edx

; 880  : 		m_dwSendXorKey = dwXorKey;

  00234	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00237	8b 4d e8	 mov	 ecx, DWORD PTR _dwXorKey$[ebp]
  0023a	89 88 60 40 01
	00		 mov	 DWORD PTR [eax+82016], ecx

; 881  : 		m_dwRecvXorKey = dwXorKey;

  00240	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00243	8b 45 e8	 mov	 eax, DWORD PTR _dwXorKey$[ebp]
  00246	89 82 64 40 01
	00		 mov	 DWORD PTR [edx+82020], eax
$LN9@EncryptBuf:

; 882  : 	}
; 883  : 
; 884  : 	//加密数据
; 885  : 	WORD * pwSeed = (WORD *)(pcbDataBuffer + sizeof(TCP_Info));

  0024c	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  0024f	83 c1 04	 add	 ecx, 4
  00252	89 4d c8	 mov	 DWORD PTR _pwSeed$[ebp], ecx

; 886  : 	DWORD * pdwXor = (DWORD *)(pcbDataBuffer + sizeof(TCP_Info));

  00255	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00258	83 c2 04	 add	 edx, 4
  0025b	89 55 c0	 mov	 DWORD PTR _pdwXor$[ebp], edx

; 887  : 	WORD wEncrypCount = (wEncryptSize + wSnapCount) / sizeof(DWORD);

  0025e	0f b7 45 d8	 movzx	 eax, WORD PTR _wEncryptSize$[ebp]
  00262	0f b7 4d cc	 movzx	 ecx, WORD PTR _wSnapCount$[ebp]
  00266	03 c1		 add	 eax, ecx
  00268	c1 e8 02	 shr	 eax, 2
  0026b	66 89 45 bc	 mov	 WORD PTR _wEncrypCount$[ebp], ax

; 888  : 	for (int i = 0; i < wEncrypCount; i++)

  0026f	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 0
  00276	eb 09		 jmp	 SHORT $LN7@EncryptBuf
$LN5@EncryptBuf:
  00278	8b 55 ac	 mov	 edx, DWORD PTR _i$3[ebp]
  0027b	83 c2 01	 add	 edx, 1
  0027e	89 55 ac	 mov	 DWORD PTR _i$3[ebp], edx
$LN7@EncryptBuf:
  00281	0f b7 45 bc	 movzx	 eax, WORD PTR _wEncrypCount$[ebp]
  00285	39 45 ac	 cmp	 DWORD PTR _i$3[ebp], eax
  00288	0f 8d 98 00 00
	00		 jge	 $LN6@EncryptBuf

; 889  : 	{
; 890  : 		*pdwXor++ ^= dwXorKey;

  0028e	8b 4d c0	 mov	 ecx, DWORD PTR _pdwXor$[ebp]
  00291	8b 11		 mov	 edx, DWORD PTR [ecx]
  00293	33 55 e8	 xor	 edx, DWORD PTR _dwXorKey$[ebp]
  00296	8b 45 c0	 mov	 eax, DWORD PTR _pdwXor$[ebp]
  00299	89 10		 mov	 DWORD PTR [eax], edx
  0029b	8b 4d c0	 mov	 ecx, DWORD PTR _pdwXor$[ebp]
  0029e	83 c1 04	 add	 ecx, 4
  002a1	89 4d c0	 mov	 DWORD PTR _pdwXor$[ebp], ecx

; 891  : 		dwXorKey = SeedRandMap(*pwSeed++);

  002a4	8b 55 c8	 mov	 edx, DWORD PTR _pwSeed$[ebp]
  002a7	66 8b 02	 mov	 ax, WORD PTR [edx]
  002aa	66 89 45 ba	 mov	 WORD PTR $T7[ebp], ax

; 976  :     DWORD dwHold = wSeed;

  002ae	0f b7 4d ba	 movzx	 ecx, WORD PTR $T7[ebp]
  002b2	89 4d a8	 mov	 DWORD PTR _dwHold$2[ebp], ecx

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  002b5	69 55 a8 cf ad
	03 00		 imul	 edx, DWORD PTR _dwHold$2[ebp], 241103
  002bc	81 c2 ed a6 26
	00		 add	 edx, 2533101		; 0026a6edH
  002c2	89 55 a8	 mov	 DWORD PTR _dwHold$2[ebp], edx
  002c5	8b 45 a8	 mov	 eax, DWORD PTR _dwHold$2[ebp]
  002c8	c1 e8 10	 shr	 eax, 16			; 00000010H

; 891  : 		dwXorKey = SeedRandMap(*pwSeed++);

  002cb	0f b7 c8	 movzx	 ecx, ax
  002ce	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx
  002d1	8b 55 c8	 mov	 edx, DWORD PTR _pwSeed$[ebp]
  002d4	83 c2 02	 add	 edx, 2
  002d7	89 55 c8	 mov	 DWORD PTR _pwSeed$[ebp], edx

; 892  : 		dwXorKey |= ((DWORD)SeedRandMap(*pwSeed++)) << 16;

  002da	8b 45 c8	 mov	 eax, DWORD PTR _pwSeed$[ebp]
  002dd	66 8b 08	 mov	 cx, WORD PTR [eax]
  002e0	66 89 4d b8	 mov	 WORD PTR $T6[ebp], cx

; 976  :     DWORD dwHold = wSeed;

  002e4	0f b7 55 b8	 movzx	 edx, WORD PTR $T6[ebp]
  002e8	89 55 a4	 mov	 DWORD PTR _dwHold$1[ebp], edx

; 977  :     return (WORD)((dwHold = dwHold * 241103L + 2533101L) >> 16);

  002eb	69 45 a4 cf ad
	03 00		 imul	 eax, DWORD PTR _dwHold$1[ebp], 241103
  002f2	05 ed a6 26 00	 add	 eax, 2533101		; 0026a6edH
  002f7	89 45 a4	 mov	 DWORD PTR _dwHold$1[ebp], eax
  002fa	8b 4d a4	 mov	 ecx, DWORD PTR _dwHold$1[ebp]
  002fd	c1 e9 10	 shr	 ecx, 16			; 00000010H

; 892  : 		dwXorKey |= ((DWORD)SeedRandMap(*pwSeed++)) << 16;

  00300	0f b7 d1	 movzx	 edx, cx
  00303	c1 e2 10	 shl	 edx, 16			; 00000010H
  00306	0b 55 e8	 or	 edx, DWORD PTR _dwXorKey$[ebp]
  00309	89 55 e8	 mov	 DWORD PTR _dwXorKey$[ebp], edx
  0030c	8b 45 c8	 mov	 eax, DWORD PTR _pwSeed$[ebp]
  0030f	83 c0 02	 add	 eax, 2
  00312	89 45 c8	 mov	 DWORD PTR _pwSeed$[ebp], eax

; 893  : 		dwXorKey ^= g_dwPacketKey;

  00315	8b 4d e8	 mov	 ecx, DWORD PTR _dwXorKey$[ebp]
  00318	81 f1 5a a5 5a
	a5		 xor	 ecx, -1520786086	; a55aa55aH
  0031e	89 4d e8	 mov	 DWORD PTR _dwXorKey$[ebp], ecx

; 894  : 	}

  00321	e9 52 ff ff ff	 jmp	 $LN5@EncryptBuf
$LN6@EncryptBuf:

; 895  : 
; 896  : 	//插入密钥
; 897  : 	if (m_dwSendPacketCount == 0)

  00326	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00329	83 ba 54 40 01
	00 00		 cmp	 DWORD PTR [edx+82004], 0
  00330	75 46		 jne	 SHORT $LN10@EncryptBuf

; 898  : 	{
; 899  : 		MoveMemory(pcbDataBuffer + sizeof(TCP_Head) + sizeof(DWORD), pcbDataBuffer + sizeof(TCP_Head), wDataSize);

  00332	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00336	50		 push	 eax
  00337	8b 4d 08	 mov	 ecx, DWORD PTR _pcbDataBuffer$[ebp]
  0033a	83 c1 08	 add	 ecx, 8
  0033d	51		 push	 ecx
  0033e	8b 55 08	 mov	 edx, DWORD PTR _pcbDataBuffer$[ebp]
  00341	83 c2 0c	 add	 edx, 12			; 0000000cH
  00344	52		 push	 edx
  00345	e8 00 00 00 00	 call	 _memmove
  0034a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 900  : 		*((DWORD *)(pcbDataBuffer + sizeof(TCP_Head))) = m_dwSendXorKey;

  0034d	8b 45 08	 mov	 eax, DWORD PTR _pcbDataBuffer$[ebp]
  00350	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00353	8b 91 60 40 01
	00		 mov	 edx, DWORD PTR [ecx+82016]
  00359	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 901  : 		pHead->TCPInfo.wPacketSize += sizeof(DWORD);

  0035c	8b 45 c4	 mov	 eax, DWORD PTR _pHead$[ebp]
  0035f	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00363	83 c1 04	 add	 ecx, 4
  00366	8b 55 c4	 mov	 edx, DWORD PTR _pHead$[ebp]
  00369	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 902  : 		wDataSize += sizeof(DWORD);

  0036d	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00371	83 c0 04	 add	 eax, 4
  00374	66 89 45 0c	 mov	 WORD PTR _wDataSize$[ebp], ax
$LN10@EncryptBuf:

; 903  : 	}
; 904  : 
; 905  : 	//设置变量
; 906  : 	m_dwSendPacketCount++;

  00378	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	8b 91 54 40 01
	00		 mov	 edx, DWORD PTR [ecx+82004]
  00381	83 c2 01	 add	 edx, 1
  00384	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00387	89 90 54 40 01
	00		 mov	 DWORD PTR [eax+82004], edx

; 907  : 	m_dwSendXorKey = dwXorKey;

  0038d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00390	8b 55 e8	 mov	 edx, DWORD PTR _dwXorKey$[ebp]
  00393	89 91 60 40 01
	00		 mov	 DWORD PTR [ecx+82016], edx

; 908  : 
; 909  :     return wDataSize;

  00399	66 8b 45 0c	 mov	 ax, WORD PTR _wDataSize$[ebp]

; 910  : }

  0039d	5e		 pop	 esi
  0039e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003a1	33 cd		 xor	 ecx, ebp
  003a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a8	8b e5		 mov	 esp, ebp
  003aa	5d		 pop	 ebp
  003ab	c2 0c 00	 ret	 12			; 0000000cH
?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z ENDP	; CTCPNetworkItem::EncryptBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnCloseCompleted@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnCloseCompleted@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::OnCloseCompleted, COMDAT
; _this$ = ecx

; 819  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 820  :     // 效验状态
; 821  :     ASSERT(m_hSocketHandle == INVALID_SOCKET);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  0000e	74 14		 je	 SHORT $LN3@OnCloseCom
  00010	68 35 03 00 00	 push	 821			; 00000335H
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001f	85 c0		 test	 eax, eax
  00021	74 01		 je	 SHORT $LN3@OnCloseCom
  00023	cc		 int	 3
$LN3@OnCloseCom:

; 822  :     ASSERT((m_bSendIng == false) && (m_bRecvIng == false));

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  0002b	85 c0		 test	 eax, eax
  0002d	75 0b		 jne	 SHORT $LN4@OnCloseCom
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  00036	85 d2		 test	 edx, edx
  00038	74 14		 je	 SHORT $LN5@OnCloseCom
$LN4@OnCloseCom:
  0003a	68 36 03 00 00	 push	 822			; 00000336H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00044	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00049	85 c0		 test	 eax, eax
  0004b	74 01		 je	 SHORT $LN5@OnCloseCom
  0004d	cc		 int	 3
$LN5@OnCloseCom:

; 823  : 
; 824  :     // 关闭事件
; 825  :     m_pITCPNetworkItemSink->OnEventSocketShut(this);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8b 10		 mov	 edx, DWORD PTR [eax]
  0005d	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	ff d0		 call	 eax

; 826  : 
; 827  :     // 恢复数据
; 828  :     ResumeData();

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?ResumeData@CTCPNetworkItem@@QAEKXZ ; CTCPNetworkItem::ResumeData

; 829  : 
; 830  :     return true;

  0006d	b0 01		 mov	 al, 1

; 831  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?OnCloseCompleted@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::OnCloseCompleted
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z
_TEXT	SEGMENT
_handshakeBuffer$2 = -18104				; size = 24
_pszMessage$3 = -18080					; size = 4
_pData$4 = -18076					; size = 4
$T5 = -18072						; size = 4
$T6 = -18068						; size = 4
$T7 = -18064						; size = 4
$T8 = -18060						; size = 4
$T9 = -18056						; size = 4
_pos$10 = -18052					; size = 4
__Last1$ = -18048					; size = 4
_this$ = -18044						; size = 4
_nResultCode$ = -18040					; size = 4
_this$ = -18036						; size = 4
_Command$11 = -18032					; size = 4
_this$ = -18028						; size = 4
tv147 = -18024						; size = 4
_aa$12 = -18020						; size = 4
_wDataSize$13 = -18016					; size = 2
_wRealySize$14 = -18012					; size = 2
tv288 = -18008						; size = 2
$T15 = -18005						; size = 1
_recvChar$16 = -18004					; size = 4
$T17 = -17997						; size = 1
_pHead$18 = -17996					; size = 4
$T19 = -17989						; size = 1
$T20 = -17988						; size = 1
$T21 = -17987						; size = 1
$T22 = -17986						; size = 1
_success$23 = -17985					; size = 1
_wPacketSize$24 = -17984				; size = 2
_this$ = -17980						; size = 4
_data$25 = -17976					; size = 28
_cbBuffer$26 = -17948					; size = 16384
_szString$27 = -1564					; size = 512
_szBuffer$28 = -1052					; size = 512
_szString$29 = -540					; size = 512
_kDoubleCRLF$30 = -28					; size = 5
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pOverLappedRecv$ = 8					; size = 4
_dwThancferred$ = 12					; size = 4
?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z PROC ; CTCPNetworkItem::OnRecvCompleted, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 a8 46 00 00	 mov	 eax, 18088		; 000046a8H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	89 8d c4 b9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 643  :     // 效验数据
; 644  :     ASSERT(m_bRecvIng == true);

  0003c	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00042	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00046	83 f9 01	 cmp	 ecx, 1
  00049	74 14		 je	 SHORT $LN27@OnRecvComp
  0004b	68 84 02 00 00	 push	 644			; 00000284H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00055	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005a	85 c0		 test	 eax, eax
  0005c	74 01		 je	 SHORT $LN27@OnRecvComp
  0005e	cc		 int	 3
$LN27@OnRecvComp:

; 645  : 
; 646  :     // 设置变量
; 647  :     m_bRecvIng = false;

  0005f	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00065	c6 40 45 00	 mov	 BYTE PTR [eax+69], 0

; 648  : 
; 649  :     // 判断关闭
; 650  :     if (m_hSocketHandle == INVALID_SOCKET)

  00069	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 79 14 ff	 cmp	 DWORD PTR [ecx+20], -1
  00073	75 1d		 jne	 SHORT $LN6@OnRecvComp

; 651  :     {
; 652  :         CloseSocket(m_wRountID);

  00075	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0007b	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0007f	50		 push	 eax
  00080	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 653  :         return true;

  0008b	b0 01		 mov	 al, 1
  0008d	e9 bf 08 00 00	 jmp	 $LN26@OnRecvComp
$LN6@OnRecvComp:

; 654  :     }
; 655  : 
; 656  :     // 接收数据
; 657  :     INT nResultCode = recv(m_hSocketHandle, (char *)m_cbRecvBuf + m_wRecvSize, sizeof(m_cbRecvBuf) - m_wRecvSize, 0);

  00092	6a 00		 push	 0
  00094	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  0009e	b8 00 40 01 00	 mov	 eax, 81920		; 00014000H
  000a3	2b c2		 sub	 eax, edx
  000a5	50		 push	 eax
  000a6	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  000b0	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8d 4c 10 4c	 lea	 ecx, DWORD PTR [eax+edx+76]
  000ba	51		 push	 ecx
  000bb	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000c1	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000c4	50		 push	 eax
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recv@16
  000cb	89 85 88 b9 ff
	ff		 mov	 DWORD PTR _nResultCode$[ebp], eax

; 658  : 
; 659  :     // 关闭判断
; 660  :     if (nResultCode <= 0)

  000d1	83 bd 88 b9 ff
	ff 00		 cmp	 DWORD PTR _nResultCode$[ebp], 0
  000d8	7f 1d		 jg	 SHORT $LN7@OnRecvComp

; 661  :     {
; 662  :         CloseSocket(m_wRountID);

  000da	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000e4	52		 push	 edx
  000e5	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 663  :         return true;

  000f0	b0 01		 mov	 al, 1
  000f2	e9 5a 08 00 00	 jmp	 $LN26@OnRecvComp
$LN7@OnRecvComp:

; 664  :     }
; 665  : 
; 666  :     // 中断判断
; 667  :     if (m_bShutDown == true)

  000f7	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000fd	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  00101	83 f9 01	 cmp	 ecx, 1
  00104	75 07		 jne	 SHORT $LN8@OnRecvComp

; 668  :         return true;

  00106	b0 01		 mov	 al, 1
  00108	e9 44 08 00 00	 jmp	 $LN26@OnRecvComp
$LN8@OnRecvComp:

; 669  : 
; 670  :     // 设置变量
; 671  :     m_wRecvSize += nResultCode;

  0010d	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00113	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00117	03 85 88 b9 ff
	ff		 add	 eax, DWORD PTR _nResultCode$[ebp]
  0011d	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00123	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 672  :     m_wSurvivalTime = SAFETY_QUOTIETY;

  00127	ba 02 00 00 00	 mov	 edx, 2
  0012c	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00132	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 673  :     m_dwRecvTickCount = GetTickCount();

  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0013c	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00142	89 81 50 40 01
	00		 mov	 DWORD PTR [ecx+82000], eax

; 674  : 
; 675  : 	if (m_connectType == CHECKING) {

  00148	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0014e	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  00152	75 2f		 jne	 SHORT $LN9@OnRecvComp

; 676  : 		if (CheckIsWinSocket() == true) {

  00154	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ ; CTCPNetworkItem::CheckIsWinSocket
  0015f	0f b6 c0	 movzx	 eax, al
  00162	83 f8 01	 cmp	 eax, 1
  00165	75 0f		 jne	 SHORT $LN10@OnRecvComp

; 677  : 			m_connectType = WINSOCKET;

  00167	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	c7 41 40 02 00
	00 00		 mov	 DWORD PTR [ecx+64], 2

; 678  : 		}
; 679  : 		else {

  00174	eb 0d		 jmp	 SHORT $LN9@OnRecvComp
$LN10@OnRecvComp:

; 680  : 			m_connectType = HANDSHAKING;

  00176	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0017c	c7 42 40 01 00
	00 00		 mov	 DWORD PTR [edx+64], 1
$LN9@OnRecvComp:

; 681  : 		}
; 682  : 	}
; 683  : 
; 684  : 	switch (m_connectType) {

  00183	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00189	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0018c	89 8d 98 b9 ff
	ff		 mov	 DWORD PTR tv147[ebp], ecx
  00192	83 bd 98 b9 ff
	ff 01		 cmp	 DWORD PTR tv147[ebp], 1
  00199	74 1f		 je	 SHORT $LN12@OnRecvComp
  0019b	83 bd 98 b9 ff
	ff 02		 cmp	 DWORD PTR tv147[ebp], 2
  001a2	0f 84 5a 02 00
	00		 je	 $LN16@OnRecvComp
  001a8	83 bd 98 b9 ff
	ff 03		 cmp	 DWORD PTR tv147[ebp], 3
  001af	0f 84 65 07 00
	00		 je	 $LN24@OnRecvComp
  001b5	e9 97 07 00 00	 jmp	 $LN26@OnRecvComp
$LN12@OnRecvComp:

; 685  : 		case HANDSHAKING:{
; 686  : 			//try to handshake for websocket
; 687  : 			const char kDoubleCRLF[] = "\r\n\r\n";

  001ba	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ??_C@_04FMMHFHOO@?$AN?6?$AN?6@
  001c0	89 55 e4	 mov	 DWORD PTR _kDoubleCRLF$30[ebp], edx
  001c3	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04FMMHFHOO@?$AN?6?$AN?6@+4
  001c8	88 45 e8	 mov	 BYTE PTR _kDoubleCRLF$30[ebp+4], al

; 688  : 			char* recvChar = (char*)m_cbRecvBuf;

  001cb	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001d1	83 c1 4c	 add	 ecx, 76			; 0000004cH
  001d4	89 8d ac b9 ff
	ff		 mov	 DWORD PTR _recvChar$16[ebp], ecx

; 689  : 			const char* pos = std::search(recvChar, recvChar + m_wRecvSize, kDoubleCRLF, kDoubleCRLF + 4);

  001da	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001e0	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  001e4	03 85 ac b9 ff
	ff		 add	 eax, DWORD PTR _recvChar$16[ebp]
  001ea	89 85 80 b9 ff
	ff		 mov	 DWORD PTR __Last1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 988  : 	return (_STD search(_First1, _Last1, _First2, _Last2, equal_to<>()));

  001f0	0f b6 8d ab b9
	ff ff		 movzx	 ecx, BYTE PTR $T15[ebp]
  001f7	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 689  : 			const char* pos = std::search(recvChar, recvChar + m_wRecvSize, kDoubleCRLF, kDoubleCRLF + 4);

  001f8	8d 55 e8	 lea	 edx, DWORD PTR _kDoubleCRLF$30[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\algorithm

; 988  : 	return (_STD search(_First1, _Last1, _First2, _Last2, equal_to<>()));

  001fb	52		 push	 edx
  001fc	8d 45 e4	 lea	 eax, DWORD PTR _kDoubleCRLF$30[ebp]
  001ff	50		 push	 eax
  00200	8b 8d 80 b9 ff
	ff		 mov	 ecx, DWORD PTR __Last1$[ebp]
  00206	51		 push	 ecx
  00207	8b 95 ac b9 ff
	ff		 mov	 edx, DWORD PTR _recvChar$16[ebp]
  0020d	52		 push	 edx
  0020e	e8 00 00 00 00	 call	 ??$search@PADPBDU?$equal_to@X@std@@@std@@YAPADPADQADQBD2U?$equal_to@X@0@@Z ; std::search<char *,char const *,std::equal_to<void> >
  00213	83 c4 14	 add	 esp, 20			; 00000014H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 689  : 			const char* pos = std::search(recvChar, recvChar + m_wRecvSize, kDoubleCRLF, kDoubleCRLF + 4);

  00216	89 85 7c b9 ff
	ff		 mov	 DWORD PTR _pos$10[ebp], eax

; 690  : 
; 691  : 			if (pos == recvChar + m_wRecvSize) {

  0021c	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00222	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00226	03 8d ac b9 ff
	ff		 add	 ecx, DWORD PTR _recvChar$16[ebp]
  0022c	39 8d 7c b9 ff
	ff		 cmp	 DWORD PTR _pos$10[ebp], ecx
  00232	75 6b		 jne	 SHORT $LN13@OnRecvComp

; 692  : 				std::string data((char*)m_cbRecvBuf, m_wRecvSize);

  00234	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0023a	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  0023e	50		 push	 eax
  0023f	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00245	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00248	51		 push	 ecx
  00249	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _data$25[ebp]
  0024f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00254	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 694  : 				return RecvData();

  0025b	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00261	e8 00 00 00 00	 call	 ?RecvData@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::RecvData
  00266	88 85 b3 b9 ff
	ff		 mov	 BYTE PTR $T17[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  0026c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 2460 : 		_Tidy_deallocate();

  00273	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _data$25[ebp]
  00279	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0027e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1949 : 		_Free_proxy();

  00282	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _data$25[ebp]
  00288	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0028d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 694  : 				return RecvData();

  00294	8a 85 b3 b9 ff
	ff		 mov	 al, BYTE PTR $T17[ebp]
  0029a	e9 b2 06 00 00	 jmp	 $LN26@OnRecvComp
$LN13@OnRecvComp:

; 695  : 			}
; 696  : 			//std::string data((char*)m_cbRecvBuf, m_wRecvSize);
; 697  : 			//LOG_PRINT("handshake request:\n%s", data.c_str());
; 698  : 			zl::net::ByteBuffer handshakeBuffer;

  0029f	8d 8d 48 b9 ff
	ff		 lea	 ecx, DWORD PTR _handshakeBuffer$2[ebp]
  002a5	e8 00 00 00 00	 call	 ??0ByteBuffer@net@zl@@QAE@XZ ; zl::net::ByteBuffer::ByteBuffer
  002aa	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 699  : 			handshakeBuffer.write(recvChar, m_wRecvSize);

  002b1	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002b7	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  002bb	50		 push	 eax
  002bc	8b 8d ac b9 ff
	ff		 mov	 ecx, DWORD PTR _recvChar$16[ebp]
  002c2	51		 push	 ecx
  002c3	8d 8d 48 b9 ff
	ff		 lea	 ecx, DWORD PTR _handshakeBuffer$2[ebp]
  002c9	e8 00 00 00 00	 call	 ?write@ByteBuffer@net@zl@@QAEXPBDI@Z ; zl::net::ByteBuffer::write

; 700  : 			bool success = handshake(&handshakeBuffer);

  002ce	8d 95 48 b9 ff
	ff		 lea	 edx, DWORD PTR _handshakeBuffer$2[ebp]
  002d4	52		 push	 edx
  002d5	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002db	e8 00 00 00 00	 call	 ?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z ; CTCPNetworkItem::handshake
  002e0	88 85 bf b9 ff
	ff		 mov	 BYTE PTR _success$23[ebp], al

; 701  : 
; 702  : 			if (success == true) {

  002e6	0f b6 85 bf b9
	ff ff		 movzx	 eax, BYTE PTR _success$23[ebp]
  002ed	83 f8 01	 cmp	 eax, 1
  002f0	75 72		 jne	 SHORT $LN14@OnRecvComp

; 703  : 				m_connectType = WEBSOCKET;

  002f2	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002f8	c7 41 40 03 00
	00 00		 mov	 DWORD PTR [ecx+64], 3

; 704  : 				m_wRecvSize = 0;

  002ff	33 d2		 xor	 edx, edx
  00301	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00307	66 89 50 4a	 mov	 WORD PTR [eax+74], dx

; 705  : 				return RecvData();

  0030b	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00311	e8 00 00 00 00	 call	 ?RecvData@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::RecvData
  00316	88 85 be b9 ff
	ff		 mov	 BYTE PTR $T22[ebp], al
  0031c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00323	8d 8d 50 b9 ff
	ff		 lea	 ecx, DWORD PTR _handshakeBuffer$2[ebp+8]
  00329	89 8d 8c b9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 893  : 		{	// destroy the object

  0032f	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 894  : 		_Tidy();

  00336	8b 8d 8c b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0033c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 460  : 		{	// destroy proxy

  00341	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 461  : 		_Free_proxy();

  00345	8b 8d 8c b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0034b	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 895  : 		}

  00350	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 705  : 				return RecvData();

  00357	8a 85 be b9 ff
	ff		 mov	 al, BYTE PTR $T22[ebp]
  0035d	e9 ef 05 00 00	 jmp	 $LN26@OnRecvComp

; 706  : 			}
; 707  : 			else {

  00362	eb 63		 jmp	 SHORT $LN15@OnRecvComp
$LN14@OnRecvComp:

; 708  : 				CloseSocket(m_wRountID);

  00364	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0036a	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0036e	50		 push	 eax
  0036f	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00375	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 709  : 				return false;

  0037a	c6 85 bd b9 ff
	ff 00		 mov	 BYTE PTR $T21[ebp], 0
  00381	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00388	8d 8d 50 b9 ff
	ff		 lea	 ecx, DWORD PTR _handshakeBuffer$2[ebp+8]
  0038e	89 8d 84 b9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 893  : 		{	// destroy the object

  00394	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 6

; 894  : 		_Tidy();

  0039b	8b 8d 84 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a1	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 460  : 		{	// destroy proxy

  003a6	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+12], 7

; 461  : 		_Free_proxy();

  003aa	8b 8d 84 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b0	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 895  : 		}

  003b5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 709  : 				return false;

  003bc	8a 85 bd b9 ff
	ff		 mov	 al, BYTE PTR $T21[ebp]
  003c2	e9 8a 05 00 00	 jmp	 $LN26@OnRecvComp
$LN15@OnRecvComp:

; 710  : 			}
; 711  : 		}

  003c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003ce	8d 95 50 b9 ff
	ff		 lea	 edx, DWORD PTR _handshakeBuffer$2[ebp+8]
  003d4	89 95 94 b9 ff
	ff		 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 893  : 		{	// destroy the object

  003da	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 8

; 894  : 		_Tidy();

  003e1	8b 8d 94 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003e7	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 460  : 		{	// destroy proxy

  003ec	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+12], 9

; 461  : 		_Free_proxy();

  003f0	8b 8d 94 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003f6	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 895  : 		}

  003fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN16@OnRecvComp:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 715  : 			TCP_Head * pHead = (TCP_Head *)m_cbRecvBuf;

  00402	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00408	83 c0 4c	 add	 eax, 76			; 0000004cH
  0040b	89 85 b4 b9 ff
	ff		 mov	 DWORD PTR _pHead$18[ebp], eax

; 716  : 
; 717  : 			// 处理数据
; 718  : 			try

  00411	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 10 ; 0000000aH
$LN4@OnRecvComp:

; 719  : 			{
; 720  : 				while (m_wRecvSize >= sizeof(TCP_Head))

  00418	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0041e	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  00422	83 fa 08	 cmp	 edx, 8
  00425	0f 82 94 03 00
	00		 jb	 $LN5@OnRecvComp

; 721  : 				{
; 722  : 					// 效验数据
; 723  : 					WORD wPacketSize = pHead->TCPInfo.wPacketSize;

  0042b	8b 85 b4 b9 ff
	ff		 mov	 eax, DWORD PTR _pHead$18[ebp]
  00431	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  00435	66 89 8d c0 b9
	ff ff		 mov	 WORD PTR _wPacketSize$24[ebp], cx

; 724  : 
; 725  : 					// 数据判断
; 726  : 					if (wPacketSize > SOCKET_TCP_BUFFER)

  0043c	0f b7 95 c0 b9
	ff ff		 movzx	 edx, WORD PTR _wPacketSize$24[ebp]
  00443	81 fa 00 40 00
	00		 cmp	 edx, 16384		; 00004000H
  00449	7e 36		 jle	 SHORT $LN18@OnRecvComp

; 727  : 					{
; 728  : 						throw TEXT("");

  0044b	c7 85 78 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], OFFSET ??_C@_00CNPNBAHC@@
  00455	68 00 00 00 00	 push	 OFFSET __TI2PAD
  0045a	8d 85 78 b9 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00460	50		 push	 eax
  00461	e8 00 00 00 00	 call	 __CxxThrowException@8

; 729  : 						throw TEXT("数据包长度太长");

  00466	c7 85 74 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], OFFSET ??_C@_0P@IFKIJFDN@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LD?$KE@
  00470	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00475	8d 8d 74 b9 ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0047b	51		 push	 ecx
  0047c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN18@OnRecvComp:

; 730  : 					}
; 731  : 					if (wPacketSize < sizeof(TCP_Head))

  00481	0f b7 95 c0 b9
	ff ff		 movzx	 edx, WORD PTR _wPacketSize$24[ebp]
  00488	83 fa 08	 cmp	 edx, 8
  0048b	0f 83 4d 01 00
	00		 jae	 $LN19@OnRecvComp

; 732  : 					{
; 733  : 						throw TEXT("");

  00491	c7 85 70 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_C@_00CNPNBAHC@@
  0049b	68 00 00 00 00	 push	 OFFSET __TI2PAD
  004a0	8d 85 70 b9 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  004a6	50		 push	 eax
  004a7	e8 00 00 00 00	 call	 __CxxThrowException@8

; 734  : 						TCHAR szBuffer[512];
; 735  : 						_sntprintf(szBuffer, CountArray(szBuffer), TEXT("数据包长度太短 %d,%d,%d,%d,%d,%d,%d,%d"), m_cbRecvBuf[0],

  004ac	b9 01 00 00 00	 mov	 ecx, 1
  004b1	6b d1 07	 imul	 edx, ecx, 7
  004b4	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004ba	0f b6 4c 10 4c	 movzx	 ecx, BYTE PTR [eax+edx+76]
  004bf	51		 push	 ecx
  004c0	ba 01 00 00 00	 mov	 edx, 1
  004c5	6b c2 06	 imul	 eax, edx, 6
  004c8	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ce	0f b6 54 01 4c	 movzx	 edx, BYTE PTR [ecx+eax+76]
  004d3	52		 push	 edx
  004d4	b8 01 00 00 00	 mov	 eax, 1
  004d9	6b c8 05	 imul	 ecx, eax, 5
  004dc	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004e2	0f b6 44 0a 4c	 movzx	 eax, BYTE PTR [edx+ecx+76]
  004e7	50		 push	 eax
  004e8	b9 01 00 00 00	 mov	 ecx, 1
  004ed	c1 e1 02	 shl	 ecx, 2
  004f0	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004f6	0f b6 44 0a 4c	 movzx	 eax, BYTE PTR [edx+ecx+76]
  004fb	50		 push	 eax
  004fc	b9 01 00 00 00	 mov	 ecx, 1
  00501	6b d1 03	 imul	 edx, ecx, 3
  00504	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0050a	0f b6 4c 10 4c	 movzx	 ecx, BYTE PTR [eax+edx+76]
  0050f	51		 push	 ecx
  00510	ba 01 00 00 00	 mov	 edx, 1
  00515	d1 e2		 shl	 edx, 1
  00517	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0051d	0f b6 4c 10 4c	 movzx	 ecx, BYTE PTR [eax+edx+76]
  00522	51		 push	 ecx
  00523	ba 01 00 00 00	 mov	 edx, 1
  00528	c1 e2 00	 shl	 edx, 0
  0052b	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00531	0f b6 4c 10 4c	 movzx	 ecx, BYTE PTR [eax+edx+76]
  00536	51		 push	 ecx
  00537	ba 01 00 00 00	 mov	 edx, 1
  0053c	6b c2 00	 imul	 eax, edx, 0
  0053f	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00545	0f b6 54 01 4c	 movzx	 edx, BYTE PTR [ecx+eax+76]
  0054a	52		 push	 edx
  0054b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MKDFEHED@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L?5?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CFd?0?$CF@
  00550	68 00 02 00 00	 push	 512			; 00000200H
  00555	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _szBuffer$28[ebp]
  0055b	50		 push	 eax
  0055c	e8 00 00 00 00	 call	 __snprintf
  00561	83 c4 2c	 add	 esp, 44			; 0000002cH

; 736  : 							m_cbRecvBuf[1],
; 737  : 							m_cbRecvBuf[2],
; 738  : 							m_cbRecvBuf[3],
; 739  : 							m_cbRecvBuf[4],
; 740  : 							m_cbRecvBuf[5],
; 741  : 							m_cbRecvBuf[6],
; 742  : 							m_cbRecvBuf[7]
; 743  : 						);
; 744  : 						g_TraceServiceManager.TraceString(szBuffer, TraceLevel_Exception);

  00564	6a 03		 push	 3
  00566	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR _szBuffer$28[ebp]
  0056c	51		 push	 ecx
  0056d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00572	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 745  : 
; 746  : 						_sntprintf(szBuffer, CountArray(szBuffer), TEXT("包长 %d, 版本 %d, 效验码 %d"), pHead->TCPInfo.wPacketSize,

  00577	8b 95 b4 b9 ff
	ff		 mov	 edx, DWORD PTR _pHead$18[ebp]
  0057d	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  00581	50		 push	 eax
  00582	8b 8d b4 b9 ff
	ff		 mov	 ecx, DWORD PTR _pHead$18[ebp]
  00588	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0058b	52		 push	 edx
  0058c	8b 85 b4 b9 ff
	ff		 mov	 eax, DWORD PTR _pHead$18[ebp]
  00592	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00596	51		 push	 ecx
  00597	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@LPKEJNLP@?$LA?$PM?$LD?$KE?5?$CFd?0?5?$LA?f?$LB?$LO?5?$CFd?0?5?P?$KH?Q?i?B?k?5?$CFd@
  0059c	68 00 02 00 00	 push	 512			; 00000200H
  005a1	8d 95 e4 fb ff
	ff		 lea	 edx, DWORD PTR _szBuffer$28[ebp]
  005a7	52		 push	 edx
  005a8	e8 00 00 00 00	 call	 __snprintf
  005ad	83 c4 18	 add	 esp, 24			; 00000018H

; 747  : 							pHead->TCPInfo.cbDataKind, pHead->TCPInfo.cbCheckCode);
; 748  : 
; 749  : 						g_TraceServiceManager.TraceString(szBuffer, TraceLevel_Exception);

  005b0	6a 03		 push	 3
  005b2	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _szBuffer$28[ebp]
  005b8	50		 push	 eax
  005b9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  005be	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 750  : 						throw TEXT("数据包长度太短");

  005c3	c7 85 6c b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_C@_0P@COEHLGHJ@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KE?$LG?H?L?$KL?$LG?L@
  005cd	68 00 00 00 00	 push	 OFFSET __TI2PAD
  005d2	8d 8d 6c b9 ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  005d8	51		 push	 ecx
  005d9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN19@OnRecvComp:

; 751  : 					}
; 752  : 					if (pHead->TCPInfo.cbDataKind != DK_MAPPED && pHead->TCPInfo.cbDataKind != 0x05) {

  005de	8b 95 b4 b9 ff
	ff		 mov	 edx, DWORD PTR _pHead$18[ebp]
  005e4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  005e7	83 f8 01	 cmp	 eax, 1
  005ea	0f 84 81 00 00
	00		 je	 $LN20@OnRecvComp
  005f0	8b 8d b4 b9 ff
	ff		 mov	 ecx, DWORD PTR _pHead$18[ebp]
  005f6	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  005f9	83 fa 05	 cmp	 edx, 5
  005fc	74 73		 je	 SHORT $LN20@OnRecvComp

; 753  : 						CString aa;

  005fe	8d 8d 9c b9 ff
	ff		 lea	 ecx, DWORD PTR _aa$12[ebp]
  00604	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0060a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+12], 11 ; 0000000bH

; 754  : 						aa.Format(TEXT("0x%x"), pHead->TCPInfo.cbDataKind);

  0060e	8b 85 b4 b9 ff
	ff		 mov	 eax, DWORD PTR _pHead$18[ebp]
  00614	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00617	51		 push	 ecx
  00618	68 00 00 00 00	 push	 OFFSET ??_C@_04OPBHEPOC@0x?$CFx@
  0061d	8d 95 9c b9 ff
	ff		 lea	 edx, DWORD PTR _aa$12[ebp]
  00623	52		 push	 edx
  00624	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0062a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 755  : 						g_TraceServiceManager.TraceString(aa, TraceLevel_Exception);

  0062d	6a 03		 push	 3
  0062f	8d 8d 9c b9 ff
	ff		 lea	 ecx, DWORD PTR _aa$12[ebp]
  00635	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  0063b	50		 push	 eax
  0063c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00641	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 756  : 						throw TEXT("数据包版本不匹配");

  00646	c7 85 68 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_C@_0BB@HMAHCNOL@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
  00650	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00655	8d 85 68 b9 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0065b	50		 push	 eax
  0065c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 757  : 					}

  00661	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+12], 10 ; 0000000aH
  00665	8d 8d 9c b9 ff
	ff		 lea	 ecx, DWORD PTR _aa$12[ebp]
  0066b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN20@OnRecvComp:

; 758  : 					// 完成判断
; 759  : 					if (m_wRecvSize < wPacketSize) break;

  00671	0f b7 8d c0 b9
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$24[ebp]
  00678	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0067e	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00682	3b c1		 cmp	 eax, ecx
  00684	7d 05		 jge	 SHORT $LN21@OnRecvComp
  00686	e9 34 01 00 00	 jmp	 $LN5@OnRecvComp
$LN21@OnRecvComp:

; 760  : 
; 761  : 					// 提取数据
; 762  : 					CopyMemory(cbBuffer, m_cbRecvBuf, wPacketSize);

  0068b	0f b7 8d c0 b9
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$24[ebp]
  00692	51		 push	 ecx
  00693	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00699	83 c2 4c	 add	 edx, 76			; 0000004cH
  0069c	52		 push	 edx
  0069d	8d 85 e4 b9 ff
	ff		 lea	 eax, DWORD PTR _cbBuffer$26[ebp]
  006a3	50		 push	 eax
  006a4	e8 00 00 00 00	 call	 _memcpy
  006a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 763  : 					WORD wRealySize = CrevasseBuffer(cbBuffer, wPacketSize);

  006ac	0f b7 8d c0 b9
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$24[ebp]
  006b3	51		 push	 ecx
  006b4	8d 95 e4 b9 ff
	ff		 lea	 edx, DWORD PTR _cbBuffer$26[ebp]
  006ba	52		 push	 edx
  006bb	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006c1	e8 00 00 00 00	 call	 ?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z ; CTCPNetworkItem::CrevasseBuffer
  006c6	66 89 85 a8 b9
	ff ff		 mov	 WORD PTR tv288[ebp], ax
  006cd	66 8b 85 a8 b9
	ff ff		 mov	 ax, WORD PTR tv288[ebp]
  006d4	66 89 85 a4 b9
	ff ff		 mov	 WORD PTR _wRealySize$14[ebp], ax

; 764  : 
; 765  : 		            // 设置变量
; 766  : 		            m_dwRecvPacketCount++;

  006db	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006e1	8b 91 58 40 01
	00		 mov	 edx, DWORD PTR [ecx+82008]
  006e7	83 c2 01	 add	 edx, 1
  006ea	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006f0	89 90 58 40 01
	00		 mov	 DWORD PTR [eax+82008], edx

; 767  : 
; 768  : 		            // 解释数据
; 769  : 		            LPVOID pData = cbBuffer + sizeof(TCP_Head);

  006f6	8d 8d ec b9 ff
	ff		 lea	 ecx, DWORD PTR _cbBuffer$26[ebp+8]
  006fc	89 8d 64 b9 ff
	ff		 mov	 DWORD PTR _pData$4[ebp], ecx

; 770  : 		            WORD wDataSize = wRealySize - sizeof(TCP_Head);

  00702	0f b7 95 a4 b9
	ff ff		 movzx	 edx, WORD PTR _wRealySize$14[ebp]
  00709	83 ea 08	 sub	 edx, 8
  0070c	66 89 95 a0 b9
	ff ff		 mov	 WORD PTR _wDataSize$13[ebp], dx

; 771  : 		            TCP_Command Command = ((TCP_Head *)cbBuffer)->CommandInfo;

  00713	8b 85 e8 b9 ff
	ff		 mov	 eax, DWORD PTR _cbBuffer$26[ebp+4]
  00719	89 85 90 b9 ff
	ff		 mov	 DWORD PTR _Command$11[ebp], eax

; 772  : 
; 773  : 					// 消息处理
; 774  : 					if (Command.wMainCmdID != MDM_KN_COMMAND)	m_pITCPNetworkItemSink->OnEventSocketRead(Command, pData, wDataSize, this);

  0071f	0f b7 8d 90 b9
	ff ff		 movzx	 ecx, WORD PTR _Command$11[ebp]
  00726	85 c9		 test	 ecx, ecx
  00728	74 36		 je	 SHORT $LN22@OnRecvComp
  0072a	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00730	52		 push	 edx
  00731	0f b7 85 a0 b9
	ff ff		 movzx	 eax, WORD PTR _wDataSize$13[ebp]
  00738	50		 push	 eax
  00739	8b 8d 64 b9 ff
	ff		 mov	 ecx, DWORD PTR _pData$4[ebp]
  0073f	51		 push	 ecx
  00740	8b 95 90 b9 ff
	ff		 mov	 edx, DWORD PTR _Command$11[ebp]
  00746	52		 push	 edx
  00747	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0074d	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00753	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00756	8b 12		 mov	 edx, DWORD PTR [edx]
  00758	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0075b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0075e	ff d0		 call	 eax
$LN22@OnRecvComp:

; 775  : 
; 776  : 					// 删除缓冲
; 777  : 					m_wRecvSize -= wPacketSize;

  00760	0f b7 8d c0 b9
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$24[ebp]
  00767	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0076d	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00771	2b c1		 sub	 eax, ecx
  00773	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00779	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 778  : 					if (m_wRecvSize > 0) MoveMemory(m_cbRecvBuf, m_cbRecvBuf + wPacketSize, m_wRecvSize);

  0077d	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00783	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00787	85 c0		 test	 eax, eax
  00789	7e 2f		 jle	 SHORT $LN23@OnRecvComp
  0078b	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00791	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  00795	52		 push	 edx
  00796	0f b7 85 c0 b9
	ff ff		 movzx	 eax, WORD PTR _wPacketSize$24[ebp]
  0079d	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007a3	8d 54 01 4c	 lea	 edx, DWORD PTR [ecx+eax+76]
  007a7	52		 push	 edx
  007a8	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007ae	83 c0 4c	 add	 eax, 76			; 0000004cH
  007b1	50		 push	 eax
  007b2	e8 00 00 00 00	 call	 _memmove
  007b7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN23@OnRecvComp:

; 779  : 				}

  007ba	e9 59 fc ff ff	 jmp	 $LN4@OnRecvComp
$LN5@OnRecvComp:

; 780  : 			}

  007bf	e9 20 01 00 00	 jmp	 $LN28@OnRecvComp
__catch$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$0:

; 781  : 			catch (LPCTSTR pszMessage)
; 782  : 			{
; 783  : 				// 错误信息
; 784  : 				TCHAR szString[512] = TEXT("");

  007c4	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_00CNPNBAHC@@
  007ca	88 8d e4 fd ff
	ff		 mov	 BYTE PTR _szString$29[ebp], cl
  007d0	68 ff 01 00 00	 push	 511			; 000001ffH
  007d5	6a 00		 push	 0
  007d7	8d 95 e5 fd ff
	ff		 lea	 edx, DWORD PTR _szString$29[ebp+1]
  007dd	52		 push	 edx
  007de	e8 00 00 00 00	 call	 _memset
  007e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 785  : 				_sntprintf(szString, CountArray(szString), TEXT("SocketEngine Index=%ld，RountID=%ld，OnRecvCompleted 发生“%s”异常"), m_wIndex, m_wRountID, pszMessage);

  007e6	8b 85 60 b9 ff
	ff		 mov	 eax, DWORD PTR _pszMessage$3[ebp]
  007ec	50		 push	 eax
  007ed	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007f3	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  007f7	52		 push	 edx
  007f8	8b 85 c4 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007fe	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00802	51		 push	 ecx
  00803	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@ONNHHJGK@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@
  00808	68 00 02 00 00	 push	 512			; 00000200H
  0080d	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _szString$29[ebp]
  00813	52		 push	 edx
  00814	e8 00 00 00 00	 call	 __snprintf
  00819	83 c4 18	 add	 esp, 24			; 00000018H

; 786  : 				g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  0081c	6a 03		 push	 3
  0081e	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _szString$29[ebp]
  00824	50		 push	 eax
  00825	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0082a	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 787  : 
; 788  : 				// 关闭链接
; 789  : 				CloseSocket(m_wRountID);

  0082f	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00835	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00839	52		 push	 edx
  0083a	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00840	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 790  : 
; 791  : 				return false;

  00845	c6 85 bb b9 ff
	ff 00		 mov	 BYTE PTR $T19[ebp], 0
  0084c	b8 00 00 00 00	 mov	 eax, $LN35@OnRecvComp
  00851	c3		 ret	 0

; 792  : 			}

  00852	b8 00 00 00 00	 mov	 eax, $LN28@OnRecvComp
  00857	c3		 ret	 0
__catch$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$1:

; 793  : 			catch (...)
; 794  : 			{
; 795  : 				// 错误信息
; 796  : 				TCHAR szString[512] = TEXT("");

  00858	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0085d	88 85 e4 f9 ff
	ff		 mov	 BYTE PTR _szString$27[ebp], al
  00863	68 ff 01 00 00	 push	 511			; 000001ffH
  00868	6a 00		 push	 0
  0086a	8d 8d e5 f9 ff
	ff		 lea	 ecx, DWORD PTR _szString$27[ebp+1]
  00870	51		 push	 ecx
  00871	e8 00 00 00 00	 call	 _memset
  00876	83 c4 0c	 add	 esp, 12			; 0000000cH

; 797  : 				_sntprintf(szString, CountArray(szString), TEXT("SocketEngine Index=%ld，RountID=%ld，OnRecvCompleted 发生“非法”异常"), m_wIndex, m_wRountID);

  00879	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0087f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00883	50		 push	 eax
  00884	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0088a	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0088e	52		 push	 edx
  0088f	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@EEAELNCF@SocketEngine?5Index?$DN?$CFld?$KD?$KMRountID@
  00894	68 00 02 00 00	 push	 512			; 00000200H
  00899	8d 85 e4 f9 ff
	ff		 lea	 eax, DWORD PTR _szString$27[ebp]
  0089f	50		 push	 eax
  008a0	e8 00 00 00 00	 call	 __snprintf
  008a5	83 c4 14	 add	 esp, 20			; 00000014H

; 798  : 				g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  008a8	6a 03		 push	 3
  008aa	8d 8d e4 f9 ff
	ff		 lea	 ecx, DWORD PTR _szString$27[ebp]
  008b0	51		 push	 ecx
  008b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  008b6	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 799  : 
; 800  : 				// 关闭链接
; 801  : 				CloseSocket(m_wRountID);

  008bb	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008c1	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  008c5	50		 push	 eax
  008c6	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008cc	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 802  : 
; 803  : 				return false;

  008d1	c6 85 bc b9 ff
	ff 00		 mov	 BYTE PTR $T20[ebp], 0
  008d8	b8 00 00 00 00	 mov	 eax, $LN37@OnRecvComp
  008dd	c3		 ret	 0

; 804  : 			}

  008de	b8 00 00 00 00	 mov	 eax, $LN28@OnRecvComp
  008e3	c3		 ret	 0
$LN28@OnRecvComp:
  008e4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  008eb	eb 0f		 jmp	 SHORT $LN36@OnRecvComp
$LN37@OnRecvComp:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
  008ed	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 802  : 
; 803  : 				return false;

  008f4	8a 85 bc b9 ff
	ff		 mov	 al, BYTE PTR $T20[ebp]
  008fa	eb 55		 jmp	 SHORT $LN26@OnRecvComp
$LN36@OnRecvComp:
  008fc	eb 0f		 jmp	 SHORT $LN34@OnRecvComp
$LN35@OnRecvComp:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
  008fe	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 790  : 
; 791  : 				return false;

  00905	8a 85 bb b9 ff
	ff		 mov	 al, BYTE PTR $T19[ebp]
  0090b	eb 44		 jmp	 SHORT $LN26@OnRecvComp
$LN34@OnRecvComp:

; 805  : 			return RecvData();

  0090d	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00913	e8 00 00 00 00	 call	 ?RecvData@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::RecvData
  00918	eb 37		 jmp	 SHORT $LN26@OnRecvComp
$LN24@OnRecvComp:

; 806  : 		}
; 807  : 		case WEBSOCKET: {
; 808  : 			if (HandleWebsocketRecv() == false) {

  0091a	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00920	e8 00 00 00 00	 call	 ?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ ; CTCPNetworkItem::HandleWebsocketRecv
  00925	0f b6 c8	 movzx	 ecx, al
  00928	85 c9		 test	 ecx, ecx
  0092a	75 1a		 jne	 SHORT $LN25@OnRecvComp

; 809  : 				CloseSocket(m_wRountID);

  0092c	8b 95 c4 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00932	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00936	50		 push	 eax
  00937	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0093d	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 810  : 				return false;

  00942	32 c0		 xor	 al, al
  00944	eb 0b		 jmp	 SHORT $LN26@OnRecvComp
$LN25@OnRecvComp:

; 811  : 			}
; 812  : 			return RecvData();

  00946	8b 8d c4 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0094c	e8 00 00 00 00	 call	 ?RecvData@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::RecvData
$LN26@OnRecvComp:

; 813  : 		}
; 814  : 	}
; 815  : }

  00951	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00954	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0095b	59		 pop	 ecx
  0095c	5f		 pop	 edi
  0095d	5e		 pop	 esi
  0095e	5b		 pop	 ebx
  0095f	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00962	33 cd		 xor	 ecx, ebp
  00964	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00969	8b e5		 mov	 esp, ebp
  0096b	5d		 pop	 ebp
  0096c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$3:
  00000	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _data$25[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$4:
  0000b	8d 8d 48 b9 ff
	ff		 lea	 ecx, DWORD PTR _handshakeBuffer$2[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1ByteBuffer@net@zl@@QAE@XZ
__unwindfunclet$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z$5:
  00016	8d 8d 9c b9 ff
	ff		 lea	 ecx, DWORD PTR _aa$12[ebp]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z:
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 8a 44 b9 ff
	ff		 mov	 ecx, DWORD PTR [edx-18108]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRecvCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedRecv@@K@Z ENDP ; CTCPNetworkItem::OnRecvCompleted
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?OnSendCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedSend@@K@Z
_TEXT	SEGMENT
_nResultCode$1 = -32					; size = 4
_dwThancferred$2 = -28					; size = 4
$T3 = -24						; size = 4
_nIndex$4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_pOverLappedSend$ = 8					; size = 4
_dwThancferred$ = 12					; size = 4
?OnSendCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedSend@@K@Z PROC ; CTCPNetworkItem::OnSendCompleted, COMDAT
; _this$ = ecx

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 590  :     // 效验变量
; 591  :     ASSERT(m_bSendIng == true);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  00010	83 f9 01	 cmp	 ecx, 1
  00013	74 14		 je	 SHORT $LN7@OnSendComp
  00015	68 4f 02 00 00	 push	 591			; 0000024fH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00024	85 c0		 test	 eax, eax
  00026	74 01		 je	 SHORT $LN7@OnSendComp
  00028	cc		 int	 3
$LN7@OnSendComp:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 88 9c 40 01
	00		 mov	 ecx, DWORD PTR [eax+82076]
  00032	89 4d f4	 mov	 DWORD PTR $T6[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 592  :     ASSERT(m_OverLappedSendActive.GetCount() > 0);

  00035	83 7d f4 00	 cmp	 DWORD PTR $T6[ebp], 0
  00039	7f 14		 jg	 SHORT $LN8@OnSendComp
  0003b	68 50 02 00 00	 push	 592			; 00000250H
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00045	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0004a	85 c0		 test	 eax, eax
  0004c	74 01		 je	 SHORT $LN8@OnSendComp
  0004e	cc		 int	 3
$LN8@OnSendComp:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0004f	6a 00		 push	 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 593  :     ASSERT(pOverLappedSend == m_OverLappedSendActive[0]);

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0005a	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
  0005f	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 593  :     ASSERT(pOverLappedSend == m_OverLappedSendActive[0]);

  00062	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _pOverLappedSend$[ebp]
  00068	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006a	74 14		 je	 SHORT $LN9@OnSendComp
  0006c	68 51 02 00 00	 push	 593			; 00000251H
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00076	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0007b	85 c0		 test	 eax, eax
  0007d	74 01		 je	 SHORT $LN9@OnSendComp
  0007f	cc		 int	 3
$LN9@OnSendComp:

; 594  : 
; 595  :     // 释放结构
; 596  :     m_OverLappedSendActive.RemoveAt(0);

  00080	6a 01		 push	 1
  00082	6a 00		 push	 0
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  0008d	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAt

; 597  :     m_OverLappedSendBuffer.Add(pOverLappedSend);

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	05 c4 40 01 00	 add	 eax, 82116		; 000140c4H
  0009a	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a3	89 55 ec	 mov	 DWORD PTR _nIndex$4[ebp], edx

; 107  : 	SetAtGrow(nIndex,newElement);

  000a6	8d 45 08	 lea	 eax, DWORD PTR _pOverLappedSend$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d ec	 mov	 ecx, DWORD PTR _nIndex$4[ebp]
  000ad	51		 push	 ecx
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 600  :     m_bSendIng = false;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b9	c6 42 44 00	 mov	 BYTE PTR [edx+68], 0

; 601  : 
; 602  :     // 判断关闭
; 603  :     if (m_hSocketHandle == INVALID_SOCKET)

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  000c4	75 17		 jne	 SHORT $LN2@OnSendComp

; 604  :     {
; 605  :         CloseSocket(m_wRountID);

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000cd	52		 push	 edx
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 606  :         return true;

  000d6	b0 01		 mov	 al, 1
  000d8	e9 a7 00 00 00	 jmp	 $LN1@OnSendComp
$LN2@OnSendComp:

; 607  :     }
; 608  : 
; 609  :     // 设置变量
; 610  :     if (dwThancferred != 0)

  000dd	83 7d 0c 00	 cmp	 DWORD PTR _dwThancferred$[ebp], 0
  000e1	74 1b		 je	 SHORT $LN3@OnSendComp

; 611  :     {
; 612  :         m_wSurvivalTime = SAFETY_QUOTIETY;

  000e3	b8 02 00 00 00	 mov	 eax, 2
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 613  :         m_dwSendTickCount = GetTickCount();

  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000f5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f8	89 82 4c 40 01
	00		 mov	 DWORD PTR [edx+81996], eax
$LN3@OnSendComp:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00101	8b 88 9c 40 01
	00		 mov	 ecx, DWORD PTR [eax+82076]
  00107	89 4d e8	 mov	 DWORD PTR $T3[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 617  :     if (m_OverLappedSendActive.GetCount() > 0)

  0010a	83 7d e8 00	 cmp	 DWORD PTR $T3[ebp], 0
  0010e	7e 72		 jle	 SHORT $LN4@OnSendComp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00110	6a 00		 push	 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 620  :         pOverLappedSend = m_OverLappedSendActive[0];

  00112	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0011b	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 620  :         pOverLappedSend = m_OverLappedSendActive[0];

  00120	8b 10		 mov	 edx, DWORD PTR [eax]
  00122	89 55 08	 mov	 DWORD PTR _pOverLappedSend$[ebp], edx

; 621  : 
; 622  :         // 发送数据
; 623  :         DWORD dwThancferred = 0;

  00125	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwThancferred$2[ebp], 0

; 624  :         INT nResultCode = WSASend(m_hSocketHandle, &pOverLappedSend->m_WSABuffer, 1, &dwThancferred, 0, &pOverLappedSend->m_OverLapped, NULL);

  0012c	6a 00		 push	 0
  0012e	8b 45 08	 mov	 eax, DWORD PTR _pOverLappedSend$[ebp]
  00131	83 c0 0c	 add	 eax, 12			; 0000000cH
  00134	50		 push	 eax
  00135	6a 00		 push	 0
  00137	8d 4d e4	 lea	 ecx, DWORD PTR _dwThancferred$2[ebp]
  0013a	51		 push	 ecx
  0013b	6a 01		 push	 1
  0013d	8b 55 08	 mov	 edx, DWORD PTR _pOverLappedSend$[ebp]
  00140	83 c2 04	 add	 edx, 4
  00143	52		 push	 edx
  00144	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00147	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0014a	51		 push	 ecx
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  00151	89 45 e0	 mov	 DWORD PTR _nResultCode$1[ebp], eax

; 625  : 
; 626  :         // 结果处理
; 627  :         if ((nResultCode == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))

  00154	83 7d e0 ff	 cmp	 DWORD PTR _nResultCode$1[ebp], -1
  00158	75 21		 jne	 SHORT $LN5@OnSendComp
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00160	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00165	74 14		 je	 SHORT $LN5@OnSendComp

; 628  :         {
; 629  :             CloseSocket(m_wRountID);

  00167	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0016a	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0016e	50		 push	 eax
  0016f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 630  :             return false;

  00177	32 c0		 xor	 al, al
  00179	eb 09		 jmp	 SHORT $LN1@OnSendComp
$LN5@OnSendComp:

; 631  :         }
; 632  : 
; 633  :         // 设置变量
; 634  :         m_bSendIng = true;

  0017b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	c6 41 44 01	 mov	 BYTE PTR [ecx+68], 1
$LN4@OnSendComp:

; 635  :     }
; 636  : 
; 637  :     return true;

  00182	b0 01		 mov	 al, 1
$LN1@OnSendComp:

; 638  : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 08 00	 ret	 8
?OnSendCompleted@CTCPNetworkItem@@QAE_NPAVCOverLappedSend@@K@Z ENDP ; CTCPNetworkItem::OnSendCompleted
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?AllowBatchSend@CTCPNetworkItem@@QAE_NG_NE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wRountID$ = 8						; size = 2
_bAllowBatch$ = 12					; size = 1
_cbBatchMask$ = 16					; size = 1
?AllowBatchSend@CTCPNetworkItem@@QAE_NG_NE@Z PROC	; CTCPNetworkItem::AllowBatchSend, COMDAT
; _this$ = ecx

; 572  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 573  :     // 状态判断
; 574  :     if (m_wRountID != wRountID)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0000e	0f b7 55 08	 movzx	 edx, WORD PTR _wRountID$[ebp]
  00012	3b ca		 cmp	 ecx, edx
  00014	74 04		 je	 SHORT $LN2@AllowBatch

; 575  :         return false;

  00016	32 c0		 xor	 al, al
  00018	eb 21		 jmp	 SHORT $LN1@AllowBatch
$LN2@AllowBatch:

; 576  :     if (m_hSocketHandle == INVALID_SOCKET)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00021	75 04		 jne	 SHORT $LN3@AllowBatch

; 577  :         return false;

  00023	32 c0		 xor	 al, al
  00025	eb 14		 jmp	 SHORT $LN1@AllowBatch
$LN3@AllowBatch:

; 578  : 
; 579  :     // 设置变量
; 580  :     m_bAllowBatch = bAllowBatch;

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8a 55 0c	 mov	 dl, BYTE PTR _bAllowBatch$[ebp]
  0002d	88 51 47	 mov	 BYTE PTR [ecx+71], dl

; 581  : 
; 582  :     m_bBatchMask = cbBatchMask;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8a 4d 10	 mov	 cl, BYTE PTR _cbBatchMask$[ebp]
  00036	88 48 48	 mov	 BYTE PTR [eax+72], cl

; 583  : 
; 584  :     return true;

  00039	b0 01		 mov	 al, 1
$LN1@AllowBatch:

; 585  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 0c 00	 ret	 12			; 0000000cH
?AllowBatchSend@CTCPNetworkItem@@QAE_NG_NE@Z ENDP	; CTCPNetworkItem::AllowBatchSend
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?ShutDownSocket@CTCPNetworkItem@@QAE_NG@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_wRountID$ = 8						; size = 2
?ShutDownSocket@CTCPNetworkItem@@QAE_NG@Z PROC		; CTCPNetworkItem::ShutDownSocket, COMDAT
; _this$ = ecx

; 549  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 550  :     // 状态判断
; 551  :     if (m_hSocketHandle == INVALID_SOCKET)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00010	75 04		 jne	 SHORT $LN2@ShutDownSo

; 552  :         return false;

  00012	32 c0		 xor	 al, al
  00014	eb 6f		 jmp	 SHORT $LN1@ShutDownSo
$LN2@ShutDownSo:

; 553  :     if ((m_wRountID != wRountID) || (m_bShutDown == true))

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0001d	0f b7 45 08	 movzx	 eax, WORD PTR _wRountID$[ebp]
  00021	3b d0		 cmp	 edx, eax
  00023	75 0c		 jne	 SHORT $LN4@ShutDownSo
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	0f b6 51 46	 movzx	 edx, BYTE PTR [ecx+70]
  0002c	83 fa 01	 cmp	 edx, 1
  0002f	75 04		 jne	 SHORT $LN3@ShutDownSo
$LN4@ShutDownSo:

; 554  :         return false;

  00031	32 c0		 xor	 al, al
  00033	eb 50		 jmp	 SHORT $LN1@ShutDownSo
$LN3@ShutDownSo:

; 555  : 
; 556  : 	//设置变量
; 557  : 	if (m_bShutDown == false)

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  0003c	85 c9		 test	 ecx, ecx
  0003e	75 2f		 jne	 SHORT $LN5@ShutDownSo

; 558  : 	{
; 559  : 		m_wRecvSize = 0;

  00040	33 d2		 xor	 edx, edx
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	66 89 50 4a	 mov	 WORD PTR [eax+74], dx

; 560  : 		m_bShutDown = true;

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	c6 41 46 01	 mov	 BYTE PTR [ecx+70], 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00050	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 82 9c 40 01
	00		 mov	 eax, DWORD PTR [edx+82076]
  00059	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 561  : 		if (m_OverLappedSendActive.GetCount() == 0) CloseSocket(wRountID);

  0005c	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00060	75 0d		 jne	 SHORT $LN5@ShutDownSo
  00062	0f b7 4d 08	 movzx	 ecx, WORD PTR _wRountID$[ebp]
  00066	51		 push	 ecx
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket
$LN5@ShutDownSo:

; 562  : 	}
; 563  : 
; 564  :     // 发送命令
; 565  :     SendData(MDM_KN_COMMAND,SUB_KN_SHUT_DOWN_SOCKET,m_wRountID);

  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00076	50		 push	 eax
  00077	6a 03		 push	 3
  00079	6a 00		 push	 0
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?SendData@CTCPNetworkItem@@QAE_NGGG@Z ; CTCPNetworkItem::SendData

; 566  : 
; 567  :     return true;

  00083	b0 01		 mov	 al, 1
$LN1@ShutDownSo:

; 568  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?ShutDownSocket@CTCPNetworkItem@@QAE_NG@Z ENDP		; CTCPNetworkItem::ShutDownSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wRountID$ = 8						; size = 2
?CloseSocket@CTCPNetworkItem@@QAE_NG@Z PROC		; CTCPNetworkItem::CloseSocket, COMDAT
; _this$ = ecx

; 526  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 527  :     // 状态判断
; 528  :     if (m_wRountID != wRountID)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0000e	0f b7 55 08	 movzx	 edx, WORD PTR _wRountID$[ebp]
  00012	3b ca		 cmp	 ecx, edx
  00014	74 04		 je	 SHORT $LN2@CloseSocke

; 529  :         return false;

  00016	32 c0		 xor	 al, al
  00018	eb 40		 jmp	 SHORT $LN1@CloseSocke
$LN2@CloseSocke:

; 530  : 
; 531  :     // 关闭连接
; 532  :     if (m_hSocketHandle != INVALID_SOCKET)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00021	74 17		 je	 SHORT $LN3@CloseSocke

; 533  :     {
; 534  :         closesocket(m_hSocketHandle);

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 535  :         m_hSocketHandle = INVALID_SOCKET;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1
$LN3@CloseSocke:

; 536  :     }
; 537  : 
; 538  :     // 判断关闭
; 539  :     if ((m_bRecvIng == false) && (m_bSendIng == false))

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	0f b6 51 45	 movzx	 edx, BYTE PTR [ecx+69]
  00041	85 d2		 test	 edx, edx
  00043	75 13		 jne	 SHORT $LN4@CloseSocke
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	0f b6 48 44	 movzx	 ecx, BYTE PTR [eax+68]
  0004c	85 c9		 test	 ecx, ecx
  0004e	75 08		 jne	 SHORT $LN4@CloseSocke

; 540  :     {
; 541  :         OnCloseCompleted();

  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?OnCloseCompleted@CTCPNetworkItem@@QAE_NXZ ; CTCPNetworkItem::OnCloseCompleted
$LN4@CloseSocke:

; 542  :     }
; 543  : 
; 544  :     return true;

  00058	b0 01		 mov	 al, 1
$LN1@CloseSocke:

; 545  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ENDP		; CTCPNetworkItem::CloseSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?RecvData@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_nResultCode$ = -20					; size = 4
_dwThancferred$ = -16					; size = 4
_dwFlags$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?RecvData@CTCPNetworkItem@@QAE_NXZ PROC			; CTCPNetworkItem::RecvData, COMDAT
; _this$ = ecx

; 495  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 496  :     // 效验变量
; 497  :     ASSERT(m_bRecvIng == false);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 45	 movzx	 ecx, BYTE PTR [eax+69]
  00010	85 c9		 test	 ecx, ecx
  00012	74 14		 je	 SHORT $LN6@RecvData
  00014	68 f1 01 00 00	 push	 497			; 000001f1H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00023	85 c0		 test	 eax, eax
  00025	74 01		 je	 SHORT $LN6@RecvData
  00027	cc		 int	 3
$LN6@RecvData:

; 498  :     ASSERT(m_hSocketHandle != INVALID_SOCKET);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  0002f	75 14		 jne	 SHORT $LN7@RecvData
  00031	68 f2 01 00 00	 push	 498			; 000001f2H
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0003b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00040	85 c0		 test	 eax, eax
  00042	74 01		 je	 SHORT $LN7@RecvData
  00044	cc		 int	 3
$LN7@RecvData:

; 499  : 
; 500  : 	//判断关闭
; 501  : 	if (m_bShutDown == true)

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	0f b6 42 46	 movzx	 eax, BYTE PTR [edx+70]
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 26		 jne	 SHORT $LN2@RecvData
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 91 9c 40 01
	00		 mov	 edx, DWORD PTR [ecx+82076]
  0005a	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 503  : 		if (m_OverLappedSendActive.GetCount() == 0) CloseSocket(m_wRountID);

  0005d	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  00061	75 10		 jne	 SHORT $LN3@RecvData
  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0006a	51		 push	 ecx
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket
$LN3@RecvData:

; 504  : 		return false;

  00073	32 c0		 xor	 al, al
  00075	eb 6e		 jmp	 SHORT $LN1@RecvData
$LN2@RecvData:

; 505  : 	}
; 506  : 
; 507  :     // 接收数据
; 508  :     DWORD dwThancferred = 0, dwFlags = 0;

  00077	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwThancferred$[ebp], 0
  0007e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwFlags$[ebp], 0

; 509  :     INT nResultCode = WSARecv(m_hSocketHandle, &m_OverLappedRecv.m_WSABuffer, 1, &dwThancferred, &dwFlags, &m_OverLappedRecv.m_OverLapped, NULL);

  00085	6a 00		 push	 0
  00087	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	81 c2 74 40 01
	00		 add	 edx, 82036		; 00014074H
  00090	52		 push	 edx
  00091	8d 45 f4	 lea	 eax, DWORD PTR _dwFlags$[ebp]
  00094	50		 push	 eax
  00095	8d 4d f0	 lea	 ecx, DWORD PTR _dwThancferred$[ebp]
  00098	51		 push	 ecx
  00099	6a 01		 push	 1
  0009b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	81 c2 6c 40 01
	00		 add	 edx, 82028		; 0001406cH
  000a4	52		 push	 edx
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ab	51		 push	 ecx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
  000b2	89 45 ec	 mov	 DWORD PTR _nResultCode$[ebp], eax

; 510  : 
; 511  :     // 结果处理
; 512  :     if ((nResultCode == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))

  000b5	83 7d ec ff	 cmp	 DWORD PTR _nResultCode$[ebp], -1
  000b9	75 21		 jne	 SHORT $LN4@RecvData
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000c1	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000c6	74 14		 je	 SHORT $LN4@RecvData

; 513  :     {
; 514  :         CloseSocket(m_wRountID);

  000c8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000cb	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  000cf	50		 push	 eax
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 515  :         return false;

  000d8	32 c0		 xor	 al, al
  000da	eb 09		 jmp	 SHORT $LN1@RecvData
$LN4@RecvData:

; 516  :     }
; 517  : 
; 518  :     // 设置变量
; 519  :     m_bRecvIng = true;

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	c6 41 45 01	 mov	 BYTE PTR [ecx+69], 1

; 520  : 
; 521  :     return true;

  000e3	b0 01		 mov	 al, 1
$LN1@RecvData:

; 522  : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?RecvData@CTCPNetworkItem@@QAE_NXZ ENDP			; CTCPNetworkItem::RecvData
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z
_TEXT	SEGMENT
_pszMessage$2 = -18104					; size = 4
tv502 = -18100						; size = 4
$T3 = -18096						; size = 4
_message$4 = -18092					; size = 20
_dwThancferred$5 = -18072				; size = 4
tv553 = -18068						; size = 4
tv483 = -18064						; size = 4
tv484 = -18060						; size = 4
_nResultCode$6 = -18056					; size = 4
tv498 = -18052						; size = 4
tv554 = -18048						; size = 4
tv551 = -18044						; size = 4
_encodesize$7 = -18040					; size = 4
tv200 = -18036						; size = 4
$T8 = -18032						; size = 4
$T9 = -18028						; size = 4
$T10 = -18024						; size = 4
$T11 = -18020						; size = 4
tv549 = -18016						; size = 4
$T12 = -18012						; size = 4
_command$13 = -18008					; size = 4
_head$14 = -18004					; size = 4
tv79 = -18000						; size = 4
_pHead$15 = -17996					; size = 4
_info$16 = -17992					; size = 4
$T17 = -17985						; size = 1
_wEncryptLen$18 = -17984				; size = 2
tv556 = -17978						; size = 2
_sendData$19 = -17976					; size = 8
_buffsize$20 = -17968					; size = 4
_wPacketSize$21 = -17964				; size = 2
_wSourceLen$22 = -17960					; size = 2
$T23 = -17956						; size = 1
$T24 = -17955						; size = 1
tv552 = -17954						; size = 1
tv495 = -17953						; size = 1
_pOverLappedSend$25 = -17952				; size = 4
$T26 = -17945						; size = 1
_this$ = -17944						; size = 4
_cbSendData$27 = -17940					; size = 16384
_szString$28 = -1556					; size = 512
_szString$29 = -1044					; size = 512
_szString$30 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pData$ = 8						; size = 4
_wDataSize$ = 12					; size = 2
_wMainCmdID$ = 16					; size = 2
_wSubCmdID$ = 20					; size = 2
_wRountID$ = 24						; size = 2
?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z PROC		; CTCPNetworkItem::SendData, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 a8 46 00 00	 mov	 eax, 18088		; 000046a8H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	89 8d e8 b9 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0003c	c7 85 50 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0

; 375  :     // 效验参数
; 376  :     ASSERT(wDataSize <= SOCKET_TCP_PACKET);

  00046	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0004a	3d f8 3f 00 00	 cmp	 eax, 16376		; 00003ff8H
  0004f	76 14		 jbe	 SHORT $LN17@SendData
  00051	68 78 01 00 00	 push	 376			; 00000178H
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0005b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00060	85 c0		 test	 eax, eax
  00062	74 01		 je	 SHORT $LN17@SendData
  00064	cc		 int	 3
$LN17@SendData:

; 377  : 
; 378  :     // 发送判断
; 379  :     if (wDataSize > SOCKET_TCP_PACKET) return false;

  00065	0f b7 55 0c	 movzx	 edx, WORD PTR _wDataSize$[ebp]
  00069	81 fa f8 3f 00
	00		 cmp	 edx, 16376		; 00003ff8H
  0006f	76 07		 jbe	 SHORT $LN4@SendData
  00071	32 c0		 xor	 al, al
  00073	e9 9a 06 00 00	 jmp	 $LN16@SendData
$LN4@SendData:

; 999  :     if ((m_wRountID != wRountID) || (m_bShutDown == true))

  00078	0f b7 45 18	 movzx	 eax, WORD PTR _wRountID$[ebp]
  0007c	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00082	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00086	3b d0		 cmp	 edx, eax
  00088	75 0f		 jne	 SHORT $LN33@SendData
  0008a	8b 85 e8 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00090	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  00094	83 f9 01	 cmp	 ecx, 1
  00097	75 09		 jne	 SHORT $LN32@SendData
$LN33@SendData:

; 1000 :         return false;

  00099	c6 85 e7 b9 ff
	ff 00		 mov	 BYTE PTR $T26[ebp], 0
  000a0	eb 2b		 jmp	 SHORT $LN31@SendData
$LN32@SendData:

; 1001 :     if ((m_hSocketHandle == INVALID_SOCKET) || (m_dwRecvPacketCount == 0))

  000a2	8b 95 e8 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000a8	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  000ac	74 0f		 je	 SHORT $LN35@SendData
  000ae	8b 85 e8 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000b4	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  000bb	75 09		 jne	 SHORT $LN34@SendData
$LN35@SendData:

; 1002 :         return false;

  000bd	c6 85 e7 b9 ff
	ff 00		 mov	 BYTE PTR $T26[ebp], 0
  000c4	eb 07		 jmp	 SHORT $LN31@SendData
$LN34@SendData:

; 1003 : 
; 1004 :     return true;

  000c6	c6 85 e7 b9 ff
	ff 01		 mov	 BYTE PTR $T26[ebp], 1
$LN31@SendData:

; 380  :     if (SendVerdict(wRountID) == false) return false;

  000cd	0f b6 8d e7 b9
	ff ff		 movzx	 ecx, BYTE PTR $T26[ebp]
  000d4	85 c9		 test	 ecx, ecx
  000d6	75 07		 jne	 SHORT $LN5@SendData
  000d8	32 c0		 xor	 al, al
  000da	e9 33 06 00 00	 jmp	 $LN16@SendData
$LN5@SendData:

; 381  : 	try

  000df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 382  : 	{
; 383  : 		switch (m_connectType) {

  000e6	8b 95 e8 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000ec	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000ef	89 85 b0 b9 ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  000f5	83 bd b0 b9 ff
	ff 02		 cmp	 DWORD PTR tv79[ebp], 2
  000fc	0f 84 6f 03 00
	00		 je	 $LN11@SendData
  00102	83 bd b0 b9 ff
	ff 03		 cmp	 DWORD PTR tv79[ebp], 3
  00109	74 05		 je	 SHORT $LN7@SendData
  0010b	e9 30 05 00 00	 jmp	 $LN2@SendData
$LN7@SendData:

; 384  : 			case WEBSOCKET: {
; 385  : 				if (wDataSize == 0) {

  00110	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  00114	85 c9		 test	 ecx, ecx
  00116	0f 85 83 00 00
	00		 jne	 $LN8@SendData

; 386  : 					TCHAR szString[512] = TEXT("");

  0011c	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  00122	88 95 ec fb ff
	ff		 mov	 BYTE PTR _szString$29[ebp], dl
  00128	68 ff 01 00 00	 push	 511			; 000001ffH
  0012d	6a 00		 push	 0
  0012f	8d 85 ed fb ff
	ff		 lea	 eax, DWORD PTR _szString$29[ebp+1]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _memset
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 387  : 					_sntprintf(szString, CountArray(szString), TEXT("数据为空:wMainCmdID:%d,wSubCmdID:%d"), wMainCmdID, wSubCmdID);

  0013e	0f b7 4d 14	 movzx	 ecx, WORD PTR _wSubCmdID$[ebp]
  00142	51		 push	 ecx
  00143	0f b7 55 10	 movzx	 edx, WORD PTR _wMainCmdID$[ebp]
  00147	52		 push	 edx
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NEGGEINK@?J?$PN?$LO?$NN?N?$KK?$LP?U?3wMainCmdID?3?$CFd?0wSubCmdI@
  0014d	68 00 02 00 00	 push	 512			; 00000200H
  00152	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _szString$29[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 __snprintf
  0015e	83 c4 14	 add	 esp, 20			; 00000014H

; 388  : 					g_TraceServiceManager.TraceString(szString, TraceLevel_Normal);

  00161	6a 01		 push	 1
  00163	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szString$29[ebp]
  00169	51		 push	 ecx
  0016a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0016f	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 389  : 					return SendData(wMainCmdID, wSubCmdID, wRountID);

  00174	0f b7 55 18	 movzx	 edx, WORD PTR _wRountID$[ebp]
  00178	52		 push	 edx
  00179	0f b7 45 14	 movzx	 eax, WORD PTR _wSubCmdID$[ebp]
  0017d	50		 push	 eax
  0017e	0f b7 4d 10	 movzx	 ecx, WORD PTR _wMainCmdID$[ebp]
  00182	51		 push	 ecx
  00183	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00189	e8 00 00 00 00	 call	 ?SendData@CTCPNetworkItem@@QAE_NGGG@Z ; CTCPNetworkItem::SendData
  0018e	88 85 df b9 ff
	ff		 mov	 BYTE PTR tv495[ebp], al
  00194	8a 85 df b9 ff
	ff		 mov	 al, BYTE PTR tv495[ebp]
  0019a	e9 73 05 00 00	 jmp	 $LN16@SendData
$LN8@SendData:

; 390  : 				}
; 391  : 
; 392  : 				TCHAR szString[512] = TEXT("");

  0019f	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  001a5	88 95 ec fd ff
	ff		 mov	 BYTE PTR _szString$30[ebp], dl
  001ab	68 ff 01 00 00	 push	 511			; 000001ffH
  001b0	6a 00		 push	 0
  001b2	8d 85 ed fd ff
	ff		 lea	 eax, DWORD PTR _szString$30[ebp+1]
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 _memset
  001be	83 c4 0c	 add	 esp, 12			; 0000000cH

; 393  : 				_sntprintf(szString, CountArray(szString), TEXT("发送消息pData:wMainCmdID:%d,wSubCmdID:%d"), wMainCmdID, wSubCmdID);

  001c1	0f b7 4d 14	 movzx	 ecx, WORD PTR _wSubCmdID$[ebp]
  001c5	51		 push	 ecx
  001c6	0f b7 55 10	 movzx	 edx, WORD PTR _wMainCmdID$[ebp]
  001ca	52		 push	 edx
  001cb	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@PPIPIEAL@?$LH?$KC?K?M?O?$PL?O?$KCpData?3wMainCmdID?3?$CFd?0wSu@
  001d0	68 00 02 00 00	 push	 512			; 00000200H
  001d5	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szString$30[ebp]
  001db	50		 push	 eax
  001dc	e8 00 00 00 00	 call	 __snprintf
  001e1	83 c4 14	 add	 esp, 20			; 00000014H

; 394  : 				g_TraceServiceManager.TraceString(szString, TraceLevel_Normal);

  001e4	6a 01		 push	 1
  001e6	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szString$30[ebp]
  001ec	51		 push	 ecx
  001ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  001f2	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 395  : 				
; 396  : 				NullPmd::message message;

  001f7	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  001fd	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message
  00202	89 85 4c b9 ff
	ff		 mov	 DWORD PTR tv502[ebp], eax
  00208	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 397  : 				message.Clear();

  0020c	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00212	e8 00 00 00 00	 call	 ?Clear@message@NullPmd@@UAEXXZ ; NullPmd::message::Clear

; 398  : 				NullPmd::head* head = message.mutable_head();

  00217	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  0021d	e8 00 00 00 00	 call	 ?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ ; NullPmd::message::mutable_head
  00222	89 85 6c b9 ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  00228	8b 95 6c b9 ff
	ff		 mov	 edx, DWORD PTR tv553[ebp]
  0022e	89 95 ac b9 ff
	ff		 mov	 DWORD PTR _head$14[ebp], edx

; 399  : 				NullPmd::command* command = head->mutable_command();

  00234	8b 8d ac b9 ff
	ff		 mov	 ecx, DWORD PTR _head$14[ebp]
  0023a	e8 00 00 00 00	 call	 ?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ; NullPmd::head::mutable_command
  0023f	89 85 70 b9 ff
	ff		 mov	 DWORD PTR tv483[ebp], eax
  00245	8b 85 70 b9 ff
	ff		 mov	 eax, DWORD PTR tv483[ebp]
  0024b	89 85 a8 b9 ff
	ff		 mov	 DWORD PTR _command$13[ebp], eax

; 400  : 				NullPmd::info* info = head->mutable_info();

  00251	8b 8d ac b9 ff
	ff		 mov	 ecx, DWORD PTR _head$14[ebp]
  00257	e8 00 00 00 00	 call	 ?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ ; NullPmd::head::mutable_info
  0025c	89 85 7c b9 ff
	ff		 mov	 DWORD PTR tv498[ebp], eax
  00262	8b 8d 7c b9 ff
	ff		 mov	 ecx, DWORD PTR tv498[ebp]
  00268	89 8d b8 b9 ff
	ff		 mov	 DWORD PTR _info$16[ebp], ecx

; 401  : 
; 402  : 				command->set_mainid(wMainCmdID);

  0026e	0f b7 45 10	 movzx	 eax, WORD PTR _wMainCmdID$[ebp]
  00272	99		 cdq
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 799  :   mainid_ = value;

  00273	8b 8d a8 b9 ff
	ff		 mov	 ecx, DWORD PTR _command$13[ebp]
  00279	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0027c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 403  : 				command->set_subid(wSubCmdID);

  0027f	0f b7 45 14	 movzx	 eax, WORD PTR _wSubCmdID$[ebp]
  00283	99		 cdq
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 813  :   subid_ = value;

  00284	8b 8d a8 b9 ff
	ff		 mov	 ecx, DWORD PTR _command$13[ebp]
  0028a	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0028d	89 51 14	 mov	 DWORD PTR [ecx+20], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 404  : 				message.set_data((char*)pData);

  00290	8b 55 08	 mov	 edx, DWORD PTR _pData$[ebp]
  00293	52		 push	 edx
  00294	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  0029a	e8 00 00 00 00	 call	 ?set_data@message@NullPmd@@QAEXPBD@Z ; NullPmd::message::set_data
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 845  :   cbcheckcode_ = value;

  0029f	8b 85 b8 b9 ff
	ff		 mov	 eax, DWORD PTR _info$16[ebp]
  002a5	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1
  002ac	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 406  : 				info->set_wpacketsize(wDataSize);

  002b3	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  002b7	99		 cdq
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 859  :   wpacketsize_ = value;

  002b8	8b 8d b8 b9 ff
	ff		 mov	 ecx, DWORD PTR _info$16[ebp]
  002be	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  002c1	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 831  :   cbdatakind_ = value;

  002c4	8b 95 b8 b9 ff
	ff		 mov	 edx, DWORD PTR _info$16[ebp]
  002ca	c7 42 08 01 00
	00 00		 mov	 DWORD PTR [edx+8], 1
  002d1	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 409  : 				int buffsize = message.ByteSize();

  002d8	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  002de	e8 00 00 00 00	 call	 ?ByteSize@MessageLite@protobuf@google@@QBEHXZ ; google::protobuf::MessageLite::ByteSize
  002e3	89 85 74 b9 ff
	ff		 mov	 DWORD PTR tv484[ebp], eax
  002e9	8b 85 74 b9 ff
	ff		 mov	 eax, DWORD PTR tv484[ebp]
  002ef	89 85 d0 b9 ff
	ff		 mov	 DWORD PTR _buffsize$20[ebp], eax

; 410  : 				if (buffsize > SOCKET_TCP_PACKET) {

  002f5	81 bd d0 b9 ff
	ff f8 3f 00 00	 cmp	 DWORD PTR _buffsize$20[ebp], 16376 ; 00003ff8H
  002ff	76 1b		 jbe	 SHORT $LN9@SendData

; 411  : 					throw TEXT("发送包太大");

  00301	c7 85 a4 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp], OFFSET ??_C@_0L@JNDINJCC@?$LH?$KC?K?M?$LA?$PM?L?$KL?$LE?s@
  0030b	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00310	8d 8d a4 b9 ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00316	51		 push	 ecx
  00317	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN9@SendData:

; 413  : 				std::shared_ptr<char> sendData(new char[buffsize]);

  0031c	8b 95 d0 b9 ff
	ff		 mov	 edx, DWORD PTR _buffsize$20[ebp]
  00322	52		 push	 edx
  00323	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00328	83 c4 04	 add	 esp, 4
  0032b	89 85 a0 b9 ff
	ff		 mov	 DWORD PTR tv549[ebp], eax
  00331	8b 85 a0 b9 ff
	ff		 mov	 eax, DWORD PTR tv549[ebp]
  00337	89 85 9c b9 ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1157 : 	element_type * _Ptr{nullptr};

  0033d	c7 85 c8 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _sendData$19[ebp], 0

; 1158 : 	_Ref_count_base * _Rep{nullptr};

  00347	c7 85 cc b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _sendData$19[ebp+4], 0

; 1284 : 		_Setp(_Px, is_array<_Ty>{});

  00351	0f b6 8d bf b9
	ff ff		 movzx	 ecx, BYTE PTR $T17[ebp]
  00358	51		 push	 ecx
  00359	8b 95 9c b9 ff
	ff		 mov	 edx, DWORD PTR $T11[ebp]
  0035f	52		 push	 edx
  00360	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _sendData$19[ebp]
  00366	e8 00 00 00 00	 call	 ??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z ; std::shared_ptr<char>::_Setp<char>
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 413  : 				std::shared_ptr<char> sendData(new char[buffsize]);

  0036b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1059 : 		return (_Ptr);

  0036f	8b 85 c8 b9 ff
	ff		 mov	 eax, DWORD PTR _sendData$19[ebp]
  00375	89 85 98 b9 ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 414  : 				if (message.SerializeToArray(sendData.get(), buffsize) == false) {

  0037b	8b 8d d0 b9 ff
	ff		 mov	 ecx, DWORD PTR _buffsize$20[ebp]
  00381	51		 push	 ecx
  00382	8b 95 98 b9 ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  00388	52		 push	 edx
  00389	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  0038f	e8 00 00 00 00	 call	 ?SerializeToArray@MessageLite@protobuf@google@@QBE_NPAXH@Z ; google::protobuf::MessageLite::SerializeToArray
  00394	88 85 de b9 ff
	ff		 mov	 BYTE PTR tv552[ebp], al
  0039a	0f b6 85 de b9
	ff ff		 movzx	 eax, BYTE PTR tv552[ebp]
  003a1	85 c0		 test	 eax, eax
  003a3	75 1b		 jne	 SHORT $LN10@SendData

; 415  : 					throw TEXT("Serialize error");

  003a5	c7 85 94 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], OFFSET ??_C@_0BA@LDGEJDBI@Serialize?5error@
  003af	68 00 00 00 00	 push	 OFFSET __TI2PAD
  003b4	8d 8d 94 b9 ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  003ba	51		 push	 ecx
  003bb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1059 : 		return (_Ptr);

  003c0	8b 95 c8 b9 ff
	ff		 mov	 edx, DWORD PTR _sendData$19[ebp]
  003c6	89 95 90 b9 ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 419  : 				int encodesize = zl::net::ws::encodeFrame(zl::net::ws::WsFrameType::WS_BINARY_FRAME, sendData.get(), buffsize, cbSendData, SOCKET_TCP_BUFFER);

  003cc	68 00 40 00 00	 push	 16384			; 00004000H
  003d1	8d 85 ec b9 ff
	ff		 lea	 eax, DWORD PTR _cbSendData$27[ebp]
  003d7	50		 push	 eax
  003d8	8b 8d d0 b9 ff
	ff		 mov	 ecx, DWORD PTR _buffsize$20[ebp]
  003de	51		 push	 ecx
  003df	8b 95 90 b9 ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  003e5	52		 push	 edx
  003e6	68 82 00 00 00	 push	 130			; 00000082H
  003eb	e8 00 00 00 00	 call	 ?encodeFrame@ws@net@zl@@YAHW4WsFrameType@123@PBDHPADH@Z ; zl::net::ws::encodeFrame
  003f0	83 c4 14	 add	 esp, 20			; 00000014H
  003f3	89 85 8c b9 ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  003f9	8b 85 8c b9 ff
	ff		 mov	 eax, DWORD PTR tv200[ebp]
  003ff	89 85 88 b9 ff
	ff		 mov	 DWORD PTR _encodesize$7[ebp], eax

; 420  : 				
; 421  : 				SendRawData(cbSendData, encodesize);

  00405	8b 8d 88 b9 ff
	ff		 mov	 ecx, DWORD PTR _encodesize$7[ebp]
  0040b	51		 push	 ecx
  0040c	8d 95 ec b9 ff
	ff		 lea	 edx, DWORD PTR _cbSendData$27[ebp]
  00412	52		 push	 edx
  00413	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00419	e8 00 00 00 00	 call	 ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ; CTCPNetworkItem::SendRawData
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1402 : 		{	// release resource

  0041e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 1118 : 		if (_Rep)

  00422	83 bd cc b9 ff
	ff 00		 cmp	 DWORD PTR _sendData$19[ebp+4], 0
  00429	74 0b		 je	 SHORT $LN180@SendData

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  0042b	8b 8d cc b9 ff
	ff		 mov	 ecx, DWORD PTR _sendData$19[ebp+4]
  00431	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN180@SendData:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 422  : 				break;

  00436	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0043a	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00440	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
  00445	e9 f6 01 00 00	 jmp	 $LN2@SendData
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1402 : 		{	// release resource

  0044a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4

; 1118 : 		if (_Rep)

  0044e	83 bd cc b9 ff
	ff 00		 cmp	 DWORD PTR _sendData$19[ebp+4], 0
  00455	74 0b		 je	 SHORT $LN192@SendData

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  00457	8b 8d cc b9 ff
	ff		 mov	 ecx, DWORD PTR _sendData$19[ebp+4]
  0045d	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN192@SendData:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 423  : 			}

  00462	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00466	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  0046c	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
$LN11@SendData:

; 424  : 			case WINSOCKET: {
; 425  : 				// 获取缓冲
; 426  : 				WORD wPacketSize = sizeof(TCP_Head) + wDataSize;

  00471	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  00475	83 c0 08	 add	 eax, 8
  00478	66 89 85 d4 b9
	ff ff		 mov	 WORD PTR _wPacketSize$21[ebp], ax

; 427  : 				COverLappedSend * pOverLappedSend = GetSendOverLapped(wPacketSize);

  0047f	6a 01		 push	 1
  00481	0f b7 8d d4 b9
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$21[ebp]
  00488	51		 push	 ecx
  00489	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0048f	e8 00 00 00 00	 call	 ?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z ; CTCPNetworkItem::GetSendOverLapped
  00494	89 85 84 b9 ff
	ff		 mov	 DWORD PTR tv551[ebp], eax
  0049a	8b 95 84 b9 ff
	ff		 mov	 edx, DWORD PTR tv551[ebp]
  004a0	89 95 e0 b9 ff
	ff		 mov	 DWORD PTR _pOverLappedSend$25[ebp], edx

; 428  : 
; 429  : 				// 关闭判断
; 430  : 				if (pOverLappedSend == NULL)

  004a6	83 bd e0 b9 ff
	ff 00		 cmp	 DWORD PTR _pOverLappedSend$25[ebp], 0
  004ad	75 17		 jne	 SHORT $LN12@SendData

; 431  : 				{
; 432  : 					CloseSocket(wRountID);

  004af	0f b7 45 18	 movzx	 eax, WORD PTR _wRountID$[ebp]
  004b3	50		 push	 eax
  004b4	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ba	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 433  : 					return false;

  004bf	32 c0		 xor	 al, al
  004c1	e9 4c 02 00 00	 jmp	 $LN16@SendData
$LN12@SendData:

; 434  : 				}
; 435  : 
; 436  : 				// 变量定义
; 437  : 				WORD wSourceLen = (WORD)pOverLappedSend->m_WSABuffer.len;

  004c6	8b 8d e0 b9 ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$25[ebp]
  004cc	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  004d0	66 89 95 d8 b9
	ff ff		 mov	 WORD PTR _wSourceLen$22[ebp], dx

; 438  : 				TCP_Head * pHead = (TCP_Head *)(pOverLappedSend->m_cbBuffer + wSourceLen);

  004d7	0f b7 85 d8 b9
	ff ff		 movzx	 eax, WORD PTR _wSourceLen$22[ebp]
  004de	8b 8d e0 b9 ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$25[ebp]
  004e4	8d 54 01 24	 lea	 edx, DWORD PTR [ecx+eax+36]
  004e8	89 95 b4 b9 ff
	ff		 mov	 DWORD PTR _pHead$15[ebp], edx

; 439  : 
; 440  : 				// 设置变量
; 441  : 				pHead->CommandInfo.wSubCmdID = wSubCmdID;

  004ee	8b 85 b4 b9 ff
	ff		 mov	 eax, DWORD PTR _pHead$15[ebp]
  004f4	66 8b 4d 14	 mov	 cx, WORD PTR _wSubCmdID$[ebp]
  004f8	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 442  : 				pHead->CommandInfo.wMainCmdID = wMainCmdID;

  004fc	8b 95 b4 b9 ff
	ff		 mov	 edx, DWORD PTR _pHead$15[ebp]
  00502	66 8b 45 10	 mov	 ax, WORD PTR _wMainCmdID$[ebp]
  00506	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 443  : 
; 444  : 				// 附加数据
; 445  : 				if (wDataSize > 0)

  0050a	0f b7 4d 0c	 movzx	 ecx, WORD PTR _wDataSize$[ebp]
  0050e	85 c9		 test	 ecx, ecx
  00510	7e 40		 jle	 SHORT $LN13@SendData

; 446  : 				{
; 447  : 					ASSERT(pData != NULL);

  00512	83 7d 08 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00516	75 1f		 jne	 SHORT $LN18@SendData
  00518	68 bf 01 00 00	 push	 447			; 000001bfH
  0051d	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00522	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00527	89 85 80 b9 ff
	ff		 mov	 DWORD PTR tv554[ebp], eax
  0052d	83 bd 80 b9 ff
	ff 00		 cmp	 DWORD PTR tv554[ebp], 0
  00534	74 01		 je	 SHORT $LN18@SendData
  00536	cc		 int	 3
$LN18@SendData:

; 448  : 					CopyMemory(pHead + 1, pData, wDataSize);

  00537	0f b7 45 0c	 movzx	 eax, WORD PTR _wDataSize$[ebp]
  0053b	50		 push	 eax
  0053c	8b 4d 08	 mov	 ecx, DWORD PTR _pData$[ebp]
  0053f	51		 push	 ecx
  00540	8b 95 b4 b9 ff
	ff		 mov	 edx, DWORD PTR _pHead$15[ebp]
  00546	83 c2 08	 add	 edx, 8
  00549	52		 push	 edx
  0054a	e8 00 00 00 00	 call	 _memcpy
  0054f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@SendData:

; 449  : 				}
; 450  : 
; 451  : 				// 加密数据
; 452  : 				WORD wEncryptLen = EncryptBuffer(pOverLappedSend->m_cbBuffer + wSourceLen, wPacketSize, sizeof(pOverLappedSend->m_cbBuffer) - wSourceLen);

  00552	0f b7 85 d8 b9
	ff ff		 movzx	 eax, WORD PTR _wSourceLen$22[ebp]
  00559	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0055e	2b c8		 sub	 ecx, eax
  00560	51		 push	 ecx
  00561	0f b7 95 d4 b9
	ff ff		 movzx	 edx, WORD PTR _wPacketSize$21[ebp]
  00568	52		 push	 edx
  00569	0f b7 85 d8 b9
	ff ff		 movzx	 eax, WORD PTR _wSourceLen$22[ebp]
  00570	8b 8d e0 b9 ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$25[ebp]
  00576	8d 54 01 24	 lea	 edx, DWORD PTR [ecx+eax+36]
  0057a	52		 push	 edx
  0057b	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00581	e8 00 00 00 00	 call	 ?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z ; CTCPNetworkItem::EncryptBuffer
  00586	66 89 85 c6 b9
	ff ff		 mov	 WORD PTR tv556[ebp], ax
  0058d	66 8b 85 c6 b9
	ff ff		 mov	 ax, WORD PTR tv556[ebp]
  00594	66 89 85 c0 b9
	ff ff		 mov	 WORD PTR _wEncryptLen$18[ebp], ax

; 453  : 				pOverLappedSend->m_WSABuffer.len += wEncryptLen;

  0059b	0f b7 8d c0 b9
	ff ff		 movzx	 ecx, WORD PTR _wEncryptLen$18[ebp]
  005a2	8b 95 e0 b9 ff
	ff		 mov	 edx, DWORD PTR _pOverLappedSend$25[ebp]
  005a8	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  005ab	8b 85 e0 b9 ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$25[ebp]
  005b1	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 454  : 
; 455  : 				// 发送数据
; 456  : 				if (m_bSendIng == false)

  005b4	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005ba	0f b6 51 44	 movzx	 edx, BYTE PTR [ecx+68]
  005be	85 d2		 test	 edx, edx
  005c0	75 7e		 jne	 SHORT $LN2@SendData

; 457  : 				{
; 458  : 					// 发送数据
; 459  : 					DWORD dwThancferred = 0;

  005c2	c7 85 68 b9 ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwThancferred$5[ebp], 0

; 460  : 					INT nResultCode = WSASend(m_hSocketHandle, &pOverLappedSend->m_WSABuffer, 1, &dwThancferred, 0, &pOverLappedSend->m_OverLapped, NULL);

  005cc	6a 00		 push	 0
  005ce	8b 85 e0 b9 ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$25[ebp]
  005d4	83 c0 0c	 add	 eax, 12			; 0000000cH
  005d7	50		 push	 eax
  005d8	6a 00		 push	 0
  005da	8d 8d 68 b9 ff
	ff		 lea	 ecx, DWORD PTR _dwThancferred$5[ebp]
  005e0	51		 push	 ecx
  005e1	6a 01		 push	 1
  005e3	8b 95 e0 b9 ff
	ff		 mov	 edx, DWORD PTR _pOverLappedSend$25[ebp]
  005e9	83 c2 04	 add	 edx, 4
  005ec	52		 push	 edx
  005ed	8b 85 e8 b9 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005f3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  005f6	51		 push	 ecx
  005f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  005fd	89 85 78 b9 ff
	ff		 mov	 DWORD PTR _nResultCode$6[ebp], eax

; 461  : 
; 462  : 					// 结果处理
; 463  : 					if ((nResultCode == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))

  00603	83 bd 78 b9 ff
	ff ff		 cmp	 DWORD PTR _nResultCode$6[ebp], -1
  0060a	75 2a		 jne	 SHORT $LN15@SendData
  0060c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00612	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  00617	74 1d		 je	 SHORT $LN15@SendData

; 464  : 					{
; 465  : 						CloseSocket(m_wRountID);

  00619	8b 95 e8 b9 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0061f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00623	50		 push	 eax
  00624	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0062a	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 466  : 						return false;

  0062f	32 c0		 xor	 al, al
  00631	e9 dc 00 00 00	 jmp	 $LN16@SendData
$LN15@SendData:

; 467  : 					}
; 468  : 
; 469  : 					// 设置变量
; 470  : 					m_bSendIng = true;

  00636	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0063c	c6 41 44 01	 mov	 BYTE PTR [ecx+68], 1
$LN2@SendData:

; 471  : 				}
; 472  : 				break;
; 473  : 			}
; 474  : 		}
; 475  : 	}

  00640	e9 a2 00 00 00	 jmp	 $LN19@SendData
__catch$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$0:

; 476  : 	catch (LPCTSTR pszMessage) {
; 477  : 		// 错误信息
; 478  : 		TCHAR szString[512] = TEXT("");

  00645	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  0064b	88 95 ec f9 ff
	ff		 mov	 BYTE PTR _szString$28[ebp], dl
  00651	68 ff 01 00 00	 push	 511			; 000001ffH
  00656	6a 00		 push	 0
  00658	8d 85 ed f9 ff
	ff		 lea	 eax, DWORD PTR _szString$28[ebp+1]
  0065e	50		 push	 eax
  0065f	e8 00 00 00 00	 call	 _memset
  00664	83 c4 0c	 add	 esp, 12			; 0000000cH

; 479  : 		_sntprintf(szString, CountArray(szString), TEXT("SendData pData 异常:%s"), pszMessage);

  00667	8b 8d 48 b9 ff
	ff		 mov	 ecx, DWORD PTR _pszMessage$2[ebp]
  0066d	51		 push	 ecx
  0066e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@NLJMDLEL@SendData?5pData?5?R?l?$LD?$KD?3?$CFs@
  00673	68 00 02 00 00	 push	 512			; 00000200H
  00678	8d 95 ec f9 ff
	ff		 lea	 edx, DWORD PTR _szString$28[ebp]
  0067e	52		 push	 edx
  0067f	e8 00 00 00 00	 call	 __snprintf
  00684	83 c4 10	 add	 esp, 16			; 00000010H

; 480  : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00687	6a 03		 push	 3
  00689	8d 85 ec f9 ff
	ff		 lea	 eax, DWORD PTR _szString$28[ebp]
  0068f	50		 push	 eax
  00690	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00695	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 481  : 		return false;

  0069a	c6 85 dc b9 ff
	ff 00		 mov	 BYTE PTR $T23[ebp], 0
  006a1	b8 00 00 00 00	 mov	 eax, $LN25@SendData
  006a6	c3		 ret	 0

; 482  : 	}

  006a7	b8 00 00 00 00	 mov	 eax, $LN19@SendData
  006ac	c3		 ret	 0
__catch$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$1:

; 483  : 	catch (...)
; 484  : 	{
; 485  : 		g_TraceServiceManager.TraceString("SendData pData 异常", TraceLevel_Exception);

  006ad	6a 03		 push	 3
  006af	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BFBPJPAH@SendData?5pData?5?R?l?$LD?$KD@
  006b4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  006b9	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 486  : 		CloseSocket(m_wRountID);

  006be	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006c4	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  006c8	52		 push	 edx
  006c9	8b 8d e8 b9 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006cf	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 487  : 		return false;

  006d4	c6 85 dd b9 ff
	ff 00		 mov	 BYTE PTR $T24[ebp], 0
  006db	b8 00 00 00 00	 mov	 eax, $LN27@SendData
  006e0	c3		 ret	 0

; 488  : 	}

  006e1	b8 00 00 00 00	 mov	 eax, $LN19@SendData
  006e6	c3		 ret	 0
$LN19@SendData:
  006e7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  006ee	eb 0f		 jmp	 SHORT $LN26@SendData
$LN27@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
  006f0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 487  : 		return false;

  006f7	8a 85 dd b9 ff
	ff		 mov	 al, BYTE PTR $T24[ebp]
  006fd	eb 13		 jmp	 SHORT $LN16@SendData
$LN26@SendData:
  006ff	eb 0f		 jmp	 SHORT $LN24@SendData
$LN25@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
  00701	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 481  : 		return false;

  00708	8a 85 dc b9 ff
	ff		 mov	 al, BYTE PTR $T23[ebp]
  0070e	eb 02		 jmp	 SHORT $LN16@SendData
$LN24@SendData:

; 489  : 	
; 490  :     return true;

  00710	b0 01		 mov	 al, 1
$LN16@SendData:

; 491  : }

  00712	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00715	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0071c	59		 pop	 ecx
  0071d	5f		 pop	 edi
  0071e	5e		 pop	 esi
  0071f	5b		 pop	 ebx
  00720	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00723	33 cd		 xor	 ecx, ebp
  00725	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072a	8b e5		 mov	 esp, ebp
  0072c	5d		 pop	 ebp
  0072d	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$3:
  00000	8d 8d 54 b9 ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z$4:
  0000b	8d 8d c8 b9 ff
	ff		 lea	 ecx, DWORD PTR _sendData$19[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@D@std@@QAE@XZ ; std::shared_ptr<char>::~shared_ptr<char>
__ehhandler$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 44 b9 ff
	ff		 mov	 ecx, DWORD PTR [edx-18108]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CTCPNetworkItem@@QAE_NPAXGGGG@Z ENDP		; CTCPNetworkItem::SendData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendData@CTCPNetworkItem@@QAE_NGGG@Z
_TEXT	SEGMENT
_pszMessage$2 = -17080					; size = 4
tv145 = -17076						; size = 4
$T3 = -17072						; size = 4
_message$4 = -17068					; size = 20
tv397 = -17048						; size = 4
tv398 = -17044						; size = 4
tv386 = -17040						; size = 4
_nResultCode$5 = -17036					; size = 4
_dwThancferred$6 = -17032				; size = 4
tv390 = -17028						; size = 4
_encodesize$7 = -17024					; size = 4
tv393 = -17020						; size = 4
$T8 = -17016						; size = 4
$T9 = -17012						; size = 4
$T10 = -17008						; size = 4
$T11 = -17004						; size = 4
tv392 = -17000						; size = 4
$T12 = -16996						; size = 4
tv395 = -16992						; size = 4
_this$13 = -16988					; size = 4
_pHead$14 = -16984					; size = 4
_this$ = -16980						; size = 4
_command$15 = -16976					; size = 4
_head$16 = -16972					; size = 4
tv70 = -16968						; size = 4
_info$17 = -16964					; size = 4
_wEncryptLen$18 = -16960				; size = 2
tv382 = -16956						; size = 2
$T19 = -16953						; size = 1
_sendData$20 = -16952					; size = 8
_buffsize$21 = -16944					; size = 4
_wPacketSize$22 = -16940				; size = 2
_wSourceLen$23 = -16936					; size = 2
$T24 = -16931						; size = 1
$T25 = -16930						; size = 1
tv394 = -16929						; size = 1
_pOverLappedSend$26 = -16928				; size = 4
$T27 = -16921						; size = 1
_this$ = -16920						; size = 4
_cbSendData$28 = -16916					; size = 16384
_szString$29 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_wMainCmdID$ = 8					; size = 2
_wSubCmdID$ = 12					; size = 2
_wRountID$ = 16						; size = 2
?SendData@CTCPNetworkItem@@QAE_NGGG@Z PROC		; CTCPNetworkItem::SendData, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendData@CTCPNetworkItem@@QAE_NGGG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 a8 42 00 00	 mov	 eax, 17064		; 000042a8H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	89 8d e8 bd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0003c	c7 85 50 bd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], 0

; 999  :     if ((m_wRountID != wRountID) || (m_bShutDown == true))

  00046	0f b7 45 10	 movzx	 eax, WORD PTR _wRountID$[ebp]
  0004a	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00050	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00054	3b d0		 cmp	 edx, eax
  00056	75 0f		 jne	 SHORT $LN25@SendData
  00058	8b 85 e8 bd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0005e	0f b6 48 46	 movzx	 ecx, BYTE PTR [eax+70]
  00062	83 f9 01	 cmp	 ecx, 1
  00065	75 09		 jne	 SHORT $LN24@SendData
$LN25@SendData:

; 1000 :         return false;

  00067	c6 85 e7 bd ff
	ff 00		 mov	 BYTE PTR $T27[ebp], 0
  0006e	eb 2b		 jmp	 SHORT $LN23@SendData
$LN24@SendData:

; 1001 :     if ((m_hSocketHandle == INVALID_SOCKET) || (m_dwRecvPacketCount == 0))

  00070	8b 95 e8 bd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00076	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  0007a	74 0f		 je	 SHORT $LN27@SendData
  0007c	8b 85 e8 bd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  00089	75 09		 jne	 SHORT $LN26@SendData
$LN27@SendData:

; 1002 :         return false;

  0008b	c6 85 e7 bd ff
	ff 00		 mov	 BYTE PTR $T27[ebp], 0
  00092	eb 07		 jmp	 SHORT $LN23@SendData
$LN26@SendData:

; 1003 : 
; 1004 :     return true;

  00094	c6 85 e7 bd ff
	ff 01		 mov	 BYTE PTR $T27[ebp], 1
$LN23@SendData:

; 277  :     // 发送判断
; 278  :     if (SendVerdict(wRountID) == false) return false;

  0009b	0f b6 8d e7 bd
	ff ff		 movzx	 ecx, BYTE PTR $T27[ebp]
  000a2	85 c9		 test	 ecx, ecx
  000a4	75 07		 jne	 SHORT $LN4@SendData
  000a6	32 c0		 xor	 al, al
  000a8	e9 34 05 00 00	 jmp	 $LN13@SendData
$LN4@SendData:

; 279  : 	try

  000ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 280  : 	{
; 281  : 		switch (m_connectType) {

  000b4	8b 95 e8 bd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000bd	89 85 b8 bd ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  000c3	83 bd b8 bd ff
	ff 02		 cmp	 DWORD PTR tv70[ebp], 2
  000ca	0f 84 bb 02 00
	00		 je	 $LN9@SendData
  000d0	83 bd b8 bd ff
	ff 03		 cmp	 DWORD PTR tv70[ebp], 3
  000d7	74 05		 je	 SHORT $LN6@SendData
  000d9	e9 32 04 00 00	 jmp	 $LN2@SendData
$LN6@SendData:

; 282  : 			case WEBSOCKET: {
; 283  : 				NullPmd::message message;

  000de	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  000e4	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message
  000e9	89 85 4c bd ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  000ef	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 284  : 				message.Clear();

  000f3	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  000f9	e8 00 00 00 00	 call	 ?Clear@message@NullPmd@@UAEXXZ ; NullPmd::message::Clear

; 285  : 				NullPmd::head* head = message.mutable_head();

  000fe	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00104	e8 00 00 00 00	 call	 ?mutable_head@message@NullPmd@@QAEPAVhead@2@XZ ; NullPmd::message::mutable_head
  00109	89 85 70 bd ff
	ff		 mov	 DWORD PTR tv386[ebp], eax
  0010f	8b 8d 70 bd ff
	ff		 mov	 ecx, DWORD PTR tv386[ebp]
  00115	89 8d b4 bd ff
	ff		 mov	 DWORD PTR _head$16[ebp], ecx

; 286  : 				NullPmd::command* command = head->mutable_command();

  0011b	8b 8d b4 bd ff
	ff		 mov	 ecx, DWORD PTR _head$16[ebp]
  00121	e8 00 00 00 00	 call	 ?mutable_command@head@NullPmd@@QAEPAVcommand@2@XZ ; NullPmd::head::mutable_command
  00126	89 85 6c bd ff
	ff		 mov	 DWORD PTR tv398[ebp], eax
  0012c	8b 95 6c bd ff
	ff		 mov	 edx, DWORD PTR tv398[ebp]
  00132	89 95 b0 bd ff
	ff		 mov	 DWORD PTR _command$15[ebp], edx

; 287  : 				NullPmd::info* info = head->mutable_info();

  00138	8b 8d b4 bd ff
	ff		 mov	 ecx, DWORD PTR _head$16[ebp]
  0013e	e8 00 00 00 00	 call	 ?mutable_info@head@NullPmd@@QAEPAVinfo@2@XZ ; NullPmd::head::mutable_info
  00143	89 85 68 bd ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  00149	8b 85 68 bd ff
	ff		 mov	 eax, DWORD PTR tv397[ebp]
  0014f	89 85 bc bd ff
	ff		 mov	 DWORD PTR _info$17[ebp], eax

; 288  : 
; 289  : 				command->set_mainid(wMainCmdID);

  00155	0f b7 45 08	 movzx	 eax, WORD PTR _wMainCmdID$[ebp]
  00159	99		 cdq
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 799  :   mainid_ = value;

  0015a	8b 8d b0 bd ff
	ff		 mov	 ecx, DWORD PTR _command$15[ebp]
  00160	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00163	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 290  : 				command->set_subid(wSubCmdID);

  00166	0f b7 45 0c	 movzx	 eax, WORD PTR _wSubCmdID$[ebp]
  0016a	99		 cdq
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 813  :   subid_ = value;

  0016b	8b 8d b0 bd ff
	ff		 mov	 ecx, DWORD PTR _command$15[ebp]
  00171	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00174	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 990  :   data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

  00177	8d 95 5c bd ff
	ff		 lea	 edx, DWORD PTR _message$4[ebp+8]
  0017d	89 95 ac bd ff
	ff		 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 263  :     if (ptr_ == default_value) {

  00183	8b 85 ac bd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00189	81 38 00 00 00
	00		 cmp	 DWORD PTR [eax], OFFSET ?fixed_address_empty_string@internal@protobuf@google@@3V?$ExplicitlyConstructed@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@123@A ; google::protobuf::internal::fixed_address_empty_string
  0018f	75 02		 jne	 SHORT $LN58@SendData

; 264  :       // Nothing: already equal to default (which is the empty string).
; 265  :     } else {

  00191	eb 23		 jmp	 SHORT $LN51@SendData
$LN58@SendData:

; 266  :       ptr_->clear();

  00193	8b 8d ac bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00199	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019b	89 95 a4 bd ff
	ff		 mov	 DWORD PTR _this$13[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2870 : 		{	// erase all

  001a1	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 2871 : 		_Eos(0);

  001a5	6a 00		 push	 0
  001a7	8b 8d a4 bd ff
	ff		 mov	 ecx, DWORD PTR _this$13[ebp]
  001ad	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  001b2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
$LN51@SendData:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 845  :   cbcheckcode_ = value;

  001b6	8b 85 bc bd ff
	ff		 mov	 eax, DWORD PTR _info$17[ebp]
  001bc	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1
  001c3	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 859  :   wpacketsize_ = value;

  001ca	8b 8d bc bd ff
	ff		 mov	 ecx, DWORD PTR _info$17[ebp]
  001d0	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  001d7	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 831  :   cbdatakind_ = value;

  001de	8b 95 bc bd ff
	ff		 mov	 edx, DWORD PTR _info$17[ebp]
  001e4	c7 42 08 01 00
	00 00		 mov	 DWORD PTR [edx+8], 1
  001eb	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 296  : 				int buffsize = message.ByteSize();

  001f2	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  001f8	e8 00 00 00 00	 call	 ?ByteSize@MessageLite@protobuf@google@@QBEHXZ ; google::protobuf::MessageLite::ByteSize
  001fd	89 85 a0 bd ff
	ff		 mov	 DWORD PTR tv395[ebp], eax
  00203	8b 85 a0 bd ff
	ff		 mov	 eax, DWORD PTR tv395[ebp]
  00209	89 85 d0 bd ff
	ff		 mov	 DWORD PTR _buffsize$21[ebp], eax

; 297  : 				if (buffsize > SOCKET_TCP_PACKET) {

  0020f	81 bd d0 bd ff
	ff f8 3f 00 00	 cmp	 DWORD PTR _buffsize$21[ebp], 16376 ; 00003ff8H
  00219	76 1b		 jbe	 SHORT $LN7@SendData

; 298  : 					throw TEXT("发送包太大");

  0021b	c7 85 9c bd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp], OFFSET ??_C@_0L@JNDINJCC@?$LH?$KC?K?M?$LA?$PM?L?$KL?$LE?s@
  00225	68 00 00 00 00	 push	 OFFSET __TI2PAD
  0022a	8d 8d 9c bd ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00230	51		 push	 ecx
  00231	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN7@SendData:

; 300  : 				std::shared_ptr<char> sendData(new char[buffsize]);

  00236	8b 95 d0 bd ff
	ff		 mov	 edx, DWORD PTR _buffsize$21[ebp]
  0023c	52		 push	 edx
  0023d	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00242	83 c4 04	 add	 esp, 4
  00245	89 85 98 bd ff
	ff		 mov	 DWORD PTR tv392[ebp], eax
  0024b	8b 85 98 bd ff
	ff		 mov	 eax, DWORD PTR tv392[ebp]
  00251	89 85 94 bd ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1157 : 	element_type * _Ptr{nullptr};

  00257	c7 85 c8 bd ff
	ff 00 00 00 00	 mov	 DWORD PTR _sendData$20[ebp], 0

; 1158 : 	_Ref_count_base * _Rep{nullptr};

  00261	c7 85 cc bd ff
	ff 00 00 00 00	 mov	 DWORD PTR _sendData$20[ebp+4], 0

; 1284 : 		_Setp(_Px, is_array<_Ty>{});

  0026b	0f b6 8d c7 bd
	ff ff		 movzx	 ecx, BYTE PTR $T19[ebp]
  00272	51		 push	 ecx
  00273	8b 95 94 bd ff
	ff		 mov	 edx, DWORD PTR $T11[ebp]
  00279	52		 push	 edx
  0027a	8d 8d c8 bd ff
	ff		 lea	 ecx, DWORD PTR _sendData$20[ebp]
  00280	e8 00 00 00 00	 call	 ??$_Setp@D@?$shared_ptr@D@std@@AAEXPADU?$integral_constant@_N$0A@@1@@Z ; std::shared_ptr<char>::_Setp<char>
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 300  : 				std::shared_ptr<char> sendData(new char[buffsize]);

  00285	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1059 : 		return (_Ptr);

  00289	8b 85 c8 bd ff
	ff		 mov	 eax, DWORD PTR _sendData$20[ebp]
  0028f	89 85 90 bd ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 301  : 				if (message.SerializeToArray(sendData.get(), buffsize) == false) {

  00295	8b 8d d0 bd ff
	ff		 mov	 ecx, DWORD PTR _buffsize$21[ebp]
  0029b	51		 push	 ecx
  0029c	8b 95 90 bd ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  002a2	52		 push	 edx
  002a3	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  002a9	e8 00 00 00 00	 call	 ?SerializeToArray@MessageLite@protobuf@google@@QBE_NPAXH@Z ; google::protobuf::MessageLite::SerializeToArray
  002ae	88 85 df bd ff
	ff		 mov	 BYTE PTR tv394[ebp], al
  002b4	0f b6 85 df bd
	ff ff		 movzx	 eax, BYTE PTR tv394[ebp]
  002bb	85 c0		 test	 eax, eax
  002bd	75 1b		 jne	 SHORT $LN8@SendData

; 302  : 					throw TEXT("Serialize error");

  002bf	c7 85 8c bd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], OFFSET ??_C@_0BA@LDGEJDBI@Serialize?5error@
  002c9	68 00 00 00 00	 push	 OFFSET __TI2PAD
  002ce	8d 8d 8c bd ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  002d4	51		 push	 ecx
  002d5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1059 : 		return (_Ptr);

  002da	8b 95 c8 bd ff
	ff		 mov	 edx, DWORD PTR _sendData$20[ebp]
  002e0	89 95 88 bd ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 306  : 				int encodesize = zl::net::ws::encodeFrame(zl::net::ws::WsFrameType::WS_BINARY_FRAME, sendData.get(), buffsize, cbSendData, SOCKET_TCP_BUFFER);

  002e6	68 00 40 00 00	 push	 16384			; 00004000H
  002eb	8d 85 ec bd ff
	ff		 lea	 eax, DWORD PTR _cbSendData$28[ebp]
  002f1	50		 push	 eax
  002f2	8b 8d d0 bd ff
	ff		 mov	 ecx, DWORD PTR _buffsize$21[ebp]
  002f8	51		 push	 ecx
  002f9	8b 95 88 bd ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  002ff	52		 push	 edx
  00300	68 82 00 00 00	 push	 130			; 00000082H
  00305	e8 00 00 00 00	 call	 ?encodeFrame@ws@net@zl@@YAHW4WsFrameType@123@PBDHPADH@Z ; zl::net::ws::encodeFrame
  0030a	83 c4 14	 add	 esp, 20			; 00000014H
  0030d	89 85 84 bd ff
	ff		 mov	 DWORD PTR tv393[ebp], eax
  00313	8b 85 84 bd ff
	ff		 mov	 eax, DWORD PTR tv393[ebp]
  00319	89 85 80 bd ff
	ff		 mov	 DWORD PTR _encodesize$7[ebp], eax

; 307  : 
; 308  : 				SendRawData(cbSendData, encodesize);

  0031f	8b 8d 80 bd ff
	ff		 mov	 ecx, DWORD PTR _encodesize$7[ebp]
  00325	51		 push	 ecx
  00326	8d 95 ec bd ff
	ff		 lea	 edx, DWORD PTR _cbSendData$28[ebp]
  0032c	52		 push	 edx
  0032d	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00333	e8 00 00 00 00	 call	 ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ; CTCPNetworkItem::SendRawData
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1402 : 		{	// release resource

  00338	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4

; 1118 : 		if (_Rep)

  0033c	83 bd cc bd ff
	ff 00		 cmp	 DWORD PTR _sendData$20[ebp+4], 0
  00343	74 0b		 je	 SHORT $LN109@SendData

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  00345	8b 8d cc bd ff
	ff		 mov	 ecx, DWORD PTR _sendData$20[ebp+4]
  0034b	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN109@SendData:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 309  : 				break;

  00350	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00354	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  0035a	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
  0035f	e9 ac 01 00 00	 jmp	 $LN2@SendData
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory

; 1402 : 		{	// release resource

  00364	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 1118 : 		if (_Rep)

  00368	83 bd cc bd ff
	ff 00		 cmp	 DWORD PTR _sendData$20[ebp+4], 0
  0036f	74 0b		 je	 SHORT $LN121@SendData

; 1119 : 			{
; 1120 : 			_Rep->_Decref();

  00371	8b 8d cc bd ff
	ff		 mov	 ecx, DWORD PTR _sendData$20[ebp+4]
  00377	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN121@SendData:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 310  : 			}

  0037c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00380	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00386	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
$LN9@SendData:

; 311  : 			case WINSOCKET: {
; 312  : 				// 获取缓冲
; 313  : 				WORD wPacketSize = sizeof(TCP_Head);

  0038b	b8 08 00 00 00	 mov	 eax, 8
  00390	66 89 85 d4 bd
	ff ff		 mov	 WORD PTR _wPacketSize$22[ebp], ax

; 314  : 				COverLappedSend * pOverLappedSend = GetSendOverLapped(wPacketSize);

  00397	6a 01		 push	 1
  00399	0f b7 8d d4 bd
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$22[ebp]
  003a0	51		 push	 ecx
  003a1	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003a7	e8 00 00 00 00	 call	 ?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z ; CTCPNetworkItem::GetSendOverLapped
  003ac	89 85 7c bd ff
	ff		 mov	 DWORD PTR tv390[ebp], eax
  003b2	8b 95 7c bd ff
	ff		 mov	 edx, DWORD PTR tv390[ebp]
  003b8	89 95 e0 bd ff
	ff		 mov	 DWORD PTR _pOverLappedSend$26[ebp], edx

; 315  : 
; 316  : 				// 关闭判断
; 317  : 				if (pOverLappedSend == NULL)

  003be	83 bd e0 bd ff
	ff 00		 cmp	 DWORD PTR _pOverLappedSend$26[ebp], 0
  003c5	75 17		 jne	 SHORT $LN10@SendData

; 318  : 				{
; 319  : 					CloseSocket(wRountID);

  003c7	0f b7 45 10	 movzx	 eax, WORD PTR _wRountID$[ebp]
  003cb	50		 push	 eax
  003cc	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003d2	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 320  : 					return false;

  003d7	32 c0		 xor	 al, al
  003d9	e9 03 02 00 00	 jmp	 $LN13@SendData
$LN10@SendData:

; 321  : 				}
; 322  : 
; 323  : 				// 变量定义
; 324  : 				WORD wSourceLen = (WORD)pOverLappedSend->m_WSABuffer.len;

  003de	8b 8d e0 bd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$26[ebp]
  003e4	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  003e8	66 89 95 d8 bd
	ff ff		 mov	 WORD PTR _wSourceLen$23[ebp], dx

; 325  : 				TCP_Head * pHead = (TCP_Head *)(pOverLappedSend->m_cbBuffer + wSourceLen);

  003ef	0f b7 85 d8 bd
	ff ff		 movzx	 eax, WORD PTR _wSourceLen$23[ebp]
  003f6	8b 8d e0 bd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$26[ebp]
  003fc	8d 54 01 24	 lea	 edx, DWORD PTR [ecx+eax+36]
  00400	89 95 a8 bd ff
	ff		 mov	 DWORD PTR _pHead$14[ebp], edx

; 326  : 
; 327  : 				// 设置数据
; 328  : 				pHead->CommandInfo.wSubCmdID = wSubCmdID;

  00406	8b 85 a8 bd ff
	ff		 mov	 eax, DWORD PTR _pHead$14[ebp]
  0040c	66 8b 4d 0c	 mov	 cx, WORD PTR _wSubCmdID$[ebp]
  00410	66 89 48 06	 mov	 WORD PTR [eax+6], cx

; 329  : 				pHead->CommandInfo.wMainCmdID = wMainCmdID;

  00414	8b 95 a8 bd ff
	ff		 mov	 edx, DWORD PTR _pHead$14[ebp]
  0041a	66 8b 45 08	 mov	 ax, WORD PTR _wMainCmdID$[ebp]
  0041e	66 89 42 04	 mov	 WORD PTR [edx+4], ax

; 330  : 
; 331  : 				// 加密数据
; 332  : 				WORD wEncryptLen = EncryptBuffer(pOverLappedSend->m_cbBuffer + wSourceLen, wPacketSize, sizeof(pOverLappedSend->m_cbBuffer) - wSourceLen);

  00422	0f b7 8d d8 bd
	ff ff		 movzx	 ecx, WORD PTR _wSourceLen$23[ebp]
  00429	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  0042e	2b d1		 sub	 edx, ecx
  00430	52		 push	 edx
  00431	0f b7 85 d4 bd
	ff ff		 movzx	 eax, WORD PTR _wPacketSize$22[ebp]
  00438	50		 push	 eax
  00439	0f b7 8d d8 bd
	ff ff		 movzx	 ecx, WORD PTR _wSourceLen$23[ebp]
  00440	8b 95 e0 bd ff
	ff		 mov	 edx, DWORD PTR _pOverLappedSend$26[ebp]
  00446	8d 44 0a 24	 lea	 eax, DWORD PTR [edx+ecx+36]
  0044a	50		 push	 eax
  0044b	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00451	e8 00 00 00 00	 call	 ?EncryptBuffer@CTCPNetworkItem@@AAEGQAEGG@Z ; CTCPNetworkItem::EncryptBuffer
  00456	66 89 85 c4 bd
	ff ff		 mov	 WORD PTR tv382[ebp], ax
  0045d	66 8b 8d c4 bd
	ff ff		 mov	 cx, WORD PTR tv382[ebp]
  00464	66 89 8d c0 bd
	ff ff		 mov	 WORD PTR _wEncryptLen$18[ebp], cx

; 333  : 				pOverLappedSend->m_WSABuffer.len += wEncryptLen;

  0046b	0f b7 95 c0 bd
	ff ff		 movzx	 edx, WORD PTR _wEncryptLen$18[ebp]
  00472	8b 85 e0 bd ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$26[ebp]
  00478	03 50 04	 add	 edx, DWORD PTR [eax+4]
  0047b	8b 8d e0 bd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$26[ebp]
  00481	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 334  : 
; 335  : 				// 发送数据
; 336  : 				if (m_bSendIng == false)

  00484	8b 95 e8 bd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0048a	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  0048e	85 c0		 test	 eax, eax
  00490	75 7e		 jne	 SHORT $LN2@SendData

; 337  : 				{
; 338  : 					// 发送数据
; 339  : 					DWORD dwThancferred = 0;

  00492	c7 85 78 bd ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwThancferred$6[ebp], 0

; 340  : 					INT nResultCode = WSASend(m_hSocketHandle, &pOverLappedSend->m_WSABuffer, 1, &dwThancferred, 0, &pOverLappedSend->m_OverLapped, NULL);

  0049c	6a 00		 push	 0
  0049e	8b 8d e0 bd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$26[ebp]
  004a4	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004a7	51		 push	 ecx
  004a8	6a 00		 push	 0
  004aa	8d 95 78 bd ff
	ff		 lea	 edx, DWORD PTR _dwThancferred$6[ebp]
  004b0	52		 push	 edx
  004b1	6a 01		 push	 1
  004b3	8b 85 e0 bd ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$26[ebp]
  004b9	83 c0 04	 add	 eax, 4
  004bc	50		 push	 eax
  004bd	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004c3	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  004c6	52		 push	 edx
  004c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  004cd	89 85 74 bd ff
	ff		 mov	 DWORD PTR _nResultCode$5[ebp], eax

; 341  : 
; 342  : 					// 结果处理
; 343  : 					if ((nResultCode == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING))

  004d3	83 bd 74 bd ff
	ff ff		 cmp	 DWORD PTR _nResultCode$5[ebp], -1
  004da	75 2a		 jne	 SHORT $LN12@SendData
  004dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  004e2	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  004e7	74 1d		 je	 SHORT $LN12@SendData

; 344  : 					{
; 345  : 						CloseSocket(m_wRountID);

  004e9	8b 85 e8 bd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004ef	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  004f3	51		 push	 ecx
  004f4	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004fa	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 346  : 						return false;

  004ff	32 c0		 xor	 al, al
  00501	e9 db 00 00 00	 jmp	 $LN13@SendData
$LN12@SendData:

; 347  : 					}
; 348  : 
; 349  : 					// 设置变量
; 350  : 					m_bSendIng = true;

  00506	8b 95 e8 bd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0050c	c6 42 44 01	 mov	 BYTE PTR [edx+68], 1
$LN2@SendData:

; 351  : 				}
; 352  : 				break;
; 353  : 			}
; 354  : 		}
; 355  : 	}

  00510	e9 a1 00 00 00	 jmp	 $LN14@SendData
__catch$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$0:

; 356  : 	catch (LPCTSTR pszMessage) {
; 357  : 		// 错误信息
; 358  : 		TCHAR szString[512] = TEXT("");

  00515	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  0051a	88 85 ec fd ff
	ff		 mov	 BYTE PTR _szString$29[ebp], al
  00520	68 ff 01 00 00	 push	 511			; 000001ffH
  00525	6a 00		 push	 0
  00527	8d 8d ed fd ff
	ff		 lea	 ecx, DWORD PTR _szString$29[ebp+1]
  0052d	51		 push	 ecx
  0052e	e8 00 00 00 00	 call	 _memset
  00533	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  : 		_sntprintf(szString, CountArray(szString), TEXT("SendData 异常:%s"), pszMessage);

  00536	8b 95 48 bd ff
	ff		 mov	 edx, DWORD PTR _pszMessage$2[ebp]
  0053c	52		 push	 edx
  0053d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OELGDMNI@SendData?5?R?l?$LD?$KD?3?$CFs@
  00542	68 00 02 00 00	 push	 512			; 00000200H
  00547	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szString$29[ebp]
  0054d	50		 push	 eax
  0054e	e8 00 00 00 00	 call	 __snprintf
  00553	83 c4 10	 add	 esp, 16			; 00000010H

; 360  : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00556	6a 03		 push	 3
  00558	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szString$29[ebp]
  0055e	51		 push	 ecx
  0055f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00564	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 361  : 		return false;

  00569	c6 85 dd bd ff
	ff 00		 mov	 BYTE PTR $T24[ebp], 0
  00570	b8 00 00 00 00	 mov	 eax, $LN20@SendData
  00575	c3		 ret	 0

; 362  : 	}

  00576	b8 00 00 00 00	 mov	 eax, $LN14@SendData
  0057b	c3		 ret	 0
__catch$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$1:

; 363  : 	catch (...)
; 364  : 	{
; 365  : 		g_TraceServiceManager.TraceString("SendData 异常", TraceLevel_Exception);

  0057c	6a 03		 push	 3
  0057e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LEAMMJHF@SendData?5?R?l?$LD?$KD@
  00583	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00588	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 366  : 		CloseSocket(m_wRountID);

  0058d	8b 95 e8 bd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00593	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00597	50		 push	 eax
  00598	8b 8d e8 bd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0059e	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 367  : 		return false;

  005a3	c6 85 de bd ff
	ff 00		 mov	 BYTE PTR $T25[ebp], 0
  005aa	b8 00 00 00 00	 mov	 eax, $LN22@SendData
  005af	c3		 ret	 0

; 368  : 	}

  005b0	b8 00 00 00 00	 mov	 eax, $LN14@SendData
  005b5	c3		 ret	 0
$LN14@SendData:
  005b6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  005bd	eb 0f		 jmp	 SHORT $LN21@SendData
$LN22@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
  005bf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 367  : 		return false;

  005c6	8a 85 de bd ff
	ff		 mov	 al, BYTE PTR $T25[ebp]
  005cc	eb 13		 jmp	 SHORT $LN13@SendData
$LN21@SendData:
  005ce	eb 0f		 jmp	 SHORT $LN19@SendData
$LN20@SendData:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
  005d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 361  : 		return false;

  005d7	8a 85 dd bd ff
	ff		 mov	 al, BYTE PTR $T24[ebp]
  005dd	eb 02		 jmp	 SHORT $LN13@SendData
$LN19@SendData:

; 369  :     return true;

  005df	b0 01		 mov	 al, 1
$LN13@SendData:

; 370  : }

  005e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  005e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005eb	59		 pop	 ecx
  005ec	5f		 pop	 edi
  005ed	5e		 pop	 esi
  005ee	5b		 pop	 ebx
  005ef	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005f2	33 cd		 xor	 ecx, ebp
  005f4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005f9	8b e5		 mov	 esp, ebp
  005fb	5d		 pop	 ebp
  005fc	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$3:
  00000	8d 8d 54 bd ff
	ff		 lea	 ecx, DWORD PTR _message$4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
__unwindfunclet$?SendData@CTCPNetworkItem@@QAE_NGGG@Z$4:
  0000b	8d 8d c8 bd ff
	ff		 lea	 ecx, DWORD PTR _sendData$20[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@D@std@@QAE@XZ ; std::shared_ptr<char>::~shared_ptr<char>
__ehhandler$?SendData@CTCPNetworkItem@@QAE_NGGG@Z:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 8a 44 bd ff
	ff		 mov	 ecx, DWORD PTR [edx-17084]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendData@CTCPNetworkItem@@QAE_NGGG@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendData@CTCPNetworkItem@@QAE_NGGG@Z ENDP		; CTCPNetworkItem::SendData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?ResumeData@CTCPNetworkItem@@QAEKXZ
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
?ResumeData@CTCPNetworkItem@@QAEKXZ PROC		; CTCPNetworkItem::ResumeData, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :     // 效验状态
; 232  :     ASSERT(m_hSocketHandle == INVALID_SOCKET);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00010	74 14		 je	 SHORT $LN3@ResumeData
  00012	68 e8 00 00 00	 push	 232			; 000000e8H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN3@ResumeData
  00025	cc		 int	 3
$LN3@ResumeData:

; 233  : 
; 234  :     // 连接属性
; 235  :     m_dwClientIP = 0L;

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 236  :     m_dwActiveTime = 0L;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 237  : 
; 238  :     // 核心变量
; 239  :     m_wSurvivalTime = 0;

  0003a	33 c9		 xor	 ecx, ecx
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	66 89 4a 10	 mov	 WORD PTR [edx+16], cx

; 240  :     m_hSocketHandle = INVALID_SOCKET;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 40 14 ff ff
	ff ff		 mov	 DWORD PTR [eax+20], -1

; 241  :     m_wRountID = __max(1, m_wRountID + 1);

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00054	83 c2 01	 add	 edx, 1
  00057	83 fa 01	 cmp	 edx, 1
  0005a	7d 09		 jge	 SHORT $LN4@ResumeData
  0005c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  00063	eb 0d		 jmp	 SHORT $LN5@ResumeData
$LN4@ResumeData:
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0006c	83 c1 01	 add	 ecx, 1
  0006f	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
$LN5@ResumeData:
  00072	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00075	66 8b 45 f8	 mov	 ax, WORD PTR tv83[ebp]
  00079	66 89 42 0e	 mov	 WORD PTR [edx+14], ax

; 242  : 
; 243  :     // 状态变量
; 244  :     m_bSendIng = false;

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	c6 41 44 00	 mov	 BYTE PTR [ecx+68], 0

; 245  :     m_bRecvIng = false;

  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	c6 42 45 00	 mov	 BYTE PTR [edx+69], 0

; 246  :     m_bShutDown = false;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	c6 40 46 00	 mov	 BYTE PTR [eax+70], 0

; 247  :     m_bAllowBatch = false;

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	c6 41 47 00	 mov	 BYTE PTR [ecx+71], 0

; 248  : 
; 249  :     // 接收变量
; 250  :     m_wRecvSize = 0;

  00099	33 d2		 xor	 edx, edx
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	66 89 50 4a	 mov	 WORD PTR [eax+74], dx

; 251  :     ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf));

  000a2	68 00 40 01 00	 push	 81920			; 00014000H
  000a7	6a 00		 push	 0
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000af	51		 push	 ecx
  000b0	e8 00 00 00 00	 call	 _memset
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 252  : 
; 253  :     // 计数变量
; 254  :     m_dwSendTickCount = 0L;

  000b8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	c7 82 4c 40 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+81996], 0

; 255  :     m_dwRecvTickCount = 0L;

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	c7 80 50 40 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+82000], 0

; 256  :     m_dwSendPacketCount = 0L;

  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	c7 81 54 40 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+82004], 0

; 257  :     m_dwRecvPacketCount = 0L;

  000df	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e2	c7 82 58 40 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+82008], 0

; 258  : 
; 259  :     // 加密数据
; 260  :     m_cbSendRound = 0;

  000ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	c6 80 5c 40 01
	00 00		 mov	 BYTE PTR [eax+82012], 0

; 261  :     m_cbRecvRound = 0;

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	c6 81 5d 40 01
	00 00		 mov	 BYTE PTR [ecx+82013], 0

; 262  :     m_dwSendXorKey = 0;

  00100	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00103	c7 82 60 40 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+82016], 0

; 263  :     m_dwRecvXorKey = 0;

  0010d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00110	c7 80 64 40 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+82020], 0

; 264  : 
; 265  : 	m_connectType = CHECKING;

  0011a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 266  : 
; 267  :     // 重叠数组
; 268  :     m_OverLappedSendBuffer.Append(m_OverLappedSendActive);

  00124	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00127	81 c2 8c 40 01
	00		 add	 edx, 82060		; 0001408cH
  0012d	52		 push	 edx
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
  00137	e8 00 00 00 00	 call	 ?Append@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABV1@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Append

; 269  :     m_OverLappedSendActive.RemoveAll();

  0013c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  00145	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  0014a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00151	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00157	0f b7 d1	 movzx	 edx, cx
  0015a	c1 e2 10	 shl	 edx, 16			; 00000010H
  0015d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00160	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00164	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0016a	0f b7 c1	 movzx	 eax, cx
  0016d	0b c2		 or	 eax, edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 272  : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
?ResumeData@CTCPNetworkItem@@QAEKXZ ENDP		; CTCPNetworkItem::ResumeData
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?Attach@CTCPNetworkItem@@QAEKIK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hSocket$ = 8						; size = 4
_dwClientIP$ = 12					; size = 4
?Attach@CTCPNetworkItem@@QAEKIK@Z PROC			; CTCPNetworkItem::Attach, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  :     // 效验参数
; 199  :     ASSERT(dwClientIP != 0);

  00007	83 7d 0c 00	 cmp	 DWORD PTR _dwClientIP$[ebp], 0
  0000b	75 14		 jne	 SHORT $LN3@Attach
  0000d	68 c7 00 00 00	 push	 199			; 000000c7H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN3@Attach
  00020	cc		 int	 3
$LN3@Attach:

; 200  :     ASSERT(hSocket != INVALID_SOCKET);

  00021	83 7d 08 ff	 cmp	 DWORD PTR _hSocket$[ebp], -1
  00025	75 14		 jne	 SHORT $LN4@Attach
  00027	68 c8 00 00 00	 push	 200			; 000000c8H
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00031	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00036	85 c0		 test	 eax, eax
  00038	74 01		 je	 SHORT $LN4@Attach
  0003a	cc		 int	 3
$LN4@Attach:

; 201  : 
; 202  :     // 效验状态
; 203  :     ASSERT(m_bRecvIng == false);

  0003b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	0f b6 42 45	 movzx	 eax, BYTE PTR [edx+69]
  00042	85 c0		 test	 eax, eax
  00044	74 14		 je	 SHORT $LN5@Attach
  00046	68 cb 00 00 00	 push	 203			; 000000cbH
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00050	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00055	85 c0		 test	 eax, eax
  00057	74 01		 je	 SHORT $LN5@Attach
  00059	cc		 int	 3
$LN5@Attach:

; 204  :     ASSERT(m_bSendIng == false);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	0f b6 42 44	 movzx	 eax, BYTE PTR [edx+68]
  00061	85 c0		 test	 eax, eax
  00063	74 14		 je	 SHORT $LN6@Attach
  00065	68 cc 00 00 00	 push	 204			; 000000ccH
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0006f	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00074	85 c0		 test	 eax, eax
  00076	74 01		 je	 SHORT $LN6@Attach
  00078	cc		 int	 3
$LN6@Attach:

; 205  :     ASSERT(m_hSocketHandle == INVALID_SOCKET);

  00079	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  00080	74 14		 je	 SHORT $LN7@Attach
  00082	68 cd 00 00 00	 push	 205			; 000000cdH
  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0008c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00091	85 c0		 test	 eax, eax
  00093	74 01		 je	 SHORT $LN7@Attach
  00095	cc		 int	 3
$LN7@Attach:

; 206  : 
; 207  :     // 状态变量
; 208  :     m_bSendIng = false;

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	c6 41 44 00	 mov	 BYTE PTR [ecx+68], 0

; 209  :     m_bRecvIng = false;

  0009d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a0	c6 42 45 00	 mov	 BYTE PTR [edx+69], 0

; 210  :     m_bShutDown = false;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	c6 40 46 00	 mov	 BYTE PTR [eax+70], 0

; 211  :     m_bAllowBatch = false;

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	c6 41 47 00	 mov	 BYTE PTR [ecx+71], 0

; 212  :     m_bBatchMask = 0xFF;

  000b2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	c6 42 48 ff	 mov	 BYTE PTR [edx+72], 255	; 000000ffH

; 213  : 
; 214  :     // 设置变量
; 215  :     m_dwClientIP = dwClientIP;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _dwClientIP$[ebp]
  000bf	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 216  :     m_hSocketHandle = hSocket;

  000c2	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c5	8b 45 08	 mov	 eax, DWORD PTR _hSocket$[ebp]
  000c8	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 217  :     m_wSurvivalTime = SAFETY_QUOTIETY;

  000cb	b9 02 00 00 00	 mov	 ecx, 2
  000d0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d3	66 89 4a 10	 mov	 WORD PTR [edx+16], cx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h

; 536  :             return _time64(_Time);

  000d7	6a 00		 push	 0
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  000df	83 c4 04	 add	 esp, 4
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 218  :     m_dwActiveTime = (DWORD)time(NULL);

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 219  : 	m_dwSendTickCount = GetTickCount();

  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000ee	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f1	89 82 4c 40 01
	00		 mov	 DWORD PTR [edx+81996], eax

; 220  : 	m_dwRecvTickCount = GetTickCount();

  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	89 81 50 40 01
	00		 mov	 DWORD PTR [ecx+82000], eax

; 221  : 
; 222  :     // 发送通知
; 223  :     m_pITCPNetworkItemSink->OnEventSocketBind(this);

  00106	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00109	52		 push	 edx
  0010a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00110	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00113	8b 01		 mov	 eax, DWORD PTR [ecx]
  00115	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00118	8b 10		 mov	 edx, DWORD PTR [eax]
  0011a	ff d2		 call	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  0011c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00123	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00129	0f b7 d1	 movzx	 edx, cx
  0012c	c1 e2 10	 shl	 edx, 16			; 00000010H
  0012f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00132	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00136	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0013c	0f b7 c1	 movzx	 eax, cx
  0013f	0b c2		 or	 eax, edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 226  : }

  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	c2 08 00	 ret	 8
?Attach@CTCPNetworkItem@@QAEKIK@Z ENDP			; CTCPNetworkItem::Attach
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetBatchMask@CTCPNetworkItem@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBatchMask@CTCPNetworkItem@@QAEEXZ PROC		; CTCPNetworkItem::GetBatchMask, COMDAT
; _this$ = ecx

; 226  :     inline BYTE GetBatchMask() { return m_bBatchMask; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 48	 mov	 al, BYTE PTR [eax+72]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBatchMask@CTCPNetworkItem@@QAEEXZ ENDP		; CTCPNetworkItem::GetBatchMask
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?IsRecvIng@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsRecvIng@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::IsRecvIng, COMDAT
; _this$ = ecx

; 224  :     inline bool IsRecvIng() { return m_bRecvIng; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 45	 mov	 al, BYTE PTR [eax+69]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?IsRecvIng@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::IsRecvIng
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?IsValidSocket@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsValidSocket@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::IsValidSocket, COMDAT
; _this$ = ecx

; 222  :     inline bool IsValidSocket() { return (m_hSocketHandle != INVALID_SOCKET); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 ff	 cmp	 DWORD PTR [eax+20], -1
  00010	74 09		 je	 SHORT $LN3@IsValidSoc
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@IsValidSoc
$LN3@IsValidSoc:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsValidSoc:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?IsValidSocket@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::IsValidSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?IsAllowSendData@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsAllowSendData@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::IsAllowSendData, COMDAT
; _this$ = ecx

; 220  :     inline bool IsAllowSendData() { return m_dwRecvPacketCount > 0L; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 58 40 01
	00 00		 cmp	 DWORD PTR [eax+82008], 0
  00013	76 09		 jbe	 SHORT $LN3@IsAllowSen
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@IsAllowSen
$LN3@IsAllowSen:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@IsAllowSen:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?IsAllowSendData@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::IsAllowSendData
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?IsAllowBatch@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsAllowBatch@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::IsAllowBatch, COMDAT
; _this$ = ecx

; 218  :     inline bool IsAllowBatch() { return m_bAllowBatch; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 40 47	 mov	 al, BYTE PTR [eax+71]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?IsAllowBatch@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::IsAllowBatch
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetCriticalSection@CTCPNetworkItem@@QAEAAVCCriticalSection@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCriticalSection@CTCPNetworkItem@@QAEAAVCCriticalSection@@XZ PROC ; CTCPNetworkItem::GetCriticalSection, COMDAT
; _this$ = ecx

; 213  :     inline CCriticalSection & GetCriticalSection() { return m_CriticalSection; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 18	 add	 eax, 24			; 00000018H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCriticalSection@CTCPNetworkItem@@QAEAAVCCriticalSection@@XZ ENDP ; CTCPNetworkItem::GetCriticalSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetActiveTime@CTCPNetworkItem@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetActiveTime@CTCPNetworkItem@@QAEKXZ PROC		; CTCPNetworkItem::GetActiveTime, COMDAT
; _this$ = ecx

; 203  :     inline DWORD GetActiveTime() { return m_dwActiveTime; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetActiveTime@CTCPNetworkItem@@QAEKXZ ENDP		; CTCPNetworkItem::GetActiveTime
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetClientIP@CTCPNetworkItem@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetClientIP@CTCPNetworkItem@@QAEKXZ PROC		; CTCPNetworkItem::GetClientIP, COMDAT
; _this$ = ecx

; 201  :     inline DWORD GetClientIP() { return m_dwClientIP; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetClientIP@CTCPNetworkItem@@QAEKXZ ENDP		; CTCPNetworkItem::GetClientIP
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetIdentifierID@CTCPNetworkItem@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIdentifierID@CTCPNetworkItem@@QAEKXZ PROC		; CTCPNetworkItem::GetIdentifierID, COMDAT
; _this$ = ecx

; 196  :     inline DWORD GetIdentifierID() { return MAKELONG(m_wIndex, m_wRountID); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0000e	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00014	0f b7 c1	 movzx	 eax, cx
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	0f b7 4a 0e	 movzx	 ecx, WORD PTR [edx+14]
  0001e	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00024	0f b7 d1	 movzx	 edx, cx
  00027	c1 e2 10	 shl	 edx, 16			; 00000010H
  0002a	0b c2		 or	 eax, edx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?GetIdentifierID@CTCPNetworkItem@@QAEKXZ ENDP		; CTCPNetworkItem::GetIdentifierID
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetRountID@CTCPNetworkItem@@QAEGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRountID@CTCPNetworkItem@@QAEGXZ PROC		; CTCPNetworkItem::GetRountID, COMDAT
; _this$ = ecx

; 194  :     inline WORD GetRountID() { return m_wRountID; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 40 0e	 mov	 ax, WORD PTR [eax+14]
  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?GetRountID@CTCPNetworkItem@@QAEGXZ ENDP		; CTCPNetworkItem::GetRountID
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?sendPingFrame@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -16396						; size = 4
_encodesize$ = -16392					; size = 4
_cbSendData$ = -16388					; size = 16384
__$ArrayPad$ = -4					; size = 4
?sendPingFrame@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::sendPingFrame, COMDAT
; _this$ = ecx

; 1195 : bool CTCPNetworkItem::sendPingFrame() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 40 00 00	 mov	 eax, 16396		; 0000400cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	89 8d f4 bf ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1196 : 	char cbSendData[SOCKET_TCP_BUFFER];
; 1197 : 	int encodesize = zl::net::ws::encodeFrame(zl::net::ws::WsFrameType::WS_PING_FRAME, NULL, 0, cbSendData, SOCKET_TCP_BUFFER);

  0001d	68 00 40 00 00	 push	 16384			; 00004000H
  00022	8d 85 fc bf ff
	ff		 lea	 eax, DWORD PTR _cbSendData$[ebp]
  00028	50		 push	 eax
  00029	6a 00		 push	 0
  0002b	6a 00		 push	 0
  0002d	68 89 00 00 00	 push	 137			; 00000089H
  00032	e8 00 00 00 00	 call	 ?encodeFrame@ws@net@zl@@YAHW4WsFrameType@123@PBDHPADH@Z ; zl::net::ws::encodeFrame
  00037	83 c4 14	 add	 esp, 20			; 00000014H
  0003a	89 85 f8 bf ff
	ff		 mov	 DWORD PTR _encodesize$[ebp], eax

; 1198 : 	return SendRawData(cbSendData, encodesize);

  00040	8b 8d f8 bf ff
	ff		 mov	 ecx, DWORD PTR _encodesize$[ebp]
  00046	51		 push	 ecx
  00047	8d 95 fc bf ff
	ff		 lea	 edx, DWORD PTR _cbSendData$[ebp]
  0004d	52		 push	 edx
  0004e	8b 8d f4 bf ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ; CTCPNetworkItem::SendRawData

; 1199 : }

  00059	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005c	33 cd		 xor	 ecx, ebp
  0005e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
?sendPingFrame@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::sendPingFrame
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?isWinSocket@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?isWinSocket@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::isWinSocket, COMDAT
; _this$ = ecx

; 1072 : bool CTCPNetworkItem::isWinSocket() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1073 : 	return m_connectType == WINSOCKET;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 40 02	 cmp	 DWORD PTR [eax+64], 2
  00010	75 09		 jne	 SHORT $LN3@isWinSocke
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@isWinSocke
$LN3@isWinSocke:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@isWinSocke:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 1074 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?isWinSocket@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::isWinSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?isWebSocket@CTCPNetworkItem@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?isWebSocket@CTCPNetworkItem@@QAE_NXZ PROC		; CTCPNetworkItem::isWebSocket, COMDAT
; _this$ = ecx

; 1068 : bool CTCPNetworkItem::isWebSocket() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1069 : 	return m_connectType == WEBSOCKET;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 40 03	 cmp	 DWORD PTR [eax+64], 3
  00010	75 09		 jne	 SHORT $LN3@isWebSocke
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@isWebSocke
$LN3@isWebSocke:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@isWebSocke:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 1070 : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?isWebSocket@CTCPNetworkItem@@QAE_NXZ ENDP		; CTCPNetworkItem::isWebSocket
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ
_TEXT	SEGMENT
_info$2 = -18740					; size = 40
_command$3 = -18700					; size = 32
tv393 = -18668						; size = 4
tv400 = -18664						; size = 4
tv387 = -18660						; size = 4
_pszMessage$4 = -18656					; size = 4
tv405 = -18652						; size = 4
_head$5 = -18648					; size = 20
$T6 = -18628						; size = 8
$T7 = -18620						; size = 8
_message$8 = -18612					; size = 20
$T9 = -18592						; size = 4
$T10 = -18588						; size = 4
$T11 = -18584						; size = 4
_type$12 = -18580					; size = 4
$T13 = -18576						; size = 8
tv173 = -18568						; size = 8
tv239 = -18560						; size = 4
$T14 = -18556						; size = 8
$T15 = -18548						; size = 4
$T16 = -18544						; size = 4
$T17 = -18540						; size = 4
$T18 = -18536						; size = 4
$T19 = -18532						; size = 4
$T20 = -18528						; size = 4
$T21 = -18524						; size = 4
$T22 = -18520						; size = 4
tv200 = -18516						; size = 4
$T23 = -18512						; size = 4
$T24 = -18508						; size = 4
__Result$25 = -18504					; size = 4
tv403 = -18500						; size = 4
tv369 = -18496						; size = 4
tv365 = -18492						; size = 4
tv361 = -18488						; size = 4
_outlen$26 = -18484					; size = 4
_frameSize$27 = -18480					; size = 4
$T28 = -18476						; size = 4
_aa$29 = -18472						; size = 4
_Command$30 = -18468					; size = 4
$T31 = -18463						; size = 1
$T32 = -18462						; size = 1
tv397 = -18461						; size = 1
tv128 = -18460						; size = 4
_this$ = -18456						; size = 4
_outbuf$33 = -18452					; size = 16384
_szString$34 = -2068					; size = 512
_szString$35 = -1556					; size = 512
_szString$36 = -1044					; size = 512
_szString$37 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ PROC	; CTCPNetworkItem::HandleWebsocketRecv, COMDAT
; _this$ = ecx

; 1076 : bool CTCPNetworkItem::HandleWebsocketRecv() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 24 49 00 00	 mov	 eax, 18724		; 00004924H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	89 8d e8 b7 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1077 : 	using namespace zl::net::ws;
; 1078 : 
; 1079 : 	if (m_wRecvSize > SOCKET_TCP_BUFFER) {

  0003c	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00042	0f b7 48 4a	 movzx	 ecx, WORD PTR [eax+74]
  00046	81 f9 00 40 00
	00		 cmp	 ecx, 16384		; 00004000H
  0004c	7e 60		 jle	 SHORT $LN8@HandleWebs

; 1080 : 		TCHAR szString[512] = TEXT("");

  0004e	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  00054	88 95 ec fd ff
	ff		 mov	 BYTE PTR _szString$37[ebp], dl
  0005a	68 ff 01 00 00	 push	 511			; 000001ffH
  0005f	6a 00		 push	 0
  00061	8d 85 ed fd ff
	ff		 lea	 eax, DWORD PTR _szString$37[ebp+1]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _memset
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1081 : 		_sntprintf(szString, CountArray(szString), TEXT("error,receive data len > SOCKET_TCP_BUFFER,%d>32768"), (int)m_wRecvSize);

  00070	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00076	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  0007a	52		 push	 edx
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@HPGDGIOK@error?0receive?5data?5len?5?$DO?5SOCKET@
  00080	68 00 02 00 00	 push	 512			; 00000200H
  00085	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szString$37[ebp]
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 __snprintf
  00091	83 c4 10	 add	 esp, 16			; 00000010H

; 1082 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00094	6a 03		 push	 3
  00096	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szString$37[ebp]
  0009c	51		 push	 ecx
  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  000a2	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1083 : 		return false;

  000a7	32 c0		 xor	 al, al
  000a9	e9 60 07 00 00	 jmp	 $LN22@HandleWebs
$LN8@HandleWebs:

; 1084 : 	}
; 1085 : 
; 1086 : 	try {

  000ae	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN2@HandleWebs:

; 1087 : 		while (m_wRecvSize > 0) {

  000b5	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  000bb	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  000bf	85 c0		 test	 eax, eax
  000c1	0f 8e 22 06 00
	00		 jle	 $LN3@HandleWebs

; 1088 : 			char outbuf[SOCKET_TCP_BUFFER];
; 1089 : 			int outlen = 0;

  000c7	c7 85 cc b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _outlen$26[ebp], 0

; 1090 : 			int frameSize = 0;

  000d1	c7 85 d0 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _frameSize$27[ebp], 0

; 1091 : 			WsFrameType type = decodeFrame((char*)m_cbRecvBuf, m_wRecvSize, outbuf, &outlen, &frameSize);

  000db	8d 8d d0 b7 ff
	ff		 lea	 ecx, DWORD PTR _frameSize$27[ebp]
  000e1	51		 push	 ecx
  000e2	8d 95 cc b7 ff
	ff		 lea	 edx, DWORD PTR _outlen$26[ebp]
  000e8	52		 push	 edx
  000e9	8d 85 ec b7 ff
	ff		 lea	 eax, DWORD PTR _outbuf$33[ebp]
  000ef	50		 push	 eax
  000f0	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  000fa	52		 push	 edx
  000fb	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00101	83 c0 4c	 add	 eax, 76			; 0000004cH
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?decodeFrame@ws@net@zl@@YA?AW4WsFrameType@123@PBDHPADPAH2@Z ; zl::net::ws::decodeFrame
  0010a	83 c4 14	 add	 esp, 20			; 00000014H
  0010d	89 85 80 b7 ff
	ff		 mov	 DWORD PTR tv239[ebp], eax
  00113	8b 8d 80 b7 ff
	ff		 mov	 ecx, DWORD PTR tv239[ebp]
  00119	89 8d 6c b7 ff
	ff		 mov	 DWORD PTR _type$12[ebp], ecx

; 1092 : 
; 1093 : 			switch (type) {

  0011f	8b 95 6c b7 ff
	ff		 mov	 edx, DWORD PTR _type$12[ebp]
  00125	89 95 e4 b7 ff
	ff		 mov	 DWORD PTR tv128[ebp], edx
  0012b	81 bd e4 b7 ff
	ff 89 00 00 00	 cmp	 DWORD PTR tv128[ebp], 137 ; 00000089H
  00135	7f 43		 jg	 SHORT $LN23@HandleWebs
  00137	81 bd e4 b7 ff
	ff 89 00 00 00	 cmp	 DWORD PTR tv128[ebp], 137 ; 00000089H
  00141	0f 84 e4 04 00
	00		 je	 $LN18@HandleWebs
  00147	8b 85 e4 b7 ff
	ff		 mov	 eax, DWORD PTR tv128[ebp]
  0014d	83 e8 01	 sub	 eax, 1
  00150	89 85 e4 b7 ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  00156	81 bd e4 b7 ff
	ff 87 00 00 00	 cmp	 DWORD PTR tv128[ebp], 135 ; 00000087H
  00160	0f 87 08 05 00
	00		 ja	 $LN21@HandleWebs
  00166	8b 8d e4 b7 ff
	ff		 mov	 ecx, DWORD PTR tv128[ebp]
  0016c	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN97@HandleWebs[ecx]
  00173	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN101@HandleWebs[edx*4]
$LN23@HandleWebs:
  0017a	81 bd e4 b7 ff
	ff 8a 00 00 00	 cmp	 DWORD PTR tv128[ebp], 138 ; 0000008aH
  00184	0f 84 b4 04 00
	00		 je	 $LN19@HandleWebs
  0018a	81 bd e4 b7 ff
	ff 00 fe 00 00	 cmp	 DWORD PTR tv128[ebp], 65024 ; 0000fe00H
  00194	74 05		 je	 SHORT $LN10@HandleWebs
  00196	e9 d3 04 00 00	 jmp	 $LN21@HandleWebs
$LN10@HandleWebs:

; 1094 : 			case WS_INCOMPLETE_TEXT_FRAME:
; 1095 : 			case WS_INCOMPLETE_BINARY_FRAME:
; 1096 : 			case WS_INCOMPLETE_FRAME: {
; 1097 : 				return true;

  0019b	b0 01		 mov	 al, 1
  0019d	e9 6c 06 00 00	 jmp	 $LN22@HandleWebs
$LN11@HandleWebs:

; 1098 : 			}
; 1099 : 			case WS_TEXT_FRAME:
; 1100 : 			case WS_BINARY_FRAME: {
; 1101 : 				m_dwRecvPacketCount++;

  001a2	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001a8	8b 88 58 40 01
	00		 mov	 ecx, DWORD PTR [eax+82008]
  001ae	83 c1 01	 add	 ecx, 1
  001b1	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001b7	89 8a 58 40 01
	00		 mov	 DWORD PTR [edx+82008], ecx

; 1102 : 				
; 1103 : 				TCP_Command Command;
; 1104 : 				NullPmd::message message;

  001bd	8d 8d 4c b7 ff
	ff		 lea	 ecx, DWORD PTR _message$8[ebp]
  001c3	e8 00 00 00 00	 call	 ??0message@NullPmd@@QAE@XZ ; NullPmd::message::message
  001c8	89 85 1c b7 ff
	ff		 mov	 DWORD PTR tv387[ebp], eax
  001ce	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 1105 : 				if (message.ParseFromArray(outbuf, outlen) == false) {

  001d2	8b 85 cc b7 ff
	ff		 mov	 eax, DWORD PTR _outlen$26[ebp]
  001d8	50		 push	 eax
  001d9	8d 8d ec b7 ff
	ff		 lea	 ecx, DWORD PTR _outbuf$33[ebp]
  001df	51		 push	 ecx
  001e0	8d 8d 4c b7 ff
	ff		 lea	 ecx, DWORD PTR _message$8[ebp]
  001e6	e8 00 00 00 00	 call	 ?ParseFromArray@MessageLite@protobuf@google@@QAE_NPBXH@Z ; google::protobuf::MessageLite::ParseFromArray
  001eb	88 85 e3 b7 ff
	ff		 mov	 BYTE PTR tv397[ebp], al
  001f1	0f b6 95 e3 b7
	ff ff		 movzx	 edx, BYTE PTR tv397[ebp]
  001f8	85 d2		 test	 edx, edx
  001fa	75 1b		 jne	 SHORT $LN12@HandleWebs

; 1106 : 					throw TEXT("parse error");

  001fc	c7 85 68 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], OFFSET ??_C@_0M@BJIBBOFC@parse?5error@
  00206	68 00 00 00 00	 push	 OFFSET __TI2PAD
  0020b	8d 85 68 b7 ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@HandleWebs:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 959  :   return head_ != NULL ? *head_

  00217	83 bd 58 b7 ff
	ff 00		 cmp	 DWORD PTR _message$8[ebp+12], 0
  0021e	74 0e		 je	 SHORT $LN40@HandleWebs
  00220	8b 8d 58 b7 ff
	ff		 mov	 ecx, DWORD PTR _message$8[ebp+12]
  00226	89 8d c8 b7 ff
	ff		 mov	 DWORD PTR tv361[ebp], ecx
  0022c	eb 0a		 jmp	 SHORT $LN39@HandleWebs
$LN40@HandleWebs:
  0022e	c7 85 c8 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv361[ebp], OFFSET ?_head_default_instance_@NullPmd@@3VheadDefaultTypeInternal@1@A ; NullPmd::_head_default_instance_
$LN39@HandleWebs:
  00238	8b 95 c8 b7 ff
	ff		 mov	 edx, DWORD PTR tv361[ebp]
  0023e	89 95 64 b7 ff
	ff		 mov	 DWORD PTR $T10[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1108 : 				NullPmd::head head = message.head();

  00244	8b 85 64 b7 ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0024a	50		 push	 eax
  0024b	8d 8d 28 b7 ff
	ff		 lea	 ecx, DWORD PTR _head$5[ebp]
  00251	e8 00 00 00 00	 call	 ??0head@NullPmd@@QAE@ABV01@@Z ; NullPmd::head::head
  00256	89 85 18 b7 ff
	ff		 mov	 DWORD PTR tv400[ebp], eax
  0025c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 877  :   return command_ != NULL ? *command_

  00260	83 bd 30 b7 ff
	ff 00		 cmp	 DWORD PTR _head$5[ebp+8], 0
  00267	74 0e		 je	 SHORT $LN46@HandleWebs
  00269	8b 8d 30 b7 ff
	ff		 mov	 ecx, DWORD PTR _head$5[ebp+8]
  0026f	89 8d c4 b7 ff
	ff		 mov	 DWORD PTR tv365[ebp], ecx
  00275	eb 0a		 jmp	 SHORT $LN45@HandleWebs
$LN46@HandleWebs:
  00277	c7 85 c4 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv365[ebp], OFFSET ?_command_default_instance_@NullPmd@@3VcommandDefaultTypeInternal@1@A ; NullPmd::_command_default_instance_
$LN45@HandleWebs:
  00281	8b 95 c4 b7 ff
	ff		 mov	 edx, DWORD PTR tv365[ebp]
  00287	89 95 60 b7 ff
	ff		 mov	 DWORD PTR $T9[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1109 : 				NullPmd::command command = head.command();

  0028d	8b 85 60 b7 ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00293	50		 push	 eax
  00294	8d 8d f4 b6 ff
	ff		 lea	 ecx, DWORD PTR _command$3[ebp]
  0029a	e8 00 00 00 00	 call	 ??0command@NullPmd@@QAE@ABV01@@Z ; NullPmd::command::command
  0029f	89 85 14 b7 ff
	ff		 mov	 DWORD PTR tv393[ebp], eax
  002a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 916  :   return info_ != NULL ? *info_

  002a9	83 bd 34 b7 ff
	ff 00		 cmp	 DWORD PTR _head$5[ebp+12], 0
  002b0	74 0e		 je	 SHORT $LN52@HandleWebs
  002b2	8b 8d 34 b7 ff
	ff		 mov	 ecx, DWORD PTR _head$5[ebp+12]
  002b8	89 8d c0 b7 ff
	ff		 mov	 DWORD PTR tv369[ebp], ecx
  002be	eb 0a		 jmp	 SHORT $LN51@HandleWebs
$LN52@HandleWebs:
  002c0	c7 85 c0 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv369[ebp], OFFSET ?_info_default_instance_@NullPmd@@3VinfoDefaultTypeInternal@1@A ; NullPmd::_info_default_instance_
$LN51@HandleWebs:
  002ca	8b 95 c0 b7 ff
	ff		 mov	 edx, DWORD PTR tv369[ebp]
  002d0	89 95 b4 b7 ff
	ff		 mov	 DWORD PTR $T24[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1110 : 				NullPmd::info info = head.info();

  002d6	8b 85 b4 b7 ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  002dc	50		 push	 eax
  002dd	8d 8d cc b6 ff
	ff		 lea	 ecx, DWORD PTR _info$2[ebp]
  002e3	e8 00 00 00 00	 call	 ??0info@NullPmd@@QAE@ABV01@@Z ; NullPmd::info::info
  002e8	89 85 24 b7 ff
	ff		 mov	 DWORD PTR tv405[ebp], eax
  002ee	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  002f2	8b 8d d4 b6 ff
	ff		 mov	 ecx, DWORD PTR _info$2[ebp+8]
  002f8	89 8d 84 b7 ff
	ff		 mov	 DWORD PTR $T14[ebp], ecx
  002fe	8b 95 d8 b6 ff
	ff		 mov	 edx, DWORD PTR _info$2[ebp+12]
  00304	89 95 88 b7 ff
	ff		 mov	 DWORD PTR $T14[ebp+4], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1112 : 				if (info.cbdatakind() != DK_MAPPED && info.cbdatakind() != 0x05) {

  0030a	83 bd 84 b7 ff
	ff 01		 cmp	 DWORD PTR $T14[ebp], 1
  00311	75 0d		 jne	 SHORT $LN98@HandleWebs
  00313	83 bd 88 b7 ff
	ff 00		 cmp	 DWORD PTR $T14[ebp+4], 0
  0031a	0f 84 bc 00 00
	00		 je	 $LN13@HandleWebs
$LN98@HandleWebs:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 827  :   return cbdatakind_;

  00320	8b 85 d4 b6 ff
	ff		 mov	 eax, DWORD PTR _info$2[ebp+8]
  00326	89 85 70 b7 ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
  0032c	8b 8d d8 b6 ff
	ff		 mov	 ecx, DWORD PTR _info$2[ebp+12]
  00332	89 8d 74 b7 ff
	ff		 mov	 DWORD PTR $T13[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1112 : 				if (info.cbdatakind() != DK_MAPPED && info.cbdatakind() != 0x05) {

  00338	83 bd 70 b7 ff
	ff 05		 cmp	 DWORD PTR $T13[ebp], 5
  0033f	75 0d		 jne	 SHORT $LN99@HandleWebs
  00341	83 bd 74 b7 ff
	ff 00		 cmp	 DWORD PTR $T13[ebp+4], 0
  00348	0f 84 8e 00 00
	00		 je	 $LN13@HandleWebs
$LN99@HandleWebs:

; 1113 : 					CString aa;

  0034e	8d 8d d8 b7 ff
	ff		 lea	 ecx, DWORD PTR _aa$29[ebp]
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0035a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5

; 1114 : 					aa.Format(TEXT("0x%x"), info.cbdatakind());

  0035e	8d 8d cc b6 ff
	ff		 lea	 ecx, DWORD PTR _info$2[ebp]
  00364	e8 00 00 00 00	 call	 ?cbdatakind@info@NullPmd@@QBE_KXZ ; NullPmd::info::cbdatakind
  00369	89 85 78 b7 ff
	ff		 mov	 DWORD PTR tv173[ebp], eax
  0036f	89 95 7c b7 ff
	ff		 mov	 DWORD PTR tv173[ebp+4], edx
  00375	8b 95 7c b7 ff
	ff		 mov	 edx, DWORD PTR tv173[ebp+4]
  0037b	52		 push	 edx
  0037c	8b 85 78 b7 ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  00382	50		 push	 eax
  00383	68 00 00 00 00	 push	 OFFSET ??_C@_04OPBHEPOC@0x?$CFx@
  00388	8d 8d d8 b7 ff
	ff		 lea	 ecx, DWORD PTR _aa$29[ebp]
  0038e	51		 push	 ecx
  0038f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00395	83 c4 10	 add	 esp, 16			; 00000010H

; 1115 : 					g_TraceServiceManager.TraceString(aa, TraceLevel_Exception);

  00398	6a 03		 push	 3
  0039a	8d 8d d8 b7 ff
	ff		 lea	 ecx, DWORD PTR _aa$29[ebp]
  003a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
  003a6	50		 push	 eax
  003a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  003ac	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1116 : 					throw TEXT("数据包版本不匹配");

  003b1	c7 85 b0 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T23[ebp], OFFSET ??_C@_0BB@HMAHCNOL@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LC?$LL?F?$KF?E?d@
  003bb	68 00 00 00 00	 push	 OFFSET __TI2PAD
  003c0	8d 95 b0 b7 ff
	ff		 lea	 edx, DWORD PTR $T23[ebp]
  003c6	52		 push	 edx
  003c7	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1117 : 				}

  003cc	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  003d0	8d 8d d8 b7 ff
	ff		 lea	 ecx, DWORD PTR _aa$29[ebp]
  003d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$LN13@HandleWebs:
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 795  :   return mainid_;

  003dc	8b 85 fc b6 ff
	ff		 mov	 eax, DWORD PTR _command$3[ebp+8]
  003e2	89 85 44 b7 ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  003e8	8b 8d 00 b7 ff
	ff		 mov	 ecx, DWORD PTR _command$3[ebp+12]
  003ee	89 8d 48 b7 ff
	ff		 mov	 DWORD PTR $T7[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1119 : 				Command.wMainCmdID = command.mainid();

  003f4	66 8b 95 44 b7
	ff ff		 mov	 dx, WORD PTR $T7[ebp]
  003fb	66 89 95 dc b7
	ff ff		 mov	 WORD PTR _Command$30[ebp], dx
; File g:\网狐\happygamewh\服务端\系统模块\消息定义\pb\nullpmd.pb.h

; 809  :   return subid_;

  00402	8b 85 04 b7 ff
	ff		 mov	 eax, DWORD PTR _command$3[ebp+16]
  00408	89 85 3c b7 ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  0040e	8b 8d 08 b7 ff
	ff		 mov	 ecx, DWORD PTR _command$3[ebp+20]
  00414	89 8d 40 b7 ff
	ff		 mov	 DWORD PTR $T6[ebp+4], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1120 : 				Command.wSubCmdID = command.subid();

  0041a	66 8b 95 3c b7
	ff ff		 mov	 dx, WORD PTR $T6[ebp]
  00421	66 89 95 de b7
	ff ff		 mov	 WORD PTR _Command$30[ebp+2], dx

; 1121 : 				//内核命令
; 1122 : 				if (Command.wMainCmdID == MDM_KN_COMMAND) {

  00428	0f b7 85 dc b7
	ff ff		 movzx	 eax, WORD PTR _Command$30[ebp]
  0042f	85 c0		 test	 eax, eax
  00431	75 3a		 jne	 SHORT $LN14@HandleWebs

; 1123 : 					switch (Command.wSubCmdID) {

  00433	0f b7 8d de b7
	ff ff		 movzx	 ecx, WORD PTR _Command$30[ebp+2]
  0043a	89 8d ac b7 ff
	ff		 mov	 DWORD PTR tv200[ebp], ecx
  00440	83 bd ac b7 ff
	ff 01		 cmp	 DWORD PTR tv200[ebp], 1
  00447	74 02		 je	 SHORT $LN16@HandleWebs
  00449	eb 02		 jmp	 SHORT $LN17@HandleWebs
$LN16@HandleWebs:

; 1124 : 						case SUB_KN_DETECT_SOCKET: {	//网络检测
; 1125 : 							//SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, m_wRountID);
; 1126 : 							break;

  0044b	eb 1b		 jmp	 SHORT $LN6@HandleWebs
$LN17@HandleWebs:

; 1127 : 						}
; 1128 : 						default: {
; 1129 : 							throw TEXT("非法命令码");

  0044d	c7 85 a8 b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T22[ebp], OFFSET ??_C@_0L@HPNHKCLL@?$LH?G?$LH?$KI?C?$PM?A?n?B?k@
  00457	68 00 00 00 00	 push	 OFFSET __TI2PAD
  0045c	8d 95 a8 b7 ff
	ff		 lea	 edx, DWORD PTR $T22[ebp]
  00462	52		 push	 edx
  00463	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN6@HandleWebs:

; 1130 : 						}
; 1131 : 					}
; 1132 : 				}
; 1133 : 				else {

  00468	e9 41 01 00 00	 jmp	 $LN15@HandleWebs
$LN14@HandleWebs:

; 1134 : 
; 1135 : 					TCHAR szString[512] = TEXT("");

  0046d	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  00472	88 85 ec fb ff
	ff		 mov	 BYTE PTR _szString$36[ebp], al
  00478	68 ff 01 00 00	 push	 511			; 000001ffH
  0047d	6a 00		 push	 0
  0047f	8d 8d ed fb ff
	ff		 lea	 ecx, DWORD PTR _szString$36[ebp+1]
  00485	51		 push	 ecx
  00486	e8 00 00 00 00	 call	 _memset
  0048b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1136 : 					_sntprintf(szString, CountArray(szString), TEXT("收到消息:mainid:%d,subid:%d"), Command.wMainCmdID, Command.wSubCmdID);

  0048e	0f b7 95 de b7
	ff ff		 movzx	 edx, WORD PTR _Command$30[ebp+2]
  00495	52		 push	 edx
  00496	0f b7 85 dc b7
	ff ff		 movzx	 eax, WORD PTR _Command$30[ebp]
  0049d	50		 push	 eax
  0049e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EEHLBJJE@?J?U?$LF?$LN?O?$PL?O?$KC?3mainid?3?$CFd?0subid?3?$CFd@
  004a3	68 00 02 00 00	 push	 512			; 00000200H
  004a8	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szString$36[ebp]
  004ae	51		 push	 ecx
  004af	e8 00 00 00 00	 call	 __snprintf
  004b4	83 c4 14	 add	 esp, 20			; 00000014H

; 1137 : 					g_TraceServiceManager.TraceString(szString, TraceLevel_Normal);

  004b7	6a 01		 push	 1
  004b9	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _szString$36[ebp]
  004bf	52		 push	 edx
  004c0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  004c5	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  004ca	8b 85 54 b7 ff
	ff		 mov	 eax, DWORD PTR _message$8[ebp+8]
  004d0	89 85 a4 b7 ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  004d6	8b 8d a4 b7 ff
	ff		 mov	 ecx, DWORD PTR $T21[ebp]
  004dc	89 8d a0 b7 ff
	ff		 mov	 DWORD PTR $T20[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  004e2	8b 95 a0 b7 ff
	ff		 mov	 edx, DWORD PTR $T20[ebp]
  004e8	89 95 9c b7 ff
	ff		 mov	 DWORD PTR $T19[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  004ee	8b 85 9c b7 ff
	ff		 mov	 eax, DWORD PTR $T19[ebp]
  004f4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004f7	89 8d 90 b7 ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
; File g:\网狐\开发的模块\服务端\系统模块\第三方库\protobuf\include\google\protobuf\arenastring.h

; 225  :   inline const ::std::string& GetNoArena() const { return *ptr_; }

  004fd	8b 95 54 b7 ff
	ff		 mov	 edx, DWORD PTR _message$8[ebp+8]
  00503	89 95 98 b7 ff
	ff		 mov	 DWORD PTR $T18[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00509	8b 85 98 b7 ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  0050f	89 85 94 b7 ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00515	8b 8d 94 b7 ff
	ff		 mov	 ecx, DWORD PTR $T17[ebp]
  0051b	89 8d d4 b7 ff
	ff		 mov	 DWORD PTR $T28[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00521	8b 95 d4 b7 ff
	ff		 mov	 edx, DWORD PTR $T28[ebp]
  00527	83 c2 04	 add	 edx, 4
  0052a	89 95 b8 b7 ff
	ff		 mov	 DWORD PTR __Result$25[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00530	8b 85 d4 b7 ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  00536	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0053a	72 0c		 jb	 SHORT $LN93@HandleWebs
  0053c	c7 85 bc b7 ff
	ff 01 00 00 00	 mov	 DWORD PTR tv403[ebp], 1
  00546	eb 0a		 jmp	 SHORT $LN91@HandleWebs
$LN93@HandleWebs:
  00548	c7 85 bc b7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv403[ebp], 0
$LN91@HandleWebs:

; 1815 : 		if (_Large_string_engaged())

  00552	0f b6 8d bc b7
	ff ff		 movzx	 ecx, BYTE PTR tv403[ebp]
  00559	85 c9		 test	 ecx, ecx
  0055b	74 0f		 je	 SHORT $LN88@HandleWebs
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0055d	8b 95 d4 b7 ff
	ff		 mov	 edx, DWORD PTR $T28[ebp]
  00563	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00566	89 85 b8 b7 ff
	ff		 mov	 DWORD PTR __Result$25[ebp], eax
$LN88@HandleWebs:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  0056c	8b 8d b8 b7 ff
	ff		 mov	 ecx, DWORD PTR __Result$25[ebp]
  00572	89 8d 8c b7 ff
	ff		 mov	 DWORD PTR $T15[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1140 : 					m_pITCPNetworkItemSink->OnEventSocketRead(Command, (void*)message.data().c_str(), message.data().size(), this);

  00578	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0057e	52		 push	 edx
  0057f	0f b7 85 90 b7
	ff ff		 movzx	 eax, WORD PTR $T16[ebp]
  00586	50		 push	 eax
  00587	8b 8d 8c b7 ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  0058d	51		 push	 ecx
  0058e	8b 95 dc b7 ff
	ff		 mov	 edx, DWORD PTR _Command$30[ebp]
  00594	52		 push	 edx
  00595	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0059b	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005a1	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  005a4	8b 12		 mov	 edx, DWORD PTR [edx]
  005a6	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  005a9	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  005ac	ff d0		 call	 eax
$LN15@HandleWebs:

; 1141 : 				}
; 1142 : 				break;

  005ae	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  005b2	8d 8d cc b6 ff
	ff		 lea	 ecx, DWORD PTR _info$2[ebp]
  005b8	e8 00 00 00 00	 call	 ??1info@NullPmd@@UAE@XZ	; NullPmd::info::~info
  005bd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  005c1	8d 8d f4 b6 ff
	ff		 lea	 ecx, DWORD PTR _command$3[ebp]
  005c7	e8 00 00 00 00	 call	 ??1command@NullPmd@@UAE@XZ ; NullPmd::command::~command
  005cc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  005d0	8d 8d 28 b7 ff
	ff		 lea	 ecx, DWORD PTR _head$5[ebp]
  005d6	e8 00 00 00 00	 call	 ??1head@NullPmd@@UAE@XZ	; NullPmd::head::~head
  005db	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  005df	8d 8d 4c b7 ff
	ff		 lea	 ecx, DWORD PTR _message$8[ebp]
  005e5	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
  005ea	e9 ad 00 00 00	 jmp	 $LN4@HandleWebs

; 1143 : 			}

  005ef	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
  005f3	8d 8d cc b6 ff
	ff		 lea	 ecx, DWORD PTR _info$2[ebp]
  005f9	e8 00 00 00 00	 call	 ??1info@NullPmd@@UAE@XZ	; NullPmd::info::~info
  005fe	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00602	8d 8d f4 b6 ff
	ff		 lea	 ecx, DWORD PTR _command$3[ebp]
  00608	e8 00 00 00 00	 call	 ??1command@NullPmd@@UAE@XZ ; NullPmd::command::~command
  0060d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00611	8d 8d 28 b7 ff
	ff		 lea	 ecx, DWORD PTR _head$5[ebp]
  00617	e8 00 00 00 00	 call	 ??1head@NullPmd@@UAE@XZ	; NullPmd::head::~head
  0061c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00620	8d 8d 4c b7 ff
	ff		 lea	 ecx, DWORD PTR _message$8[ebp]
  00626	e8 00 00 00 00	 call	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
$LN18@HandleWebs:

; 1144 : 
; 1145 : 			case WS_PING_FRAME: {
; 1146 : 				//printf ("receive ping frame,framesize:%d\n", frameSize);
; 1147 : 				g_TraceServiceManager.TraceString("收到WS_PING_FRAME消息", TraceLevel_Normal);

  0062b	6a 01		 push	 1
  0062d	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@KIEOHCJC@?J?U?$LF?$LNWS_PING_FRAME?O?$PL?O?$KC@
  00632	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00637	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1148 : 				break;

  0063c	eb 5e		 jmp	 SHORT $LN4@HandleWebs
$LN19@HandleWebs:

; 1149 : 			}
; 1150 : 
; 1151 : 			case WS_PONG_FRAME: {
; 1152 : 				// printf ("receive pong frame,framesize:%d\n", frameSize);
; 1153 : 				break;

  0063e	eb 5c		 jmp	 SHORT $LN4@HandleWebs
$LN20@HandleWebs:

; 1154 : 			}
; 1155 : 
; 1156 : 			case WS_CLOSE_FRAME: {
; 1157 : 				//printf ("receive close frame\n");
; 1158 : 				g_TraceServiceManager.TraceString("收到WS_CLOSE_FRAME消息", TraceLevel_Normal);

  00640	6a 01		 push	 1
  00642	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KPFBJOAM@?J?U?$LF?$LNWS_CLOSE_FRAME?O?$PL?O?$KC@
  00647	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0064c	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1159 : 				CloseSocket (m_wRountID);

  00651	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00657	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  0065b	52		 push	 edx
  0065c	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00662	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1160 : 				return false;

  00667	32 c0		 xor	 al, al
  00669	e9 a0 01 00 00	 jmp	 $LN22@HandleWebs
$LN21@HandleWebs:

; 1161 : 			}
; 1162 : 
; 1163 : 			default: {
; 1164 : 				//LOG_WARN(_T("receive unknow frame,close socket,type:%d"), (int)type);
; 1165 : 				g_TraceServiceManager.TraceString("收到default消息", TraceLevel_Normal);

  0066e	6a 01		 push	 1
  00670	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LDBHEJCC@?J?U?$LF?$LNdefault?O?$PL?O?$KC@
  00675	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0067a	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1166 : 				CloseSocket (m_wRountID);

  0067f	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00685	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00689	51		 push	 ecx
  0068a	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00690	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1167 : 				return false;

  00695	32 c0		 xor	 al, al
  00697	e9 72 01 00 00	 jmp	 $LN22@HandleWebs
$LN4@HandleWebs:

; 1168 : 			}
; 1169 : 			}
; 1170 : 
; 1171 : 			//删除缓存数据
; 1172 : 			m_wRecvSize -= frameSize;

  0069c	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006a2	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  006a6	2b 85 d0 b7 ff
	ff		 sub	 eax, DWORD PTR _frameSize$27[ebp]
  006ac	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006b2	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 1173 : 			MoveMemory(m_cbRecvBuf, m_cbRecvBuf + frameSize, m_wRecvSize);

  006b6	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006bc	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  006c0	50		 push	 eax
  006c1	8b 8d d0 b7 ff
	ff		 mov	 ecx, DWORD PTR _frameSize$27[ebp]
  006c7	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006cd	8d 44 0a 4c	 lea	 eax, DWORD PTR [edx+ecx+76]
  006d1	50		 push	 eax
  006d2	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006d8	83 c1 4c	 add	 ecx, 76			; 0000004cH
  006db	51		 push	 ecx
  006dc	e8 00 00 00 00	 call	 _memmove
  006e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1174 : 		}

  006e4	e9 cc f9 ff ff	 jmp	 $LN2@HandleWebs
$LN3@HandleWebs:

; 1175 : 	}

  006e9	e9 f5 00 00 00	 jmp	 $LN24@HandleWebs
__catch$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$0:

; 1176 : 	catch (LPCTSTR pszMessage) {
; 1177 : 		// 错误信息
; 1178 : 		TCHAR szString[512] = TEXT("");

  006ee	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  006f4	88 95 ec f9 ff
	ff		 mov	 BYTE PTR _szString$35[ebp], dl
  006fa	68 ff 01 00 00	 push	 511			; 000001ffH
  006ff	6a 00		 push	 0
  00701	8d 85 ed f9 ff
	ff		 lea	 eax, DWORD PTR _szString$35[ebp+1]
  00707	50		 push	 eax
  00708	e8 00 00 00 00	 call	 _memset
  0070d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1179 : 		_sntprintf(szString, CountArray(szString), TEXT("HandleWebsocketRecv 异常:%s"), pszMessage);

  00710	8b 8d 20 b7 ff
	ff		 mov	 ecx, DWORD PTR _pszMessage$4[ebp]
  00716	51		 push	 ecx
  00717	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KAJJAILJ@HandleWebsocketRecv?5?R?l?$LD?$KD?3?$CFs@
  0071c	68 00 02 00 00	 push	 512			; 00000200H
  00721	8d 95 ec f9 ff
	ff		 lea	 edx, DWORD PTR _szString$35[ebp]
  00727	52		 push	 edx
  00728	e8 00 00 00 00	 call	 __snprintf
  0072d	83 c4 10	 add	 esp, 16			; 00000010H

; 1180 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00730	6a 03		 push	 3
  00732	8d 85 ec f9 ff
	ff		 lea	 eax, DWORD PTR _szString$35[ebp]
  00738	50		 push	 eax
  00739	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0073e	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1181 : 		return false;

  00743	c6 85 e1 b7 ff
	ff 00		 mov	 BYTE PTR $T31[ebp], 0
  0074a	b8 00 00 00 00	 mov	 eax, $LN33@HandleWebs
  0074f	c3		 ret	 0

; 1182 : 	}

  00750	b8 00 00 00 00	 mov	 eax, $LN24@HandleWebs
  00755	c3		 ret	 0
__catch$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$1:

; 1183 : 	catch (...) {
; 1184 : 		// 错误信息
; 1185 : 		TCHAR szString[512] = TEXT("");

  00756	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_00CNPNBAHC@@
  0075c	88 8d ec f7 ff
	ff		 mov	 BYTE PTR _szString$34[ebp], cl
  00762	68 ff 01 00 00	 push	 511			; 000001ffH
  00767	6a 00		 push	 0
  00769	8d 95 ed f7 ff
	ff		 lea	 edx, DWORD PTR _szString$34[ebp+1]
  0076f	52		 push	 edx
  00770	e8 00 00 00 00	 call	 _memset
  00775	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1186 : 		_sntprintf(szString, CountArray(szString), TEXT("Index=%ld，RountID=%ld，HandleWebsocketRecv 发生异常"), m_wIndex, m_wRountID);

  00778	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0077e	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00782	51		 push	 ecx
  00783	8b 95 e8 b7 ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00789	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  0078d	50		 push	 eax
  0078e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@DAAPGLPI@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMHandleW@
  00793	68 00 02 00 00	 push	 512			; 00000200H
  00798	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _szString$34[ebp]
  0079e	51		 push	 ecx
  0079f	e8 00 00 00 00	 call	 __snprintf
  007a4	83 c4 14	 add	 esp, 20			; 00000014H

; 1187 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  007a7	6a 03		 push	 3
  007a9	8d 95 ec f7 ff
	ff		 lea	 edx, DWORD PTR _szString$34[ebp]
  007af	52		 push	 edx
  007b0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  007b5	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1188 : 		CloseSocket(m_wRountID);

  007ba	8b 85 e8 b7 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007c0	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  007c4	51		 push	 ecx
  007c5	8b 8d e8 b7 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007cb	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1189 : 		return false;

  007d0	c6 85 e2 b7 ff
	ff 00		 mov	 BYTE PTR $T32[ebp], 0
  007d7	b8 00 00 00 00	 mov	 eax, $LN35@HandleWebs
  007dc	c3		 ret	 0

; 1190 : 	}

  007dd	b8 00 00 00 00	 mov	 eax, $LN24@HandleWebs
  007e2	c3		 ret	 0
$LN24@HandleWebs:
  007e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  007ea	eb 0f		 jmp	 SHORT $LN34@HandleWebs
$LN35@HandleWebs:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
  007ec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1189 : 		return false;

  007f3	8a 85 e2 b7 ff
	ff		 mov	 al, BYTE PTR $T32[ebp]
  007f9	eb 13		 jmp	 SHORT $LN22@HandleWebs
$LN34@HandleWebs:
  007fb	eb 0f		 jmp	 SHORT $LN32@HandleWebs
$LN33@HandleWebs:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
  007fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1181 : 		return false;

  00804	8a 85 e1 b7 ff
	ff		 mov	 al, BYTE PTR $T31[ebp]
  0080a	eb 02		 jmp	 SHORT $LN22@HandleWebs
$LN32@HandleWebs:

; 1191 : 
; 1192 : 	return true;

  0080c	b0 01		 mov	 al, 1
$LN22@HandleWebs:

; 1193 : }

  0080e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00811	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00818	59		 pop	 ecx
  00819	5f		 pop	 edi
  0081a	5e		 pop	 esi
  0081b	5b		 pop	 ebx
  0081c	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0081f	33 cd		 xor	 ecx, ebp
  00821	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00826	8b e5		 mov	 esp, ebp
  00828	5d		 pop	 ebp
  00829	c3		 ret	 0
  0082a	66 90		 npad	 2
$LN101@HandleWebs:
  0082c	00 00 00 00	 DD	 $LN10@HandleWebs
  00830	00 00 00 00	 DD	 $LN11@HandleWebs
  00834	00 00 00 00	 DD	 $LN20@HandleWebs
  00838	00 00 00 00	 DD	 $LN21@HandleWebs
$LN97@HandleWebs:
  0083c	00		 DB	 0
  0083d	00		 DB	 0
  0083e	03		 DB	 3
  0083f	03		 DB	 3
  00840	03		 DB	 3
  00841	03		 DB	 3
  00842	03		 DB	 3
  00843	03		 DB	 3
  00844	03		 DB	 3
  00845	03		 DB	 3
  00846	03		 DB	 3
  00847	03		 DB	 3
  00848	03		 DB	 3
  00849	03		 DB	 3
  0084a	03		 DB	 3
  0084b	03		 DB	 3
  0084c	03		 DB	 3
  0084d	03		 DB	 3
  0084e	03		 DB	 3
  0084f	03		 DB	 3
  00850	03		 DB	 3
  00851	03		 DB	 3
  00852	03		 DB	 3
  00853	03		 DB	 3
  00854	03		 DB	 3
  00855	03		 DB	 3
  00856	03		 DB	 3
  00857	03		 DB	 3
  00858	03		 DB	 3
  00859	03		 DB	 3
  0085a	03		 DB	 3
  0085b	03		 DB	 3
  0085c	03		 DB	 3
  0085d	03		 DB	 3
  0085e	03		 DB	 3
  0085f	03		 DB	 3
  00860	03		 DB	 3
  00861	03		 DB	 3
  00862	03		 DB	 3
  00863	03		 DB	 3
  00864	03		 DB	 3
  00865	03		 DB	 3
  00866	03		 DB	 3
  00867	03		 DB	 3
  00868	03		 DB	 3
  00869	03		 DB	 3
  0086a	03		 DB	 3
  0086b	03		 DB	 3
  0086c	03		 DB	 3
  0086d	03		 DB	 3
  0086e	03		 DB	 3
  0086f	03		 DB	 3
  00870	03		 DB	 3
  00871	03		 DB	 3
  00872	03		 DB	 3
  00873	03		 DB	 3
  00874	03		 DB	 3
  00875	03		 DB	 3
  00876	03		 DB	 3
  00877	03		 DB	 3
  00878	03		 DB	 3
  00879	03		 DB	 3
  0087a	03		 DB	 3
  0087b	03		 DB	 3
  0087c	03		 DB	 3
  0087d	03		 DB	 3
  0087e	03		 DB	 3
  0087f	03		 DB	 3
  00880	03		 DB	 3
  00881	03		 DB	 3
  00882	03		 DB	 3
  00883	03		 DB	 3
  00884	03		 DB	 3
  00885	03		 DB	 3
  00886	03		 DB	 3
  00887	03		 DB	 3
  00888	03		 DB	 3
  00889	03		 DB	 3
  0088a	03		 DB	 3
  0088b	03		 DB	 3
  0088c	03		 DB	 3
  0088d	03		 DB	 3
  0088e	03		 DB	 3
  0088f	03		 DB	 3
  00890	03		 DB	 3
  00891	03		 DB	 3
  00892	03		 DB	 3
  00893	03		 DB	 3
  00894	03		 DB	 3
  00895	03		 DB	 3
  00896	03		 DB	 3
  00897	03		 DB	 3
  00898	03		 DB	 3
  00899	03		 DB	 3
  0089a	03		 DB	 3
  0089b	03		 DB	 3
  0089c	03		 DB	 3
  0089d	03		 DB	 3
  0089e	03		 DB	 3
  0089f	03		 DB	 3
  008a0	03		 DB	 3
  008a1	03		 DB	 3
  008a2	03		 DB	 3
  008a3	03		 DB	 3
  008a4	03		 DB	 3
  008a5	03		 DB	 3
  008a6	03		 DB	 3
  008a7	03		 DB	 3
  008a8	03		 DB	 3
  008a9	03		 DB	 3
  008aa	03		 DB	 3
  008ab	03		 DB	 3
  008ac	03		 DB	 3
  008ad	03		 DB	 3
  008ae	03		 DB	 3
  008af	03		 DB	 3
  008b0	03		 DB	 3
  008b1	03		 DB	 3
  008b2	03		 DB	 3
  008b3	03		 DB	 3
  008b4	03		 DB	 3
  008b5	03		 DB	 3
  008b6	03		 DB	 3
  008b7	03		 DB	 3
  008b8	03		 DB	 3
  008b9	03		 DB	 3
  008ba	03		 DB	 3
  008bb	03		 DB	 3
  008bc	01		 DB	 1
  008bd	01		 DB	 1
  008be	03		 DB	 3
  008bf	03		 DB	 3
  008c0	03		 DB	 3
  008c1	03		 DB	 3
  008c2	03		 DB	 3
  008c3	02		 DB	 2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$3:
  00000	8d 8d 4c b7 ff
	ff		 lea	 ecx, DWORD PTR _message$8[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1message@NullPmd@@UAE@XZ ; NullPmd::message::~message
__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$4:
  0000b	8d 8d 28 b7 ff
	ff		 lea	 ecx, DWORD PTR _head$5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1head@NullPmd@@UAE@XZ	; NullPmd::head::~head
__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$5:
  00016	8d 8d f4 b6 ff
	ff		 lea	 ecx, DWORD PTR _command$3[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1command@NullPmd@@UAE@XZ ; NullPmd::command::~command
__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$6:
  00021	8d 8d cc b6 ff
	ff		 lea	 ecx, DWORD PTR _info$2[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1info@NullPmd@@UAE@XZ	; NullPmd::info::~info
__unwindfunclet$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ$7:
  0002c	8d 8d d8 b7 ff
	ff		 lea	 ecx, DWORD PTR _aa$29[ebp]
  00032	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ:
  00038	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003f	8b 8a c8 b6 ff
	ff		 mov	 ecx, DWORD PTR [edx-18744]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?HandleWebsocketRecv@CTCPNetworkItem@@AAE_NXZ ENDP	; CTCPNetworkItem::HandleWebsocketRecv
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ
_TEXT	SEGMENT
_pszMessage$2 = -17492					; size = 4
_pDataBuffer$3 = -17488					; size = 4
$T4 = -17484						; size = 4
tv147 = -17480						; size = 4
tv261 = -17476						; size = 4
$T5 = -17472						; size = 4
$T6 = -17468						; size = 4
$T7 = -17464						; size = 4
_pHead$8 = -17460					; size = 4
_Command$9 = -17456					; size = 4
_wDataSize$10 = -17452					; size = 2
tv262 = -17446						; size = 2
_wRealySize$11 = -17444					; size = 2
$T12 = -17438						; size = 1
$T13 = -17437						; size = 1
_wPacketSize$14 = -17436				; size = 2
_this$ = -17432						; size = 4
_cbBuffer$15 = -17428					; size = 16384
_szString$16 = -1044					; size = 512
_szString$17 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ PROC		; CTCPNetworkItem::CheckIsWinSocket, COMDAT
; _this$ = ecx

; 1201 : bool CTCPNetworkItem::CheckIsWinSocket() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	b8 44 44 00 00	 mov	 eax, 17476		; 00004444H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00036	89 8d e8 bb ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1202 : 	//处理数据
; 1203 : 	try {

  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1204 : 		BYTE cbBuffer[SOCKET_TCP_BUFFER];
; 1205 : 		TCP_Head * pHead = (TCP_Head *)m_cbRecvBuf;

  00043	8b 85 e8 bb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 c0 4c	 add	 eax, 76			; 0000004cH
  0004c	89 85 cc bb ff
	ff		 mov	 DWORD PTR _pHead$8[ebp], eax
$LN2@CheckIsWin:

; 1206 : 		while (m_wRecvSize >= sizeof(TCP_Head)) {

  00052	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00058	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  0005c	83 fa 08	 cmp	 edx, 8
  0005f	0f 82 2d 02 00
	00		 jb	 $LN3@CheckIsWin

; 1207 : 			//效验数据
; 1208 : 			WORD wPacketSize = pHead->TCPInfo.wPacketSize;

  00065	8b 85 cc bb ff
	ff		 mov	 eax, DWORD PTR _pHead$8[ebp]
  0006b	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  0006f	66 89 8d e4 bb
	ff ff		 mov	 WORD PTR _wPacketSize$14[ebp], cx

; 1209 : 
; 1210 : 			if (wPacketSize > SOCKET_TCP_BUFFER) {

  00076	0f b7 95 e4 bb
	ff ff		 movzx	 edx, WORD PTR _wPacketSize$14[ebp]
  0007d	81 fa 00 40 00
	00		 cmp	 edx, 16384		; 00004000H
  00083	7e 1b		 jle	 SHORT $LN7@CheckIsWin

; 1211 : 				throw TEXT("数据包超长");

  00085	c7 85 c8 bb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], OFFSET ??_C@_0L@DAPODOBD@?J?$PN?$LO?$NN?$LA?$PM?$LD?$KM?$LD?$KE@
  0008f	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00094	8d 85 c8 bb ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN7@CheckIsWin:

; 1212 : 			}
; 1213 : 
; 1214 : 			if (wPacketSize < sizeof(TCP_Head)) {

  000a0	0f b7 8d e4 bb
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$14[ebp]
  000a7	83 f9 08	 cmp	 ecx, 8
  000aa	73 1b		 jae	 SHORT $LN8@CheckIsWin

; 1215 : 				throw TEXT("数据包非法");

  000ac	c7 85 c4 bb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], OFFSET ??_C@_0L@ICOFAPAB@?J?$PN?$LO?$NN?$LA?$PM?$LH?G?$LH?$KI@
  000b6	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000bb	8d 95 c4 bb ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  000c1	52		 push	 edx
  000c2	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@CheckIsWin:

; 1216 : 			}
; 1217 : 
; 1218 : 			//if (pHead->TCPInfo.cbVersion != SOCKET_TCP_VER) throw TEXT("数据包版本错误");
; 1219 : 			if (pHead->TCPInfo.cbDataKind != DK_MAPPED) {

  000c7	8b 85 cc bb ff
	ff		 mov	 eax, DWORD PTR _pHead$8[ebp]
  000cd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d0	83 f9 01	 cmp	 ecx, 1
  000d3	74 1b		 je	 SHORT $LN9@CheckIsWin

; 1220 : 				throw TEXT("数据包版本错误");

  000d5	c7 85 c0 bb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], OFFSET ??_C@_0P@BBEPCAEF@?J?$PN?$LO?$NN?$LA?$PM?$LA?f?$LB?$LO?$LE?m?N?s@
  000df	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000e4	8d 95 c0 bb ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000ea	52		 push	 edx
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN9@CheckIsWin:

; 1221 : 			}
; 1222 : 
; 1223 : 			if (m_wRecvSize < wPacketSize) {

  000f0	0f b7 85 e4 bb
	ff ff		 movzx	 eax, WORD PTR _wPacketSize$14[ebp]
  000f7	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	0f b7 51 4a	 movzx	 edx, WORD PTR [ecx+74]
  00101	3b d0		 cmp	 edx, eax
  00103	7d 05		 jge	 SHORT $LN10@CheckIsWin

; 1224 : 				break;

  00105	e9 88 01 00 00	 jmp	 $LN3@CheckIsWin
$LN10@CheckIsWin:

; 1225 : 			}
; 1226 : 
; 1227 : 			//提取数据
; 1228 : 			CopyMemory(cbBuffer, m_cbRecvBuf, wPacketSize);

  0010a	0f b7 85 e4 bb
	ff ff		 movzx	 eax, WORD PTR _wPacketSize$14[ebp]
  00111	50		 push	 eax
  00112	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00118	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0011b	51		 push	 ecx
  0011c	8d 95 ec bb ff
	ff		 lea	 edx, DWORD PTR _cbBuffer$15[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _memcpy
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1229 : 			WORD wRealySize = CrevasseBuffer(cbBuffer, wPacketSize);

  0012b	0f b7 85 e4 bb
	ff ff		 movzx	 eax, WORD PTR _wPacketSize$14[ebp]
  00132	50		 push	 eax
  00133	8d 8d ec bb ff
	ff		 lea	 ecx, DWORD PTR _cbBuffer$15[ebp]
  00139	51		 push	 ecx
  0013a	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00140	e8 00 00 00 00	 call	 ?CrevasseBuffer@CTCPNetworkItem@@AAEGQAEG@Z ; CTCPNetworkItem::CrevasseBuffer
  00145	66 89 85 da bb
	ff ff		 mov	 WORD PTR tv262[ebp], ax
  0014c	66 8b 95 da bb
	ff ff		 mov	 dx, WORD PTR tv262[ebp]
  00153	66 89 95 dc bb
	ff ff		 mov	 WORD PTR _wRealySize$11[ebp], dx

; 1230 : 			ASSERT(wRealySize >= sizeof(TCP_Head));

  0015a	0f b7 85 dc bb
	ff ff		 movzx	 eax, WORD PTR _wRealySize$11[ebp]
  00161	83 f8 08	 cmp	 eax, 8
  00164	73 1f		 jae	 SHORT $LN16@CheckIsWin
  00166	68 ce 04 00 00	 push	 1230			; 000004ceH
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00170	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00175	89 85 bc bb ff
	ff		 mov	 DWORD PTR tv261[ebp], eax
  0017b	83 bd bc bb ff
	ff 00		 cmp	 DWORD PTR tv261[ebp], 0
  00182	74 01		 je	 SHORT $LN16@CheckIsWin
  00184	cc		 int	 3
$LN16@CheckIsWin:

; 1231 : 			m_dwRecvPacketCount++;

  00185	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0018b	8b 82 58 40 01
	00		 mov	 eax, DWORD PTR [edx+82008]
  00191	83 c0 01	 add	 eax, 1
  00194	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	89 81 58 40 01
	00		 mov	 DWORD PTR [ecx+82008], eax

; 1232 : 			//解释数据
; 1233 : 			WORD wDataSize = wRealySize - sizeof(TCP_Head);

  001a0	0f b7 95 dc bb
	ff ff		 movzx	 edx, WORD PTR _wRealySize$11[ebp]
  001a7	83 ea 08	 sub	 edx, 8
  001aa	66 89 95 d4 bb
	ff ff		 mov	 WORD PTR _wDataSize$10[ebp], dx

; 1234 : 			void * pDataBuffer = cbBuffer + sizeof(TCP_Head);

  001b1	8d 85 f4 bb ff
	ff		 lea	 eax, DWORD PTR _cbBuffer$15[ebp+8]
  001b7	89 85 b0 bb ff
	ff		 mov	 DWORD PTR _pDataBuffer$3[ebp], eax

; 1235 : 			TCP_Command Command = ((TCP_Head *)cbBuffer)->CommandInfo;

  001bd	8b 8d f0 bb ff
	ff		 mov	 ecx, DWORD PTR _cbBuffer$15[ebp+4]
  001c3	89 8d d0 bb ff
	ff		 mov	 DWORD PTR _Command$9[ebp], ecx

; 1236 : 
; 1237 : 			//内核命令
; 1238 : 			if (Command.wMainCmdID == MDM_KN_COMMAND) {

  001c9	0f b7 95 d0 bb
	ff ff		 movzx	 edx, WORD PTR _Command$9[ebp]
  001d0	85 d2		 test	 edx, edx
  001d2	75 37		 jne	 SHORT $LN11@CheckIsWin

; 1239 : 				switch (Command.wSubCmdID) {

  001d4	0f b7 85 d2 bb
	ff ff		 movzx	 eax, WORD PTR _Command$9[ebp+2]
  001db	89 85 b8 bb ff
	ff		 mov	 DWORD PTR tv147[ebp], eax
  001e1	83 bd b8 bb ff
	ff 01		 cmp	 DWORD PTR tv147[ebp], 1
  001e8	74 02		 je	 SHORT $LN13@CheckIsWin
  001ea	eb 02		 jmp	 SHORT $LN14@CheckIsWin
$LN13@CheckIsWin:

; 1240 : 					case SUB_KN_DETECT_SOCKET: {	//网络检测
; 1241 : 						break;

  001ec	eb 1b		 jmp	 SHORT $LN4@CheckIsWin
$LN14@CheckIsWin:

; 1242 : 					}
; 1243 : 
; 1244 : 					default: {
; 1245 : 						throw TEXT("非法命令码");

  001ee	c7 85 b4 bb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], OFFSET ??_C@_0L@HPNHKCLL@?$LH?G?$LH?$KI?C?$PM?A?n?B?k@
  001f8	68 00 00 00 00	 push	 OFFSET __TI2PAD
  001fd	8d 8d b4 bb ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00203	51		 push	 ecx
  00204	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN4@CheckIsWin:

; 1246 : 					}
; 1247 : 				}
; 1248 : 			}
; 1249 : 			else {

  00209	eb 36		 jmp	 SHORT $LN12@CheckIsWin
$LN11@CheckIsWin:

; 1250 : 				//消息处理
; 1251 : 				m_pITCPNetworkItemSink->OnEventSocketRead(Command, pDataBuffer, wDataSize, this);

  0020b	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00211	52		 push	 edx
  00212	0f b7 85 d4 bb
	ff ff		 movzx	 eax, WORD PTR _wDataSize$10[ebp]
  00219	50		 push	 eax
  0021a	8b 8d b0 bb ff
	ff		 mov	 ecx, DWORD PTR _pDataBuffer$3[ebp]
  00220	51		 push	 ecx
  00221	8b 95 d0 bb ff
	ff		 mov	 edx, DWORD PTR _Command$9[ebp]
  00227	52		 push	 edx
  00228	8b 85 e8 bb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0022e	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00234	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00237	8b 12		 mov	 edx, DWORD PTR [edx]
  00239	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0023c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0023f	ff d0		 call	 eax
$LN12@CheckIsWin:

; 1252 : 			}
; 1253 : 
; 1254 : 			//删除缓存数据
; 1255 : 			m_wRecvSize -= wPacketSize;

  00241	0f b7 8d e4 bb
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$14[ebp]
  00248	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0024e	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00252	2b c1		 sub	 eax, ecx
  00254	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	66 89 41 4a	 mov	 WORD PTR [ecx+74], ax

; 1256 : 			MoveMemory(m_cbRecvBuf, m_cbRecvBuf + wPacketSize, m_wRecvSize);

  0025e	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00264	0f b7 42 4a	 movzx	 eax, WORD PTR [edx+74]
  00268	50		 push	 eax
  00269	0f b7 8d e4 bb
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$14[ebp]
  00270	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00276	8d 44 0a 4c	 lea	 eax, DWORD PTR [edx+ecx+76]
  0027a	50		 push	 eax
  0027b	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00281	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00284	51		 push	 ecx
  00285	e8 00 00 00 00	 call	 _memmove
  0028a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1257 : 		}

  0028d	e9 c0 fd ff ff	 jmp	 $LN2@CheckIsWin
$LN3@CheckIsWin:

; 1258 : 	}

  00292	e9 f5 00 00 00	 jmp	 $LN17@CheckIsWin
__catch$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$0:

; 1259 : 	catch (LPCTSTR pszMessage) {
; 1260 : 		// 错误信息
; 1261 : 		TCHAR szString[512] = TEXT("");

  00297	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ??_C@_00CNPNBAHC@@
  0029d	88 95 ec fd ff
	ff		 mov	 BYTE PTR _szString$17[ebp], dl
  002a3	68 ff 01 00 00	 push	 511			; 000001ffH
  002a8	6a 00		 push	 0
  002aa	8d 85 ed fd ff
	ff		 lea	 eax, DWORD PTR _szString$17[ebp+1]
  002b0	50		 push	 eax
  002b1	e8 00 00 00 00	 call	 _memset
  002b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1262 : 		_sntprintf(szString, CountArray(szString), TEXT("CheckIsWinSocket 非weebsocket:%s"), pszMessage);

  002b9	8b 8d ac bb ff
	ff		 mov	 ecx, DWORD PTR _pszMessage$2[ebp]
  002bf	51		 push	 ecx
  002c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BHAJGHNJ@CheckIsWinSocket?5?$LH?Gweebsocket?3?$CF@
  002c5	68 00 02 00 00	 push	 512			; 00000200H
  002ca	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _szString$17[ebp]
  002d0	52		 push	 edx
  002d1	e8 00 00 00 00	 call	 __snprintf
  002d6	83 c4 10	 add	 esp, 16			; 00000010H

; 1263 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Normal);

  002d9	6a 01		 push	 1
  002db	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szString$17[ebp]
  002e1	50		 push	 eax
  002e2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  002e7	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1264 : 		return false;

  002ec	c6 85 e2 bb ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0
  002f3	b8 00 00 00 00	 mov	 eax, $LN21@CheckIsWin
  002f8	c3		 ret	 0

; 1265 : 	}

  002f9	b8 00 00 00 00	 mov	 eax, $LN17@CheckIsWin
  002fe	c3		 ret	 0
__catch$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ$1:

; 1266 : 	catch (...)
; 1267 : 	{
; 1268 : 		// 错误信息
; 1269 : 		TCHAR szString[512] = TEXT("");

  002ff	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ??_C@_00CNPNBAHC@@
  00305	88 8d ec fb ff
	ff		 mov	 BYTE PTR _szString$16[ebp], cl
  0030b	68 ff 01 00 00	 push	 511			; 000001ffH
  00310	6a 00		 push	 0
  00312	8d 95 ed fb ff
	ff		 lea	 edx, DWORD PTR _szString$16[ebp+1]
  00318	52		 push	 edx
  00319	e8 00 00 00 00	 call	 _memset
  0031e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1270 : 		_sntprintf(szString, CountArray(szString), TEXT("Index=%ld，RountID=%ld，CheckIsWinSocket 发生异常"), m_wIndex, m_wRountID);

  00321	8b 85 e8 bb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00327	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0032b	51		 push	 ecx
  0032c	8b 95 e8 bb ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00332	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00336	50		 push	 eax
  00337	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@OCAKDNJE@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMCheckIs@
  0033c	68 00 02 00 00	 push	 512			; 00000200H
  00341	8d 8d ec fb ff
	ff		 lea	 ecx, DWORD PTR _szString$16[ebp]
  00347	51		 push	 ecx
  00348	e8 00 00 00 00	 call	 __snprintf
  0034d	83 c4 14	 add	 esp, 20			; 00000014H

; 1271 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00350	6a 03		 push	 3
  00352	8d 95 ec fb ff
	ff		 lea	 edx, DWORD PTR _szString$16[ebp]
  00358	52		 push	 edx
  00359	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0035e	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1272 : 		CloseSocket(m_wRountID);

  00363	8b 85 e8 bb ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00369	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0036d	51		 push	 ecx
  0036e	8b 8d e8 bb ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00374	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1273 : 		return false;

  00379	c6 85 e3 bb ff
	ff 00		 mov	 BYTE PTR $T13[ebp], 0
  00380	b8 00 00 00 00	 mov	 eax, $LN23@CheckIsWin
  00385	c3		 ret	 0

; 1274 : 	}

  00386	b8 00 00 00 00	 mov	 eax, $LN17@CheckIsWin
  0038b	c3		 ret	 0
$LN17@CheckIsWin:
  0038c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00393	eb 0f		 jmp	 SHORT $LN22@CheckIsWin
$LN23@CheckIsWin:
  00395	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1273 : 		return false;

  0039c	8a 85 e3 bb ff
	ff		 mov	 al, BYTE PTR $T13[ebp]
  003a2	eb 13		 jmp	 SHORT $LN15@CheckIsWin
$LN22@CheckIsWin:
  003a4	eb 0f		 jmp	 SHORT $LN20@CheckIsWin
$LN21@CheckIsWin:
  003a6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 1264 : 		return false;

  003ad	8a 85 e2 bb ff
	ff		 mov	 al, BYTE PTR $T12[ebp]
  003b3	eb 02		 jmp	 SHORT $LN15@CheckIsWin
$LN20@CheckIsWin:

; 1275 : 
; 1276 : 	return true;

  003b5	b0 01		 mov	 al, 1
$LN15@CheckIsWin:

; 1277 : }

  003b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003c1	59		 pop	 ecx
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a a8 bb ff
	ff		 mov	 ecx, DWORD PTR [edx-17496]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckIsWinSocket@CTCPNetworkItem@@AAE_NXZ ENDP		; CTCPNetworkItem::CheckIsWinSocket
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z
_TEXT	SEGMENT
_iRetCode$2 = -576					; size = 4
_dwThancferred$3 = -572					; size = 4
$T4 = -568						; size = 4
tv200 = -564						; size = 4
tv194 = -560						; size = 4
tv139 = -556						; size = 4
_wSourceLen$5 = -552					; size = 2
_wPacketSize$6 = -548					; size = 2
$T7 = -541						; size = 1
_pOverLappedSend$8 = -540				; size = 4
_this$ = -536						; size = 4
_szString$9 = -532					; size = 512
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_data$ = 8						; size = 4
_len$ = 12						; size = 4
?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z PROC		; CTCPNetworkItem::SendRawData, COMDAT
; _this$ = ecx

; 1313 : bool CTCPNetworkItem::SendRawData(const char* data, int len) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00022	53		 push	 ebx
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00029	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00032	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 1314 : 	try

  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1315 : 	{
; 1316 : 		// 获取缓冲
; 1317 : 		WORD wPacketSize = len;

  0003f	66 8b 45 0c	 mov	 ax, WORD PTR _len$[ebp]
  00043	66 89 85 dc fd
	ff ff		 mov	 WORD PTR _wPacketSize$6[ebp], ax

; 1318 : 		COverLappedSend * pOverLappedSend = GetSendOverLapped(wPacketSize);

  0004a	6a 01		 push	 1
  0004c	0f b7 8d dc fd
	ff ff		 movzx	 ecx, WORD PTR _wPacketSize$6[ebp]
  00053	51		 push	 ecx
  00054	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?GetSendOverLapped@CTCPNetworkItem@@AAEPAVCOverLappedSend@@G_N@Z ; CTCPNetworkItem::GetSendOverLapped
  0005f	89 85 d4 fd ff
	ff		 mov	 DWORD PTR tv139[ebp], eax
  00065	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR tv139[ebp]
  0006b	89 95 e4 fd ff
	ff		 mov	 DWORD PTR _pOverLappedSend$8[ebp], edx

; 1319 : 		ASSERT(pOverLappedSend != NULL);

  00071	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _pOverLappedSend$8[ebp], 0
  00078	75 1f		 jne	 SHORT $LN8@SendRawDat
  0007a	68 27 05 00 00	 push	 1319			; 00000527H
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00084	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00089	89 85 d0 fd ff
	ff		 mov	 DWORD PTR tv194[ebp], eax
  0008f	83 bd d0 fd ff
	ff 00		 cmp	 DWORD PTR tv194[ebp], 0
  00096	74 01		 je	 SHORT $LN8@SendRawDat
  00098	cc		 int	 3
$LN8@SendRawDat:

; 1320 : 		if (pOverLappedSend == NULL) {

  00099	83 bd e4 fd ff
	ff 00		 cmp	 DWORD PTR _pOverLappedSend$8[ebp], 0
  000a0	75 1d		 jne	 SHORT $LN3@SendRawDat

; 1321 : 			CloseSocket(m_wRountID);

  000a2	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  000ac	52		 push	 edx
  000ad	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1322 : 			return false;

  000b8	32 c0		 xor	 al, al
  000ba	e9 b7 01 00 00	 jmp	 $LN1@SendRawDat
$LN3@SendRawDat:

; 1323 : 		}
; 1324 : 
; 1325 : 		// 变量定义
; 1326 : 		WORD wSourceLen = (WORD)pOverLappedSend->m_WSABuffer.len;

  000bf	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$8[ebp]
  000c5	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  000c9	66 89 8d d8 fd
	ff ff		 mov	 WORD PTR _wSourceLen$5[ebp], cx

; 1327 : 
; 1328 : 		// 附加数据
; 1329 : 		if (len > 0)

  000d0	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  000d4	7e 47		 jle	 SHORT $LN4@SendRawDat

; 1330 : 		{
; 1331 : 			ASSERT(data != NULL);

  000d6	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  000da	75 1f		 jne	 SHORT $LN9@SendRawDat
  000dc	68 33 05 00 00	 push	 1331			; 00000533H
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GEJOJCBK@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000e6	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000eb	89 85 cc fd ff
	ff		 mov	 DWORD PTR tv200[ebp], eax
  000f1	83 bd cc fd ff
	ff 00		 cmp	 DWORD PTR tv200[ebp], 0
  000f8	74 01		 je	 SHORT $LN9@SendRawDat
  000fa	cc		 int	 3
$LN9@SendRawDat:

; 1332 : 			CopyMemory(pOverLappedSend->m_cbBuffer + wSourceLen, data, len);

  000fb	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  000fe	50		 push	 eax
  000ff	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00102	51		 push	 ecx
  00103	0f b7 95 d8 fd
	ff ff		 movzx	 edx, WORD PTR _wSourceLen$5[ebp]
  0010a	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$8[ebp]
  00110	8d 4c 10 24	 lea	 ecx, DWORD PTR [eax+edx+36]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 _memcpy
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SendRawDat:

; 1333 : 		}
; 1334 : 
; 1335 : 		pOverLappedSend->m_WSABuffer.len += len;

  0011d	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR _pOverLappedSend$8[ebp]
  00123	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00126	03 45 0c	 add	 eax, DWORD PTR _len$[ebp]
  00129	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$8[ebp]
  0012f	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00132	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00138	8b 82 9c 40 01
	00		 mov	 eax, DWORD PTR [edx+82076]
  0013e	89 85 c8 fd ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1338 : 		if (m_OverLappedSendActive.GetCount() == 1) {

  00144	83 bd c8 fd ff
	ff 01		 cmp	 DWORD PTR $T4[ebp], 1
  0014b	75 7e		 jne	 SHORT $LN5@SendRawDat

; 1339 : 			DWORD dwThancferred = 0;

  0014d	c7 85 c4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwThancferred$3[ebp], 0

; 1340 : 
; 1341 : 			int iRetCode = WSASend(m_hSocketHandle, &pOverLappedSend->m_WSABuffer, 1, &dwThancferred, 0, &pOverLappedSend->m_OverLapped, NULL);

  00157	6a 00		 push	 0
  00159	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR _pOverLappedSend$8[ebp]
  0015f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00162	51		 push	 ecx
  00163	6a 00		 push	 0
  00165	8d 95 c4 fd ff
	ff		 lea	 edx, DWORD PTR _dwThancferred$3[ebp]
  0016b	52		 push	 edx
  0016c	6a 01		 push	 1
  0016e	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _pOverLappedSend$8[ebp]
  00174	83 c0 04	 add	 eax, 4
  00177	50		 push	 eax
  00178	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0017e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00181	52		 push	 edx
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  00188	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _iRetCode$2[ebp], eax

; 1342 : 			if ((iRetCode == SOCKET_ERROR) && (WSAGetLastError() != WSA_IO_PENDING)) {

  0018e	83 bd c0 fd ff
	ff ff		 cmp	 DWORD PTR _iRetCode$2[ebp], -1
  00195	75 2a		 jne	 SHORT $LN6@SendRawDat
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0019d	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  001a2	74 1d		 je	 SHORT $LN6@SendRawDat

; 1343 : 				CloseSocket(m_wRountID);

  001a4	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001aa	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  001ae	51		 push	 ecx
  001af	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1344 : 				return false;

  001ba	32 c0		 xor	 al, al
  001bc	e9 b5 00 00 00	 jmp	 $LN1@SendRawDat
$LN6@SendRawDat:

; 1345 : 			}
; 1346 : 			// 设置变量
; 1347 : 			m_bSendIng = true;

  001c1	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001c7	c6 42 44 01	 mov	 BYTE PTR [edx+68], 1
$LN5@SendRawDat:

; 1348 : 		}
; 1349 : 	}

  001cb	e9 8c 00 00 00	 jmp	 $LN10@SendRawDat
__catch$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z$0:

; 1350 : 	catch (...)
; 1351 : 	{
; 1352 : 		// 错误信息
; 1353 : 		TCHAR szString[512] = TEXT("");

  001d0	a0 00 00 00 00	 mov	 al, BYTE PTR ??_C@_00CNPNBAHC@@
  001d5	88 85 ec fd ff
	ff		 mov	 BYTE PTR _szString$9[ebp], al
  001db	68 ff 01 00 00	 push	 511			; 000001ffH
  001e0	6a 00		 push	 0
  001e2	8d 8d ed fd ff
	ff		 lea	 ecx, DWORD PTR _szString$9[ebp+1]
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 _memset
  001ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1354 : 		_sntprintf(szString, CountArray(szString), TEXT("Index=%ld，RountID=%ld，SendRawData 发生异常"), m_wIndex, m_wRountID);

  001f1	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001f7	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  001fb	50		 push	 eax
  001fc	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00202	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  00206	52		 push	 edx
  00207	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CFILDAFG@Index?$DN?$CFld?$KD?$KMRountID?$DN?$CFld?$KD?$KMSendRaw@
  0020c	68 00 02 00 00	 push	 512			; 00000200H
  00211	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _szString$9[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 __snprintf
  0021d	83 c4 14	 add	 esp, 20			; 00000014H

; 1355 : 		g_TraceServiceManager.TraceString(szString, TraceLevel_Exception);

  00220	6a 03		 push	 3
  00222	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _szString$9[ebp]
  00228	51		 push	 ecx
  00229	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  0022e	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1356 : 		CloseSocket(m_wRountID);

  00233	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00239	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  0023d	50		 push	 eax
  0023e	8b 8d e8 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00244	e8 00 00 00 00	 call	 ?CloseSocket@CTCPNetworkItem@@QAE_NG@Z ; CTCPNetworkItem::CloseSocket

; 1357 : 		return false;

  00249	c6 85 e3 fd ff
	ff 00		 mov	 BYTE PTR $T7[ebp], 0
  00250	b8 00 00 00 00	 mov	 eax, $LN13@SendRawDat
  00255	c3		 ret	 0

; 1358 : 	}

  00256	b8 00 00 00 00	 mov	 eax, $LN10@SendRawDat
  0025b	c3		 ret	 0
$LN10@SendRawDat:
  0025c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00263	eb 0f		 jmp	 SHORT $LN12@SendRawDat
$LN13@SendRawDat:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
  00265	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1357 : 		return false;

  0026c	8a 85 e3 fd ff
	ff		 mov	 al, BYTE PTR $T7[ebp]
  00272	eb 02		 jmp	 SHORT $LN1@SendRawDat
$LN12@SendRawDat:

; 1359 : 	return true;

  00274	b0 01		 mov	 al, 1
$LN1@SendRawDat:

; 1360 : }

  00276	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00279	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00280	59		 pop	 ecx
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5b		 pop	 ebx
  00284	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00287	33 cd		 xor	 ecx, ebp
  00289	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 8a bc fd ff
	ff		 mov	 ecx, DWORD PTR [edx-580]
  0000d	33 c8		 xor	 ecx, eax
  0000f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00014	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00017	33 c8		 xor	 ecx, eax
  00019	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ENDP		; CTCPNetworkItem::SendRawData
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z
_TEXT	SEGMENT
tv233 = -572						; size = 4
$T2 = -568						; size = 4
$T3 = -564						; size = 4
$T4 = -560						; size = 4
$T5 = -556						; size = 4
$T6 = -552						; size = 4
$T7 = -548						; size = 4
$T8 = -544						; size = 4
$T9 = -540						; size = 4
$T10 = -536						; size = 4
$T11 = -532						; size = 4
$T12 = -528						; size = 4
$T13 = -524						; size = 4
$T14 = -520						; size = 4
$T15 = -516						; size = 4
$T16 = -512						; size = 4
$T17 = -508						; size = 4
$T18 = -504						; size = 4
$T19 = -500						; size = 4
$T20 = -496						; size = 4
$T21 = -492						; size = 4
$T22 = -488						; size = 4
$T23 = -484						; size = 4
$T24 = -480						; size = 4
$T25 = -476						; size = 4
$T26 = -472						; size = 4
tv225 = -468						; size = 4
$T27 = -464						; size = 4
__Result$28 = -460					; size = 4
tv754 = -456						; size = 4
__Result$29 = -452					; size = 4
tv709 = -448						; size = 4
__Result$30 = -444					; size = 4
tv565 = -440						; size = 4
tv563 = -436						; size = 4
$T31 = -432						; size = 4
tv356 = -428						; size = 4
__Right$ = -424						; size = 4
tv307 = -420						; size = 4
__Result$32 = -416					; size = 4
tv304 = -412						; size = 4
$T33 = -408						; size = 4
$T34 = -404						; size = 4
$T35 = -400						; size = 4
$T36 = -396						; size = 4
$T37 = -390						; size = 1
$T38 = -389						; size = 1
_req$ = -388						; size = 4
_this$ = -384						; size = 4
$T39 = -380						; size = 1
$T40 = -379						; size = 1
$T41 = -378						; size = 1
$T42 = -377						; size = 1
_context$ = -376					; size = 108
$T43 = -268						; size = 28
_key$ = -240						; size = 28
$T44 = -212						; size = 28
$T45 = -184						; size = 28
$T46 = -156						; size = 28
_answer$ = -128						; size = 28
_msg$47 = -100						; size = 28
_ip$ = -72						; size = 28
_query$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_byteBuffer$ = 8					; size = 4
?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z PROC ; CTCPNetworkItem::handshake, COMDAT
; _this$ = ecx

; 1279 : bool CTCPNetworkItem::handshake(zl::net::ByteBuffer* byteBuffer) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 30 02 00
	00		 sub	 esp, 560		; 00000230H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 8d 80 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00031	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T31[ebp], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h

; 34   : 				: state_(kExpectRequestLine)

  0003b	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _context$[ebp], 0

; 35   : 			{

  00045	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp+4]
  0004b	e8 00 00 00 00	 call	 ??0HttpRequest@net@zl@@QAE@XZ ; zl::net::HttpRequest::HttpRequest
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1280 : 	zl::net::HttpContext context;

  00050	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1281 : 	if (!context.parseRequest(byteBuffer) || context.request().method() != zl::net::HttpGet) { // 解析失败 或者 不是Get请求

  00057	8b 45 08	 mov	 eax, DWORD PTR _byteBuffer$[ebp]
  0005a	50		 push	 eax
  0005b	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  00061	e8 00 00 00 00	 call	 ?parseRequest@HttpContext@net@zl@@QAE_NPAVByteBuffer@23@@Z ; zl::net::HttpContext::parseRequest
  00066	0f b6 c8	 movzx	 ecx, al
  00069	85 c9		 test	 ecx, ecx
  0006b	74 19		 je	 SHORT $LN3@handshake
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  0006d	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR _context$[ebp+4]
  00073	89 95 e0 fd ff
	ff		 mov	 DWORD PTR $T8[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1281 : 	if (!context.parseRequest(byteBuffer) || context.request().method() != zl::net::HttpGet) { // 解析失败 或者 不是Get请求

  00079	83 bd e0 fd ff
	ff 02		 cmp	 DWORD PTR $T8[ebp], 2
  00080	0f 84 07 01 00
	00		 je	 $LN2@handshake
$LN3@handshake:

; 1282 : 		g_TraceServiceManager.TraceString(TEXT("parse handshake error,send close header"), TraceLevel_Exception);

  00086	6a 03		 push	 3
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GGFIIOME@parse?5handshake?5error?0send?5clos@
  0008d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_TraceServiceManager@@3VCTraceServiceManager@@A ; g_TraceServiceManager
  00092	e8 00 00 00 00	 call	 ?TraceString@CTraceServiceManager@@UAE_NPBDW4enTraceLevel@@@Z ; CTraceServiceManager::TraceString

; 1283 : 		std::string msg = "HTTP/1.1 400 Bad Request\r\n\r\n";

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@PJMBPKGC@HTTP?11?41?5400?5Bad?5Request?$AN?6?$AN?6@
  0009c	8d 4d 9c	 lea	 ecx, DWORD PTR _msg$47[ebp]
  0009f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000a8	8d 45 9c	 lea	 eax, DWORD PTR _msg$47[ebp]
  000ab	89 85 f8 fd ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  000b1	8b 8d f8 fd ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  000b7	89 8d e8 fd ff
	ff		 mov	 DWORD PTR $T10[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  000bd	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  000c3	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000c6	89 85 f4 fd ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000cc	8d 4d 9c	 lea	 ecx, DWORD PTR _msg$47[ebp]
  000cf	89 8d f0 fd ff
	ff		 mov	 DWORD PTR $T12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  000d5	8b 95 f0 fd ff
	ff		 mov	 edx, DWORD PTR $T12[ebp]
  000db	89 95 74 fe ff
	ff		 mov	 DWORD PTR $T36[ebp], edx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  000e1	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR $T36[ebp]
  000e7	83 c0 04	 add	 eax, 4
  000ea	89 85 60 fe ff
	ff		 mov	 DWORD PTR __Result$32[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000f0	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR $T36[ebp]
  000f6	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  000fa	72 0c		 jb	 SHORT $LN68@handshake
  000fc	c7 85 64 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv304[ebp], 1
  00106	eb 0a		 jmp	 SHORT $LN66@handshake
$LN68@handshake:
  00108	c7 85 64 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv304[ebp], 0
$LN66@handshake:

; 1815 : 		if (_Large_string_engaged())

  00112	0f b6 95 64 fe
	ff ff		 movzx	 edx, BYTE PTR tv304[ebp]
  00119	85 d2		 test	 edx, edx
  0011b	74 0f		 je	 SHORT $LN63@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0011d	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR $T36[ebp]
  00123	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00126	89 8d 60 fe ff
	ff		 mov	 DWORD PTR __Result$32[ebp], ecx
$LN63@handshake:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  0012c	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR __Result$32[ebp]
  00132	89 95 fc fd ff
	ff		 mov	 DWORD PTR $T15[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1284 : 		SendRawData(msg.c_str(), msg.size());

  00138	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  0013e	50		 push	 eax
  0013f	8b 8d fc fd ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  00145	51		 push	 ecx
  00146	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ; CTCPNetworkItem::SendRawData

; 1285 : 		return false;

  00151	c6 85 87 fe ff
	ff 00		 mov	 BYTE PTR $T42[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00158	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 2460 : 		_Tidy_deallocate();

  0015c	8d 4d 9c	 lea	 ecx, DWORD PTR _msg$47[ebp]
  0015f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00164	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1949 : 		_Free_proxy();

  00168	8d 4d 9c	 lea	 ecx, DWORD PTR _msg$47[ebp]
  0016b	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1285 : 		return false;

  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp+4]
  0017d	e8 00 00 00 00	 call	 ??1HttpRequest@net@zl@@QAE@XZ ; zl::net::HttpRequest::~HttpRequest
  00182	8a 85 87 fe ff
	ff		 mov	 al, BYTE PTR $T42[ebp]
  00188	e9 17 05 00 00	 jmp	 $LN1@handshake
$LN2@handshake:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h

; 45   : 			bool gotAll() const            { return state_ == kGotAll; }

  0018d	83 bd 88 fe ff
	ff 03		 cmp	 DWORD PTR _context$[ebp], 3
  00194	75 0c		 jne	 SHORT $LN92@handshake
  00196	c7 85 5c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv307[ebp], 1
  001a0	eb 0a		 jmp	 SHORT $LN90@handshake
$LN92@handshake:
  001a2	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv307[ebp], 0
$LN90@handshake:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1288 : 	assert(context.gotAll());

  001ac	0f b6 95 5c fe
	ff ff		 movzx	 edx, BYTE PTR tv307[ebp]
  001b3	85 d2		 test	 edx, edx
  001b5	75 18		 jne	 SHORT $LN94@handshake
  001b7	68 08 05 00 00	 push	 1288			; 00000508H
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_1HG@EFDLDILG@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_1CC@MAPHGENJ@?$AAc?$AAo?$AAn?$AAt?$AAe?$AAx?$AAt?$AA?4?$AAg?$AAo?$AAt?$AAA?$AAl?$AAl?$AA?$CI@
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  001cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN94@handshake:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h

; 56   : 			HttpRequest& request()         { return request_; }

  001cf	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp+4]
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1289 : 	zl::net::HttpRequest& req = context.request();

  001d5	89 8d 7c fe ff
	ff		 mov	 DWORD PTR _req$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  001db	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR _req$[ebp]
  001e1	83 c2 24	 add	 edx, 36			; 00000024H
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1290 : 	std::string query = req.query();

  001e4	89 95 58 fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  001ea	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  001f0	89 85 ec fd ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  001f6	8b 8d ec fd ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  001fc	89 8d c8 fd ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx

; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))

  00202	8d 95 7b fe ff
	ff		 lea	 edx, DWORD PTR $T38[ebp]
  00208	52		 push	 edx
  00209	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  0020c	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
  00211	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 2130 : 		{	// construct by copying _Right
; 2131 : 		_Construct_lv_contents(_Right);

  00215	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  0021b	50		 push	 eax
  0021c	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  0021f	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1290 : 	std::string query = req.query();

  00224	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00228	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  0022b	89 8d dc fd ff
	ff		 mov	 DWORD PTR $T7[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00231	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR $T7[ebp]
  00237	89 95 d8 fd ff
	ff		 mov	 DWORD PTR $T6[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0023d	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  00243	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00246	89 8d d4 fd ff
	ff		 mov	 DWORD PTR $T5[ebp], ecx

; 3371 : 		return (size() == 0);

  0024c	83 bd d4 fd ff
	ff 00		 cmp	 DWORD PTR $T5[ebp], 0
  00253	75 0c		 jne	 SHORT $LN111@handshake
  00255	c7 85 54 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv356[ebp], 1
  0025f	eb 0a		 jmp	 SHORT $LN112@handshake
$LN111@handshake:
  00261	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv356[ebp], 0
$LN112@handshake:
  0026b	8a 95 54 fe ff
	ff		 mov	 dl, BYTE PTR tv356[ebp]
  00271	88 95 86 fe ff
	ff		 mov	 BYTE PTR $T41[ebp], dl
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1291 : 	if (query.empty() == false) {

  00277	0f b6 85 86 fe
	ff ff		 movzx	 eax, BYTE PTR $T41[ebp]
  0027e	85 c0		 test	 eax, eax
  00280	75 7b		 jne	 SHORT $LN4@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  00282	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00285	89 8d d0 fd ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3862 : 		return (static_cast<allocator_type>(this->_Getal()));

  0028b	8d 95 7a fe ff
	ff		 lea	 edx, DWORD PTR $T37[ebp]
  00291	89 95 30 fe ff
	ff		 mov	 DWORD PTR $T27[ebp], edx

; 3756 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  00297	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR $T27[ebp]
  0029d	50		 push	 eax
  0029e	6a ff		 push	 -1
  002a0	6a 01		 push	 1
  002a2	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  002a5	51		 push	 ecx
  002a6	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  002ac	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002b1	8b 95 50 fe ff
	ff		 mov	 edx, DWORD PTR $T31[ebp]
  002b7	83 ca 01	 or	 edx, 1
  002ba	89 95 50 fe ff
	ff		 mov	 DWORD PTR $T31[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1292 : 		query = query.substr(1);

  002c0	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T44[ebp]
  002c6	89 85 2c fe ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  002cc	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR tv225[ebp]
  002d2	51		 push	 ecx
  002d3	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  002d6	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  002db	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 2460 : 		_Tidy_deallocate();

  002df	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  002e5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  002ea	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 1949 : 		_Free_proxy();

  002ee	8d 8d 2c ff ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  002f4	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  002f9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
$LN4@handshake:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1295 : 	std::string key = req.getHeader(zl::net::ws::kSecWebSocketKeyHeader);

  002fd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?kSecWebSocketKeyHeader@ws@net@zl@@3QBDB
  00303	52		 push	 edx
  00304	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  0030a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0030f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00313	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T45[ebp]
  00319	50		 push	 eax
  0031a	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00320	51		 push	 ecx
  00321	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _req$[ebp]
  00327	e8 00 00 00 00	 call	 ?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ; zl::net::HttpRequest::getHeader
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  0032c	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 2460 : 		_Tidy_deallocate();

  00330	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  00336	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0033b	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH

; 1949 : 		_Free_proxy();

  0033f	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  00345	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0034a	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1296 : 	std::string ip = req.getHeader("X-Forwarded-For");

  0034e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HEMDDLEL@X?9Forwarded?9For@
  00353	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00359	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0035e	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00362	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR $T46[ebp]
  00368	52		 push	 edx
  00369	8d 45 b8	 lea	 eax, DWORD PTR _ip$[ebp]
  0036c	50		 push	 eax
  0036d	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _req$[ebp]
  00373	e8 00 00 00 00	 call	 ?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ; zl::net::HttpRequest::getHeader
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00378	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H

; 2460 : 		_Tidy_deallocate();

  0037c	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00382	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00387	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H

; 1949 : 		_Free_proxy();

  0038b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  00391	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00396	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0039a	8d 4d b8	 lea	 ecx, DWORD PTR _ip$[ebp]
  0039d	89 8d 28 fe ff
	ff		 mov	 DWORD PTR $T26[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  003a3	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR $T26[ebp]
  003a9	89 95 24 fe ff
	ff		 mov	 DWORD PTR $T25[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  003af	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  003b5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  003b8	89 8d 20 fe ff
	ff		 mov	 DWORD PTR $T24[ebp], ecx

; 3371 : 		return (size() == 0);

  003be	83 bd 20 fe ff
	ff 00		 cmp	 DWORD PTR $T24[ebp], 0
  003c5	75 0c		 jne	 SHORT $LN341@handshake
  003c7	c7 85 4c fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv563[ebp], 1
  003d1	eb 0a		 jmp	 SHORT $LN342@handshake
$LN341@handshake:
  003d3	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv563[ebp], 0
$LN342@handshake:
  003dd	8a 95 4c fe ff
	ff		 mov	 dl, BYTE PTR tv563[ebp]
  003e3	88 95 85 fe ff
	ff		 mov	 BYTE PTR $T40[ebp], dl
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1297 : 	if (ip.empty() == false) {

  003e9	0f b6 85 85 fe
	ff ff		 movzx	 eax, BYTE PTR $T40[ebp]
  003f0	85 c0		 test	 eax, eax
  003f2	0f 85 a1 00 00
	00		 jne	 $LN5@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  003f8	8d 4d b8	 lea	 ecx, DWORD PTR _ip$[ebp]
  003fb	89 8d 1c fe ff
	ff		 mov	 DWORD PTR $T23[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00401	8b 95 1c fe ff
	ff		 mov	 edx, DWORD PTR $T23[ebp]
  00407	89 95 70 fe ff
	ff		 mov	 DWORD PTR $T35[ebp], edx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0040d	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR $T35[ebp]
  00413	83 c0 04	 add	 eax, 4
  00416	89 85 44 fe ff
	ff		 mov	 DWORD PTR __Result$30[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0041c	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR $T35[ebp]
  00422	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00426	72 0c		 jb	 SHORT $LN367@handshake
  00428	c7 85 48 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv565[ebp], 1
  00432	eb 0a		 jmp	 SHORT $LN365@handshake
$LN367@handshake:
  00434	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv565[ebp], 0
$LN365@handshake:

; 1815 : 		if (_Large_string_engaged())

  0043e	0f b6 95 48 fe
	ff ff		 movzx	 edx, BYTE PTR tv565[ebp]
  00445	85 d2		 test	 edx, edx
  00447	74 0f		 je	 SHORT $LN362@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00449	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR $T35[ebp]
  0044f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00452	89 8d 44 fe ff
	ff		 mov	 DWORD PTR __Result$30[ebp], ecx
$LN362@handshake:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  00458	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR __Result$30[ebp]
  0045e	89 95 18 fe ff
	ff		 mov	 DWORD PTR $T22[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1299 : 		m_dwClientIP = inet_addr(ip.c_str());

  00464	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  0046a	50		 push	 eax
  0046b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00471	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00477	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1300 : 		//Attach(m_hSocket, inet_addr(ip.c_str()));
; 1301 : 		m_pITCPNetworkItemSink->OnEventSocketBind(this);

  0047a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00480	52		 push	 edx
  00481	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00487	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0048a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00490	8b 01		 mov	 eax, DWORD PTR [ecx]
  00492	8b 4a 3c	 mov	 ecx, DWORD PTR [edx+60]
  00495	8b 10		 mov	 edx, DWORD PTR [eax]
  00497	ff d2		 call	 edx
$LN5@handshake:

; 1303 : 	std::string answer = zl::net::ws::makeHandshakeResponse(key.c_str(), req.getHeader(zl::net::ws::kSecWebSocketProtocolHeader));

  00499	a1 00 00 00 00	 mov	 eax, DWORD PTR ?kSecWebSocketProtocolHeader@ws@net@zl@@3QBDB
  0049e	50		 push	 eax
  0049f	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  004a5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004aa	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  004ae	83 ec 1c	 sub	 esp, 28			; 0000001cH
  004b1	8b cc		 mov	 ecx, esp
  004b3	89 a5 cc fd ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  004b9	8d 95 f4 fe ff
	ff		 lea	 edx, DWORD PTR $T43[ebp]
  004bf	52		 push	 edx
  004c0	51		 push	 ecx
  004c1	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR _req$[ebp]
  004c7	e8 00 00 00 00	 call	 ?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ; zl::net::HttpRequest::getHeader
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  004cc	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR _key$[ebp]
  004d2	89 85 14 fe ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  004d8	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR $T21[ebp]
  004de	89 8d 6c fe ff
	ff		 mov	 DWORD PTR $T34[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  004e4	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR $T34[ebp]
  004ea	83 c2 04	 add	 edx, 4
  004ed	89 95 34 fe ff
	ff		 mov	 DWORD PTR __Result$28[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  004f3	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR $T34[ebp]
  004f9	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  004fd	72 0c		 jb	 SHORT $LN456@handshake
  004ff	c7 85 40 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv709[ebp], 1
  00509	eb 0a		 jmp	 SHORT $LN454@handshake
$LN456@handshake:
  0050b	c7 85 40 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv709[ebp], 0
$LN454@handshake:

; 1815 : 		if (_Large_string_engaged())

  00515	0f b6 8d 40 fe
	ff ff		 movzx	 ecx, BYTE PTR tv709[ebp]
  0051c	85 c9		 test	 ecx, ecx
  0051e	74 0f		 je	 SHORT $LN451@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00520	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR $T34[ebp]
  00526	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00529	89 85 34 fe ff
	ff		 mov	 DWORD PTR __Result$28[ebp], eax
$LN451@handshake:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  0052f	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR __Result$28[ebp]
  00535	89 8d 10 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1303 : 	std::string answer = zl::net::ws::makeHandshakeResponse(key.c_str(), req.getHeader(zl::net::ws::kSecWebSocketProtocolHeader));

  0053b	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR $T20[ebp]
  00541	52		 push	 edx
  00542	8d 45 80	 lea	 eax, DWORD PTR _answer$[ebp]
  00545	50		 push	 eax
  00546	e8 00 00 00 00	 call	 ?makeHandshakeResponse@ws@net@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDV45@@Z ; zl::net::ws::makeHandshakeResponse
  0054b	83 c4 24	 add	 esp, 36			; 00000024H
  0054e	89 85 c4 fd ff
	ff		 mov	 DWORD PTR tv233[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00554	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H

; 2460 : 		_Tidy_deallocate();

  00558	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  0055e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00563	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H

; 1949 : 		_Free_proxy();

  00567	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  0056d	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00572	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00576	8d 4d 80	 lea	 ecx, DWORD PTR _answer$[ebp]
  00579	89 8d 0c fe ff
	ff		 mov	 DWORD PTR $T19[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0057f	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR $T19[ebp]
  00585	89 95 08 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0058b	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00591	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00594	89 8d 00 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0059a	8d 55 80	 lea	 edx, DWORD PTR _answer$[ebp]
  0059d	89 95 04 fe ff
	ff		 mov	 DWORD PTR $T17[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  005a3	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR $T17[ebp]
  005a9	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T33[ebp], eax

; 1814 : 		const value_type * _Result = _Bx._Buf;

  005af	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR $T33[ebp]
  005b5	83 c1 04	 add	 ecx, 4
  005b8	89 8d 3c fe ff
	ff		 mov	 DWORD PTR __Result$29[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  005be	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR $T33[ebp]
  005c4	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  005c8	72 0c		 jb	 SHORT $LN498@handshake
  005ca	c7 85 38 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv754[ebp], 1
  005d4	eb 0a		 jmp	 SHORT $LN496@handshake
$LN498@handshake:
  005d6	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv754[ebp], 0
$LN496@handshake:

; 1815 : 		if (_Large_string_engaged())

  005e0	0f b6 85 38 fe
	ff ff		 movzx	 eax, BYTE PTR tv754[ebp]
  005e7	85 c0		 test	 eax, eax
  005e9	74 0f		 je	 SHORT $LN493@handshake
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  005eb	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR $T33[ebp]
  005f1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  005f4	89 95 3c fe ff
	ff		 mov	 DWORD PTR __Result$29[ebp], edx
$LN493@handshake:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  005fa	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR __Result$29[ebp]
  00600	89 85 e4 fd ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1309 : 	SendRawData(answer.c_str(), answer.size());

  00606	8b 8d 00 fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0060c	51		 push	 ecx
  0060d	8b 95 e4 fd ff
	ff		 mov	 edx, DWORD PTR $T9[ebp]
  00613	52		 push	 edx
  00614	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0061a	e8 00 00 00 00	 call	 ?SendRawData@CTCPNetworkItem@@AAE_NPBDH@Z ; CTCPNetworkItem::SendRawData

; 1310 : 	return true;

  0061f	c6 85 84 fe ff
	ff 01		 mov	 BYTE PTR $T39[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00626	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H

; 2460 : 		_Tidy_deallocate();

  0062a	8d 4d 80	 lea	 ecx, DWORD PTR _answer$[ebp]
  0062d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00632	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H

; 1949 : 		_Free_proxy();

  00636	8d 4d 80	 lea	 ecx, DWORD PTR _answer$[ebp]
  00639	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2459 : 		{	// destroy the string

  0063e	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H

; 2460 : 		_Tidy_deallocate();

  00642	8d 4d b8	 lea	 ecx, DWORD PTR _ip$[ebp]
  00645	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0064a	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH

; 1949 : 		_Free_proxy();

  0064e	8d 4d b8	 lea	 ecx, DWORD PTR _ip$[ebp]
  00651	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2459 : 		{	// destroy the string

  00656	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH

; 2460 : 		_Tidy_deallocate();

  0065a	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00660	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00665	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH

; 1949 : 		_Free_proxy();

  00669	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  0066f	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2459 : 		{	// destroy the string

  00674	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH

; 2460 : 		_Tidy_deallocate();

  00678	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  0067b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00680	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH

; 1949 : 		_Free_proxy();

  00684	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  00687	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 1310 : 	return true;

  0068c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00693	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp+4]
  00699	e8 00 00 00 00	 call	 ??1HttpRequest@net@zl@@QAE@XZ ; zl::net::HttpRequest::~HttpRequest
  0069e	8a 85 84 fe ff
	ff		 mov	 al, BYTE PTR $T39[ebp]
$LN1@handshake:

; 1311 : }

  006a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006ae	59		 pop	 ecx
  006af	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006b2	33 cd		 xor	 ecx, ebp
  006b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006b9	8b e5		 mov	 esp, ebp
  006bb	5d		 pop	 ebp
  006bc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$0:
  00000	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR _context$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1HttpContext@net@zl@@QAE@XZ
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$1:
  0000b	8d 4d 9c	 lea	 ecx, DWORD PTR _msg$47[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$29:
  00013	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$2:
  0001b	8d 4d d4	 lea	 ecx, DWORD PTR _query$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$4:
  00023	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$5:
  0002e	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$6:
  00039	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$7:
  00044	8d 4d b8	 lea	 ecx, DWORD PTR _ip$[ebp]
  00047	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$8:
  0004c	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00052	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z$10:
  00057	8d 4d 80	 lea	 ecx, DWORD PTR _answer$[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z:
  0005f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00063	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00066	8b 8a cc fd ff
	ff		 mov	 ecx, DWORD PTR [edx-564]
  0006c	33 c8		 xor	 ecx, eax
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00076	33 c8		 xor	 ecx, eax
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z
  00082	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?handshake@CTCPNetworkItem@@AAE_NPAVByteBuffer@net@zl@@@Z ENDP ; CTCPNetworkItem::handshake
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1CTCPNetworkItem@@UAE@XZ
_TEXT	SEGMENT
tv146 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
tv94 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
_i$8 = -24						; size = 4
_i$9 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTCPNetworkItem@@UAE@XZ PROC				; CTCPNetworkItem::~CTCPNetworkItem, COMDAT
; _this$ = ecx

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTCPNetworkItem@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkItem@@6B@

; 177  :     for (INT_PTR i = 0; i < m_OverLappedSendBuffer.GetCount(); i++)

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$9[ebp], 0
  00038	eb 09		 jmp	 SHORT $LN4@CTCPNetwor
$LN2@CTCPNetwor:
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _i$9[ebp]
  0003d	83 c1 01	 add	 ecx, 1
  00040	89 4d ec	 mov	 DWORD PTR _i$9[ebp], ecx
$LN4@CTCPNetwor:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00043	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00046	8b 82 d4 40 01
	00		 mov	 eax, DWORD PTR [edx+82132]
  0004c	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 177  :     for (INT_PTR i = 0; i < m_OverLappedSendBuffer.GetCount(); i++)

  0004f	8b 4d ec	 mov	 ecx, DWORD PTR _i$9[ebp]
  00052	3b 4d dc	 cmp	 ecx, DWORD PTR $T5[ebp]
  00055	7d 3f		 jge	 SHORT $LN3@CTCPNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00057	8b 55 ec	 mov	 edx, DWORD PTR _i$9[ebp]
  0005a	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 179  :         delete m_OverLappedSendBuffer[i];

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00064	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 179  :         delete m_OverLappedSendBuffer[i];

  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
  0006e	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
  00071	89 4d e4	 mov	 DWORD PTR $T7[ebp], ecx
  00074	83 7d e4 00	 cmp	 DWORD PTR $T7[ebp], 0
  00078	74 13		 je	 SHORT $LN9@CTCPNetwor
  0007a	6a 01		 push	 1
  0007c	8b 55 e4	 mov	 edx, DWORD PTR $T7[ebp]
  0007f	8b 02		 mov	 eax, DWORD PTR [edx]
  00081	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  00084	8b 10		 mov	 edx, DWORD PTR [eax]
  00086	ff d2		 call	 edx
  00088	89 45 d4	 mov	 DWORD PTR tv94[ebp], eax
  0008b	eb 07		 jmp	 SHORT $LN10@CTCPNetwor
$LN9@CTCPNetwor:
  0008d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
$LN10@CTCPNetwor:

; 180  :     }

  00094	eb a4		 jmp	 SHORT $LN2@CTCPNetwor
$LN3@CTCPNetwor:

; 183  :     for (INT_PTR i = 0; i < m_OverLappedSendActive.GetCount(); i++)

  00096	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$8[ebp], 0
  0009d	eb 09		 jmp	 SHORT $LN7@CTCPNetwor
$LN5@CTCPNetwor:
  0009f	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	89 45 e8	 mov	 DWORD PTR _i$8[ebp], eax
$LN7@CTCPNetwor:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	8b 91 9c 40 01
	00		 mov	 edx, DWORD PTR [ecx+82076]
  000b1	89 55 d0	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 183  :     for (INT_PTR i = 0; i < m_OverLappedSendActive.GetCount(); i++)

  000b4	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  000b7	3b 45 d0	 cmp	 eax, DWORD PTR $T3[ebp]
  000ba	7d 3f		 jge	 SHORT $LN6@CTCPNetwor
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000bc	8b 4d e8	 mov	 ecx, DWORD PTR _i$8[ebp]
  000bf	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 185  :         delete m_OverLappedSendActive[i];

  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000c9	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp

; 185  :         delete m_OverLappedSendActive[i];

  000ce	8b 10		 mov	 edx, DWORD PTR [eax]
  000d0	89 55 cc	 mov	 DWORD PTR $T2[ebp], edx
  000d3	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  000d6	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
  000d9	83 7d e0 00	 cmp	 DWORD PTR $T6[ebp], 0
  000dd	74 13		 je	 SHORT $LN11@CTCPNetwor
  000df	6a 01		 push	 1
  000e1	8b 4d e0	 mov	 ecx, DWORD PTR $T6[ebp]
  000e4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e6	8b 4d e0	 mov	 ecx, DWORD PTR $T6[ebp]
  000e9	8b 02		 mov	 eax, DWORD PTR [edx]
  000eb	ff d0		 call	 eax
  000ed	89 45 c8	 mov	 DWORD PTR tv146[ebp], eax
  000f0	eb 07		 jmp	 SHORT $LN12@CTCPNetwor
$LN11@CTCPNetwor:
  000f2	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
$LN12@CTCPNetwor:

; 186  :     }

  000f9	eb a4		 jmp	 SHORT $LN5@CTCPNetwor
$LN6@CTCPNetwor:

; 187  : 
; 188  :     // 删除数组
; 189  :     m_OverLappedSendBuffer.RemoveAll();

  000fb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
  00104	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll

; 190  :     m_OverLappedSendActive.RemoveAll();

  00109	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  00112	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll

; 191  : 
; 192  :     return;
; 193  : }

  00117	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
  00120	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
  00125	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00128	81 c1 a0 40 01
	00		 add	 ecx, 82080		; 000140a0H
  0012e	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  00133	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  0013c	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
  00141	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	81 c1 68 40 01
	00		 add	 ecx, 82024		; 00014068H
  0014a	e8 00 00 00 00	 call	 ??1COverLappedRecv@@UAE@XZ ; COverLappedRecv::~COverLappedRecv
  0014f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00152	83 c1 18	 add	 ecx, 24			; 00000018H
  00155	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  0015a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0015d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00164	59		 pop	 ecx
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CTCPNetworkItem@@UAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTCPNetworkItem@@UAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTCPNetworkItem@@UAE@XZ ENDP				; CTCPNetworkItem::~CTCPNetworkItem
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_wIndex$ = 8						; size = 2
_pITCPNetworkItemSink$ = 12				; size = 4
??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z PROC ; CTCPNetworkItem::CTCPNetworkItem, COMDAT
; _this$ = ecx

; 134  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTCPNetworkItem@@6B@

; 133  :     : m_wIndex(wIndex), m_pITCPNetworkItemSink(pITCPNetworkItemSink)

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	66 8b 55 08	 mov	 dx, WORD PTR _wIndex$[ebp]
  00036	66 89 51 0c	 mov	 WORD PTR [ecx+12], dx

; 134  : {

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 18	 add	 ecx, 24			; 00000018H
  00040	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 133  :     : m_wIndex(wIndex), m_pITCPNetworkItemSink(pITCPNetworkItemSink)

  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _pITCPNetworkItemSink$[ebp]
  00052	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 134  : {

  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	81 c1 68 40 01
	00		 add	 ecx, 82024		; 00014068H
  0005e	e8 00 00 00 00	 call	 ??0COverLappedRecv@@QAE@XZ ; COverLappedRecv::COverLappedRecv
  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  00070	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::CWHArray<COverLappedSend *,COverLappedSend * const &>
  00075	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00079	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	81 c1 a0 40 01
	00		 add	 ecx, 82080		; 000140a0H
  00082	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection
  00087	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0008b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	81 c1 c4 40 01
	00		 add	 ecx, 82116		; 000140c4H
  00094	e8 00 00 00 00	 call	 ??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::CWHArray<COverLappedSend *,COverLappedSend * const &>

; 135  :     // 连接属性
; 136  :     m_dwClientIP = 0L;

  00099	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 137  :     m_dwActiveTime = 0L;

  000a3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 138  : 
; 139  :     // 核心变量
; 140  :     m_wRountID = 1;

  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000b5	66 89 4a 0e	 mov	 WORD PTR [edx+14], cx

; 141  :     m_wSurvivalTime = 0;

  000b9	33 c0		 xor	 eax, eax
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 142  :     m_wSurvivalTime = DEAD_QUOTIETY;

  000c2	33 d2		 xor	 edx, edx
  000c4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 143  :     m_hSocketHandle = INVALID_SOCKET;

  000cb	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	c7 41 14 ff ff
	ff ff		 mov	 DWORD PTR [ecx+20], -1

; 144  : 
; 145  :     // 状态变量
; 146  :     m_bSendIng = false;

  000d5	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	c6 42 44 00	 mov	 BYTE PTR [edx+68], 0

; 147  :     m_bRecvIng = false;

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	c6 40 45 00	 mov	 BYTE PTR [eax+69], 0

; 148  :     m_bShutDown = false;

  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	c6 41 46 00	 mov	 BYTE PTR [ecx+70], 0

; 149  :     m_bAllowBatch = false;

  000ea	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ed	c6 42 47 00	 mov	 BYTE PTR [edx+71], 0

; 150  :     m_bBatchMask = 0xFF;

  000f1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f4	c6 40 48 ff	 mov	 BYTE PTR [eax+72], 255	; 000000ffH

; 151  : 
; 152  :     // 接收变量
; 153  :     m_wRecvSize = 0;

  000f8	33 c9		 xor	 ecx, ecx
  000fa	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	66 89 4a 4a	 mov	 WORD PTR [edx+74], cx

; 154  :     ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf));

  00101	68 00 40 01 00	 push	 81920			; 00014000H
  00106	6a 00		 push	 0
  00108	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0010b	83 c0 4c	 add	 eax, 76			; 0000004cH
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _memset
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 155  : 
; 156  :     // 计数变量
; 157  :     m_dwSendTickCount = 0L;

  00117	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	c7 81 4c 40 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+81996], 0

; 158  :     m_dwRecvTickCount = 0L;

  00124	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00127	c7 82 50 40 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+82000], 0

; 159  :     m_dwSendPacketCount = 0L;

  00131	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00134	c7 80 54 40 01
	00 00 00 00 00	 mov	 DWORD PTR [eax+82004], 0

; 160  :     m_dwRecvPacketCount = 0L;

  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	c7 81 58 40 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+82008], 0

; 161  : 
; 162  :     // 加密数据
; 163  :     m_cbSendRound = 0;

  0014b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0014e	c6 82 5c 40 01
	00 00		 mov	 BYTE PTR [edx+82012], 0

; 164  :     m_cbRecvRound = 0;

  00155	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00158	c6 80 5d 40 01
	00 00		 mov	 BYTE PTR [eax+82013], 0

; 165  :     m_dwSendXorKey = 0;

  0015f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	c7 81 60 40 01
	00 00 00 00 00	 mov	 DWORD PTR [ecx+82016], 0

; 166  :     m_dwRecvXorKey = 0;

  0016c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0016f	c7 82 64 40 01
	00 00 00 00 00	 mov	 DWORD PTR [edx+82020], 0

; 167  : 
; 168  : 	m_connectType = CHECKING;

  00179	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [eax+64], 0

; 169  : 
; 170  :     return;
; 171  : }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00190	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00197	59		 pop	 ecx
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 68 40 01
	00		 add	 ecx, 82024		; 00014068H
  00014	e9 00 00 00 00	 jmp	 ??1COverLappedRecv@@UAE@XZ ; COverLappedRecv::~COverLappedRecv
__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$2:
  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 8c 40 01
	00		 add	 ecx, 82060		; 0001408cH
  00022	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
__unwindfunclet$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z$3:
  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	81 c1 a0 40 01
	00		 add	 ecx, 82080		; 000140a0H
  00030	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
__ehhandler$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z:
  00035	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00039	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003c	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z
  0004b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTCPNetworkItem@@QAE@GPAUITCPNetworkItemSink@@@Z ENDP ; CTCPNetworkItem::CTCPNetworkItem
; Function compile flags: /Odtp
;	COMDAT ??_G?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAEPAXI@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv79 = -20						; size = 4
tv78 = -16						; size = 4
_pNewData$3 = -12					; size = 4
_nGrowCount$4 = -8					; size = 4
_this$ = -4						; size = 4
_nNewCount$ = 8						; size = 4
?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::AllocMemory, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 	//效验参数
; 415  : 	ASSERT(nNewCount>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewCount$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN5@AllocMemor
  0000f	68 9f 01 00 00	 push	 415			; 0000019fH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN5@AllocMemor
  00022	cc		 int	 3
$LN5@AllocMemor:

; 416  : 
; 417  : 	if (nNewCount>m_nMaxCount)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  00029	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002c	0f 8e dd 00 00
	00		 jle	 $LN1@AllocMemor

; 418  : 	{
; 419  : 		//计算数目
; 420  : 		INT_PTR nGrowCount=m_nGrowCount;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	89 4d f8	 mov	 DWORD PTR _nGrowCount$4[ebp], ecx

; 421  : 		if (nGrowCount==0)

  0003b	83 7d f8 00	 cmp	 DWORD PTR _nGrowCount$4[ebp], 0
  0003f	75 45		 jne	 SHORT $LN3@AllocMemor

; 422  : 		{
; 423  : 			nGrowCount=m_nElementCount/8;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00047	99		 cdq
  00048	83 e2 07	 and	 edx, 7
  0004b	03 c2		 add	 eax, edx
  0004d	c1 f8 03	 sar	 eax, 3
  00050	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 424  : 			nGrowCount=(nGrowCount<4)?4:((nGrowCount>1024)?1024:nGrowCount);

  00053	83 7d f8 04	 cmp	 DWORD PTR _nGrowCount$4[ebp], 4
  00057	7d 09		 jge	 SHORT $LN8@AllocMemor
  00059	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
  00060	eb 1e		 jmp	 SHORT $LN9@AllocMemor
$LN8@AllocMemor:
  00062	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nGrowCount$4[ebp], 1024 ; 00000400H
  00069	7e 09		 jle	 SHORT $LN6@AllocMemor
  0006b	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR tv78[ebp], 1024 ; 00000400H
  00072	eb 06		 jmp	 SHORT $LN7@AllocMemor
$LN6@AllocMemor:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _nGrowCount$4[ebp]
  00077	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
$LN7@AllocMemor:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  0007d	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
$LN9@AllocMemor:
  00080	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00083	89 55 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], edx
$LN3@AllocMemor:

; 425  : 		}
; 426  : 		nNewCount+=nGrowCount;

  00086	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  00089	03 45 f8	 add	 eax, DWORD PTR _nGrowCount$4[ebp]
  0008c	89 45 08	 mov	 DWORD PTR _nNewCount$[ebp], eax

; 427  : 
; 428  : 		//申请内存
; 429  : 		TYPE * pNewData=(TYPE *) new BYTE[nNewCount*sizeof(TYPE)];

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _nNewCount$[ebp]
  00092	c1 e1 02	 shl	 ecx, 2
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000a1	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  000a4	89 55 f4	 mov	 DWORD PTR _pNewData$3[ebp], edx

; 430  : 		memcpy(pNewData,m_pData,m_nElementCount*sizeof(TYPE));

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ad	c1 e1 02	 shl	 ecx, 2
  000b0	51		 push	 ecx
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$3[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		memset(pNewData+m_nElementCount,0,(nNewCount-m_nElementCount)*sizeof(TYPE));

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  000ca	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000cd	c1 e0 02	 shl	 eax, 2
  000d0	50		 push	 eax
  000d1	6a 00		 push	 0
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d9	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  000dc	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _memset
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		delete [] (BYTE *)m_pData;

  000e8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ee	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  000f1	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000fa	83 c4 04	 add	 esp, 4

; 433  : 
; 434  : 		//设置变量
; 435  : 		m_pData=pNewData;

  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  00103	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 436  : 		m_nMaxCount=nNewCount;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  0010c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@AllocMemor:

; 437  : 	}
; 438  : 
; 439  : 	return;
; 440  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::AllocMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??A?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::operator[], COMDAT
; _this$ = ecx

; 114  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	return ElementAt(nIndex);

  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt

; 116  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if (m_nElementCount>0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 44		 jle	 SHORT $LN1@RemoveAll

; 381  : 	{
; 382  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7d 02		 jge	 SHORT $LN3@RemoveAll
  0002f	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 383  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	c1 e2 02	 shl	 edx, 2
  0003a	52		 push	 edx
  0003b	6a 00		 push	 0
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 		m_nElementCount=0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN1@RemoveAll:

; 385  : 	}
; 386  : 
; 387  : 	return;
; 388  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?RemoveAll@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXXZ ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z
_TEXT	SEGMENT
_nMoveCount$ = -12					; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_nCount$ = 12						; size = 4
?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAt, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 	//效验参数
; 362  : 	ASSERT(nIndex>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN9@RemoveAt
  0000f	68 6a 01 00 00	 push	 362			; 0000016aH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN9@RemoveAt
  00022	cc		 int	 3
$LN9@RemoveAt:

; 363  : 	ASSERT(nCount>=0);

  00023	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00027	7d 14		 jge	 SHORT $LN10@RemoveAt
  00029	68 6b 01 00 00	 push	 363			; 0000016bH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00033	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00038	85 c0		 test	 eax, eax
  0003a	74 01		 je	 SHORT $LN10@RemoveAt
  0003c	cc		 int	 3
$LN10@RemoveAt:

; 364  : 	ASSERT(nIndex+nCount<=m_nElementCount);

  0003d	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00040	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00049	7e 14		 jle	 SHORT $LN11@RemoveAt
  0004b	68 6c 01 00 00	 push	 364			; 0000016cH
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00055	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005a	85 c0		 test	 eax, eax
  0005c	74 01		 je	 SHORT $LN11@RemoveAt
  0005e	cc		 int	 3
$LN11@RemoveAt:

; 365  : 	if ((nIndex<0)||(nCount<0)||((nIndex+nCount>m_nElementCount))) AfxThrowInvalidArgException();

  0005f	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00063	7c 14		 jl	 SHORT $LN6@RemoveAt
  00065	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00069	7c 0e		 jl	 SHORT $LN6@RemoveAt
  0006b	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0006e	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00077	7e 05		 jle	 SHORT $LN5@RemoveAt
$LN6@RemoveAt:
  00079	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@RemoveAt:

; 366  : 
; 367  : 	//删除数据
; 368  : 	INT_PTR nMoveCount=m_nElementCount-(nIndex+nCount);

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00081	03 4d 0c	 add	 ecx, DWORD PTR _nCount$[ebp]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	2b c1		 sub	 eax, ecx
  0008c	89 45 f4	 mov	 DWORD PTR _nMoveCount$[ebp], eax

; 369  : 	for (INT_PTR i=0;i<nCount;i++) (m_pData+nIndex+i)->~TYPE();

  0008f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00096	eb 09		 jmp	 SHORT $LN4@RemoveAt
$LN2@RemoveAt:
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0009b	83 c1 01	 add	 ecx, 1
  0009e	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAt:
  000a1	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  000a4	3b 55 0c	 cmp	 edx, DWORD PTR _nCount$[ebp]
  000a7	7d 02		 jge	 SHORT $LN3@RemoveAt
  000a9	eb ed		 jmp	 SHORT $LN2@RemoveAt
$LN3@RemoveAt:

; 370  : 	if (nMoveCount>0) memmove(m_pData+nIndex,m_pData+nIndex+nCount,nMoveCount*sizeof(TYPE));

  000ab	83 7d f4 00	 cmp	 DWORD PTR _nMoveCount$[ebp], 0
  000af	7e 2f		 jle	 SHORT $LN7@RemoveAt
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _nMoveCount$[ebp]
  000b4	c1 e0 02	 shl	 eax, 2
  000b7	50		 push	 eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000be	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000c1	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _nCount$[ebp]
  000c7	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d1	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000d4	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _memmove
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RemoveAt:

; 371  : 	m_nElementCount-=nCount;

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000e6	2b 45 0c	 sub	 eax, DWORD PTR _nCount$[ebp]
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN8@RemoveAt:

; 372  : 
; 373  : 	return;
; 374  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
?RemoveAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHH@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	//效验参数
; 289  : 	ASSERT(nIndex>=0);

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7d 14		 jge	 SHORT $LN5@SetAtGrow
  0000d	68 21 01 00 00	 push	 289			; 00000121H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN5@SetAtGrow
  00020	cc		 int	 3
$LN5@SetAtGrow:

; 290  : 	if (nIndex<0) AfxThrowInvalidArgException();

  00021	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00025	7d 05		 jge	 SHORT $LN2@SetAtGrow
  00027	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@SetAtGrow:

; 291  : 
; 292  : 	//设置元素
; 293  : 	if (nIndex>=m_nElementCount) SetSize(m_nElementCount+1);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00032	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00035	7c 12		 jl	 SHORT $LN3@SetAtGrow
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003d	83 c1 01	 add	 ecx, 1
  00040	51		 push	 ecx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetSize@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetSize
$LN3@SetAtGrow:

; 294  : 	m_pData[nIndex]=newElement;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00052	8b 55 0c	 mov	 edx, DWORD PTR _newElement$[ebp]
  00055	8b 12		 mov	 edx, DWORD PTR [edx]
  00057	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@SetAtGrow:

; 295  : 
; 296  : 	return;
; 297  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetSize@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Where$ = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
?SetSize@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetSize, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	//效验参数
; 254  : 	ASSERT(nNewSize>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN13@SetSize
  0000f	68 fe 00 00 00	 push	 254			; 000000feH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN13@SetSize
  00022	cc		 int	 3
$LN13@SetSize:

; 255  : 	if (nNewSize<0)	AfxThrowInvalidArgException();

  00023	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00027	7d 05		 jge	 SHORT $LN8@SetSize
  00029	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN8@SetSize:

; 256  : 	
; 257  : 	//设置大小
; 258  : 	AllocMemory(nNewSize);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::AllocMemory

; 259  : 	if (nNewSize>m_nElementCount)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00040	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00043	7e 35		 jle	 SHORT $LN9@SetSize

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
  0004e	eb 09		 jmp	 SHORT $LN4@SetSize
$LN2@SetSize:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@SetSize:
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR _nNewSize$[ebp]
  0005f	7d 17		 jge	 SHORT $LN3@SetSize
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0006a	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0006d	89 55 f0	 mov	 DWORD PTR __Where$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Where$[ebp]
  00073	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00076	eb d8		 jmp	 SHORT $LN2@SetSize
$LN3@SetSize:

; 262  : 	}
; 263  : 	else if (nNewSize<m_nElementCount)

  00078	eb 4d		 jmp	 SHORT $LN10@SetSize
$LN9@SetSize:
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00080	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00083	7d 42		 jge	 SHORT $LN10@SetSize

; 264  : 	{
; 265  : 		for (INT_PTR i=nNewSize;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00085	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00088	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
  0008b	eb 09		 jmp	 SHORT $LN7@SetSize
$LN5@SetSize:
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN7@SetSize:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0009c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0009f	7d 02		 jge	 SHORT $LN6@SetSize
  000a1	eb ea		 jmp	 SHORT $LN5@SetSize
$LN6@SetSize:

; 266  : 		memset(m_pData+nNewSize,0,(m_nElementCount-nNewSize)*sizeof(TYPE));

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a9	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  000ac	c1 e2 02	 shl	 edx, 2
  000af	52		 push	 edx
  000b0	6a 00		 push	 0
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000bb	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memset
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetSize:

; 267  : 	}
; 268  : 	m_nElementCount=nNewSize;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000cd	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN12@SetSize:

; 269  : 
; 270  : 	return;
; 271  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
?SetSize@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	ASSERT((nIndex>=0)&&(nIndex<m_nElementCount));

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN4@ElementAt
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00016	7c 14		 jl	 SHORT $LN5@ElementAt
$LN4@ElementAt:
  00018	68 e9 00 00 00	 push	 233			; 000000e9H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00022	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00027	85 c0		 test	 eax, eax
  00029	74 01		 je	 SHORT $LN5@ElementAt
  0002b	cc		 int	 3
$LN5@ElementAt:

; 234  : 	if ((nIndex<0)&&(nIndex>=m_nElementCount)) AfxThrowInvalidArgException();

  0002c	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00030	7d 10		 jge	 SHORT $LN2@ElementAt
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00038	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0003b	7c 05		 jl	 SHORT $LN2@ElementAt
  0003d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@ElementAt:

; 235  : 	
; 236  : 	return m_pData[nIndex];

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0004b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$LN3@ElementAt:

; 237  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ElementAt@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEAAPAVCOverLappedSend@@H@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::ElementAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Append@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABV1@@Z
_TEXT	SEGMENT
_nOldCount$1 = -12					; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Src$ = 8						; size = 4
?Append@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABV1@@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Append, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  : 	//效验参数
; 194  : 	ASSERT(this!=&Src);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	3b 45 08	 cmp	 eax, DWORD PTR _Src$[ebp]
  00010	75 14		 jne	 SHORT $LN8@Append
  00012	68 c2 00 00 00	 push	 194			; 000000c2H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN8@Append
  00025	cc		 int	 3
$LN8@Append:

; 195  : 	if (this==&Src) AfxThrowInvalidArgException();

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	3b 55 08	 cmp	 edx, DWORD PTR _Src$[ebp]
  0002c	75 05		 jne	 SHORT $LN5@Append
  0002e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@Append:

; 196  : 
; 197  : 	//拷贝数组
; 198  : 	if (Src.m_nElementCount>0)

  00033	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  00036	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0003a	7e 6d		 jle	 SHORT $LN6@Append

; 199  : 	{
; 200  : 		INT_PTR nOldCount=m_nElementCount;

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	89 55 f4	 mov	 DWORD PTR _nOldCount$1[ebp], edx

; 201  : 		AllocMemory(m_nElementCount+Src.m_nElementCount);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004b	8b 55 08	 mov	 edx, DWORD PTR _Src$[ebp]
  0004e	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXH@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::AllocMemory

; 202  : 		for (INT_PTR i=0;i<Src.m_nElementCount;i++)	m_pData[m_nElementCount+i]=Src.m_pData[i];

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@Append
$LN2@Append:
  00063	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Append:
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00072	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00075	7d 20		 jge	 SHORT $LN3@Append
  00077	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00083	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  00086	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0008c	8b 75 f8	 mov	 esi, DWORD PTR _i$2[ebp]
  0008f	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00092	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00095	eb cc		 jmp	 SHORT $LN2@Append
$LN3@Append:

; 203  : 		m_nElementCount+=Src.m_nElementCount;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  000a0	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN6@Append:

; 204  : 	}
; 205  : 
; 206  : 	return m_nElementCount;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LN7@Append:

; 207  : }

  000af	5e		 pop	 esi
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?Append@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABV1@@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Append
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Add@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABQAVCOverLappedSend@@@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Add@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABQAVCOverLappedSend@@@Z PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Add, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f8	 mov	 DWORD PTR _nIndex$[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00012	8b 55 08	 mov	 edx, DWORD PTR _newElement$[ebp]
  00015	52		 push	 edx
  00016	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEXHABQAVCOverLappedSend@@@Z ; CWHArray<COverLappedSend *,COverLappedSend * const &>::SetAtGrow

; 108  : 	return nIndex;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]

; 109  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Add@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAEHABQAVCOverLappedSend@@@Z ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?GetCount@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCount@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QBEHXZ PROC ; CWHArray<COverLappedSend *,COverLappedSend * const &>::GetCount, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	return m_nElementCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 100  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCount@?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QBEHXZ ENDP ; CWHArray<COverLappedSend *,COverLappedSend * const &>::GetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ PROC	; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@

; 144  : 	if (m_pData!=NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 3e		 je	 SHORT $LN6@CWHArray

; 145  : 	{
; 146  : 		for (INT_PTR i=0;i<m_nElementCount;i++)	(m_pData+i)->~TYPE();

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CWHArray
$LN2@CWHArray:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$2[ebp], edx
$LN4@CWHArray:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00033	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00036	7d 02		 jge	 SHORT $LN3@CWHArray
  00038	eb ea		 jmp	 SHORT $LN2@CWHArray
$LN3@CWHArray:

; 147  : 		delete [] (BYTE *)m_pData;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 148  : 		m_pData=NULL;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@CWHArray:

; 149  : 	}
; 150  : 
; 151  : 	return;
; 152  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@UAE@XZ ENDP	; CWHArray<COverLappedSend *,COverLappedSend * const &>::~CWHArray<COverLappedSend *,COverLappedSend * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ PROC	; CWHArray<COverLappedSend *,COverLappedSend * const &>::CWHArray<COverLappedSend *,COverLappedSend * const &>, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@6B@

; 132  : 	m_pData=NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 133  : 	m_nMaxCount=0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 134  : 	m_nGrowCount=0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 135  : 	m_nElementCount=0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 136  : 
; 137  : 	return;
; 138  : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$CWHArray@PAVCOverLappedSend@@ABQAV1@@@QAE@XZ ENDP	; CWHArray<COverLappedSend *,COverLappedSend * const &>::CWHArray<COverLappedSend *,COverLappedSend * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCOverLappedRecv@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCOverLappedRecv@@UAEPAXI@Z PROC			; COverLappedRecv::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1COverLappedRecv@@UAE@XZ ; COverLappedRecv::~COverLappedRecv
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCOverLappedRecv@@UAEPAXI@Z ENDP			; COverLappedRecv::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1COverLappedRecv@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1COverLappedRecv@@UAE@XZ PROC				; COverLappedRecv::~COverLappedRecv, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLappedRecv@@6B@

; 127  : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1COverLapped@@UAE@XZ	; COverLapped::~COverLapped
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1COverLappedRecv@@UAE@XZ ENDP				; COverLappedRecv::~COverLappedRecv
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0COverLappedRecv@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0COverLappedRecv@@QAE@XZ PROC				; COverLappedRecv::COverLappedRecv, COMDAT
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 118  : COverLappedRecv::COverLappedRecv() : COverLapped(enOperationType_Recv)

  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0COverLapped@@QAE@W4enOperationType@@@Z ; COverLapped::COverLapped

; 119  : {

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLappedRecv@@6B@

; 120  :     m_WSABuffer.len = 0;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 121  :     m_WSABuffer.buf = NULL;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 122  : }

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0COverLappedRecv@@QAE@XZ ENDP				; COverLappedRecv::COverLappedRecv
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCOverLappedSend@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCOverLappedSend@@UAEPAXI@Z PROC			; COverLappedSend::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1COverLappedSend@@UAE@XZ ; COverLappedSend::~COverLappedSend
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 11		 je	 SHORT $LN2@scalar
  00017	68 24 40 00 00	 push	 16420			; 00004024H
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00025	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_GCOverLappedSend@@UAEPAXI@Z ENDP			; COverLappedSend::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1COverLappedSend@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1COverLappedSend@@UAE@XZ PROC				; COverLappedSend::~COverLappedSend, COMDAT
; _this$ = ecx

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLappedSend@@6B@

; 113  : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1COverLapped@@UAE@XZ	; COverLapped::~COverLapped
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1COverLappedSend@@UAE@XZ ENDP				; COverLappedSend::~COverLappedSend
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0COverLappedSend@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0COverLappedSend@@QAE@XZ PROC				; COverLappedSend::COverLappedSend, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : COverLappedSend::COverLappedSend() : COverLapped(enOperationType_Send)

  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0COverLapped@@QAE@W4enOperationType@@@Z ; COverLapped::COverLapped

; 105  : {

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLappedSend@@6B@

; 106  :     m_WSABuffer.len = 0;

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 107  :     m_WSABuffer.buf = (char *)m_cbBuffer;

  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	83 c2 24	 add	 edx, 36			; 00000024H
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 108  : }

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??0COverLappedSend@@QAE@XZ ENDP				; COverLappedSend::COverLappedSend
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCOverLapped@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCOverLapped@@UAEPAXI@Z PROC				; COverLapped::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1COverLapped@@UAE@XZ	; COverLapped::~COverLapped
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCOverLapped@@UAEPAXI@Z ENDP				; COverLapped::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.h
;	COMDAT ?GetOperationType@COverLapped@@QAE?AW4enOperationType@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOperationType@COverLapped@@QAE?AW4enOperationType@@XZ PROC ; COverLapped::GetOperationType, COMDAT
; _this$ = ecx

; 70   :     enOperationType GetOperationType() { return m_OperationType; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetOperationType@COverLapped@@QAE?AW4enOperationType@@XZ ENDP ; COverLapped::GetOperationType
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??1COverLapped@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1COverLapped@@UAE@XZ PROC				; COverLapped::~COverLapped, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLapped@@6B@

; 99   : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1COverLapped@@UAE@XZ ENDP				; COverLapped::~COverLapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ??0COverLapped@@QAE@W4enOperationType@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_OperationType$ = 8					; size = 4
??0COverLapped@@QAE@W4enOperationType@@@Z PROC		; COverLapped::COverLapped, COMDAT
; _this$ = ecx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COverLapped@@6B@

; 87   : COverLapped::COverLapped(enOperationType OperationType) : m_OperationType(OperationType)

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 55 08	 mov	 edx, DWORD PTR _OperationType$[ebp]
  00016	89 51 20	 mov	 DWORD PTR [ecx+32], edx

; 89   :     // 设置变量
; 90   :     ZeroMemory(&m_WSABuffer, sizeof(m_WSABuffer));

  00019	33 c0		 xor	 eax, eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	89 01		 mov	 DWORD PTR [ecx], eax
  00023	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 91   :     ZeroMemory(&m_OverLapped, sizeof(m_OverLapped));

  00026	33 d2		 xor	 edx, edx
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002e	89 10		 mov	 DWORD PTR [eax], edx
  00030	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00033	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00036	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00039	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 92   : 
; 93   :     return;
; 94   : }

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??0COverLapped@@QAE@W4enOperationType@@@Z ENDP		; COverLapped::COverLapped
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ITCPNetworkItemSink@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITCPNetworkItemSink@@QAE@XZ PROC			; ITCPNetworkItemSink::ITCPNetworkItemSink, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ITCPNetworkItemSink@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0ITCPNetworkItemSink@@QAE@XZ ENDP			; ITCPNetworkItemSink::ITCPNetworkItemSink
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1HttpContext@net@zl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1HttpContext@net@zl@@QAE@XZ PROC			; zl::net::HttpContext::~HttpContext, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??1HttpRequest@net@zl@@QAE@XZ ; zl::net::HttpRequest::~HttpRequest
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1HttpContext@net@zl@@QAE@XZ ENDP			; zl::net::HttpContext::~HttpContext
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
;	COMDAT ?request@HttpContext@net@zl@@QAEAAVHttpRequest@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?request@HttpContext@net@zl@@QAEAAVHttpRequest@23@XZ PROC ; zl::net::HttpContext::request, COMDAT
; _this$ = ecx

; 56   : 			HttpRequest& request()         { return request_; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?request@HttpContext@net@zl@@QAEAAVHttpRequest@23@XZ ENDP ; zl::net::HttpContext::request
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
;	COMDAT ?gotAll@HttpContext@net@zl@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?gotAll@HttpContext@net@zl@@QBE_NXZ PROC		; zl::net::HttpContext::gotAll, COMDAT
; _this$ = ecx

; 45   : 			bool gotAll() const            { return state_ == kGotAll; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 03	 cmp	 DWORD PTR [eax], 3
  0000f	75 09		 jne	 SHORT $LN3@gotAll
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN4@gotAll
$LN3@gotAll:
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@gotAll:
  00021	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?gotAll@HttpContext@net@zl@@QBE_NXZ ENDP		; zl::net::HttpContext::gotAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httpcontext.h
;	COMDAT ??0HttpContext@net@zl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0HttpContext@net@zl@@QAE@XZ PROC			; zl::net::HttpContext::HttpContext, COMDAT
; _this$ = ecx

; 35   : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 34   : 				: state_(kExpectRequestLine)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 35   : 			{

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
  00016	e8 00 00 00 00	 call	 ??0HttpRequest@net@zl@@QAE@XZ ; zl::net::HttpRequest::HttpRequest

; 36   : 			}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0HttpContext@net@zl@@QAE@XZ ENDP			; zl::net::HttpContext::HttpContext
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 38		 push	 56			; 00000038H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 1c	 add	 eax, 28			; 0000001cH
  0002e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 2459 : 		{	// destroy the string

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2460 : 		_Tidy_deallocate();

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00040	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1949 : 		_Free_proxy();

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2459 : 		{	// destroy the string

  00059	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 2460 : 		_Tidy_deallocate();

  00060	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00068	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1949 : 		_Free_proxy();

  0006c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00074	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0001a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0001a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::~_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv69 = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator!=, COMDAT
; _this$ = ecx

; 282  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 283  : 		return (!(*this == _Right));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  00015	0f b6 c8	 movzx	 ecx, al
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN3@operator
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0002c	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 284  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
tv136 = -16						; size = 4
tv146 = -12						; size = 4
tv142 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==, COMDAT
; _this$ = ecx

; 273  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN16@operator
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN17@operator
$LN16@operator:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv142[ebp], eax
$LN17@operator:
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv142[ebp]
  00027	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00030	75 09		 jne	 SHORT $LN21@operator
  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
  00039	eb 0a		 jmp	 SHORT $LN22@operator
$LN21@operator:
  0003b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	89 55 f4	 mov	 DWORD PTR tv146[ebp], edx
$LN22@operator:
  00045	8b 45 f4	 mov	 eax, DWORD PTR tv146[ebp]
  00048	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 275  : 		_STL_VERIFY(this->_Getcont() == _Right._Getcont(), "map/set iterators incompatible");

  0004b	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  0004e	3b 4d e8	 cmp	 ecx, DWORD PTR $T1[ebp]
  00051	75 02		 jne	 SHORT $LN7@operator
  00053	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLDKBHLM@map?1set?5iterators?5incompatible@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0005f	6a 00		 push	 0
  00061	68 13 01 00 00	 push	 275			; 00000113H
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0006b	6a 02		 push	 2
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	83 f8 01	 cmp	 eax, 1
  00079	75 01		 jne	 SHORT $LN11@operator
  0007b	cc		 int	 3
$LN11@operator:
  0007c	6a 00		 push	 0
  0007e	68 13 01 00 00	 push	 275			; 00000113H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_1CFG@FGJHCIBH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1EC@JLIDLCDH@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00098	83 c4 14	 add	 esp, 20			; 00000014H
  0009b	33 c0		 xor	 eax, eax
  0009d	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  0009f	33 c9		 xor	 ecx, ecx
  000a1	0f 85 62 ff ff
	ff		 jne	 $LN4@operator

; 276  :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 277  : 
; 278  : 		return (this->_Ptr == _Right._Ptr);

  000a7	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000ad	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000b0	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000b3	75 09		 jne	 SHORT $LN12@operator
  000b5	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
  000bc	eb 07		 jmp	 SHORT $LN13@operator
$LN12@operator:
  000be	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$LN13@operator:
  000c5	8a 45 f0	 mov	 al, BYTE PTR tv136[ebp]

; 279  : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -36						; size = 12
__Lock$2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++, COMDAT
; _this$ = ecx

; 245  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0002f	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __Tmp$[ebp], 0
  00036	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Tmp$[ebp+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	50		 push	 eax
  00041	8d 4d dc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00044	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0004f	89 55 e4	 mov	 DWORD PTR __Tmp$[ebp+8], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 246  : 		_Tree_const_iterator _Tmp = *this;

  00052	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 247  : 		++*this;

  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00061	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00064	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0006d	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  00074	8d 55 dc	 lea	 edx, DWORD PTR __Tmp$[ebp]
  00077	52		 push	 edx
  00078	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0007b	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00080	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00083	8b 4d e4	 mov	 ecx, DWORD PTR __Tmp$[ebp+8]
  00086	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 248  : 		return (_Tmp);

  00089	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  0008c	83 ca 01	 or	 edx, 1
  0008f	89 55 ec	 mov	 DWORD PTR $T3[ebp], edx
  00092	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00099	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  000a0	6a 03		 push	 3
  000a2	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  000ab	8d 4d dc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  000b3	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000bc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 248  : 		return (_Tmp);

  000c3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 249  : 		}

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv152 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++, COMDAT
; _this$ = ecx

; 234  : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN23@operator
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN24@operator
$LN23@operator:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv152[ebp], eax
$LN24@operator:
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv152[ebp]
  00027	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 236  : 		_STL_VERIFY(this->_Getcont(), "cannot increment value-initialized map/set iterator");

  0002a	83 7d f4 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002e	74 02		 je	 SHORT $LN7@operator
  00030	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@DMNPKCGM@cannot?5increment?5value?9initiali@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0003c	6a 00		 push	 0
  0003e	68 ec 00 00 00	 push	 236			; 000000ecH
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00048	6a 02		 push	 2
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 01		 jne	 SHORT $LN19@operator
  00058	cc		 int	 3
$LN19@operator:
  00059	6a 00		 push	 0
  0005b	68 ec 00 00 00	 push	 236			; 000000ecH
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1CFG@PGGKMBNC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1GM@BJMCGEGI@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	33 c0		 xor	 eax, eax
  0007a	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  0007c	33 c9		 xor	 ecx, ecx
  0007e	75 89		 jne	 SHORT $LN4@operator
$LN10@operator:

; 237  : 		_STL_VERIFY(!this->_Ptr->_Isnil, "cannot increment end map/set iterator");

  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00086	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0008a	85 c9		 test	 ecx, ecx
  0008c	75 02		 jne	 SHORT $LN13@operator
  0008e	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NLEHEOHN@cannot?5increment?5end?5map?1set?5it@
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0009a	6a 00		 push	 0
  0009c	68 ed 00 00 00	 push	 237			; 000000edH
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000a6	6a 02		 push	 2
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000ae	83 c4 18	 add	 esp, 24			; 00000018H
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	75 01		 jne	 SHORT $LN20@operator
  000b6	cc		 int	 3
$LN20@operator:
  000b7	6a 00		 push	 0
  000b9	68 ed 00 00 00	 push	 237			; 000000edH
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1CFG@PGGKMBNC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1FA@KLFCDGNE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000d3	83 c4 14	 add	 esp, 20			; 00000014H
  000d6	33 c0		 xor	 eax, eax
  000d8	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  000da	33 c9		 xor	 ecx, ecx
  000dc	75 a2		 jne	 SHORT $LN10@operator

; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 239  : 
; 240  : 		++static_cast<_Mybase&>(*this);

  000de	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::operator++

; 241  : 		return (*this);

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 242  : 		}

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->, COMDAT
; _this$ = ecx

; 229  : 		{	// return pointer to class object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 230  : 		return (pointer_traits<pointer>::pointer_to(**this));

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
  00011	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00014	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 230  : 		return (pointer_traits<pointer>::pointer_to(**this));

  0001a	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 231  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ
_TEXT	SEGMENT
__Mycont$ = -12						; size = 4
tv156 = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*, COMDAT
; _this$ = ecx

; 218  : 		{	// return designated value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN23@operator
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv156[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN24@operator
$LN23@operator:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv156[ebp], eax
$LN24@operator:
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv156[ebp]
  00027	89 4d f4	 mov	 DWORD PTR __Mycont$[ebp], ecx
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 221  : 		_STL_ASSERT(_Mycont, "cannot dereference value-initialized map/set iterator");

  0002a	83 7d f4 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  0002e	74 02		 je	 SHORT $LN7@operator
  00030	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@LCFNIIPB@cannot?5dereference?5value?9initia@
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0003c	6a 00		 push	 0
  0003e	68 dd 00 00 00	 push	 221			; 000000ddH
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00048	6a 02		 push	 2
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 01		 jne	 SHORT $LN19@operator
  00058	cc		 int	 3
$LN19@operator:
  00059	6a 00		 push	 0
  0005b	68 dd 00 00 00	 push	 221			; 000000ddH
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_1CFE@PPLBLEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@ILGCNILF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00075	83 c4 14	 add	 esp, 20			; 00000014H
  00078	33 c0		 xor	 eax, eax
  0007a	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  0007c	33 c9		 xor	 ecx, ecx
  0007e	75 aa		 jne	 SHORT $LN4@operator
$LN10@operator:

; 222  : 		_STL_VERIFY(this->_Ptr != _Mycont->_Myhead, "cannot dereference end map/set iterator");

  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 45 f4	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00086	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00089	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0008c	74 02		 je	 SHORT $LN13@operator
  0008e	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OKFEHCEB@cannot?5dereference?5end?5map?1set?5@
  00095	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0009a	6a 00		 push	 0
  0009c	68 de 00 00 00	 push	 222			; 000000deH
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000a6	6a 02		 push	 2
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000ae	83 c4 18	 add	 esp, 24			; 00000018H
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	75 01		 jne	 SHORT $LN20@operator
  000b6	cc		 int	 3
$LN20@operator:
  000b7	6a 00		 push	 0
  000b9	68 de 00 00 00	 push	 222			; 000000deH
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1CFE@PPLBLEGL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAc?$AAo?$AAn?$AAs@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1FE@NKHAAGMB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000d3	83 c4 14	 add	 esp, 20			; 00000014H
  000d6	33 c0		 xor	 eax, eax
  000d8	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  000da	33 c9		 xor	 ecx, ecx
  000dc	75 a2		 jne	 SHORT $LN10@operator

; 223  :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 224  : 
; 225  : 		return (this->_Ptr->_Myval);

  000de	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e1	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000e4	83 c0 10	 add	 eax, 16			; 00000010H

; 226  : 		}

  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Plist$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 215  : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@$$QAV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0001a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@$$QAV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@ABV01@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0001a	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002c	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@ABV01@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::~_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::~_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnode$1 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 59   : 		if (_Ptr->_Right->_Isnil)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00012	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  00016	85 c0		 test	 eax, eax
  00018	74 3b		 je	 SHORT $LN4@operator
$LN2@operator:

; 60   : 			{	// climb looking for right subtree
; 61   : 			_Nodeptr _Pnode;
; 62   : 			while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right)

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00023	89 45 f8	 mov	 DWORD PTR __Pnode$1[ebp], eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00029	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  0002d	85 d2		 test	 edx, edx
  0002f	75 19		 jne	 SHORT $LN3@operator
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00037	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003d	75 0b		 jne	 SHORT $LN3@operator

; 63   : 				{
; 64   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$1[ebp]
  00045	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 65   : 				}

  00048	eb d0		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 66   : 
; 67   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0004a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$1[ebp]
  00050	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 68   : 			}
; 69   : 		else

  00053	eb 2c		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 70   : 			{
; 71   : 			_Ptr = _Mytree::_Min(_Ptr->_Right);	// ==> smallest of right subtree

  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 486  : 		while (!_Pnode->_Left->_Isnil)

  00061	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  0006a	85 c0		 test	 eax, eax
  0006c	75 0a		 jne	 SHORT $LN7@operator

; 487  : 			_Pnode = _Pnode->_Left;

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 f4	 mov	 DWORD PTR __Pnode$[ebp], edx
  00076	eb e9		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 70   : 			{
; 71   : 			_Ptr = _Mytree::_Min(_Ptr->_Right);	// ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN5@operator:

; 72   : 			}
; 73   : 
; 74   : 		return (*this);

  00081	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 75   : 		}

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 44   : 		this->_Adopt(_Plist);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Plist$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 45   : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1167 : 		{	// destroy tree

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1168 : 		_Tidy();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy

; 1169 : 		}

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 115  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1084 : 		: _Mybase(_Parg)

  00009	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map

; 116  : 		}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key, COMDAT
; _this$ = ecx

; 2122 : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map

; 71   : 		return (_Val.first);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2124 : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2117 : 		{	// get key from value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2118 : 		return (_Traits::_Kfn(_Val));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 2119 : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T2 = -124						; size = 12
$T3 = -112						; size = 12
$T4 = -100						; size = 12
tv149 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
$T7 = -76						; size = 4
__Lock$8 = -72						; size = 4
__Lock$9 = -68						; size = 4
__Lock$10 = -64						; size = 4
tv80 = -60						; size = 4
$T11 = -56						; size = 4
__Pnode$ = -52						; size = 4
$T12 = -48						; size = 4
$T13 = -44						; size = 4
$T14 = -40						; size = 4
$T15 = -36						; size = 4
$T16 = -32						; size = 4
__My_data$17 = -28					; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2112 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 70	 sub	 esp, 112		; 00000070H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], 0

; 1197 : 		{	// return iterator for end of mutable sequence

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00036	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	89 45 d8	 mov	 DWORD PTR $T14[ebp], eax
  0003c	8b 4d d8	 mov	 ecx, DWORD PTR $T14[ebp]
  0003f	89 4d d4	 mov	 DWORD PTR $T13[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00042	8b 55 d4	 mov	 edx, DWORD PTR $T13[ebp]
  00045	89 55 e4	 mov	 DWORD PTR __My_data$17[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00048	8b 45 e4	 mov	 eax, DWORD PTR __My_data$17[ebp]
  0004b	89 45 d0	 mov	 DWORD PTR $T12[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1199 : 		return (iterator(_My_data._Myhead, _STD addressof(_My_data)));

  0004e	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$17[ebp]
  00051	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00054	89 55 cc	 mov	 DWORD PTR __Pnode$[ebp], edx

; 213  : 		: _Mybase(_Pnode, _Plist)

  00057	8b 45 d0	 mov	 eax, DWORD PTR $T12[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d cc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0005e	51		 push	 ecx
  0005f	8d 4d 9c	 lea	 ecx, DWORD PTR $T4[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>

; 1199 : 		return (iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00067	8d 55 9c	 lea	 edx, DWORD PTR $T4[ebp]
  0006a	89 55 c8	 mov	 DWORD PTR $T11[ebp], edx

; 1200 : 		}

  0006d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 2113 : 		erase(begin(), end());

  00074	8b 45 c8	 mov	 eax, DWORD PTR $T11[ebp]
  00077	89 45 e0	 mov	 DWORD PTR $T16[ebp], eax
  0007a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00081	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00084	8b cc		 mov	 ecx, esp
  00086	89 65 b0	 mov	 DWORD PTR $T6[ebp], esp
  00089	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0008c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00095	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00098	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  0009f	8b 4d e0	 mov	 ecx, DWORD PTR $T16[ebp]
  000a2	51		 push	 ecx
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  000ab	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ae	8b 45 e0	 mov	 eax, DWORD PTR $T16[ebp]
  000b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b4	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2113 : 		erase(begin(), end());

  000b7	8d 55 84	 lea	 edx, DWORD PTR $T2[ebp]
  000ba	52		 push	 edx
  000bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
  000c3	89 45 c4	 mov	 DWORD PTR tv80[ebp], eax
  000c6	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  000c9	89 45 dc	 mov	 DWORD PTR $T15[ebp], eax
  000cc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000d0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000d3	8b cc		 mov	 ecx, esp
  000d5	89 65 ac	 mov	 DWORD PTR $T5[ebp], esp
  000d8	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  000db	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000de	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000e4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  000ee	8b 4d dc	 mov	 ecx, DWORD PTR $T15[ebp]
  000f1	51		 push	 ecx
  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  000fa	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 45 dc	 mov	 eax, DWORD PTR $T15[ebp]
  00100	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00103	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2113 : 		erase(begin(), end());

  00106	8d 55 90	 lea	 edx, DWORD PTR $T3[ebp]
  00109	52		 push	 edx
  0010a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00112	89 45 a8	 mov	 DWORD PTR tv149[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00115	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00119	6a 03		 push	 3
  0011b	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$10[ebp]
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00124	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  00127	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0012c	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$10[ebp]
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2113 : 		erase(begin(), end());

  00135	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00139	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0013d	6a 03		 push	 3
  0013f	8d 4d bc	 lea	 ecx, DWORD PTR __Lock$9[ebp]
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00148	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  0014b	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00150	8d 4d bc	 lea	 ecx, DWORD PTR __Lock$9[ebp]
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2113 : 		erase(begin(), end());

  00159	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00160	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00167	6a 03		 push	 3
  00169	8d 4d b8	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00172	8d 4d 9c	 lea	 ecx, DWORD PTR $T4[ebp]
  00175	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0017a	8d 4d b8	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2114 : 		}

  0018a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00194	59		 pop	 ecx
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ$0:
  00000	8d 4d 9c	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ$2:
  00008	8d 4d 84	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 8c	 mov	 ecx, DWORD PTR [edx-116]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Lock$ = -60						; size = 4
$T1 = -56						; size = 4
_this$ = -52						; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_this$ = -16						; size = 4
tv162 = -12						; size = 4
$T8 = -8						; size = 4
__Pnext$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_ptr, COMDAT
; _this$ = ecx

; 2089 : 		{	// orphan iterators with specified node pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2090 : 		_Lockit _Lock(_LOCK_DEBUG);

  00009	6a 03		 push	 3
  0000b	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00014	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
  0001a	8b 4d ec	 mov	 ecx, DWORD PTR $T7[ebp]
  0001d	89 4d e8	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00020	8b 55 e8	 mov	 edx, DWORD PTR $T6[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T8[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

  00026	8b 45 f8	 mov	 eax, DWORD PTR $T8[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	75 09		 jne	 SHORT $LN23@Orphan_ptr
  0002e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv162[ebp], 0
  00035	eb 0b		 jmp	 SHORT $LN24@Orphan_ptr
$LN23@Orphan_ptr:
  00037	8b 4d f8	 mov	 ecx, DWORD PTR $T8[ebp]
  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	83 c2 04	 add	 edx, 4
  0003f	89 55 f4	 mov	 DWORD PTR tv162[ebp], edx
$LN24@Orphan_ptr:
  00042	8b 45 f4	 mov	 eax, DWORD PTR tv162[ebp]
  00045	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2091 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

  00048	8b 4d e4	 mov	 ecx, DWORD PTR $T5[ebp]
  0004b	89 4d fc	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 2092 : 		if (_Pnext != nullptr)

  0004e	83 7d fc 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  00052	74 7e		 je	 SHORT $LN4@Orphan_ptr
$LN2@Orphan_ptr:

; 2093 : 			{
; 2094 : 			while (*_Pnext != nullptr)

  00054	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00057	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0005a	74 76		 je	 SHORT $LN4@Orphan_ptr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00062	8b 4d e0	 mov	 ecx, DWORD PTR $T4[ebp]
  00065	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00068	8b 55 dc	 mov	 edx, DWORD PTR $T3[ebp]
  0006b	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx

; 2095 : 				{
; 2096 : 				if ((*_Pnext)->_Ptr == this->_Get_data()._Myhead
; 2097 : 					|| (_Ptr != nullptr && (*_Pnext)->_Ptr != _Ptr))

  0006e	8b 45 fc	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00071	8b 08		 mov	 ecx, DWORD PTR [eax]
  00073	8b 55 d8	 mov	 edx, DWORD PTR $T2[ebp]
  00076	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00079	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0007c	74 13		 je	 SHORT $LN7@Orphan_ptr
  0007e	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  00082	74 20		 je	 SHORT $LN5@Orphan_ptr
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00087	8b 11		 mov	 edx, DWORD PTR [ecx]
  00089	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0008f	74 13		 je	 SHORT $LN5@Orphan_ptr
$LN7@Orphan_ptr:

; 2098 : 					{
; 2099 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00094	8b 11		 mov	 edx, DWORD PTR [ecx]
  00096	89 55 d4	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 187  : 		return (&_Mynextiter);

  00099	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 c0 04	 add	 eax, 4
  0009f	89 45 fc	 mov	 DWORD PTR __Pnext$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2101 : 				else

  000a2	eb 2c		 jmp	 SHORT $LN6@Orphan_ptr
$LN5@Orphan_ptr:

; 2102 : 					{	// orphan the iterator
; 2103 : 					(*_Pnext)->_Clrcont();

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000a7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a9	89 55 d0	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 177  : 		_Myproxy = nullptr;

  000ac	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000af	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2104 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000b8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ba	89 55 cc	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 187  : 		return (&_Mynextiter);

  000bd	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 c0 04	 add	 eax, 4
  000c3	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2104 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

  000c6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000c9	8b 55 c8	 mov	 edx, DWORD PTR $T1[ebp]
  000cc	8b 02		 mov	 eax, DWORD PTR [edx]
  000ce	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@Orphan_ptr:

; 2105 : 					}
; 2106 : 				}

  000d0	eb 82		 jmp	 SHORT $LN2@Orphan_ptr
$LN4@Orphan_ptr:

; 2107 : 			}
; 2108 : 		}

  000d2	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 04 00	 ret	 4
?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_ptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Compare, COMDAT
; _this$ = ecx

; 2031 : 		{	// compare key_type to key_type, with debug checks

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 1000 : 		return (_Mypair._Get_first());

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00013	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1000 : 		return (_Mypair._Get_first());

  00016	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00019	89 4d f4	 mov	 DWORD PTR $T2[ebp], ecx

; 2032 : 		return (_DEBUG_LT_PRED(this->_Getcomp(), _Left, _Right));

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2033 : 		}

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Al$1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
_this$ = -8						; size = 4
__Pnode$5 = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2019 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2020 : 		for (_Nodeptr _Pnode = _Rootnode; !_Pnode->_Isnil; _Rootnode = _Pnode)

  00009	8b 45 08	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Pnode$5[ebp], eax
  0000f	eb 06		 jmp	 SHORT $LN4@Erase
$LN2@Erase:
  00011	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$5[ebp]
  00014	89 4d 08	 mov	 DWORD PTR __Rootnode$[ebp], ecx
$LN4@Erase:
  00017	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$5[ebp]
  0001a	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  0001e	85 c0		 test	 eax, eax
  00020	75 61		 jne	 SHORT $LN1@Erase

; 2021 : 			{	// free subtrees, then node
; 2022 : 			_Erase(_Pnode->_Right);

  00022	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$5[ebp]
  00025	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00028	52		 push	 edx
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 2023 : 			_Pnode = _Pnode->_Left;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$5[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	89 4d fc	 mov	 DWORD PTR __Pnode$5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00039	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	89 55 f0	 mov	 DWORD PTR $T3[ebp], edx

; 292  : 		return (*this);

  0003f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00042	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  00045	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00048	89 4d e8	 mov	 DWORD PTR __Al$1[ebp], ecx

; 2024 : 			_Alnode& _Al = this->_Getal();
; 2025 : 			_Alnode_traits::destroy(_Al, _STD addressof(_Rootnode->_Myval));

  0004b	8b 55 08	 mov	 edx, DWORD PTR __Rootnode$[ebp]
  0004e	83 c2 10	 add	 edx, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00051	89 55 f4	 mov	 DWORD PTR $T4[ebp], edx
  00054	8b 4d f4	 mov	 ecx, DWORD PTR $T4[ebp]
  00057	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  0005c	33 c0		 xor	 eax, eax
  0005e	83 e0 01	 and	 eax, 1
  00061	74 0e		 je	 SHORT $LN18@Erase
  00063	6a 38		 push	 56			; 00000038H
  00065	8b 4d f4	 mov	 ecx, DWORD PTR $T4[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006e	83 c4 08	 add	 esp, 8
$LN18@Erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2026 : 			_Node::_Freenode0(_Al, _Rootnode);

  00071	8b 55 08	 mov	 edx, DWORD PTR __Rootnode$[ebp]
  00074	52		 push	 edx
  00075	8b 45 e8	 mov	 eax, DWORD PTR __Al$1[ebp]
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  0007e	83 c4 08	 add	 esp, 8

; 2027 : 			}

  00081	eb 8e		 jmp	 SHORT $LN2@Erase
$LN1@Erase:

; 2028 : 		}

  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Pnode$ = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1485 : 		{	// find leftmost node not less than _Keyval in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR $T4[ebp]
  00019	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  0001c	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp]
  0001f	89 55 ec	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00022	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00025	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1486 : 		return (const_iterator(_Lbound(_Keyval), _STD addressof(this->_Get_data())));

  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00034	89 45 e8	 mov	 DWORD PTR __Pnode$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00037	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	8b 55 e8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00050	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00053	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00056	50		 push	 eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1486 : 		return (const_iterator(_Lbound(_Keyval), _STD addressof(this->_Get_data())));

  0005f	8b 4d f8	 mov	 ecx, DWORD PTR $T5[ebp]
  00062	83 c9 01	 or	 ecx, 1
  00065	89 4d f8	 mov	 DWORD PTR $T5[ebp], ecx
  00068	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1487 : 		}

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T2 = -180						; size = 12
$T3 = -168						; size = 12
__Where$ = -156						; size = 12
$T4 = -144						; size = 12
__Lock$5 = -132						; size = 4
__Lock$6 = -128						; size = 4
__Lock$7 = -124						; size = 4
__Lock$8 = -120						; size = 4
tv161 = -116						; size = 4
$T9 = -112						; size = 4
__Pnode$ = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
tv156 = -92						; size = 4
$T13 = -88						; size = 4
$T14 = -84						; size = 4
$T15 = -80						; size = 4
tv151 = -76						; size = 4
$T16 = -72						; size = 4
__Pnode$ = -68						; size = 4
$T17 = -64						; size = 4
$T18 = -60						; size = 4
$T19 = -56						; size = 4
$T20 = -52						; size = 4
$T21 = -48						; size = 4
$T22 = -44						; size = 4
$T23 = -40						; size = 4
$T24 = -36						; size = 4
tv143 = -32						; size = 4
__My_data$25 = -28					; size = 4
__My_data$26 = -24					; size = 4
_this$ = -20						; size = 4
$T27 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find, COMDAT
; _this$ = ecx

; 1432 : 		{	// find an element in nonmutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T27[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T23[ebp], eax
  00038	8b 4d d8	 mov	 ecx, DWORD PTR $T23[ebp]
  0003b	89 4d d4	 mov	 DWORD PTR $T22[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  0003e	8b 55 d4	 mov	 edx, DWORD PTR $T22[ebp]
  00041	89 55 d0	 mov	 DWORD PTR $T21[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00044	8b 45 d0	 mov	 eax, DWORD PTR $T21[ebp]
  00047	89 45 cc	 mov	 DWORD PTR $T20[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1486 : 		return (const_iterator(_Lbound(_Keyval), _STD addressof(this->_Get_data())));

  0004a	8b 4d cc	 mov	 ecx, DWORD PTR $T20[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00051	52		 push	 edx
  00052	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0005a	50		 push	 eax
  0005b	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Where$[ebp]
  00061	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
  00066	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  00069	83 c8 10	 or	 eax, 16			; 00000010H
  0006c	89 45 f0	 mov	 DWORD PTR $T27[ebp], eax

; 1203 : 		{	// return iterator for end of nonmutable sequence

  0006f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00076	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	89 4d c8	 mov	 DWORD PTR $T19[ebp], ecx
  0007c	8b 55 c8	 mov	 edx, DWORD PTR $T19[ebp]
  0007f	89 55 c4	 mov	 DWORD PTR $T18[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00082	8b 45 c4	 mov	 eax, DWORD PTR $T18[ebp]
  00085	89 45 e8	 mov	 DWORD PTR __My_data$26[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00088	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$26[ebp]
  0008b	89 4d c0	 mov	 DWORD PTR $T17[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  0008e	8b 55 e8	 mov	 edx, DWORD PTR __My_data$26[ebp]
  00091	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00094	89 45 bc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 213  : 		: _Mybase(_Pnode, _Plist)

  00097	8b 4d c0	 mov	 ecx, DWORD PTR $T17[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 bc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0009e	52		 push	 edx
  0009f	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000a5	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  000aa	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000b0	89 45 b8	 mov	 DWORD PTR $T16[ebp], eax

; 1206 : 		}

  000b3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 1434 : 		return (_Where == end()

  000b7	8b 4d b8	 mov	 ecx, DWORD PTR $T16[ebp]
  000ba	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  000bd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c1	8b 55 f0	 mov	 edx, DWORD PTR $T27[ebp]
  000c4	83 ca 01	 or	 edx, 1
  000c7	89 55 f0	 mov	 DWORD PTR $T27[ebp], edx
  000ca	8b 45 b4	 mov	 eax, DWORD PTR tv151[ebp]
  000cd	50		 push	 eax
  000ce	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Where$[ebp]
  000d4	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  000d9	0f b6 c8	 movzx	 ecx, al
  000dc	85 c9		 test	 ecx, ecx
  000de	75 7f		 jne	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\map

; 71   : 		return (_Val.first);

  000e0	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR __Where$[ebp+8]
  000e6	83 c2 10	 add	 edx, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 2123 : 		return (this->_Kfn(_Pnode->_Myval));

  000e9	89 55 ac	 mov	 DWORD PTR $T14[ebp], edx

; 1000 : 		return (_Mypair._Get_first());

  000ec	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  000ef	89 45 b0	 mov	 DWORD PTR $T15[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1000 : 		return (_Mypair._Get_first());

  000f2	8b 4d b0	 mov	 ecx, DWORD PTR $T15[ebp]
  000f5	89 4d a8	 mov	 DWORD PTR $T13[ebp], ecx

; 1434 : 		return (_Where == end()

  000f8	8b 55 ac	 mov	 edx, DWORD PTR $T14[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000ff	50		 push	 eax
  00100	8b 4d a8	 mov	 ecx, DWORD PTR $T13[ebp]
  00103	51		 push	 ecx
  00104	e8 00 00 00 00	 call	 ??$_Debug_lt_pred@ABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@std@@YA_NABUstring_cmp_nocase@base@zl@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@1@Z ; std::_Debug_lt_pred<zl::base::string_cmp_nocase const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010c	0f b6 d0	 movzx	 edx, al
  0010f	85 d2		 test	 edx, edx
  00111	75 4c		 jne	 SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00113	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  0011d	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  00127	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR __Where$[ebp]
  0012d	50		 push	 eax
  0012e	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00134	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  00139	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR __Where$[ebp+8]
  0013f	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T4[ebp+8], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  00145	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0014b	89 55 a4	 mov	 DWORD PTR tv156[ebp], edx
  0014e	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  00151	83 c8 02	 or	 eax, 2
  00154	89 45 f0	 mov	 DWORD PTR $T27[ebp], eax
  00157	8b 4d a4	 mov	 ecx, DWORD PTR tv156[ebp]
  0015a	89 4d e0	 mov	 DWORD PTR tv143[ebp], ecx
  0015d	eb 5d		 jmp	 SHORT $LN4@find
$LN3@find:

; 1203 : 		{	// return iterator for end of nonmutable sequence

  0015f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00166	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00169	89 55 a0	 mov	 DWORD PTR $T12[ebp], edx
  0016c	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0016f	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00172	8b 4d 9c	 mov	 ecx, DWORD PTR $T11[ebp]
  00175	89 4d e4	 mov	 DWORD PTR __My_data$25[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00178	8b 55 e4	 mov	 edx, DWORD PTR __My_data$25[ebp]
  0017b	89 55 98	 mov	 DWORD PTR $T10[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  0017e	8b 45 e4	 mov	 eax, DWORD PTR __My_data$25[ebp]
  00181	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00184	89 4d 94	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 213  : 		: _Mybase(_Pnode, _Plist)

  00187	8b 55 98	 mov	 edx, DWORD PTR $T10[ebp]
  0018a	52		 push	 edx
  0018b	8b 45 94	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0018e	50		 push	 eax
  0018f	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00195	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  0019a	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a0	89 4d 90	 mov	 DWORD PTR $T9[ebp], ecx

; 1206 : 		}

  001a3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1434 : 		return (_Where == end()

  001a7	8b 55 90	 mov	 edx, DWORD PTR $T9[ebp]
  001aa	89 55 8c	 mov	 DWORD PTR tv161[ebp], edx
  001ad	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  001b0	83 c8 04	 or	 eax, 4
  001b3	89 45 f0	 mov	 DWORD PTR $T27[ebp], eax
  001b6	8b 4d 8c	 mov	 ecx, DWORD PTR tv161[ebp]
  001b9	89 4d e0	 mov	 DWORD PTR tv143[ebp], ecx
$LN4@find:
  001bc	8b 55 e0	 mov	 edx, DWORD PTR tv143[ebp]
  001bf	89 55 dc	 mov	 DWORD PTR $T24[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  001c2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001c5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  001cb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001ce	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  001d5	8b 55 dc	 mov	 edx, DWORD PTR $T24[ebp]
  001d8	52		 push	 edx
  001d9	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001dc	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  001e1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001e4	8b 4d dc	 mov	 ecx, DWORD PTR $T24[ebp]
  001e7	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001ea	89 50 08	 mov	 DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  001ed	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  001f0	83 c8 08	 or	 eax, 8
  001f3	89 45 f0	 mov	 DWORD PTR $T27[ebp], eax
  001f6	8b 4d f0	 mov	 ecx, DWORD PTR $T27[ebp]
  001f9	83 e1 04	 and	 ecx, 4
  001fc	74 2e		 je	 SHORT $LN14@find
  001fe	83 65 f0 fb	 and	 DWORD PTR $T27[ebp], -5	; fffffffbH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00202	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00209	6a 03		 push	 3
  0020b	8d 4d 88	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00214	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0021a	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0021f	8d 4d 88	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00228	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
$LN14@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  0022c	8b 55 f0	 mov	 edx, DWORD PTR $T27[ebp]
  0022f	83 e2 02	 and	 edx, 2
  00232	74 2a		 je	 SHORT $LN15@find
  00234	83 65 f0 fd	 and	 DWORD PTR $T27[ebp], -3	; fffffffdH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00238	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0023f	6a 03		 push	 3
  00241	8d 4d 84	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0024a	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00250	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00255	8d 4d 84	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN15@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  0025e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00265	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  00268	83 e0 01	 and	 eax, 1
  0026b	74 27		 je	 SHORT $LN16@find
  0026d	83 65 f0 fe	 and	 DWORD PTR $T27[ebp], -2	; fffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00271	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00275	6a 03		 push	 3
  00277	8d 4d 80	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00280	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00286	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0028b	8d 4d 80	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0028e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN16@find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  00294	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0029b	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  002a2	6a 03		 push	 3
  002a4	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$5[ebp]
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  002b0	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Where$[ebp]
  002b6	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  002bb	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$5[ebp]
  002c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  002c7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1434 : 		return (_Where == end()

  002ce	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1435 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1436 : 				_Keyval, this->_Key(_Where._Ptr))
; 1437 : 					? end() : _Where);
; 1438 : 		}

  002d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002db	59		 pop	 ecx
  002dc	8b e5		 mov	 esp, ebp
  002de	5d		 pop	 ebp
  002df	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Where$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  0000b	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  0000e	83 e0 01	 and	 eax, 1
  00011	0f 84 0f 00 00
	00		 je	 $LN7@find
  00017	83 65 f0 fe	 and	 DWORD PTR $T27[ebp], -2	; fffffffeH
  0001b	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
$LN7@find:
  00026	c3		 ret	 0
__ehhandler$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 8a 54 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-172]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
__Head$ = -24						; size = 4
_this$ = -20						; size = 4
__My_data$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear, COMDAT
; _this$ = ecx

; 1408 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1409 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1410 : 		this->_Orphan_ptr(nullptr);

  00028	6a 00		 push	 0
  0002a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_ptr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00038	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  0003b	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  0003e	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  00041	89 55 f0	 mov	 DWORD PTR __My_data$[ebp], edx

; 1411 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1412 : 
; 1413 : 		auto& _My_data = this->_Get_data();
; 1414 : 		auto _Head = _My_data._Myhead;

  00044	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00047	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004a	89 4d e8	 mov	 DWORD PTR __Head$[ebp], ecx

; 1415 : 		_Erase(_My_data._Root());

  0004d	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00050	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00053	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00056	51		 push	 ecx
  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Erase

; 1416 : 		_My_data._Root() = _Head;

  0005f	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00062	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00065	8b 4d e8	 mov	 ecx, DWORD PTR __Head$[ebp]
  00068	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1417 : 		_My_data._Lmost() = _Head;

  0006b	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  0006e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00071	8b 4d e8	 mov	 ecx, DWORD PTR __Head$[ebp]
  00074	89 08		 mov	 DWORD PTR [eax], ecx

; 1418 : 		_My_data._Rmost() = _Head;

  00076	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00079	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007c	8b 4d e8	 mov	 ecx, DWORD PTR __Head$[ebp]
  0007f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1419 : 		_My_data._Mysize = 0;

  00082	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00085	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 1420 : 		}

  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T2 = -164						; size = 12
$T3 = -152						; size = 12
$T4 = -140						; size = 12
tv201 = -128						; size = 4
$T5 = -124						; size = 4
__Lock$6 = -120						; size = 4
__Lock$7 = -116						; size = 4
__Lock$8 = -112						; size = 4
__Lock$9 = -108						; size = 4
__Pnode$ = -104						; size = 4
$T10 = -100						; size = 4
$T11 = -96						; size = 4
$T12 = -92						; size = 4
$T13 = -88						; size = 4
__Lock$14 = -84						; size = 4
__Lock$15 = -80						; size = 4
__Lock$16 = -76						; size = 4
__Lock$17 = -72						; size = 4
__Lock$18 = -68						; size = 4
tv188 = -64						; size = 4
$T19 = -60						; size = 4
$T20 = -56						; size = 4
$T21 = -52						; size = 4
$T22 = -48						; size = 4
tv183 = -44						; size = 4
tv461 = -40						; size = 4
tv350 = -36						; size = 4
tv94 = -32						; size = 4
__My_data$23 = -28					; size = 4
_this$ = -24						; size = 4
$T24 = -17						; size = 1
$T25 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1385 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T25[ebp], 0
  00032	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1386 : 		if (_First == begin() && _Last == end())

  00039	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0003f	50		 push	 eax
  00040	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
  00048	89 45 d8	 mov	 DWORD PTR tv461[ebp], eax
  0004b	8b 4d d8	 mov	 ecx, DWORD PTR tv461[ebp]
  0004e	89 4d d4	 mov	 DWORD PTR tv183[ebp], ecx
  00051	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00055	8b 55 f0	 mov	 edx, DWORD PTR $T25[ebp]
  00058	83 ca 01	 or	 edx, 1
  0005b	89 55 f0	 mov	 DWORD PTR $T25[ebp], edx
  0005e	8b 45 d4	 mov	 eax, DWORD PTR tv183[ebp]
  00061	50		 push	 eax
  00062	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00065	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  0006a	0f b6 c8	 movzx	 ecx, al
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 74		 je	 SHORT $LN7@erase

; 1197 : 		{	// return iterator for end of mutable sequence

  00071	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00078	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0007b	89 55 d0	 mov	 DWORD PTR $T22[ebp], edx
  0007e	8b 45 d0	 mov	 eax, DWORD PTR $T22[ebp]
  00081	89 45 cc	 mov	 DWORD PTR $T21[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00084	8b 4d cc	 mov	 ecx, DWORD PTR $T21[ebp]
  00087	89 4d e4	 mov	 DWORD PTR __My_data$23[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0008a	8b 55 e4	 mov	 edx, DWORD PTR __My_data$23[ebp]
  0008d	89 55 c8	 mov	 DWORD PTR $T20[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1199 : 		return (iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00090	8b 45 c8	 mov	 eax, DWORD PTR $T20[ebp]
  00093	50		 push	 eax
  00094	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$23[ebp]
  00097	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009a	52		 push	 edx
  0009b	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000a1	e8 00 00 00 00	 call	 ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
  000a6	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  000ac	89 45 c4	 mov	 DWORD PTR $T19[ebp], eax

; 1200 : 		}

  000af	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1386 : 		if (_First == begin() && _Last == end())

  000b3	8b 4d c4	 mov	 ecx, DWORD PTR $T19[ebp]
  000b6	89 4d c0	 mov	 DWORD PTR tv188[ebp], ecx
  000b9	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  000c0	8b 55 f0	 mov	 edx, DWORD PTR $T25[ebp]
  000c3	83 ca 02	 or	 edx, 2
  000c6	89 55 f0	 mov	 DWORD PTR $T25[ebp], edx
  000c9	8b 45 c0	 mov	 eax, DWORD PTR tv188[ebp]
  000cc	50		 push	 eax
  000cd	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  000d0	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  000d5	0f b6 c8	 movzx	 ecx, al
  000d8	85 c9		 test	 ecx, ecx
  000da	74 09		 je	 SHORT $LN7@erase
  000dc	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv94[ebp], 1
  000e3	eb 07		 jmp	 SHORT $LN8@erase
$LN7@erase:
  000e5	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv94[ebp], 0
$LN8@erase:
  000ec	8a 55 e0	 mov	 dl, BYTE PTR tv94[ebp]
  000ef	88 55 ef	 mov	 BYTE PTR $T24[ebp], dl
  000f2	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000f9	8b 45 f0	 mov	 eax, DWORD PTR $T25[ebp]
  000fc	83 e0 02	 and	 eax, 2
  000ff	74 2a		 je	 SHORT $LN15@erase
  00101	83 65 f0 fd	 and	 DWORD PTR $T25[ebp], -3	; fffffffdH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00105	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0010c	6a 03		 push	 3
  0010e	8d 4d bc	 lea	 ecx, DWORD PTR __Lock$18[ebp]
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00117	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0011d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00122	8d 4d bc	 lea	 ecx, DWORD PTR __Lock$18[ebp]
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN15@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1386 : 		if (_First == begin() && _Last == end())

  0012b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00132	8b 4d f0	 mov	 ecx, DWORD PTR $T25[ebp]
  00135	83 e1 01	 and	 ecx, 1
  00138	74 2b		 je	 SHORT $LN16@erase
  0013a	83 65 f0 fe	 and	 DWORD PTR $T25[ebp], -2	; fffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0013e	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00142	6a 03		 push	 3
  00144	8d 4d b8	 lea	 ecx, DWORD PTR __Lock$17[ebp]
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0014d	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00153	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00158	8d 4d b8	 lea	 ecx, DWORD PTR __Lock$17[ebp]
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00161	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LN16@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1386 : 		if (_First == begin() && _Last == end())

  00165	0f b6 55 ef	 movzx	 edx, BYTE PTR $T24[ebp]
  00169	85 d2		 test	 edx, edx
  0016b	74 7f		 je	 SHORT $LN2@erase

; 1387 : 			{	// erase all
; 1388 : 			clear();

  0016d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::clear

; 1389 : 			return (begin());

  00175	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00178	50		 push	 eax
  00179	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
  00181	8b 4d f0	 mov	 ecx, DWORD PTR $T25[ebp]
  00184	83 c9 04	 or	 ecx, 4
  00187	89 4d f0	 mov	 DWORD PTR $T25[ebp], ecx
  0018a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0018e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00192	6a 03		 push	 3
  00194	8d 4d b4	 lea	 ecx, DWORD PTR __Lock$16[ebp]
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0019d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  001a0	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  001a5	8d 4d b4	 lea	 ecx, DWORD PTR __Lock$16[ebp]
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1389 : 			return (begin());

  001ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  001b5	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 8

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  001bc	6a 03		 push	 3
  001be	8d 4d b0	 lea	 ecx, DWORD PTR __Lock$15[ebp]
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  001c7	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  001ca	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  001cf	8d 4d b0	 lea	 ecx, DWORD PTR __Lock$15[ebp]
  001d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  001d8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1389 : 			return (begin());

  001df	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001e2	e9 64 01 00 00	 jmp	 $LN1@erase

; 1390 : 			}
; 1391 : 		else

  001e7	e9 0a 01 00 00	 jmp	 $LN5@erase
$LN2@erase:

; 283  : 		return (!(*this == _Right));

  001ec	8d 55 18	 lea	 edx, DWORD PTR __Last$[ebp]
  001ef	52		 push	 edx
  001f0	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  001f3	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  001f8	0f b6 c0	 movzx	 eax, al
  001fb	85 c0		 test	 eax, eax
  001fd	75 09		 jne	 SHORT $LN183@erase
  001ff	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv350[ebp], 1
  00206	eb 07		 jmp	 SHORT $LN181@erase
$LN183@erase:
  00208	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv350[ebp], 0
$LN181@erase:

; 1392 : 			{	// partial erase, one at a time
; 1393 : 			while (_First != _Last)

  0020f	0f b6 4d dc	 movzx	 ecx, BYTE PTR tv350[ebp]
  00213	85 c9		 test	 ecx, ecx
  00215	74 4e		 je	 SHORT $LN3@erase

; 1394 : 				erase(_First++);

  00217	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0021a	8b d4		 mov	 edx, esp
  0021c	89 65 84	 mov	 DWORD PTR $T5[ebp], esp
  0021f	6a 00		 push	 0
  00221	52		 push	 edx
  00222	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00225	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++
  0022a	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00230	50		 push	 eax
  00231	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
  00239	89 45 80	 mov	 DWORD PTR tv201[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0023c	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00240	6a 03		 push	 3
  00242	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$14[ebp]
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0024b	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00251	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00256	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$14[ebp]
  00259	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0025f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1394 : 				erase(_First++);

  00263	eb 87		 jmp	 SHORT $LN2@erase
$LN3@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00265	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00268	89 4d a8	 mov	 DWORD PTR $T13[ebp], ecx
  0026b	8b 55 a8	 mov	 edx, DWORD PTR $T13[ebp]
  0026e	89 55 a4	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00271	8b 45 a4	 mov	 eax, DWORD PTR $T12[ebp]
  00274	89 45 a0	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00277	8b 4d a0	 mov	 ecx, DWORD PTR $T11[ebp]
  0027a	89 4d 9c	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1395 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

  0027d	8b 55 14	 mov	 edx, DWORD PTR __First$[ebp+8]
  00280	89 55 98	 mov	 DWORD PTR __Pnode$[ebp], edx

; 326  : 		: _Mybase(_Pnode, _Plist)

  00283	8b 45 9c	 mov	 eax, DWORD PTR $T10[ebp]
  00286	50		 push	 eax
  00287	8b 4d 98	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0028a	51		 push	 ecx
  0028b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0028e	e8 00 00 00 00	 call	 ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >

; 1395 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

  00293	8b 55 f0	 mov	 edx, DWORD PTR $T25[ebp]
  00296	83 ca 04	 or	 edx, 4
  00299	89 55 f0	 mov	 DWORD PTR $T25[ebp], edx
  0029c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  002a0	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  002a4	6a 03		 push	 3
  002a6	8d 4d 94	 lea	 ecx, DWORD PTR __Lock$9[ebp]
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  002af	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  002b2	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  002b7	8d 4d 94	 lea	 ecx, DWORD PTR __Lock$9[ebp]
  002ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1395 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

  002c0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  002c7	c7 45 fc 0b 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 11 ; 0000000bH

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  002ce	6a 03		 push	 3
  002d0	8d 4d 90	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  002d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  002d9	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  002dc	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  002e1	8d 4d 90	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  002e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  002ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1395 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

  002f1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f4	eb 55		 jmp	 SHORT $LN1@erase
$LN5@erase:

; 1397 : 		}

  002f6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  002fa	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  002fe	6a 03		 push	 3
  00300	8d 4d 8c	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00303	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00309	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0030c	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00311	8d 4d 8c	 lea	 ecx, DWORD PTR __Lock$7[ebp]
  00314	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1397 : 		}

  0031a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00321	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00328	6a 03		 push	 3
  0032a	8d 4d 88	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0032d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00333	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00336	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0033b	8d 4d 88	 lea	 ecx, DWORD PTR __Lock$6[ebp]
  0033e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00344	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
$LN1@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1397 : 		}

  0034b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0034e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00355	59		 pop	 ecx
  00356	8b e5		 mov	 esp, ebp
  00358	5d		 pop	 ebp
  00359	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$0:
  00000	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$2:
  00010	8b 45 f0	 mov	 eax, DWORD PTR $T25[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	0f 84 0f 00 00
	00		 je	 $LN12@erase
  0001c	83 65 f0 fe	 and	 DWORD PTR $T25[ebp], -2	; fffffffeH
  00020	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
$LN12@erase:
  0002b	c3		 ret	 0
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z$3:
  0002c	8b 45 f0	 mov	 eax, DWORD PTR $T25[ebp]
  0002f	83 e0 02	 and	 eax, 2
  00032	0f 84 0f 00 00
	00		 je	 $LN14@erase
  00038	83 65 f0 fd	 and	 DWORD PTR $T25[ebp], -3	; fffffffdH
  0003c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
$LN14@erase:
  00047	c3		 ret	 0
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z:
  00048	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004f	8b 8a 64 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-156]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Successor$ = -104					; size = 12
$T2 = -92						; size = 4
__Lock$3 = -88						; size = 4
__Lock$4 = -84						; size = 4
$T5 = -80						; size = 4
__Pnode$ = -76						; size = 4
__Al$ = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
tv192 = -60						; size = 4
_this$ = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -40						; size = 4
$T12 = -36						; size = 4
$T13 = -32						; size = 4
tv206 = -28						; size = 4
__My_data$ = -24					; size = 4
__Erasednode$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase, COMDAT
; _this$ = ecx

; 1362 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	89 45 d8	 mov	 DWORD PTR $T11[ebp], eax
  0003c	8b 4d d8	 mov	 ecx, DWORD PTR $T11[ebp]
  0003f	89 4d d4	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00042	8b 55 d4	 mov	 edx, DWORD PTR $T10[ebp]
  00045	89 55 e8	 mov	 DWORD PTR __My_data$[ebp], edx
$LN4@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00048	83 7d 0c 00	 cmp	 DWORD PTR __Where$[ebp], 0
  0004c	75 09		 jne	 SHORT $LN28@erase
  0004e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv206[ebp], 0
  00055	eb 08		 jmp	 SHORT $LN29@erase
$LN28@erase:
  00057	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	89 4d e4	 mov	 DWORD PTR tv206[ebp], ecx
$LN29@erase:
  0005f	8b 55 e4	 mov	 edx, DWORD PTR tv206[ebp]
  00062	89 55 d0	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00065	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00068	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1365 : 		_STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data)

  0006b	8b 4d d0	 mov	 ecx, DWORD PTR $T9[ebp]
  0006e	3b 4d cc	 cmp	 ecx, DWORD PTR $T8[ebp]
  00071	75 0d		 jne	 SHORT $LN7@erase
  00073	8b 55 14	 mov	 edx, DWORD PTR __Where$[ebp+8]
  00076	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  0007a	85 c0		 test	 eax, eax
  0007c	75 02		 jne	 SHORT $LN7@erase
  0007e	eb 4a		 jmp	 SHORT $LN2@erase
$LN7@erase:
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JILFNJOL@map?1set?5erase?5iterator?5outside?5@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0008a	6a 00		 push	 0
  0008c	68 56 05 00 00	 push	 1366			; 00000556H
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00096	6a 02		 push	 2
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0009e	83 c4 18	 add	 esp, 24			; 00000018H
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	75 01		 jne	 SHORT $LN11@erase
  000a6	cc		 int	 3
$LN11@erase:
  000a7	6a 00		 push	 0
  000a9	68 56 05 00 00	 push	 1366			; 00000556H
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_1DMG@NDMMDDDJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@CEDAEPC@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5@
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000c3	83 c4 14	 add	 esp, 20			; 00000014H

; 1366 : 			&& !_Where._Ptr->_Isnil, "map/set erase iterator outside range");

  000c6	33 d2		 xor	 edx, edx
  000c8	75 b6		 jne	 SHORT $LN7@erase
$LN2@erase:
  000ca	33 c0		 xor	 eax, eax
  000cc	0f 85 76 ff ff
	ff		 jne	 $LN4@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  000d2	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __Successor$[ebp], 0
  000d9	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __Successor$[ebp+4], 0

; 114  : 		{	// copy an iterator
; 115  : 		*this = _Right;

  000e0	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  000e3	51		 push	 ecx
  000e4	8d 4d 98	 lea	 ecx, DWORD PTR __Successor$[ebp]
  000e7	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=
  000ec	8b 55 14	 mov	 edx, DWORD PTR __Where$[ebp+8]
  000ef	89 55 a0	 mov	 DWORD PTR __Successor$[ebp+8], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1369 : 		const_iterator _Successor = _Where;

  000f2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1370 : 		++_Successor;	// save successor iterator for return

  000f6	8d 4d 98	 lea	 ecx, DWORD PTR __Successor$[ebp]
  000f9	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++

; 1371 : 		_Nodeptr _Erasednode = _My_data._Extract(_Where);	// node to erase

  000fe	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00101	8b c4		 mov	 eax, esp
  00103	89 65 a4	 mov	 DWORD PTR $T2[ebp], esp
  00106	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
  00109	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00110	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@ABV01@@Z
  00115	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00118	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Extract
  0011d	89 45 c4	 mov	 DWORD PTR tv192[ebp], eax
  00120	8b 55 c4	 mov	 edx, DWORD PTR tv192[ebp]
  00123	89 55 ec	 mov	 DWORD PTR __Erasednode$[ebp], edx

; 1372 : 
; 1373 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1374 : 		_Orphan_ptr(_Erasednode);

  00126	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00129	50		 push	 eax
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	e8 00 00 00 00	 call	 ?_Orphan_ptr@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_ptr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00132	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00135	89 4d c0	 mov	 DWORD PTR $T7[ebp], ecx

; 292  : 		return (*this);

  00138	8b 55 c0	 mov	 edx, DWORD PTR $T7[ebp]
  0013b	89 55 bc	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  0013e	8b 45 bc	 mov	 eax, DWORD PTR $T6[ebp]
  00141	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 1375 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1376 : 
; 1377 : 		_Alnode& _Al = this->_Getal();
; 1378 : 		_Alnode_traits::destroy(_Al, _STD addressof(_Erasednode->_Myval));	// delete erased node

  00144	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00147	83 c1 10	 add	 ecx, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0014a	89 4d e0	 mov	 DWORD PTR $T13[ebp], ecx
  0014d	8b 4d e0	 mov	 ecx, DWORD PTR $T13[ebp]
  00150	e8 00 00 00 00	 call	 ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@QAE@XZ
  00155	33 d2		 xor	 edx, edx
  00157	83 e2 01	 and	 edx, 1
  0015a	74 0e		 je	 SHORT $LN126@erase
  0015c	6a 38		 push	 56			; 00000038H
  0015e	8b 45 e0	 mov	 eax, DWORD PTR $T13[ebp]
  00161	50		 push	 eax
  00162	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00167	83 c4 08	 add	 esp, 8
$LN126@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1379 : 		_Node::_Freenode0(_Al, _Erasednode);

  0016a	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0016d	51		 push	 ecx
  0016e	8b 55 b8	 mov	 edx, DWORD PTR __Al$[ebp]
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00177	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0017a	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0017d	89 45 b0	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1381 : 		return (iterator(_Successor._Ptr, _STD addressof(_My_data)));	// return successor iterator

  00180	8b 4d a0	 mov	 ecx, DWORD PTR __Successor$[ebp+8]
  00183	89 4d b4	 mov	 DWORD PTR __Pnode$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00186	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00189	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  0018f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00192	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  00199	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0019c	8b 55 b4	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0019f	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  001a2	8b 45 b0	 mov	 eax, DWORD PTR $T5[ebp]
  001a5	50		 push	 eax
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  001a9	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1381 : 		return (iterator(_Successor._Ptr, _STD addressof(_My_data)));	// return successor iterator

  001ae	8b 4d dc	 mov	 ecx, DWORD PTR $T12[ebp]
  001b1	83 c9 01	 or	 ecx, 1
  001b4	89 4d dc	 mov	 DWORD PTR $T12[ebp], ecx
  001b7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  001bb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  001bf	6a 03		 push	 3
  001c1	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  001c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  001ca	8d 4d 98	 lea	 ecx, DWORD PTR __Successor$[ebp]
  001cd	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  001d2	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1381 : 		return (iterator(_Successor._Ptr, _STD addressof(_My_data)));	// return successor iterator

  001db	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  001e2	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  001e9	6a 03		 push	 3
  001eb	8d 4d a8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  001f4	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  001f7	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  001fc	8d 4d a8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00205	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1381 : 		return (iterator(_Successor._Ptr, _STD addressof(_My_data)));	// return successor iterator

  0020c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1382 : 		}

  0020f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00212	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00219	59		 pop	 ecx
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$1:
  00008	8d 4d 98	 lea	 ecx, DWORD PTR __Successor$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::erase
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Pnode$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT
; _this$ = ecx

; 1203 : 		{	// return iterator for end of nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 fc	 mov	 DWORD PTR __My_data$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00021	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	89 55 ec	 mov	 DWORD PTR __Pnode$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00036	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0003d	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00040	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00043	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00046	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00052	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1206 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Pnode$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end, COMDAT
; _this$ = ecx

; 1197 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 fc	 mov	 DWORD PTR __My_data$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1199 : 		return (iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00021	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	89 55 ec	 mov	 DWORD PTR __Pnode$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00036	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0003d	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00040	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00043	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00046	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00049	51		 push	 ecx
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1199 : 		return (iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00052	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1200 : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Pnode$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin, COMDAT
; _this$ = ecx

; 1185 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 fc	 mov	 DWORD PTR __My_data$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1187 : 		return (iterator(_My_data._Lmost(), _STD addressof(_My_data)));

  00021	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00024	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00035	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00038	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 42   : 		: _Ptr(_Pnode)

  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00042	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00045	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 43   : 		{	// construct with node pointer _Pnode
; 44   : 		this->_Adopt(_Plist);

  00048	8b 55 e8	 mov	 edx, DWORD PTR $T1[ebp]
  0004b	52		 push	 edx
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1187 : 		return (iterator(_My_data._Lmost(), _STD addressof(_My_data)));

  00054	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1188 : 		}

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 1167 : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1168 : 		_Tidy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy

; 1169 : 		}

  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 1085 : 		{	// construct empty tree from comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1084 : 		: _Mybase(_Parg)

  00007	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >

; 1086 : 		}

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 303  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QAEAAV?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABUstring_cmp_nocase@base@zl@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABUstring_cmp_nocase@base@zl@@XZ PROC ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 298  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@Ustring_cmp_nocase@base@zl@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@$00@std@@QBEABUstring_cmp_nocase@base@zl@@XZ ENDP ; std::_Compressed_pair<zl::base::string_cmp_nocase,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 303  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 293  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 4
__Lock$3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
$T7 = -68						; size = 4
__Right$ = -64						; size = 4
__Left$ = -60						; size = 4
tv190 = -56						; size = 4
tv179 = -52						; size = 4
tv325 = -48						; size = 4
__Pnode$ = -44						; size = 4
__Pnode$ = -40						; size = 4
_this$ = -36						; size = 4
__Erasednode$ = -32					; size = 4
__Fixnode$ = -28					; size = 4
__Fixnodeparent$ = -24					; size = 4
__Pnode$ = -20						; size = 4
__Tmp$8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Where$ = 8						; size = 12
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Extract, COMDAT
; _this$ = ecx

; 562  : 		{	// extract node at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
$LN4@Extract:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  0002f	83 7d 08 00	 cmp	 DWORD PTR __Where$[ebp], 0
  00033	75 09		 jne	 SHORT $LN58@Extract
  00035	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv325[ebp], 0
  0003c	eb 08		 jmp	 SHORT $LN59@Extract
$LN58@Extract:
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	89 4d d0	 mov	 DWORD PTR tv325[ebp], ecx
$LN59@Extract:
  00046	8b 55 d0	 mov	 edx, DWORD PTR tv325[ebp]
  00049	89 55 bc	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 564  : 		_STL_VERIFY(_Where._Getcont() == this

  0004c	8b 45 bc	 mov	 eax, DWORD PTR $T7[ebp]
  0004f	3b 45 dc	 cmp	 eax, DWORD PTR _this$[ebp]
  00052	75 0d		 jne	 SHORT $LN7@Extract
  00054	8b 4d 10	 mov	 ecx, DWORD PTR __Where$[ebp+8]
  00057	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  0005b	85 d2		 test	 edx, edx
  0005d	75 02		 jne	 SHORT $LN7@Extract
  0005f	eb 4a		 jmp	 SHORT $LN2@Extract
$LN7@Extract:
  00061	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@JILFNJOL@map?1set?5erase?5iterator?5outside?5@
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0006b	6a 00		 push	 0
  0006d	68 35 02 00 00	 push	 565			; 00000235H
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0GG@NEGGIBJL@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00077	6a 02		 push	 2
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0007f	83 c4 18	 add	 esp, 24			; 00000018H
  00082	83 f8 01	 cmp	 eax, 1
  00085	75 01		 jne	 SHORT $LN50@Extract
  00087	cc		 int	 3
$LN50@Extract:
  00088	6a 00		 push	 0
  0008a	68 35 02 00 00	 push	 565			; 00000235H
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_1MM@GNDNJPBP@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_1CAM@NGLDEJOH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAT?$AAr?$AAe?$AAe?$AA_?$AAv?$AAa?$AAl?$AA?$DM@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@CEDAEPC@?$AA?$CC?$AAm?$AAa?$AAp?$AA?1?$AAs?$AAe?$AAt?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5@
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a4	83 c4 14	 add	 esp, 20			; 00000014H

; 565  : 			&& !_Where._Ptr->_Isnil, "map/set erase iterator outside range");

  000a7	33 c9		 xor	 ecx, ecx
  000a9	75 b6		 jne	 SHORT $LN7@Extract
$LN2@Extract:
  000ab	33 d2		 xor	 edx, edx
  000ad	75 80		 jne	 SHORT $LN4@Extract

; 566  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 567  : 
; 568  : 		_Nodeptr _Erasednode = _Where._Ptr;	// node to erase

  000af	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+8]
  000b2	89 45 e0	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 569  : 		++_Where;	// save successor iterator for return

  000b5	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  000b8	e8 00 00 00 00	 call	 ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator++

; 570  : 
; 571  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 572  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 573  : 		_Nodeptr _Pnode = _Erasednode;

  000bd	8b 4d e0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  000c0	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 574  : 
; 575  : 		if (_Pnode->_Left->_Isnil)

  000c3	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000c6	8b 02		 mov	 eax, DWORD PTR [edx]
  000c8	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  000cc	85 c9		 test	 ecx, ecx
  000ce	74 0b		 je	 SHORT $LN13@Extract

; 576  : 			{
; 577  : 			_Fixnode = _Pnode->_Right;	// stitch up right subtree

  000d0	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d6	89 45 e4	 mov	 DWORD PTR __Fixnode$[ebp], eax
  000d9	eb 27		 jmp	 SHORT $LN14@Extract
$LN13@Extract:

; 578  : 			}
; 579  : 		else if (_Pnode->_Right->_Isnil)

  000db	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000de	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e1	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  000e5	85 c0		 test	 eax, eax
  000e7	74 0a		 je	 SHORT $LN15@Extract

; 580  : 			{
; 581  : 			_Fixnode = _Pnode->_Left;	// stitch up left subtree

  000e9	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ee	89 55 e4	 mov	 DWORD PTR __Fixnode$[ebp], edx

; 582  : 			}
; 583  : 		else

  000f1	eb 0f		 jmp	 SHORT $LN14@Extract
$LN15@Extract:

; 584  : 			{	// two subtrees, must lift successor node to replace erased
; 585  : 			_Pnode = _Where._Ptr;	// _Pnode is successor node

  000f3	8b 45 10	 mov	 eax, DWORD PTR __Where$[ebp+8]
  000f6	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 586  : 			_Fixnode = _Pnode->_Right;	// _Fixnode is only subtree

  000f9	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000fc	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ff	89 55 e4	 mov	 DWORD PTR __Fixnode$[ebp], edx
$LN14@Extract:

; 587  : 			}
; 588  : 
; 589  : 		if (_Pnode == _Erasednode)

  00102	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00105	3b 45 e0	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00108	0f 85 fb 00 00
	00		 jne	 $LN17@Extract

; 590  : 			{	// at most one subtree, relink it
; 591  : 			_Fixnodeparent = _Erasednode->_Parent;

  0010e	8b 4d e0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00111	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00114	89 55 e8	 mov	 DWORD PTR __Fixnodeparent$[ebp], edx

; 592  : 			if (!_Fixnode->_Isnil)

  00117	8b 45 e4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0011a	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  0011e	85 c9		 test	 ecx, ecx
  00120	75 09		 jne	 SHORT $LN96@Extract

; 593  : 				_Fixnode->_Parent = _Fixnodeparent;	// link up

  00122	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00125	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00128	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN96@Extract:

; 594  : 
; 595  : 			if (_Root() == _Erasednode)

  0012b	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00131	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00134	3b 45 e0	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00137	75 0e		 jne	 SHORT $LN20@Extract

; 596  : 				{
; 597  : 				_Root() = _Fixnode;	// link down from root

  00139	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013f	8b 45 e4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00142	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00145	eb 1d		 jmp	 SHORT $LN100@Extract
$LN20@Extract:

; 598  : 				}
; 599  : 			else if (_Fixnodeparent->_Left == _Erasednode)

  00147	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0014a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014c	3b 55 e0	 cmp	 edx, DWORD PTR __Erasednode$[ebp]
  0014f	75 0a		 jne	 SHORT $LN22@Extract

; 600  : 				{
; 601  : 				_Fixnodeparent->_Left = _Fixnode;	// link down to left

  00151	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00154	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 602  : 				}
; 603  : 			else

  00159	eb 09		 jmp	 SHORT $LN100@Extract
$LN22@Extract:

; 604  : 				{
; 605  : 				_Fixnodeparent->_Right = _Fixnode;	// link down to right

  0015b	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0015e	8b 45 e4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00161	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN100@Extract:

; 606  : 				}
; 607  : 
; 608  : 			if (_Lmost() == _Erasednode)

  00164	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00167	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0016a	8b 02		 mov	 eax, DWORD PTR [edx]
  0016c	3b 45 e0	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  0016f	75 41		 jne	 SHORT $LN108@Extract

; 609  : 				{
; 610  : 				_Lmost() = _Fixnode->_Isnil

  00171	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00174	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  00178	85 d2		 test	 edx, edx
  0017a	74 08		 je	 SHORT $LN51@Extract
  0017c	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0017f	89 45 cc	 mov	 DWORD PTR tv179[ebp], eax
  00182	eb 23		 jmp	 SHORT $LN106@Extract
$LN51@Extract:
  00184	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00187	89 4d d8	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN103@Extract:

; 486  : 		while (!_Pnode->_Left->_Isnil)

  0018a	8b 55 d8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0018d	8b 02		 mov	 eax, DWORD PTR [edx]
  0018f	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00193	85 c9		 test	 ecx, ecx
  00195	75 0a		 jne	 SHORT $LN102@Extract

; 487  : 			_Pnode = _Pnode->_Left;

  00197	8b 55 d8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0019a	8b 02		 mov	 eax, DWORD PTR [edx]
  0019c	89 45 d8	 mov	 DWORD PTR __Pnode$[ebp], eax
  0019f	eb e9		 jmp	 SHORT $LN103@Extract
$LN102@Extract:

; 609  : 				{
; 610  : 				_Lmost() = _Fixnode->_Isnil

  001a1	8b 4d d8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001a4	89 4d cc	 mov	 DWORD PTR tv179[ebp], ecx
$LN106@Extract:
  001a7	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001aa	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001ad	8b 4d cc	 mov	 ecx, DWORD PTR tv179[ebp]
  001b0	89 08		 mov	 DWORD PTR [eax], ecx
$LN108@Extract:

; 611  : 					? _Fixnodeparent	// smallest is parent of erased node
; 612  : 					: _Min(_Fixnode);	// smallest in relinked subtree
; 613  : 				}
; 614  : 
; 615  : 			if (_Rmost() == _Erasednode)

  001b2	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001b5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001b8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001bb	3b 4d e0	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  001be	75 44		 jne	 SHORT $LN25@Extract

; 616  : 				{
; 617  : 				_Rmost() = _Fixnode->_Isnil

  001c0	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  001c3	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  001c7	85 c0		 test	 eax, eax
  001c9	74 08		 je	 SHORT $LN53@Extract
  001cb	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  001ce	89 4d c8	 mov	 DWORD PTR tv190[ebp], ecx
  001d1	eb 25		 jmp	 SHORT $LN114@Extract
$LN53@Extract:
  001d3	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  001d6	89 55 d4	 mov	 DWORD PTR __Pnode$[ebp], edx
$LN111@Extract:

; 479  : 		while (!_Pnode->_Right->_Isnil)

  001d9	8b 45 d4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001dc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001df	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  001e3	85 d2		 test	 edx, edx
  001e5	75 0b		 jne	 SHORT $LN110@Extract

; 480  : 			_Pnode = _Pnode->_Right;

  001e7	8b 45 d4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001ea	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ed	89 4d d4	 mov	 DWORD PTR __Pnode$[ebp], ecx
  001f0	eb e7		 jmp	 SHORT $LN111@Extract
$LN110@Extract:

; 616  : 				{
; 617  : 				_Rmost() = _Fixnode->_Isnil

  001f2	8b 55 d4	 mov	 edx, DWORD PTR __Pnode$[ebp]
  001f5	89 55 c8	 mov	 DWORD PTR tv190[ebp], edx
$LN114@Extract:
  001f8	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  001fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001fe	8b 55 c8	 mov	 edx, DWORD PTR tv190[ebp]
  00201	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN25@Extract:

; 618  : 					? _Fixnodeparent	// largest is parent of erased node
; 619  : 					: _Max(_Fixnode);	// largest in relinked subtree
; 620  : 				}
; 621  : 			}
; 622  : 		else

  00204	e9 f3 00 00 00	 jmp	 $LN18@Extract
$LN17@Extract:

; 623  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 624  : 			_Erasednode->_Left->_Parent = _Pnode;	// link left up

  00209	8b 45 e0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0020c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020e	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00211	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 625  : 			_Pnode->_Left = _Erasednode->_Left;	// link successor down

  00214	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00217	8b 4d e0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0021a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021c	89 10		 mov	 DWORD PTR [eax], edx

; 626  : 
; 627  : 			if (_Pnode == _Erasednode->_Right)

  0021e	8b 45 e0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00221	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00224	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00227	75 08		 jne	 SHORT $LN26@Extract

; 628  : 				{
; 629  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00229	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0022c	89 55 e8	 mov	 DWORD PTR __Fixnodeparent$[ebp], edx

; 630  : 				}
; 631  : 			else

  0022f	eb 3d		 jmp	 SHORT $LN116@Extract
$LN26@Extract:

; 632  : 				{	// successor further down, link in place of erased
; 633  : 				_Fixnodeparent = _Pnode->_Parent;	// parent is successor's

  00231	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00234	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00237	89 4d e8	 mov	 DWORD PTR __Fixnodeparent$[ebp], ecx

; 634  : 				if (!_Fixnode->_Isnil)

  0023a	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  0023d	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  00241	85 c0		 test	 eax, eax
  00243	75 09		 jne	 SHORT $LN28@Extract

; 635  : 					{
; 636  : 					_Fixnode->_Parent = _Fixnodeparent;	// link fix up

  00245	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00248	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0024b	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN28@Extract:

; 637  : 					}
; 638  : 
; 639  : 				_Fixnodeparent->_Left = _Fixnode;	// link fix down

  0024e	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00251	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  00254	89 08		 mov	 DWORD PTR [eax], ecx

; 640  : 				_Pnode->_Right = _Erasednode->_Right;	// link next down

  00256	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00259	8b 45 e0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0025c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0025f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 641  : 				_Erasednode->_Right->_Parent = _Pnode;	// right up

  00262	8b 55 e0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  00265	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00268	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0026b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN116@Extract:

; 642  : 				}
; 643  : 
; 644  : 			if (_Root() == _Erasednode)

  0026e	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  00271	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00274	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00277	3b 4d e0	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  0027a	75 0e		 jne	 SHORT $LN29@Extract

; 645  : 				{
; 646  : 				_Root() = _Pnode;	// link down from root

  0027c	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  0027f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00282	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00285	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00288	eb 26		 jmp	 SHORT $LN30@Extract
$LN29@Extract:

; 647  : 				}
; 648  : 			else if (_Erasednode->_Parent->_Left == _Erasednode)

  0028a	8b 55 e0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0028d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00290	8b 08		 mov	 ecx, DWORD PTR [eax]
  00292	3b 4d e0	 cmp	 ecx, DWORD PTR __Erasednode$[ebp]
  00295	75 0d		 jne	 SHORT $LN31@Extract

; 649  : 				{
; 650  : 				_Erasednode->_Parent->_Left = _Pnode;	// link down to left

  00297	8b 55 e0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  0029a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0029d	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002a0	89 08		 mov	 DWORD PTR [eax], ecx

; 651  : 				}
; 652  : 			else

  002a2	eb 0c		 jmp	 SHORT $LN30@Extract
$LN31@Extract:

; 653  : 				{
; 654  : 				_Erasednode->_Parent->_Right = _Pnode;	// link down to right

  002a4	8b 55 e0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002a7	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  002aa	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  002ad	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN30@Extract:

; 655  : 				}
; 656  : 
; 657  : 			_Pnode->_Parent = _Erasednode->_Parent;	// link successor up

  002b0	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  002b3	8b 45 e0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002b6	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  002b9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 658  : 			_STD swap(_Pnode->_Color, _Erasednode->_Color);	// recolor it

  002bc	8b 55 e0	 mov	 edx, DWORD PTR __Erasednode$[ebp]
  002bf	83 c2 0c	 add	 edx, 12			; 0000000cH
  002c2	89 55 c0	 mov	 DWORD PTR __Right$[ebp], edx
  002c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002c8	83 c0 0c	 add	 eax, 12			; 0000000cH
  002cb	89 45 c4	 mov	 DWORD PTR __Left$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  002ce	8b 4d c4	 mov	 ecx, DWORD PTR __Left$[ebp]
  002d1	89 4d b8	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  002d4	8b 55 b8	 mov	 edx, DWORD PTR $T6[ebp]
  002d7	8a 02		 mov	 al, BYTE PTR [edx]
  002d9	88 45 f3	 mov	 BYTE PTR __Tmp$8[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  002dc	8b 4d c0	 mov	 ecx, DWORD PTR __Right$[ebp]
  002df	89 4d b4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  002e2	8b 55 c4	 mov	 edx, DWORD PTR __Left$[ebp]
  002e5	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  002e8	8a 08		 mov	 cl, BYTE PTR [eax]
  002ea	88 0a		 mov	 BYTE PTR [edx], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  002ec	8d 55 f3	 lea	 edx, DWORD PTR __Tmp$8[ebp]
  002ef	89 55 b0	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  002f2	8b 45 c0	 mov	 eax, DWORD PTR __Right$[ebp]
  002f5	8b 4d b0	 mov	 ecx, DWORD PTR $T4[ebp]
  002f8	8a 11		 mov	 dl, BYTE PTR [ecx]
  002fa	88 10		 mov	 BYTE PTR [eax], dl
$LN18@Extract:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 661  : 		if (_Erasednode->_Color == this->_Black)

  002fc	8b 45 e0	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  002ff	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  00303	83 f9 01	 cmp	 ecx, 1
  00306	0f 85 fb 01 00
	00		 jne	 $LN33@Extract

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root()

  0030c	eb 09		 jmp	 SHORT $LN132@Extract
$LN8@Extract:

; 665  : 				_Fixnodeparent = _Fixnode->_Parent)

  0030e	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00311	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00314	89 45 e8	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax
$LN132@Extract:

; 664  : 				&& _Fixnode->_Color == this->_Black;

  00317	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0031d	8b 45 e4	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00320	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00323	0f 84 d7 01 00
	00		 je	 $LN9@Extract
  00329	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0032c	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  00330	83 fa 01	 cmp	 edx, 1
  00333	0f 85 c7 01 00
	00		 jne	 $LN9@Extract

; 666  : 				if (_Fixnode == _Fixnodeparent->_Left)

  00339	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0033c	8b 4d e4	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0033f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00341	0f 85 e0 00 00
	00		 jne	 $LN34@Extract

; 667  : 					{	// fixup left subtree
; 668  : 					_Pnode = _Fixnodeparent->_Right;

  00347	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0034a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0034d	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 669  : 					if (_Pnode->_Color == this->_Red)

  00350	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00353	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  00357	85 d2		 test	 edx, edx
  00359	75 23		 jne	 SHORT $LN36@Extract

; 670  : 						{	// rotate red up from right subtree
; 671  : 						_Pnode->_Color = this->_Black;

  0035b	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0035e	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 672  : 						_Fixnodeparent->_Color = this->_Red;

  00362	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00365	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 673  : 						_Lrotate(_Fixnodeparent);

  00369	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0036c	52		 push	 edx
  0036d	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00370	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate

; 674  : 						_Pnode = _Fixnodeparent->_Right;

  00375	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00378	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0037b	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN36@Extract:

; 675  : 						}
; 676  : 
; 677  : 					if (_Pnode->_Isnil)

  0037e	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00381	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  00385	85 c0		 test	 eax, eax
  00387	74 0b		 je	 SHORT $LN37@Extract

; 678  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00389	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0038c	89 4d e4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 679  : 					else if (_Pnode->_Left->_Color == this->_Black

  0038f	e9 8e 00 00 00	 jmp	 $LN38@Extract
$LN37@Extract:

; 680  : 						&& _Pnode->_Right->_Color == this->_Black)

  00394	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00397	8b 02		 mov	 eax, DWORD PTR [edx]
  00399	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  0039d	83 f9 01	 cmp	 ecx, 1
  003a0	75 1e		 jne	 SHORT $LN39@Extract
  003a2	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  003a5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003a8	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  003ac	83 f9 01	 cmp	 ecx, 1
  003af	75 0f		 jne	 SHORT $LN39@Extract

; 681  : 						{	// redden right subtree with black children
; 682  : 						_Pnode->_Color = this->_Red;

  003b1	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  003b4	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 683  : 						_Fixnode = _Fixnodeparent;

  003b8	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003bb	89 45 e4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 684  : 						}
; 685  : 					else

  003be	eb 62		 jmp	 SHORT $LN38@Extract
$LN39@Extract:

; 686  : 						{	// must rearrange right subtree
; 687  : 						if (_Pnode->_Right->_Color == this->_Black)

  003c0	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  003c3	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003c6	0f be 42 0c	 movsx	 eax, BYTE PTR [edx+12]
  003ca	83 f8 01	 cmp	 eax, 1
  003cd	75 25		 jne	 SHORT $LN41@Extract

; 688  : 							{	// rotate red up from left sub-subtree
; 689  : 							_Pnode->_Left->_Color = this->_Black;

  003cf	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  003d2	8b 11		 mov	 edx, DWORD PTR [ecx]
  003d4	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1

; 690  : 							_Pnode->_Color = this->_Red;

  003d8	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003db	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 691  : 							_Rrotate(_Pnode);

  003df	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  003e2	51		 push	 ecx
  003e3	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e6	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate

; 692  : 							_Pnode = _Fixnodeparent->_Right;

  003eb	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  003ee	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  003f1	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN41@Extract:

; 693  : 							}
; 694  : 
; 695  : 						_Pnode->_Color = _Fixnodeparent->_Color;

  003f4	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  003f7	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  003fa	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  003fd	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 696  : 						_Fixnodeparent->_Color = this->_Black;

  00400	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00403	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 697  : 						_Pnode->_Right->_Color = this->_Black;

  00407	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0040a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0040d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 698  : 						_Lrotate(_Fixnodeparent);

  00411	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00414	51		 push	 ecx
  00415	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00418	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate

; 699  : 						break;	// tree now recolored/rebalanced

  0041d	e9 de 00 00 00	 jmp	 $LN9@Extract
$LN38@Extract:

; 700  : 						}
; 701  : 					}
; 702  : 				else

  00422	e9 d4 00 00 00	 jmp	 $LN35@Extract
$LN34@Extract:

; 703  : 					{	// fixup right subtree
; 704  : 					_Pnode = _Fixnodeparent->_Left;

  00427	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0042a	8b 02		 mov	 eax, DWORD PTR [edx]
  0042c	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 705  : 					if (_Pnode->_Color == this->_Red)

  0042f	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00432	0f be 51 0c	 movsx	 edx, BYTE PTR [ecx+12]
  00436	85 d2		 test	 edx, edx
  00438	75 22		 jne	 SHORT $LN42@Extract

; 706  : 						{	// rotate red up from left subtree
; 707  : 						_Pnode->_Color = this->_Black;

  0043a	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0043d	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 708  : 						_Fixnodeparent->_Color = this->_Red;

  00441	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00444	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 709  : 						_Rrotate(_Fixnodeparent);

  00448	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  0044b	52		 push	 edx
  0044c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0044f	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate

; 710  : 						_Pnode = _Fixnodeparent->_Left;

  00454	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00457	8b 08		 mov	 ecx, DWORD PTR [eax]
  00459	89 4d ec	 mov	 DWORD PTR __Pnode$[ebp], ecx
$LN42@Extract:

; 711  : 						}
; 712  : 
; 713  : 					if (_Pnode->_Isnil)

  0045c	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0045f	0f be 42 0d	 movsx	 eax, BYTE PTR [edx+13]
  00463	85 c0		 test	 eax, eax
  00465	74 0b		 je	 SHORT $LN43@Extract

; 714  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

  00467	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0046a	89 4d e4	 mov	 DWORD PTR __Fixnode$[ebp], ecx

; 715  : 					else if (_Pnode->_Right->_Color == this->_Black

  0046d	e9 89 00 00 00	 jmp	 $LN35@Extract
$LN43@Extract:

; 716  : 						&& _Pnode->_Left->_Color == this->_Black)

  00472	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00475	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00478	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  0047c	83 f9 01	 cmp	 ecx, 1
  0047f	75 1d		 jne	 SHORT $LN45@Extract
  00481	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00484	8b 02		 mov	 eax, DWORD PTR [edx]
  00486	0f be 48 0c	 movsx	 ecx, BYTE PTR [eax+12]
  0048a	83 f9 01	 cmp	 ecx, 1
  0048d	75 0f		 jne	 SHORT $LN45@Extract

; 717  : 						{	// redden left subtree with black children
; 718  : 						_Pnode->_Color = this->_Red;

  0048f	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00492	c6 42 0c 00	 mov	 BYTE PTR [edx+12], 0

; 719  : 						_Fixnode = _Fixnodeparent;

  00496	8b 45 e8	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00499	89 45 e4	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 720  : 						}
; 721  : 					else

  0049c	eb 5d		 jmp	 SHORT $LN35@Extract
$LN45@Extract:

; 722  : 						{	// must rearrange left subtree
; 723  : 						if (_Pnode->_Left->_Color == this->_Black)

  0049e	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a3	0f be 42 0c	 movsx	 eax, BYTE PTR [edx+12]
  004a7	83 f8 01	 cmp	 eax, 1
  004aa	75 25		 jne	 SHORT $LN47@Extract

; 724  : 							{	// rotate red up from right sub-subtree
; 725  : 							_Pnode->_Right->_Color = this->_Black;

  004ac	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004af	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  004b2	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1

; 726  : 							_Pnode->_Color = this->_Red;

  004b6	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  004b9	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 727  : 							_Lrotate(_Pnode);

  004bd	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004c0	51		 push	 ecx
  004c1	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  004c4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate

; 728  : 							_Pnode = _Fixnodeparent->_Left;

  004c9	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  004cc	8b 02		 mov	 eax, DWORD PTR [edx]
  004ce	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN47@Extract:

; 729  : 							}
; 730  : 
; 731  : 						_Pnode->_Color = _Fixnodeparent->_Color;

  004d1	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  004d4	8b 55 e8	 mov	 edx, DWORD PTR __Fixnodeparent$[ebp]
  004d7	8a 42 0c	 mov	 al, BYTE PTR [edx+12]
  004da	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 732  : 						_Fixnodeparent->_Color = this->_Black;

  004dd	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  004e0	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 733  : 						_Pnode->_Left->_Color = this->_Black;

  004e4	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  004e7	8b 02		 mov	 eax, DWORD PTR [edx]
  004e9	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 734  : 						_Rrotate(_Fixnodeparent);

  004ed	8b 4d e8	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  004f0	51		 push	 ecx
  004f1	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  004f4	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate

; 735  : 						break;	// tree now recolored/rebalanced

  004f9	eb 05		 jmp	 SHORT $LN9@Extract
$LN35@Extract:

; 736  : 						}
; 737  : 					}

  004fb	e9 0e fe ff ff	 jmp	 $LN8@Extract
$LN9@Extract:

; 738  : 
; 739  : 			_Fixnode->_Color = this->_Black;	// stopping node is black

  00500	8b 55 e4	 mov	 edx, DWORD PTR __Fixnode$[ebp]
  00503	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
$LN33@Extract:

; 740  : 			}
; 741  : 
; 742  : 		if (0 < _Mysize)

  00507	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0050a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0050e	76 0f		 jbe	 SHORT $LN48@Extract

; 743  : 			--_Mysize;

  00510	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00513	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00516	83 ea 01	 sub	 edx, 1
  00519	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0051c	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN48@Extract:

; 745  : 		return (_Erasednode);

  0051f	8b 4d e0	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00522	89 4d a8	 mov	 DWORD PTR $T2[ebp], ecx
  00525	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0052c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00533	6a 03		 push	 3
  00535	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00538	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0053e	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00541	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00546	8d 4d ac	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00549	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0054f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 745  : 		return (_Erasednode);

  00556	8b 45 a8	 mov	 eax, DWORD PTR $T2[ebp]

; 746  : 		}

  00559	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0055c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00563	59		 pop	 ecx
  00564	8b e5		 mov	 esp, ebp
  00566	5d		 pop	 ebp
  00567	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Extract
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate, COMDAT
; _this$ = ecx

; 536  : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 537  : 		_Nodeptr _Pnode = _Wherenode->_Left;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 538  : 		_Wherenode->_Left = _Pnode->_Right;

  00011	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00014	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx

; 539  : 
; 540  : 		if (!_Pnode->_Right->_Isnil)

  0001c	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0001f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00022	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00026	85 c9		 test	 ecx, ecx
  00028	75 0c		 jne	 SHORT $LN2@Rrotate

; 541  : 			_Pnode->_Right->_Parent = _Wherenode;

  0002a	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0002d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00033	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 542  : 		_Pnode->_Parent = _Wherenode->_Parent;

  00036	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00039	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 543  : 
; 544  : 		if (_Wherenode == _Myhead->_Parent)

  00042	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0004b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004e	75 0e		 jne	 SHORT $LN3@Rrotate

; 545  : 			{
; 546  : 			_Myhead->_Parent = _Pnode;

  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00056	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00059	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0005c	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 547  : 			}
; 548  : 		else if (_Wherenode == _Wherenode->_Parent->_Right)

  0005e	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00061	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00064	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00067	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006a	75 0e		 jne	 SHORT $LN5@Rrotate

; 549  : 			{
; 550  : 			_Wherenode->_Parent->_Right = _Pnode;

  0006c	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0006f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00075	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 551  : 			}
; 552  : 		else

  00078	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 553  : 			{
; 554  : 			_Wherenode->_Parent->_Left = _Pnode;

  0007a	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0007d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 555  : 			}
; 556  : 
; 557  : 		_Pnode->_Right = _Wherenode;

  00085	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 558  : 		_Wherenode->_Parent = _Pnode;

  0008e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00091	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00094	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 559  : 		}

  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate, COMDAT
; _this$ = ecx

; 507  : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 508  : 		_Nodeptr _Pnode = _Wherenode->_Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000f	89 4d fc	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 509  : 		_Wherenode->_Right = _Pnode->_Left;

  00012	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00015	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 510  : 
; 511  : 		if (!_Pnode->_Left->_Isnil)

  0001d	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	0f be 48 0d	 movsx	 ecx, BYTE PTR [eax+13]
  00026	85 c9		 test	 ecx, ecx
  00028	75 0b		 jne	 SHORT $LN2@Lrotate

; 512  : 			{
; 513  : 			_Pnode->_Left->_Parent = _Wherenode;

  0002a	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 514  : 			}
; 515  : 
; 516  : 		_Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00038	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0003b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003e	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 517  : 
; 518  : 		if (_Wherenode == _Myhead->_Parent)

  00041	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0004a	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004d	75 0e		 jne	 SHORT $LN3@Lrotate

; 519  : 			{
; 520  : 			_Myhead->_Parent = _Pnode;

  0004f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00055	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00058	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0005b	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 521  : 			}
; 522  : 		else if (_Wherenode == _Wherenode->_Parent->_Left)

  0005d	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00060	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00066	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00068	75 0d		 jne	 SHORT $LN5@Lrotate

; 523  : 			{
; 524  : 			_Wherenode->_Parent->_Left = _Pnode;

  0006a	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0006d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx

; 525  : 			}
; 526  : 		else

  00075	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 527  : 			{
; 528  : 			_Wherenode->_Parent->_Right = _Pnode;

  00077	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  0007a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 529  : 			}
; 530  : 
; 531  : 		_Pnode->_Left = _Wherenode;

  00083	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00086	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00089	89 02		 mov	 DWORD PTR [edx], eax

; 532  : 		_Wherenode->_Parent = _Pnode;

  0008b	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0008e	8b 55 fc	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00091	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 533  : 		}

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rmost, COMDAT
; _this$ = ecx

; 502  : 		{	// return rightmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 		return (_Myhead->_Right);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	83 c0 08	 add	 eax, 8

; 504  : 		}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Rmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Rmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lmost, COMDAT
; _this$ = ecx

; 497  : 		{	// return leftmost node in nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 498  : 		return (_Myhead->_Left);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 499  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Lmost@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Lmost
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Root, COMDAT
; _this$ = ecx

; 492  : 		{	// return root of nonmutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 493  : 		return (_Myhead->_Parent);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	83 c0 04	 add	 eax, 4

; 494  : 		}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Root@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Root
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Min, COMDAT

; 485  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@Min:

; 486  : 		while (!_Pnode->_Left->_Isnil)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  0000c	85 d2		 test	 edx, edx
  0000e	75 0a		 jne	 SHORT $LN3@Min

; 487  : 			_Pnode = _Pnode->_Left;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  00018	eb e9		 jmp	 SHORT $LN2@Min
$LN3@Min:

; 488  : 		return (_Pnode);

  0001a	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 489  : 		}

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Min
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Max, COMDAT

; 478  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@Max:

; 479  : 		while (!_Pnode->_Right->_Isnil)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	0f be 51 0d	 movsx	 edx, BYTE PTR [ecx+13]
  0000d	85 d2		 test	 edx, edx
  0000f	75 0b		 jne	 SHORT $LN3@Max

; 480  : 			_Pnode = _Pnode->_Right;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00014	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00017	89 4d 08	 mov	 DWORD PTR __Pnode$[ebp], ecx
  0001a	eb e7		 jmp	 SHORT $LN2@Max
$LN3@Max:

; 481  : 		return (_Pnode);

  0001c	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 482  : 		}

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@SAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Max
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 470  : 		{	// initialize data

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 468  : 		: _Myhead(),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 469  : 		_Mysize(0)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 471  : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 1019 : 		{	// return const reference to _Tree_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 1021 : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 1014 : 		{	// return reference to _Tree_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 1016 : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getal, COMDAT
; _this$ = ecx

; 1004 : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax

; 292  : 		return (*this);

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 1006 : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABUstring_cmp_nocase@base@zl@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABUstring_cmp_nocase@base@zl@@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 999  : 		{	// return const reference to ordering predicate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1000 : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1000 : 		return (_Mypair._Get_first());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1001 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEABUstring_cmp_nocase@base@zl@@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 946  : 		{	// free head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax

; 292  : 		return (*this);

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx

; 947  : 		_Node::_Freenode0(_Getal(), _Pnode);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00028	83 c4 08	 add	 esp, 8

; 948  : 		}

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
__Val$ = -72						; size = 4
$T5 = -68						; size = 4
$T6 = -64						; size = 4
$T7 = -60						; size = 4
__Val$ = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
$T10 = -44						; size = 4
__Val$ = -40						; size = 4
$T11 = -36						; size = 4
$T12 = -32						; size = 4
_this$ = -28						; size = 4
__Al$ = -24						; size = 4
__Pnode$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buyheadnode, COMDAT
; _this$ = ecx

; 927  : 		{	// get head node using current allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T12[ebp], eax

; 292  : 		return (*this);

  00035	8b 4d e0	 mov	 ecx, DWORD PTR $T12[ebp]
  00038	89 4d dc	 mov	 DWORD PTR $T11[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  0003b	8b 55 dc	 mov	 edx, DWORD PTR $T11[ebp]
  0003e	89 55 e8	 mov	 DWORD PTR __Al$[ebp], edx

; 928  : 		_Alnode& _Al = _Getal();
; 929  : 		_Nodeptr _Pnode = _Al.allocate(1);

  00041	6a 01		 push	 1
  00043	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Pnode$[ebp], eax

; 930  : 
; 931  : 		_TRY_BEGIN

  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 932  : 		_Alnode_traits::construct(_Al, _STD addressof(_Pnode->_Left), _Pnode);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00058	89 45 d8	 mov	 DWORD PTR __Val$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0005b	8b 4d d8	 mov	 ecx, DWORD PTR __Val$[ebp]
  0005e	89 4d d4	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00061	8b 55 d4	 mov	 edx, DWORD PTR $T10[ebp]
  00064	89 55 d0	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00067	8d 45 ec	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0006a	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0006d	8b 4d d0	 mov	 ecx, DWORD PTR $T9[ebp]
  00070	8b 55 cc	 mov	 edx, DWORD PTR $T8[ebp]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 933  : 		_Alnode_traits::construct(_Al, _STD addressof(_Pnode->_Parent), _Pnode);

  00077	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007a	83 c1 04	 add	 ecx, 4
  0007d	89 4d c8	 mov	 DWORD PTR __Val$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00080	8b 55 c8	 mov	 edx, DWORD PTR __Val$[ebp]
  00083	89 55 c4	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00086	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00089	89 45 c0	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0008c	8d 4d ec	 lea	 ecx, DWORD PTR __Pnode$[ebp]
  0008f	89 4d bc	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00092	8b 55 c0	 mov	 edx, DWORD PTR $T6[ebp]
  00095	8b 45 bc	 mov	 eax, DWORD PTR $T5[ebp]
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 934  : 		_Alnode_traits::construct(_Al, _STD addressof(_Pnode->_Right), _Pnode);

  0009c	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  0009f	83 c2 08	 add	 edx, 8
  000a2	89 55 b8	 mov	 DWORD PTR __Val$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  000a5	8b 45 b8	 mov	 eax, DWORD PTR __Val$[ebp]
  000a8	89 45 b4	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  000ab	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp]
  000ae	89 4d b0	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  000b1	8d 55 ec	 lea	 edx, DWORD PTR __Pnode$[ebp]
  000b4	89 55 ac	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000b7	8b 45 b0	 mov	 eax, DWORD PTR $T3[ebp]
  000ba	8b 4d ac	 mov	 ecx, DWORD PTR $T2[ebp]
  000bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bf	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 934  : 		_Alnode_traits::construct(_Al, _STD addressof(_Pnode->_Right), _Pnode);

  000c1	eb 1d		 jmp	 SHORT $LN4@Buyheadnod
__catch$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$0:

; 935  : 		_CATCH_ALL
; 936  : 		_Al.deallocate(_Pnode, 1);

  000c3	6a 01		 push	 1
  000c5	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000c8	50		 push	 eax
  000c9	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  000cc	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate

; 937  : 		_RERAISE;

  000d1	6a 00		 push	 0
  000d3	6a 00		 push	 0
  000d5	e8 00 00 00 00	 call	 __CxxThrowException@8

; 938  : 		_CATCH_END

  000da	b8 00 00 00 00	 mov	 eax, $LN7@Buyheadnod
  000df	c3		 ret	 0
$LN4@Buyheadnod:
  000e0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000e7	eb 07		 jmp	 SHORT __tryend$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$1
$LN7@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
  000e9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ$1:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 939  : 
; 940  : 		_Pnode->_Color = _Black;

  000f0	8b 4d ec	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  000f3	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 941  : 		_Pnode->_Isnil = true;

  000f7	8b 55 ec	 mov	 edx, DWORD PTR __Pnode$[ebp]
  000fa	c6 42 0d 01	 mov	 BYTE PTR [edx+13], 1

; 942  : 		return (_Pnode);

  000fe	8b 45 ec	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN3@Buyheadnod:

; 943  : 		}

  00101	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00104	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010b	59		 pop	 ecx
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buyheadnode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Orphan_all@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_all@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_all, COMDAT
; _this$ = ecx

; 917  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx

; 918  : 		_Get_data()._Orphan_all();

  0001b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 919  : 		}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Orphan_all@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Myproxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?_Myproxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myproxy, COMDAT
; _this$ = ecx

; 866  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx

; 867  : 		return (_Get_data()._Myproxy);

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 868  : 		}

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Myproxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Getpfirst@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
tv80 = -8						; size = 4
$T4 = -4						; size = 4
?_Getpfirst@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getpfirst, COMDAT
; _this$ = ecx

; 861  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00015	8b 55 ec	 mov	 edx, DWORD PTR $T2[ebp]
  00018	89 55 fc	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00021	75 09		 jne	 SHORT $LN14@Getpfirst
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
  0002a	eb 0b		 jmp	 SHORT $LN15@Getpfirst
$LN14@Getpfirst:
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	83 c2 04	 add	 edx, 4
  00034	89 55 f8	 mov	 DWORD PTR tv80[ebp], edx
$LN15@Getpfirst:
  00037	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]
  0003a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 862  : 		return (_Get_data()._Getpfirst());

  0003d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]

; 863  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Getpfirst@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Free_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
$T13 = -36						; size = 4
$T14 = -32						; size = 4
$T15 = -28						; size = 4
$T16 = -24						; size = 4
$T17 = -20						; size = 4
$T18 = -16						; size = 4
__Ptr$19 = -12						; size = 4
__Bytes$20 = -8						; size = 4
_this$ = -4						; size = 4
?_Free_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Free_proxy, COMDAT
; _this$ = ecx

; 852  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T18[ebp], eax

; 292  : 		return (*this);

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T18[ebp]
  00012	89 4d ec	 mov	 DWORD PTR $T17[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  00015	8b 55 ec	 mov	 edx, DWORD PTR $T17[ebp]
  00018	89 55 ac	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T16[ebp], eax
  00021	8b 4d e8	 mov	 ecx, DWORD PTR $T16[ebp]
  00024	89 4d e4	 mov	 DWORD PTR $T15[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00027	8b 55 e4	 mov	 edx, DWORD PTR $T15[ebp]
  0002a	89 55 e0	 mov	 DWORD PTR $T14[ebp], edx

; 918  : 		_Get_data()._Orphan_all();

  0002d	8b 4d e0	 mov	 ecx, DWORD PTR $T14[ebp]
  00030	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 45 dc	 mov	 DWORD PTR $T13[ebp], eax
  0003b	8b 4d dc	 mov	 ecx, DWORD PTR $T13[ebp]
  0003e	89 4d d8	 mov	 DWORD PTR $T12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00041	8b 55 d8	 mov	 edx, DWORD PTR $T12[ebp]
  00044	89 55 d4	 mov	 DWORD PTR $T11[ebp], edx

; 867  : 		return (_Get_data()._Myproxy);

  00047	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
  0004a	89 45 a8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	89 4d d0	 mov	 DWORD PTR $T10[ebp], ecx
  00053	8b 55 d0	 mov	 edx, DWORD PTR $T10[ebp]
  00056	89 55 cc	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00059	8b 45 cc	 mov	 eax, DWORD PTR $T9[ebp]
  0005c	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax

; 867  : 		return (_Get_data()._Myproxy);

  0005f	8b 4d c8	 mov	 ecx, DWORD PTR $T8[ebp]
  00062	89 4d c4	 mov	 DWORD PTR $T7[ebp], ecx

; 853  : 		_Alproxy _Proxy_allocator(_Getal());
; 854  : 		_Orphan_all();
; 855  : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
; 856  : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

  00065	8b 55 c4	 mov	 edx, DWORD PTR $T7[ebp]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	c1 e1 03	 shl	 ecx, 3
  00075	89 4d f8	 mov	 DWORD PTR __Bytes$20[ebp], ecx
  00078	8b 55 c0	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0007b	89 55 f4	 mov	 DWORD PTR __Ptr$19[ebp], edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0007e	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __Bytes$20[ebp], 4096 ; 00001000H
  00085	72 10		 jb	 SHORT $LN64@Free_proxy

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00087	8d 45 f8	 lea	 eax, DWORD PTR __Bytes$20[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d f4	 lea	 ecx, DWORD PTR __Ptr$19[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00094	83 c4 08	 add	 esp, 8
$LN64@Free_proxy:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  00097	8b 55 f8	 mov	 edx, DWORD PTR __Bytes$20[ebp]
  0009a	52		 push	 edx
  0009b	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$19[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a4	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	89 4d bc	 mov	 DWORD PTR $T6[ebp], ecx
  000ad	8b 55 bc	 mov	 edx, DWORD PTR $T6[ebp]
  000b0	89 55 b8	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  000b3	8b 45 b8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 b4	 mov	 DWORD PTR $T4[ebp], eax

; 867  : 		return (_Get_data()._Myproxy);

  000b9	8b 4d b4	 mov	 ecx, DWORD PTR $T4[ebp]
  000bc	89 4d b0	 mov	 DWORD PTR $T3[ebp], ecx

; 857  : 		_Myproxy() = nullptr;

  000bf	8b 55 b0	 mov	 edx, DWORD PTR $T3[ebp]
  000c2	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 858  : 		}

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?_Free_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Alloc_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -108						; size = 8
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
$T11 = -64						; size = 4
$T12 = -60						; size = 4
__Ptr$ = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
__Ptr$ = -36						; size = 4
$T17 = -32						; size = 4
$T18 = -28						; size = 4
$T19 = -24						; size = 4
$T20 = -20						; size = 4
$T21 = -16						; size = 4
$T22 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 844  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T22[ebp], eax

; 292  : 		return (*this);

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T22[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T21[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  00015	8b 55 f0	 mov	 edx, DWORD PTR $T21[ebp]
  00018	89 55 9c	 mov	 DWORD PTR $T2[ebp], edx

; 845  : 		_Alproxy _Proxy_allocator(_Getal());
; 846  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0001b	6a 01		 push	 1
  0001d	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy_allocator$[ebp]
  00020	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00025	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00028	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR $T20[ebp], eax
  0002e	8b 4d ec	 mov	 ecx, DWORD PTR $T20[ebp]
  00031	89 4d e8	 mov	 DWORD PTR $T19[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00034	8b 55 e8	 mov	 edx, DWORD PTR $T19[ebp]
  00037	89 55 e4	 mov	 DWORD PTR $T18[ebp], edx

; 867  : 		return (_Get_data()._Myproxy);

  0003a	8b 45 e4	 mov	 eax, DWORD PTR $T18[ebp]
  0003d	89 45 e0	 mov	 DWORD PTR $T17[ebp], eax

; 845  : 		_Alproxy _Proxy_allocator(_Getal());
; 846  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00040	8b 4d e0	 mov	 ecx, DWORD PTR $T17[ebp]
  00043	8b 55 dc	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00046	89 11		 mov	 DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  00048	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0004f	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], 0

; 302  : 		return (_Myval2);

  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
  0005c	8b 4d d8	 mov	 ecx, DWORD PTR $T16[ebp]
  0005f	89 4d d4	 mov	 DWORD PTR $T15[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00062	8b 55 d4	 mov	 edx, DWORD PTR $T15[ebp]
  00065	89 55 d0	 mov	 DWORD PTR $T14[ebp], edx

; 867  : 		return (_Get_data()._Myproxy);

  00068	8b 45 d0	 mov	 eax, DWORD PTR $T14[ebp]
  0006b	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax

; 847  : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

  0006e	8b 4d cc	 mov	 ecx, DWORD PTR $T13[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 c8	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00076	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00079	89 45 c0	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0007c	8d 4d 94	 lea	 ecx, DWORD PTR $T1[ebp]
  0007f	89 4d c4	 mov	 DWORD PTR $T12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00082	8b 55 c4	 mov	 edx, DWORD PTR $T12[ebp]
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0008a	8b 55 c0	 mov	 edx, DWORD PTR $T11[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax
  0008f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 45 bc	 mov	 DWORD PTR $T10[ebp], eax
  00098	8b 4d bc	 mov	 ecx, DWORD PTR $T10[ebp]
  0009b	89 4d b8	 mov	 DWORD PTR $T9[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  0009e	8b 55 b8	 mov	 edx, DWORD PTR $T9[ebp]
  000a1	89 55 b4	 mov	 DWORD PTR $T8[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  000a4	8b 45 b4	 mov	 eax, DWORD PTR $T8[ebp]
  000a7	89 45 a0	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000aa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	89 4d b0	 mov	 DWORD PTR $T7[ebp], ecx
  000b0	8b 55 b0	 mov	 edx, DWORD PTR $T7[ebp]
  000b3	89 55 ac	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  000b6	8b 45 ac	 mov	 eax, DWORD PTR $T6[ebp]
  000b9	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax

; 867  : 		return (_Get_data()._Myproxy);

  000bc	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  000bf	89 4d a4	 mov	 DWORD PTR $T4[ebp], ecx

; 848  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  000c2	8b 55 a4	 mov	 edx, DWORD PTR $T4[ebp]
  000c5	8b 02		 mov	 eax, DWORD PTR [edx]
  000c7	8b 4d a0	 mov	 ecx, DWORD PTR $T3[ebp]
  000ca	89 08		 mov	 DWORD PTR [eax], ecx

; 849  : 		}

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
?_Alloc_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -44						; size = 4
__Pnode$ = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 838  : 		{	// destroy head node, proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
  0002e	8b 4d ec	 mov	 ecx, DWORD PTR $T7[ebp]
  00031	89 4d e8	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  00034	8b 55 e8	 mov	 edx, DWORD PTR $T6[ebp]
  00037	89 55 e4	 mov	 DWORD PTR $T5[ebp], edx

; 839  : 		_Freeheadnode(_Get_data()._Myhead);

  0003a	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  0003d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00040	89 4d d8	 mov	 DWORD PTR __Pnode$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00043	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00046	89 55 e0	 mov	 DWORD PTR $T4[ebp], edx

; 292  : 		return (*this);

  00049	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0004c	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1005 : 		return (_Mypair._Get_second()._Get_first());

  0004f	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00052	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx

; 947  : 		_Node::_Freenode0(_Getal(), _Pnode);

  00055	8b 55 d8	 mov	 edx, DWORD PTR __Pnode$[ebp]
  00058	52		 push	 edx
  00059	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >
  00062	83 c4 08	 add	 esp, 8

; 840  : 		_Free_proxy();

  00065	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Free_proxy

; 841  : 		}

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
$T3 = -28						; size = 4
__My_data$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Construct, COMDAT
; _this$ = ecx

; 826  : 		{	// construct head node, proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 10	 sub	 esp, 16			; 00000010H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00035	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00038	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1015 : 		return (_Mypair._Get_second()._Get_second());

  0003b	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  0003e	89 55 e8	 mov	 DWORD PTR __My_data$[ebp], edx

; 827  : 		auto& _My_data = _Get_data();
; 828  : 		_My_data._Myhead = _Buyheadnode();

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Buyheadnode
  00049	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 829  : 		_TRY_BEGIN

  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 830  : 		_Alloc_proxy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Alloc_proxy
  0005e	eb 1e		 jmp	 SHORT $LN4@Construct
__catch$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ$0:

; 831  : 		_CATCH_ALL
; 832  : 		_Freeheadnode(_My_data._Myhead);

  00060	8b 55 e8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00063	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00066	50		 push	 eax
  00067	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	e8 00 00 00 00	 call	 ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Freeheadnode

; 833  : 		_RERAISE;

  0006f	6a 00		 push	 0
  00071	6a 00		 push	 0
  00073	e8 00 00 00 00	 call	 __CxxThrowException@8

; 834  : 		_CATCH_END

  00078	b8 00 00 00 00	 mov	 eax, $LN7@Construct
  0007d	c3		 ret	 0
$LN4@Construct:
  0007e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00085	eb 07		 jmp	 SHORT $LN3@Construct
$LN7@Construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
  00087	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 835  : 		}

  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Construct
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$ = -16						; size = 4
_this$2 = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >, COMDAT
; _this$ = ecx

; 791  : 		{	// construct from comparator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 470  : 		{	// initialize data
; 471  : 		}
; 472  : 
; 473  : 	enum _Redbl
; 474  : 		{	// colors for link to parent
; 475  : 		_Red, _Black};
; 476  : 
; 477  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 478  : 		{	// return rightmost node in subtree at _Pnode
; 479  : 		while (!_Pnode->_Right->_Isnil)
; 480  : 			_Pnode = _Pnode->_Right;
; 481  : 		return (_Pnode);
; 482  : 		}
; 483  : 
; 484  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 485  : 		{	// return leftmost node in subtree at _Pnode
; 486  : 		while (!_Pnode->_Left->_Isnil)
; 487  : 			_Pnode = _Pnode->_Left;
; 488  : 		return (_Pnode);
; 489  : 		}
; 490  : 
; 491  : 	_Nodeptr& _Root() const
; 492  : 		{	// return root of nonmutable tree
; 493  : 		return (_Myhead->_Parent);
; 494  : 		}
; 495  : 
; 496  : 	_Nodeptr& _Lmost() const
; 497  : 		{	// return leftmost node in nonmutable tree
; 498  : 		return (_Myhead->_Left);
; 499  : 		}
; 500  : 
; 501  : 	_Nodeptr& _Rmost() const
; 502  : 		{	// return rightmost node in nonmutable tree
; 503  : 		return (_Myhead->_Right);
; 504  : 		}
; 505  : 
; 506  : 	void _Lrotate(_Nodeptr _Wherenode)
; 507  : 		{	// promote right node to root of subtree
; 508  : 		_Nodeptr _Pnode = _Wherenode->_Right;
; 509  : 		_Wherenode->_Right = _Pnode->_Left;
; 510  : 
; 511  : 		if (!_Pnode->_Left->_Isnil)
; 512  : 			{
; 513  : 			_Pnode->_Left->_Parent = _Wherenode;
; 514  : 			}
; 515  : 
; 516  : 		_Pnode->_Parent = _Wherenode->_Parent;
; 517  : 
; 518  : 		if (_Wherenode == _Myhead->_Parent)
; 519  : 			{
; 520  : 			_Myhead->_Parent = _Pnode;
; 521  : 			}
; 522  : 		else if (_Wherenode == _Wherenode->_Parent->_Left)
; 523  : 			{
; 524  : 			_Wherenode->_Parent->_Left = _Pnode;
; 525  : 			}
; 526  : 		else
; 527  : 			{
; 528  : 			_Wherenode->_Parent->_Right = _Pnode;
; 529  : 			}
; 530  : 
; 531  : 		_Pnode->_Left = _Wherenode;
; 532  : 		_Wherenode->_Parent = _Pnode;
; 533  : 		}
; 534  : 
; 535  : 	void _Rrotate(_Nodeptr _Wherenode)
; 536  : 		{	// promote left node to root of subtree
; 537  : 		_Nodeptr _Pnode = _Wherenode->_Left;
; 538  : 		_Wherenode->_Left = _Pnode->_Right;
; 539  : 
; 540  : 		if (!_Pnode->_Right->_Isnil)
; 541  : 			_Pnode->_Right->_Parent = _Wherenode;
; 542  : 		_Pnode->_Parent = _Wherenode->_Parent;
; 543  : 
; 544  : 		if (_Wherenode == _Myhead->_Parent)
; 545  : 			{
; 546  : 			_Myhead->_Parent = _Pnode;
; 547  : 			}
; 548  : 		else if (_Wherenode == _Wherenode->_Parent->_Right)
; 549  : 			{
; 550  : 			_Wherenode->_Parent->_Right = _Pnode;
; 551  : 			}
; 552  : 		else
; 553  : 			{
; 554  : 			_Wherenode->_Parent->_Left = _Pnode;
; 555  : 			}
; 556  : 
; 557  : 		_Pnode->_Right = _Wherenode;
; 558  : 		_Wherenode->_Parent = _Pnode;
; 559  : 		}
; 560  : 
; 561  : 	_Nodeptr _Extract(const_iterator _Where)
; 562  : 		{	// extract node at _Where
; 563  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 564  : 		_STL_VERIFY(_Where._Getcont() == this
; 565  : 			&& !_Where._Ptr->_Isnil, "map/set erase iterator outside range");
; 566  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 567  : 
; 568  : 		_Nodeptr _Erasednode = _Where._Ptr;	// node to erase
; 569  : 		++_Where;	// save successor iterator for return
; 570  : 
; 571  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 572  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 573  : 		_Nodeptr _Pnode = _Erasednode;
; 574  : 
; 575  : 		if (_Pnode->_Left->_Isnil)
; 576  : 			{
; 577  : 			_Fixnode = _Pnode->_Right;	// stitch up right subtree
; 578  : 			}
; 579  : 		else if (_Pnode->_Right->_Isnil)
; 580  : 			{
; 581  : 			_Fixnode = _Pnode->_Left;	// stitch up left subtree
; 582  : 			}
; 583  : 		else
; 584  : 			{	// two subtrees, must lift successor node to replace erased
; 585  : 			_Pnode = _Where._Ptr;	// _Pnode is successor node
; 586  : 			_Fixnode = _Pnode->_Right;	// _Fixnode is only subtree
; 587  : 			}
; 588  : 
; 589  : 		if (_Pnode == _Erasednode)
; 590  : 			{	// at most one subtree, relink it
; 591  : 			_Fixnodeparent = _Erasednode->_Parent;
; 592  : 			if (!_Fixnode->_Isnil)
; 593  : 				_Fixnode->_Parent = _Fixnodeparent;	// link up
; 594  : 
; 595  : 			if (_Root() == _Erasednode)
; 596  : 				{
; 597  : 				_Root() = _Fixnode;	// link down from root
; 598  : 				}
; 599  : 			else if (_Fixnodeparent->_Left == _Erasednode)
; 600  : 				{
; 601  : 				_Fixnodeparent->_Left = _Fixnode;	// link down to left
; 602  : 				}
; 603  : 			else
; 604  : 				{
; 605  : 				_Fixnodeparent->_Right = _Fixnode;	// link down to right
; 606  : 				}
; 607  : 
; 608  : 			if (_Lmost() == _Erasednode)
; 609  : 				{
; 610  : 				_Lmost() = _Fixnode->_Isnil
; 611  : 					? _Fixnodeparent	// smallest is parent of erased node
; 612  : 					: _Min(_Fixnode);	// smallest in relinked subtree
; 613  : 				}
; 614  : 
; 615  : 			if (_Rmost() == _Erasednode)
; 616  : 				{
; 617  : 				_Rmost() = _Fixnode->_Isnil
; 618  : 					? _Fixnodeparent	// largest is parent of erased node
; 619  : 					: _Max(_Fixnode);	// largest in relinked subtree
; 620  : 				}
; 621  : 			}
; 622  : 		else
; 623  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 624  : 			_Erasednode->_Left->_Parent = _Pnode;	// link left up
; 625  : 			_Pnode->_Left = _Erasednode->_Left;	// link successor down
; 626  : 
; 627  : 			if (_Pnode == _Erasednode->_Right)
; 628  : 				{
; 629  : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 630  : 				}
; 631  : 			else
; 632  : 				{	// successor further down, link in place of erased
; 633  : 				_Fixnodeparent = _Pnode->_Parent;	// parent is successor's
; 634  : 				if (!_Fixnode->_Isnil)
; 635  : 					{
; 636  : 					_Fixnode->_Parent = _Fixnodeparent;	// link fix up
; 637  : 					}
; 638  : 
; 639  : 				_Fixnodeparent->_Left = _Fixnode;	// link fix down
; 640  : 				_Pnode->_Right = _Erasednode->_Right;	// link next down
; 641  : 				_Erasednode->_Right->_Parent = _Pnode;	// right up
; 642  : 				}
; 643  : 
; 644  : 			if (_Root() == _Erasednode)
; 645  : 				{
; 646  : 				_Root() = _Pnode;	// link down from root
; 647  : 				}
; 648  : 			else if (_Erasednode->_Parent->_Left == _Erasednode)
; 649  : 				{
; 650  : 				_Erasednode->_Parent->_Left = _Pnode;	// link down to left
; 651  : 				}
; 652  : 			else
; 653  : 				{
; 654  : 				_Erasednode->_Parent->_Right = _Pnode;	// link down to right
; 655  : 				}
; 656  : 
; 657  : 			_Pnode->_Parent = _Erasednode->_Parent;	// link successor up
; 658  : 			_STD swap(_Pnode->_Color, _Erasednode->_Color);	// recolor it
; 659  : 			}
; 660  : 
; 661  : 		if (_Erasednode->_Color == this->_Black)
; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root()
; 664  : 				&& _Fixnode->_Color == this->_Black;
; 665  : 				_Fixnodeparent = _Fixnode->_Parent)
; 666  : 				if (_Fixnode == _Fixnodeparent->_Left)
; 667  : 					{	// fixup left subtree
; 668  : 					_Pnode = _Fixnodeparent->_Right;
; 669  : 					if (_Pnode->_Color == this->_Red)
; 670  : 						{	// rotate red up from right subtree
; 671  : 						_Pnode->_Color = this->_Black;
; 672  : 						_Fixnodeparent->_Color = this->_Red;
; 673  : 						_Lrotate(_Fixnodeparent);
; 674  : 						_Pnode = _Fixnodeparent->_Right;
; 675  : 						}
; 676  : 
; 677  : 					if (_Pnode->_Isnil)
; 678  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 679  : 					else if (_Pnode->_Left->_Color == this->_Black
; 680  : 						&& _Pnode->_Right->_Color == this->_Black)
; 681  : 						{	// redden right subtree with black children
; 682  : 						_Pnode->_Color = this->_Red;
; 683  : 						_Fixnode = _Fixnodeparent;
; 684  : 						}
; 685  : 					else
; 686  : 						{	// must rearrange right subtree
; 687  : 						if (_Pnode->_Right->_Color == this->_Black)
; 688  : 							{	// rotate red up from left sub-subtree
; 689  : 							_Pnode->_Left->_Color = this->_Black;
; 690  : 							_Pnode->_Color = this->_Red;
; 691  : 							_Rrotate(_Pnode);
; 692  : 							_Pnode = _Fixnodeparent->_Right;
; 693  : 							}
; 694  : 
; 695  : 						_Pnode->_Color = _Fixnodeparent->_Color;
; 696  : 						_Fixnodeparent->_Color = this->_Black;
; 697  : 						_Pnode->_Right->_Color = this->_Black;
; 698  : 						_Lrotate(_Fixnodeparent);
; 699  : 						break;	// tree now recolored/rebalanced
; 700  : 						}
; 701  : 					}
; 702  : 				else
; 703  : 					{	// fixup right subtree
; 704  : 					_Pnode = _Fixnodeparent->_Left;
; 705  : 					if (_Pnode->_Color == this->_Red)
; 706  : 						{	// rotate red up from left subtree
; 707  : 						_Pnode->_Color = this->_Black;
; 708  : 						_Fixnodeparent->_Color = this->_Red;
; 709  : 						_Rrotate(_Fixnodeparent);
; 710  : 						_Pnode = _Fixnodeparent->_Left;
; 711  : 						}
; 712  : 
; 713  : 					if (_Pnode->_Isnil)
; 714  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 715  : 					else if (_Pnode->_Right->_Color == this->_Black
; 716  : 						&& _Pnode->_Left->_Color == this->_Black)
; 717  : 						{	// redden left subtree with black children
; 718  : 						_Pnode->_Color = this->_Red;
; 719  : 						_Fixnode = _Fixnodeparent;
; 720  : 						}
; 721  : 					else
; 722  : 						{	// must rearrange left subtree
; 723  : 						if (_Pnode->_Left->_Color == this->_Black)
; 724  : 							{	// rotate red up from right sub-subtree
; 725  : 							_Pnode->_Right->_Color = this->_Black;
; 726  : 							_Pnode->_Color = this->_Red;
; 727  : 							_Lrotate(_Pnode);
; 728  : 							_Pnode = _Fixnodeparent->_Left;
; 729  : 							}
; 730  : 
; 731  : 						_Pnode->_Color = _Fixnodeparent->_Color;
; 732  : 						_Fixnodeparent->_Color = this->_Black;
; 733  : 						_Pnode->_Left->_Color = this->_Black;
; 734  : 						_Rrotate(_Fixnodeparent);
; 735  : 						break;	// tree now recolored/rebalanced
; 736  : 						}
; 737  : 					}
; 738  : 
; 739  : 			_Fixnode->_Color = this->_Black;	// stopping node is black
; 740  : 			}
; 741  : 
; 742  : 		if (0 < _Mysize)
; 743  : 			--_Mysize;
; 744  : 
; 745  : 		return (_Erasednode);
; 746  : 		}
; 747  : 
; 748  : 	_Nodeptr _Myhead;	// pointer to head node
; 749  : 	size_type _Mysize;	// number of elements
; 750  : 	};
; 751  : 
; 752  : 		// CLASS TEMPLATE _Tree_comp_alloc
; 753  : template<class _Traits>
; 754  : 	class _Tree_comp_alloc
; 755  : 	{	// base class for tree to hold ordering predicate, allocator
; 756  : public:
; 757  : 	using allocator_type = typename _Traits::allocator_type;
; 758  : 	using key_compare = typename _Traits::key_compare;
; 759  : 
; 760  : 	using _Alloc_types = _Tree_base_types<typename _Traits::value_type, allocator_type>;
; 761  : 
; 762  : 	using _Alnode = typename _Alloc_types::_Alnode;
; 763  : 	using _Alnode_traits = typename _Alloc_types::_Alnode_traits;
; 764  : 	using _Alproxy = _Rebind_alloc_t<_Alnode, _Container_proxy>;
; 765  : 	using _Alproxy_traits = allocator_traits<_Alproxy>;
; 766  : 	using _Node = typename _Alloc_types::_Node;
; 767  : 	using _Nodeptr = typename _Alloc_types::_Nodeptr;
; 768  : 	using _Val_types = typename _Alloc_types::_Val_types;
; 769  : 
; 770  : 	using value_type = typename _Val_types::value_type;
; 771  : 	using size_type = typename _Val_types::size_type;
; 772  : 	using difference_type = typename _Val_types::difference_type;
; 773  : 	using pointer = typename _Val_types::pointer;
; 774  : 	using const_pointer = typename _Val_types::const_pointer;
; 775  : 	using reference = value_type&;
; 776  : 	using const_reference = const value_type&;
; 777  : 
; 778  : 	using iterator = _Tree_iterator<_Tree_val<_Val_types>>;
; 779  : 	using const_iterator = _Tree_const_iterator<_Tree_val<_Val_types>>;
; 780  : 	using _Unchecked_iterator = _Tree_unchecked_iterator<_Tree_val<_Val_types>>;
; 781  : 	using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val<_Val_types>>;
; 782  : 
; 783  : 	enum _Redbl
; 784  : 		{	// colors for link to parent
; 785  : 		_Red, _Black
; 786  : 		};
; 787  : 
; 788  : 	_Tree_comp_alloc(const key_compare& _Parg)
; 789  : 		: _Mypair(_One_then_variadic_args_t(), _Parg,

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0000f	8d 4d ff	 lea	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00015	8b 55 ec	 mov	 edx, DWORD PTR $T1[ebp]
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  00023	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00026	89 55 f4	 mov	 DWORD PTR _this$2[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  00029	8b 45 f4	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 468  : 		: _Myhead(),

  00032	8b 4d f4	 mov	 ecx, DWORD PTR _this$2[ebp]
  00035	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 469  : 		_Mysize(0)

  0003c	8b 55 f4	 mov	 edx, DWORD PTR _this$2[ebp]
  0003f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 792  : 		_Construct();

  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Construct

; 793  : 		}

  0004e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = -8						; size = 4
__Bytes$ = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate, COMDAT

; 871  : 		{	// deallocate _Count elements at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 872  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00006	6b 45 10 48	 imul	 eax, DWORD PTR __Count$[ebp], 72
  0000a	89 45 fc	 mov	 DWORD PTR __Bytes$[ebp], eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00013	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0001a	72 10		 jb	 SHORT $LN4@deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0001c	8d 55 fc	 lea	 edx, DWORD PTR __Bytes$[ebp]
  0001f	52		 push	 edx
  00020	8d 45 f8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00029	83 c4 08	 add	 esp, 8
$LN4@deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  0002f	51		 push	 ecx
  00030	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	83 c4 08	 add	 esp, 8

; 874  : 		}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@2@QAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Max_possible$1 = -16					; size = 4
_this$ = -12						; size = 4
$T2 = -8						; size = 4
__Result$3 = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00009	c7 45 f0 e3 38
	8e 03		 mov	 DWORD PTR __Max_possible$1[ebp], 59652323 ; 038e38e3H

; 25   : 	size_t _Result = _Count * _Ty_size;

  00010	6b 45 08 48	 imul	 eax, DWORD PTR __Count$[ebp], 72
  00014	89 45 fc	 mov	 DWORD PTR __Result$3[ebp], eax

; 26   : 	if (_Max_possible < _Count)

  00017	81 7d 08 e3 38
	8e 03		 cmp	 DWORD PTR __Count$[ebp], 59652323 ; 038e38e3H
  0001e	76 07		 jbe	 SHORT $LN3@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00020	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Result$3[ebp], -1
$LN3@allocate:

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00027	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Result$3[ebp], 4096 ; 00001000H
  0002e	72 11		 jb	 SHORT $LN7@allocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00030	8b 4d fc	 mov	 ecx, DWORD PTR __Result$3[ebp]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00039	83 c4 04	 add	 esp, 4
  0003c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0003f	eb 1e		 jmp	 SHORT $LN6@allocate
$LN7@allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00041	83 7d fc 00	 cmp	 DWORD PTR __Result$3[ebp], 0
  00045	74 11		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  00047	8b 55 fc	 mov	 edx, DWORD PTR __Result$3[ebp]
  0004a	52		 push	 edx
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00053	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00056	eb 07		 jmp	 SHORT $LN6@allocate
$LN8@allocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00058	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
$LN6@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0005f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]

; 998  : 		}

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
__Bytes$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00009	6b 45 0c 48	 imul	 eax, DWORD PTR __Count$[ebp], 72
  0000d	89 45 fc	 mov	 DWORD PTR __Bytes$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00016	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0001d	72 10		 jb	 SHORT $LN4@deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0001f	8d 55 fc	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00022	52		 push	 edx
  00023	8d 45 f8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0002c	83 c4 08	 add	 esp, 8
$LN4@deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8

; 993  : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAEXQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,void *> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
;	COMDAT ?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z
_TEXT	SEGMENT
$T2 = -128						; size = 12
_it$ = -116						; size = 12
__Lock$3 = -104						; size = 4
$T4 = -100						; size = 4
__Val$ = -96						; size = 4
__Lock$5 = -92						; size = 4
$T6 = -88						; size = 4
$T7 = -84						; size = 4
__Pnode$ = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
$T11 = -64						; size = 4
tv305 = -60						; size = 4
__My_data$12 = -56					; size = 4
_this$ = -52						; size = 4
$T13 = -45						; size = 1
_result$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_field$ = 12						; size = 4
?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z PROC ; zl::net::HttpRequest::getHeader, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 74	 sub	 esp, 116		; 00000074H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR $T11[ebp], 0

  00032	8d 4d d4	 lea	 ecx, DWORD PTR _result$[ebp]
  00035	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

  00041	8b 45 0c	 mov	 eax, DWORD PTR _field$[ebp]
  00044	50		 push	 eax
  00045	8d 4d 8c	 lea	 ecx, DWORD PTR _it$[ebp]
  00048	51		 push	 ecx
  00049	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 5c	 add	 ecx, 92			; 0000005cH
  0004f	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QBE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1203 : 		{	// return iterator for end of nonmutable sequence

  00054	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00058	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	83 c2 5c	 add	 edx, 92			; 0000005cH
  0005e	89 55 bc	 mov	 DWORD PTR $T10[ebp], edx
  00061	8b 45 bc	 mov	 eax, DWORD PTR $T10[ebp]
  00064	89 45 b8	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1020 : 		return (_Mypair._Get_second()._Get_second());

  00067	8b 4d b8	 mov	 ecx, DWORD PTR $T9[ebp]
  0006a	89 4d c8	 mov	 DWORD PTR __My_data$12[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0006d	8b 55 c8	 mov	 edx, DWORD PTR __My_data$12[ebp]
  00070	89 55 b4	 mov	 DWORD PTR $T8[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  00073	8b 45 c8	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00076	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00079	89 4d b0	 mov	 DWORD PTR __Pnode$[ebp], ecx

; 213  : 		: _Mybase(_Pnode, _Plist)

  0007c	8b 55 b4	 mov	 edx, DWORD PTR $T8[ebp]
  0007f	52		 push	 edx
  00080	8b 45 b0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	50		 push	 eax
  00084	8d 4d 80	 lea	 ecx, DWORD PTR $T2[ebp]
  00087	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@U_Iterator_base12@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::_Iterator_base12>

; 1205 : 		return (const_iterator(_My_data._Myhead, _STD addressof(_My_data)));

  0008c	8d 4d 80	 lea	 ecx, DWORD PTR $T2[ebp]
  0008f	89 4d ac	 mov	 DWORD PTR $T7[ebp], ecx

; 1206 : 		}

  00092	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  00096	8b 55 ac	 mov	 edx, DWORD PTR $T7[ebp]
  00099	89 55 a8	 mov	 DWORD PTR $T6[ebp], edx
  0009c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 283  : 		return (!(*this == _Right));

  000a0	8b 45 a8	 mov	 eax, DWORD PTR $T6[ebp]
  000a3	50		 push	 eax
  000a4	8d 4d 8c	 lea	 ecx, DWORD PTR _it$[ebp]
  000a7	e8 00 00 00 00	 call	 ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator==
  000ac	0f b6 c8	 movzx	 ecx, al
  000af	85 c9		 test	 ecx, ecx
  000b1	75 09		 jne	 SHORT $LN132@getHeader
  000b3	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv305[ebp], 1
  000ba	eb 07		 jmp	 SHORT $LN130@getHeader
$LN132@getHeader:
  000bc	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv305[ebp], 0
$LN130@getHeader:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  000c3	8a 55 c4	 mov	 dl, BYTE PTR tv305[ebp]
  000c6	88 55 d3	 mov	 BYTE PTR $T13[ebp], dl
  000c9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  000cd	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  000d1	6a 03		 push	 3
  000d3	8d 4d a4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  000dc	8d 4d 80	 lea	 ecx, DWORD PTR $T2[ebp]
  000df	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  000e4	8d 4d a4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ed	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  000f1	0f b6 45 d3	 movzx	 eax, BYTE PTR $T13[ebp]
  000f5	85 c0		 test	 eax, eax
  000f7	74 20		 je	 SHORT $LN2@getHeader
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 230  : 		return (pointer_traits<pointer>::pointer_to(**this));

  000f9	8d 4d 8c	 lea	 ecx, DWORD PTR _it$[ebp]
  000fc	e8 00 00 00 00	 call	 ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >::operator*
  00101	89 45 a0	 mov	 DWORD PTR __Val$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00104	8b 4d a0	 mov	 ecx, DWORD PTR __Val$[ebp]
  00107	89 4d 9c	 mov	 DWORD PTR $T4[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  0010a	8b 55 9c	 mov	 edx, DWORD PTR $T4[ebp]
  0010d	83 c2 1c	 add	 edx, 28			; 0000001cH
  00110	52		 push	 edx
  00111	8d 4d d4	 lea	 ecx, DWORD PTR _result$[ebp]
  00114	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN2@getHeader:

  00119	8d 45 d4	 lea	 eax, DWORD PTR _result$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00120	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00125	8b 4d c0	 mov	 ecx, DWORD PTR $T11[ebp]
  00128	83 c9 01	 or	 ecx, 1
  0012b	89 4d c0	 mov	 DWORD PTR $T11[ebp], ecx
  0012e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00132	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00136	6a 03		 push	 3
  00138	8d 4d 98	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00141	8d 4d 8c	 lea	 ecx, DWORD PTR _it$[ebp]
  00144	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00149	8d 4d 98	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00152	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 2460 : 		_Tidy_deallocate();

  00159	8d 4d d4	 lea	 ecx, DWORD PTR _result$[ebp]
  0015c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00161	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 1949 : 		_Free_proxy();

  00165	8d 4d d4	 lea	 ecx, DWORD PTR _result$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0016d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  00174	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

  00177	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00181	59		 pop	 ecx
  00182	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00185	33 cd		 xor	 ecx, ebp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _result$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$1:
  00008	8d 4d 8c	 lea	 ecx, DWORD PTR _it$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z$2:
  00010	8d 4d 80	 lea	 ecx, DWORD PTR $T2[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z:
  00018	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001f	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00022	33 c8		 xor	 ecx, eax
  00024	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00029	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getHeader@HttpRequest@net@zl@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ENDP ; zl::net::HttpRequest::getHeader
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
;	COMDAT ?query@HttpRequest@net@zl@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?query@HttpRequest@net@zl@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; zl::net::HttpRequest::query, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 24	 add	 eax, 36			; 00000024H
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?query@HttpRequest@net@zl@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; zl::net::HttpRequest::query
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
;	COMDAT ?method@HttpRequest@net@zl@@QBE?AW4HttpMethod@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?method@HttpRequest@net@zl@@QBE?AW4HttpMethod@23@XZ PROC ; zl::net::HttpRequest::method, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?method@HttpRequest@net@zl@@QBE?AW4HttpMethod@23@XZ ENDP ; zl::net::HttpRequest::method
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
;	COMDAT ??1HttpRequest@net@zl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HttpRequest@net@zl@@QAE@XZ PROC			; zl::net::HttpRequest::~HttpRequest, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1HttpRequest@net@zl@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 5c	 add	 eax, 92			; 0000005cH
  0002e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1167 : 		{	// destroy tree

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1168 : 		_Tidy();

  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tidy

; 1169 : 		}

  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
  00048	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	83 c1 40	 add	 ecx, 64			; 00000040H
  00055	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00058	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2460 : 		_Tidy_deallocate();

  0005f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00067	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 1949 : 		_Free_proxy();

  0006b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00073	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  0007a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007d	83 c2 24	 add	 edx, 36			; 00000024H
  00080	89 55 e4	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  00083	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3

; 2460 : 		_Tidy_deallocate();

  0008a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00092	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 1949 : 		_Free_proxy();

  00096	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  0009e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  000a5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	83 c0 08	 add	 eax, 8
  000ab	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2459 : 		{	// destroy the string

  000ae	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 2460 : 		_Tidy_deallocate();

  000b5	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  000bd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 1949 : 		_Free_proxy();

  000c1	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  000c9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1HttpRequest@net@zl@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1HttpRequest@net@zl@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1HttpRequest@net@zl@@QAE@XZ ENDP			; zl::net::HttpRequest::~HttpRequest
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h
;	COMDAT ??0HttpRequest@net@zl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0HttpRequest@net@zl@@QAE@XZ PROC			; zl::net::HttpRequest::HttpRequest, COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0HttpRequest@net@zl@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 08	 add	 ecx, 8
  00041	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00046	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 24	 add	 ecx, 36			; 00000024H
  00053	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00058	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 40	 add	 ecx, 64			; 00000040H
  00062	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00067	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	83 c2 5c	 add	 edx, 92			; 0000005cH
  00071	89 55 e8	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xtree

; 1084 : 		: _Mybase(_Parg)

  00074	8d 45 f3	 lea	 eax, DWORD PTR $T2[ebp]
  00077	50		 push	 eax
  00078	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@Ustring_cmp_nocase@base@zl@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@@2@$0A@@std@@@std@@QAE@ABUstring_cmp_nocase@base@zl@@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,zl::base::string_cmp_nocase,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,0> >
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\net\http\httprequest.h

  00080	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00087	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 08	 add	 ecx, 8
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 24	 add	 ecx, 36			; 00000024H
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0HttpRequest@net@zl@@QAE@XZ$2:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 40	 add	 ecx, 64			; 00000040H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0HttpRequest@net@zl@@QAE@XZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0HttpRequest@net@zl@@QAE@XZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0HttpRequest@net@zl@@QAE@XZ ENDP			; zl::net::HttpRequest::HttpRequest
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv133 = -12						; size = 4
tv129 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 1588 : 		{	// test for compatible iterator pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@Compat:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN14@Compat
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN15@Compat
$LN14@Compat:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv129[ebp], eax
$LN15@Compat:
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv129[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00030	75 09		 jne	 SHORT $LN19@Compat
  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv133[ebp], 0
  00039	eb 0a		 jmp	 SHORT $LN20@Compat
$LN19@Compat:
  0003b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	8b 11		 mov	 edx, DWORD PTR [ecx]
  00042	89 55 f4	 mov	 DWORD PTR tv133[ebp], edx
$LN20@Compat:
  00045	8b 45 f4	 mov	 eax, DWORD PTR tv133[ebp]
  00048	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1590 : 		_STL_VERIFY(this->_Getcont() == _Right._Getcont(), "string iterators incompatible (e.g."

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004e	3b 4d ec	 cmp	 ecx, DWORD PTR $T1[ebp]
  00051	75 02		 jne	 SHORT $LN7@Compat
  00053	eb 4a		 jmp	 SHORT $LN2@Compat
$LN7@Compat:
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0EJ@NPIAEPMO@string?5iterators?5incompatible?5?$CI@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0005f	6a 00		 push	 0
  00061	68 37 06 00 00	 push	 1591			; 00000637H
  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0006b	6a 02		 push	 2
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	83 f8 01	 cmp	 eax, 1
  00079	75 01		 jne	 SHORT $LN11@Compat
  0007b	cc		 int	 3
$LN11@Compat:
  0007c	6a 00		 push	 0
  0007e	68 37 06 00 00	 push	 1591			; 00000637H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00088	68 00 00 00 00	 push	 OFFSET ??_C@_1MA@BDELDFHB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1JM@EIPCMFMM@?$AA?$CC?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo@
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00098	83 c4 14	 add	 esp, 20			; 00000014H

; 1591 : 			" point to different string instances)");

  0009b	33 c0		 xor	 eax, eax
  0009d	75 b6		 jne	 SHORT $LN7@Compat
$LN2@Compat:
  0009f	33 c9		 xor	 ecx, ecx
  000a1	0f 85 62 ff ff
	ff		 jne	 $LN4@Compat

; 1592 : #else /* ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv */
; 1593 : 		(void)_Right;
; 1594 : #endif /* _ITERATOR_DEBUG_LEVEL */
; 1595 : 		}

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=, COMDAT
; _this$ = ecx

; 1562 : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1557 : 		_Compat(_Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 1558 : 		return (_Ptr == _Right._Ptr);

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0001b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001e	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00021	75 09		 jne	 SHORT $LN7@operator
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0002a	eb 07		 jmp	 SHORT $LN5@operator
$LN7@operator:
  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@operator:

; 1563 : 		return (!(*this == _Right));

  00033	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv76[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	75 09		 jne	 SHORT $LN3@operator
  0003b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00042	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  0004b	8a 45 f4	 mov	 al, BYTE PTR tv69[ebp]

; 1564 : 		}

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
??9?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 1556 : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1557 : 		_Compat(_Right);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 1558 : 		return (_Ptr == _Right._Ptr);

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0001b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001e	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00021	75 09		 jne	 SHORT $LN3@operator
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0002a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00033	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]

; 1559 : 		}

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Result$2 = -20					; size = 4
tv182 = -16						; size = 4
tv172 = -12						; size = 4
__Mycont$ = -8						; size = 4
_this$ = -4						; size = 4
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++, COMDAT
; _this$ = ecx

; 1444 : 		{	// preincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@operator:

; 1445 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1446 : 		_STL_VERIFY(_Ptr, "cannot increment value-initialized string iterator");

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 02		 je	 SHORT $LN7@operator
  00012	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@LAECODHC@cannot?5increment?5value?9initiali@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0001e	6a 00		 push	 0
  00020	68 a6 05 00 00	 push	 1446			; 000005a6H
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 01		 jne	 SHORT $LN27@operator
  0003a	cc		 int	 3
$LN27@operator:
  0003b	6a 00		 push	 0
  0003d	68 a6 05 00 00	 push	 1446			; 000005a6H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_1GK@MICKMFNF@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	33 d2		 xor	 edx, edx
  0005c	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  0005e	33 c0		 xor	 eax, eax
  00060	75 a7		 jne	 SHORT $LN4@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00068	75 09		 jne	 SHORT $LN32@operator
  0006a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv172[ebp], 0
  00071	eb 0a		 jmp	 SHORT $LN33@operator
$LN32@operator:
  00073	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00076	8b 02		 mov	 eax, DWORD PTR [edx]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d f4	 mov	 DWORD PTR tv172[ebp], ecx
$LN33@operator:
  0007d	8b 55 f4	 mov	 edx, DWORD PTR tv172[ebp]
  00080	89 55 f8	 mov	 DWORD PTR __Mycont$[ebp], edx
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1448 : 		_STL_VERIFY(_Mycont, "cannot increment string iterator because the iterator was"

  00083	83 7d f8 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  00087	74 02		 je	 SHORT $LN13@operator
  00089	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0IA@BFMOHEDB@cannot?5increment?5string?5iterato@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00095	6a 00		 push	 0
  00097	68 a9 05 00 00	 push	 1449			; 000005a9H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000a1	6a 02		 push	 2
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000a9	83 c4 18	 add	 esp, 24			; 00000018H
  000ac	83 f8 01	 cmp	 eax, 1
  000af	75 01		 jne	 SHORT $LN28@operator
  000b1	cc		 int	 3
$LN28@operator:
  000b2	6a 00		 push	 0
  000b4	68 a9 05 00 00	 push	 1449			; 000005a9H
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1BAK@GBJMLMKM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ce	83 c4 14	 add	 esp, 20			; 00000014H

; 1449 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");

  000d1	33 c9		 xor	 ecx, ecx
  000d3	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  000d5	33 d2		 xor	 edx, edx
  000d7	75 aa		 jne	 SHORT $LN10@operator
$LN16@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000d9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000df	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  000e2	8b 55 f8	 mov	 edx, DWORD PTR __Mycont$[ebp]
  000e5	83 c2 04	 add	 edx, 4
  000e8	89 55 ec	 mov	 DWORD PTR __Result$2[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000eb	8b 45 f8	 mov	 eax, DWORD PTR __Mycont$[ebp]
  000ee	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  000f2	72 09		 jb	 SHORT $LN42@operator
  000f4	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
  000fb	eb 07		 jmp	 SHORT $LN40@operator
$LN42@operator:
  000fd	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
$LN40@operator:

; 1815 : 		if (_Large_string_engaged())

  00104	0f b6 4d f0	 movzx	 ecx, BYTE PTR tv182[ebp]
  00108	85 c9		 test	 ecx, ecx
  0010a	74 09		 je	 SHORT $LN37@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0010c	8b 55 f8	 mov	 edx, DWORD PTR __Mycont$[ebp]
  0010f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00112	89 45 ec	 mov	 DWORD PTR __Result$2[ebp], eax
$LN37@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1450 : 		_STL_VERIFY(_Unfancy(_Ptr) < _Mycont->_Myptr() + _Mycont->_Mysize,

  00115	8b 4d f8	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00118	8b 55 ec	 mov	 edx, DWORD PTR __Result$2[ebp]
  0011b	03 51 14	 add	 edx, DWORD PTR [ecx+20]
  0011e	39 55 e8	 cmp	 DWORD PTR $T1[ebp], edx
  00121	73 02		 jae	 SHORT $LN19@operator
  00123	eb 4a		 jmp	 SHORT $LN14@operator
$LN19@operator:
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IKJHPFKC@cannot?5increment?5string?5iterato@
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0012f	6a 00		 push	 0
  00131	68 ab 05 00 00	 push	 1451			; 000005abH
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0013b	6a 02		 push	 2
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00143	83 c4 18	 add	 esp, 24			; 00000018H
  00146	83 f8 01	 cmp	 eax, 1
  00149	75 01		 jne	 SHORT $LN29@operator
  0014b	cc		 int	 3
$LN29@operator:
  0014c	6a 00		 push	 0
  0014e	68 ab 05 00 00	 push	 1451			; 000005abH
  00153	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00158	68 00 00 00 00	 push	 OFFSET ??_C@_1MI@IFMPOAI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@JCCODAAD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe@
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00168	83 c4 14	 add	 esp, 20			; 00000014H

; 1451 : 			"cannot increment string iterator past end");

  0016b	33 c9		 xor	 ecx, ecx
  0016d	75 b6		 jne	 SHORT $LN19@operator
$LN14@operator:
  0016f	33 d2		 xor	 edx, edx
  00171	0f 85 62 ff ff
	ff		 jne	 $LN16@operator

; 1452 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1453 : 
; 1454 : 		++_Ptr;

  00177	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017d	83 c1 01	 add	 ecx, 1
  00180	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00183	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1455 : 		return (*this);

  00186	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1456 : 		}

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c3		 ret	 0
??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
__Rawptr$ = -28						; size = 4
__Contptr$ = -24					; size = 4
__Result$1 = -20					; size = 4
tv182 = -16						; size = 4
tv171 = -12						; size = 4
_this$ = -8						; size = 4
__Mycont$ = -4						; size = 4
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 1422 : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN4@operator:

; 1423 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1424 : 		_STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 02		 je	 SHORT $LN7@operator
  00012	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IMIHIHOP@cannot?5dereference?5value?9initia@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0001e	6a 00		 push	 0
  00020	68 90 05 00 00	 push	 1424			; 00000590H
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0002a	6a 02		 push	 2
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	83 f8 01	 cmp	 eax, 1
  00038	75 01		 jne	 SHORT $LN27@operator
  0003a	cc		 int	 3
$LN27@operator:
  0003b	6a 00		 push	 0
  0003d	68 90 05 00 00	 push	 1424			; 00000590H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_1GO@PNALIMBD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00057	83 c4 14	 add	 esp, 20			; 00000014H
  0005a	33 d2		 xor	 edx, edx
  0005c	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  0005e	33 c0		 xor	 eax, eax
  00060	75 a7		 jne	 SHORT $LN4@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00068	75 09		 jne	 SHORT $LN32@operator
  0006a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv171[ebp], 0
  00071	eb 0a		 jmp	 SHORT $LN33@operator
$LN32@operator:
  00073	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00076	8b 02		 mov	 eax, DWORD PTR [edx]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d f4	 mov	 DWORD PTR tv171[ebp], ecx
$LN33@operator:
  0007d	8b 55 f4	 mov	 edx, DWORD PTR tv171[ebp]
  00080	89 55 fc	 mov	 DWORD PTR __Mycont$[ebp], edx
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1426 : 		_STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"

  00083	83 7d fc 00	 cmp	 DWORD PTR __Mycont$[ebp], 0
  00087	74 02		 je	 SHORT $LN13@operator
  00089	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_0IC@DGJDAAEM@cannot?5dereference?5string?5itera@
  00090	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00095	6a 00		 push	 0
  00097	68 93 05 00 00	 push	 1427			; 00000593H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000a1	6a 02		 push	 2
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000a9	83 c4 18	 add	 esp, 24			; 00000018H
  000ac	83 f8 01	 cmp	 eax, 1
  000af	75 01		 jne	 SHORT $LN28@operator
  000b1	cc		 int	 3
$LN28@operator:
  000b2	6a 00		 push	 0
  000b4	68 93 05 00 00	 push	 1427			; 00000593H
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1BAO@BGLBIONH@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ce	83 c4 14	 add	 esp, 20			; 00000014H

; 1427 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");

  000d1	33 c9		 xor	 ecx, ecx
  000d3	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  000d5	33 d2		 xor	 edx, edx
  000d7	75 aa		 jne	 SHORT $LN10@operator

; 1814 : 		const value_type * _Result = _Bx._Buf;

  000d9	8b 45 fc	 mov	 eax, DWORD PTR __Mycont$[ebp]
  000dc	83 c0 04	 add	 eax, 4
  000df	89 45 ec	 mov	 DWORD PTR __Result$1[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  000e5	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  000e9	72 09		 jb	 SHORT $LN40@operator
  000eb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
  000f2	eb 07		 jmp	 SHORT $LN38@operator
$LN40@operator:
  000f4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv182[ebp], 0
$LN38@operator:

; 1815 : 		if (_Large_string_engaged())

  000fb	0f b6 55 f0	 movzx	 edx, BYTE PTR tv182[ebp]
  000ff	85 d2		 test	 edx, edx
  00101	74 09		 je	 SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00103	8b 45 fc	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00106	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00109	89 4d ec	 mov	 DWORD PTR __Result$1[ebp], ecx
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1428 : 		const auto _Contptr = _Mycont->_Myptr();

  0010c	8b 55 ec	 mov	 edx, DWORD PTR __Result$1[ebp]
  0010f	89 55 e8	 mov	 DWORD PTR __Contptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00118	89 4d e4	 mov	 DWORD PTR __Rawptr$[ebp], ecx
$LN16@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1430 : 		_STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,

  0011b	8b 55 e8	 mov	 edx, DWORD PTR __Contptr$[ebp]
  0011e	3b 55 e4	 cmp	 edx, DWORD PTR __Rawptr$[ebp]
  00121	77 10		 ja	 SHORT $LN19@operator
  00123	8b 45 fc	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00126	8b 4d e8	 mov	 ecx, DWORD PTR __Contptr$[ebp]
  00129	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  0012c	39 4d e4	 cmp	 DWORD PTR __Rawptr$[ebp], ecx
  0012f	73 02		 jae	 SHORT $LN19@operator
  00131	eb 4a		 jmp	 SHORT $LN14@operator
$LN19@operator:
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@HJKEHIBC@cannot?5dereference?5string?5itera@
  00138	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0013d	6a 00		 push	 0
  0013f	68 97 05 00 00	 push	 1431			; 00000597H
  00144	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OLBHAGPC@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00149	6a 02		 push	 2
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00151	83 c4 18	 add	 esp, 24			; 00000018H
  00154	83 f8 01	 cmp	 eax, 1
  00157	75 01		 jne	 SHORT $LN29@operator
  00159	cc		 int	 3
$LN29@operator:
  0015a	6a 00		 push	 0
  0015c	68 97 05 00 00	 push	 1431			; 00000597H
  00161	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@CLPMMMDB@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo@
  0016b	68 00 00 00 00	 push	 OFFSET ??_C@_1KO@CMPBFHAM@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00176	83 c4 14	 add	 esp, 20			; 00000014H

; 1431 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");

  00179	33 c0		 xor	 eax, eax
  0017b	75 b6		 jne	 SHORT $LN19@operator
$LN14@operator:
  0017d	33 c9		 xor	 ecx, ecx
  0017f	75 9a		 jne	 SHORT $LN16@operator

; 1432 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1433 : 
; 1434 : 		_Analysis_assume_(_Ptr);
; 1435 : 		return (*_Ptr);

  00181	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00184	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 1436 : 		}

  00187	8b e5		 mov	 esp, ebp
  00189	5d		 pop	 ebp
  0018a	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 1417 : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1416 : 		: _Ptr(_Parg)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1418 : 		this->_Adopt(_Pstring);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Pstring$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1419 : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base12@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h
;	COMDAT ??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
$T2 = -192						; size = 12
$T3 = -180						; size = 12
_this$ = -168						; size = 4
tv289 = -164						; size = 4
tv69 = -160						; size = 4
__Lock$4 = -156						; size = 4
__Lock$5 = -152						; size = 4
$T6 = -148						; size = 4
$T7 = -144						; size = 4
$T8 = -140						; size = 4
$T9 = -136						; size = 4
$T10 = -132						; size = 4
$T11 = -128						; size = 4
$T12 = -124						; size = 4
$T13 = -120						; size = 4
$T14 = -116						; size = 4
$T15 = -112						; size = 4
$T16 = -108						; size = 4
$T17 = -104						; size = 4
__Lock$18 = -100					; size = 4
__Lock$19 = -96						; size = 4
__Lock$20 = -92						; size = 4
__Lock$21 = -88						; size = 4
_p$ = -84						; size = 12
_p2$ = -72						; size = 12
tv165 = -60						; size = 4
tv164 = -56						; size = 4
tv150 = -52						; size = 4
tv92 = -48						; size = 4
tv269 = -44						; size = 4
tv271 = -40						; size = 4
$T22 = -36						; size = 4
tv245 = -32						; size = 4
tv247 = -28						; size = 4
$T23 = -24						; size = 4
$T24 = -19						; size = 1
$T25 = -18						; size = 1
$T26 = -17						; size = 1
$T27 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; zl::base::string_cmp_nocase::operator(), COMDAT
; _this$ = ecx

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00017	56		 push	 esi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T27[ebp], 0

  00036	8d 45 ac	 lea	 eax, DWORD PTR _p$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  0003d	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

  00049	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  00050	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00055	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LN2@operator:

  00059	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0005f	52		 push	 edx
  00060	8b 4d 08	 mov	 ecx, DWORD PTR _lhs$[ebp]
  00063	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  00068	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  0006e	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]
  00074	89 45 e8	 mov	 DWORD PTR $T23[ebp], eax
  00077	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T27[ebp]
  0007e	83 c9 01	 or	 ecx, 1
  00081	89 4d f0	 mov	 DWORD PTR $T27[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1557 : 		_Compat(_Right);

  00084	8b 55 e8	 mov	 edx, DWORD PTR $T23[ebp]
  00087	52		 push	 edx
  00088	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 1558 : 		return (_Ptr == _Right._Ptr);

  00090	8b 45 e8	 mov	 eax, DWORD PTR $T23[ebp]
  00093	8b 4d b4	 mov	 ecx, DWORD PTR _p$[ebp+8]
  00096	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00099	75 09		 jne	 SHORT $LN97@operator
  0009b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv247[ebp], 1
  000a2	eb 07		 jmp	 SHORT $LN95@operator
$LN97@operator:
  000a4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv247[ebp], 0
$LN95@operator:

; 1563 : 		return (!(*this == _Right));

  000ab	0f b6 55 e4	 movzx	 edx, BYTE PTR tv247[ebp]
  000af	85 d2		 test	 edx, edx
  000b1	75 09		 jne	 SHORT $LN93@operator
  000b3	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv245[ebp], 1
  000ba	eb 07		 jmp	 SHORT $LN91@operator
$LN93@operator:
  000bc	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv245[ebp], 0
$LN91@operator:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  000c3	0f b6 45 e0	 movzx	 eax, BYTE PTR tv245[ebp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 7e		 je	 SHORT $LN6@operator
  000cb	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000d1	51		 push	 ecx
  000d2	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  000d5	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  000da	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  000e0	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  000e6	89 55 dc	 mov	 DWORD PTR $T22[ebp], edx
  000e9	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  000f0	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  000f3	83 c8 02	 or	 eax, 2
  000f6	89 45 f0	 mov	 DWORD PTR $T27[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1557 : 		_Compat(_Right);

  000f9	8b 4d dc	 mov	 ecx, DWORD PTR $T22[ebp]
  000fc	51		 push	 ecx
  000fd	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  00100	e8 00 00 00 00	 call	 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat

; 1558 : 		return (_Ptr == _Right._Ptr);

  00105	8b 55 dc	 mov	 edx, DWORD PTR $T22[ebp]
  00108	8b 45 c0	 mov	 eax, DWORD PTR _p2$[ebp+8]
  0010b	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0010e	75 09		 jne	 SHORT $LN128@operator
  00110	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv271[ebp], 1
  00117	eb 07		 jmp	 SHORT $LN126@operator
$LN128@operator:
  00119	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv271[ebp], 0
$LN126@operator:

; 1563 : 		return (!(*this == _Right));

  00120	0f b6 4d d8	 movzx	 ecx, BYTE PTR tv271[ebp]
  00124	85 c9		 test	 ecx, ecx
  00126	75 09		 jne	 SHORT $LN124@operator
  00128	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv269[ebp], 1
  0012f	eb 07		 jmp	 SHORT $LN122@operator
$LN124@operator:
  00131	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv269[ebp], 0
$LN122@operator:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  00138	0f b6 55 d4	 movzx	 edx, BYTE PTR tv269[ebp]
  0013c	85 d2		 test	 edx, edx
  0013e	74 09		 je	 SHORT $LN6@operator
  00140	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00147	eb 07		 jmp	 SHORT $LN7@operator
$LN6@operator:
  00149	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], 0
$LN7@operator:
  00150	8a 45 d0	 mov	 al, BYTE PTR tv92[ebp]
  00153	88 45 ef	 mov	 BYTE PTR $T26[ebp], al
  00156	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0015d	8b 4d f0	 mov	 ecx, DWORD PTR $T27[ebp]
  00160	83 e1 02	 and	 ecx, 2
  00163	74 2a		 je	 SHORT $LN20@operator
  00165	83 65 f0 fd	 and	 DWORD PTR $T27[ebp], -3	; fffffffdH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00169	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00170	6a 03		 push	 3
  00172	8d 4d a8	 lea	 ecx, DWORD PTR __Lock$21[ebp]
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0017b	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00181	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00186	8d 4d a8	 lea	 ecx, DWORD PTR __Lock$21[ebp]
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN20@operator:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  0018f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00196	8b 55 f0	 mov	 edx, DWORD PTR $T27[ebp]
  00199	83 e2 01	 and	 edx, 1
  0019c	74 2b		 je	 SHORT $LN21@operator
  0019e	83 65 f0 fe	 and	 DWORD PTR $T27[ebp], -2	; fffffffeH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  001a2	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  001a6	6a 03		 push	 3
  001a8	8d 4d a4	 lea	 ecx, DWORD PTR __Lock$20[ebp]
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  001b1	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001b7	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  001bc	8d 4d a4	 lea	 ecx, DWORD PTR __Lock$20[ebp]
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  001c5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$LN21@operator:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  001c9	0f b6 45 ef	 movzx	 eax, BYTE PTR $T26[ebp]
  001cd	85 c0		 test	 eax, eax
  001cf	0f 84 ec 00 00
	00		 je	 $LN3@operator

  001d5	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  001d8	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  001dd	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001e0	51		 push	 ecx
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  001e7	83 c4 04	 add	 esp, 4
  001ea	8b f0		 mov	 esi, eax
  001ec	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  001ef	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  001f4	0f be 10	 movsx	 edx, BYTE PTR [eax]
  001f7	52		 push	 edx
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  001fe	83 c4 04	 add	 esp, 4
  00201	3b f0		 cmp	 esi, eax
  00203	0f 84 a3 00 00
	00		 je	 $LN4@operator

  00209	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  0020c	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00211	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00214	50		 push	 eax
  00215	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  0021b	83 c4 04	 add	 esp, 4
  0021e	8b f0		 mov	 esi, eax
  00220	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  00223	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00228	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0022b	51		 push	 ecx
  0022c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00232	83 c4 04	 add	 esp, 4
  00235	3b f0		 cmp	 esi, eax
  00237	7d 09		 jge	 SHORT $LN8@operator
  00239	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv150[ebp], 1
  00240	eb 07		 jmp	 SHORT $LN9@operator
$LN8@operator:
  00242	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv150[ebp], 0
$LN9@operator:
  00249	8a 55 cc	 mov	 dl, BYTE PTR tv150[ebp]
  0024c	88 55 ee	 mov	 BYTE PTR $T25[ebp], dl
  0024f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00253	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00257	6a 03		 push	 3
  00259	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$19[ebp]
  0025c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00262	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  00265	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0026a	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$19[ebp]
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  00273	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0027a	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00281	6a 03		 push	 3
  00283	8d 4d 9c	 lea	 ecx, DWORD PTR __Lock$18[ebp]
  00286	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0028c	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  0028f	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00294	8d 4d 9c	 lea	 ecx, DWORD PTR __Lock$18[ebp]
  00297	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0029d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  002a4	8a 45 ee	 mov	 al, BYTE PTR $T25[ebp]
  002a7	e9 20 01 00 00	 jmp	 $LN1@operator
$LN4@operator:

  002ac	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  002af	e8 00 00 00 00	 call	 ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++

  002b4	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  002b7	e8 00 00 00 00	 call	 ??E?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAEAAV01@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator++

  002bc	e9 98 fd ff ff	 jmp	 $LN2@operator
$LN3@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  002c1	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  002c4	89 45 98	 mov	 DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  002c7	8b 4d 98	 mov	 ecx, DWORD PTR $T17[ebp]
  002ca	89 4d 94	 mov	 DWORD PTR $T16[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  002cd	8b 55 94	 mov	 edx, DWORD PTR $T16[ebp]
  002d0	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  002d3	89 45 88	 mov	 DWORD PTR $T13[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  002d6	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  002d9	89 4d 90	 mov	 DWORD PTR $T15[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  002dc	8b 55 90	 mov	 edx, DWORD PTR $T15[ebp]
  002df	89 55 8c	 mov	 DWORD PTR $T14[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  002e2	8b 45 8c	 mov	 eax, DWORD PTR $T14[ebp]
  002e5	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002e8	89 4d 84	 mov	 DWORD PTR $T12[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  002eb	8b 55 88	 mov	 edx, DWORD PTR $T13[ebp]
  002ee	3b 55 84	 cmp	 edx, DWORD PTR $T12[ebp]
  002f1	75 09		 jne	 SHORT $LN12@operator
  002f3	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], 0
  002fa	eb 66		 jmp	 SHORT $LN13@operator
$LN12@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  002fc	8b 45 08	 mov	 eax, DWORD PTR _lhs$[ebp]
  002ff	89 45 80	 mov	 DWORD PTR $T11[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00302	8b 4d 80	 mov	 ecx, DWORD PTR $T11[ebp]
  00305	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T10[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  0030b	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  00311	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00314	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0031a	8b 4d 0c	 mov	 ecx, DWORD PTR _rhs$[ebp]
  0031d	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00323	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T9[ebp]
  00329	89 95 74 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], edx

; 3302 : 		return (this->_Get_data()._Mysize);

  0032f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00335	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00338	89 8d 6c ff ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  0033e	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T7[ebp]
  00344	3b 95 6c ff ff
	ff		 cmp	 edx, DWORD PTR $T6[ebp]
  0034a	73 09		 jae	 SHORT $LN10@operator
  0034c	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv164[ebp], 1
  00353	eb 07		 jmp	 SHORT $LN11@operator
$LN10@operator:
  00355	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv164[ebp], 0
$LN11@operator:
  0035c	8b 45 c8	 mov	 eax, DWORD PTR tv164[ebp]
  0035f	89 45 c4	 mov	 DWORD PTR tv165[ebp], eax
$LN13@operator:
  00362	8a 4d c4	 mov	 cl, BYTE PTR tv165[ebp]
  00365	88 4d ed	 mov	 BYTE PTR $T24[ebp], cl
  00368	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  0036c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00370	6a 03		 push	 3
  00372	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00378	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0037e	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  00381	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00386	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0038c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  00392	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00399	c7 45 fc 09 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 9

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  003a0	6a 03		 push	 3
  003a2	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$4[ebp]
  003a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  003ae	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  003b1	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  003b6	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR __Lock$4[ebp]
  003bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  003c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.h

  003c9	8a 45 ed	 mov	 al, BYTE PTR $T24[ebp]
$LN1@operator:

  003cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003d6	59		 pop	 ecx
  003d7	5e		 pop	 esi
  003d8	8b e5		 mov	 esp, ebp
  003da	5d		 pop	 ebp
  003db	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _p$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR _p2$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$2:
  00010	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	0f 84 0f 00 00
	00		 je	 $LN17@operator
  0001c	83 65 f0 fe	 and	 DWORD PTR $T27[ebp], -2	; fffffffeH
  00020	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
$LN17@operator:
  0002b	c3		 ret	 0
__unwindfunclet$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z$3:
  0002c	8b 45 f0	 mov	 eax, DWORD PTR $T27[ebp]
  0002f	83 e0 02	 and	 eax, 2
  00032	0f 84 0f 00 00
	00		 je	 $LN19@operator
  00038	83 65 f0 fd	 and	 DWORD PTR $T27[ebp], -3	; fffffffdH
  0003c	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00042	e9 00 00 00 00	 jmp	 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
$LN19@operator:
  00047	c3		 ret	 0
__ehhandler$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:
  00048	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004f	8b 8a 44 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-188]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??Rstring_cmp_nocase@base@zl@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; zl::base::string_cmp_nocase::operator()
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 257  : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 		return (const_cast<reference>(_Mybase::operator*()));

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*

; 259  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 253  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 41   : 		: _Ptr(_Parg)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 42   : 		{	// construct with pointer _Parg
; 43   : 		this->_Adopt(_Pvector);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Pvector$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 254  : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 		{	// destroy the iterator

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00042	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0004b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
__Mycont$ = -12						; size = 4
tv151 = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 47   : 		{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN23@operator
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv151[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN24@operator
$LN23@operator:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv151[ebp], eax
$LN24@operator:
  00024	8b 4d f8	 mov	 ecx, DWORD PTR tv151[ebp]
  00027	89 4d f4	 mov	 DWORD PTR __Mycont$[ebp], ecx
$LN4@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 50   : 		_STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  00031	74 02		 je	 SHORT $LN7@operator
  00033	eb 44		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@CHADHGFF@can?8t?5dereference?5value?9initial@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0003f	6a 00		 push	 0
  00041	6a 32		 push	 50			; 00000032H
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00048	6a 02		 push	 2
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 01		 jne	 SHORT $LN19@operator
  00058	cc		 int	 3
$LN19@operator:
  00059	6a 00		 push	 0
  0005b	6a 32		 push	 50			; 00000032H
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@DDPKBOFO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_1GM@FNBFNBEL@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00072	83 c4 14	 add	 esp, 20			; 00000014H
  00075	33 c9		 xor	 ecx, ecx
  00077	75 bc		 jne	 SHORT $LN7@operator
$LN2@operator:
  00079	33 d2		 xor	 edx, edx
  0007b	75 ad		 jne	 SHORT $LN4@operator
$LN10@operator:

; 51   : 		_STL_VERIFY(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast,

  0007d	8b 45 f4	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00086	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00089	77 10		 ja	 SHORT $LN13@operator
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00091	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00094	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00097	73 02		 jae	 SHORT $LN13@operator
  00099	eb 44		 jmp	 SHORT $LN8@operator
$LN13@operator:
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@MDHADBHN@can?8t?5dereference?5out?5of?5range?5@
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000a5	6a 00		 push	 0
  000a7	6a 34		 push	 52			; 00000034H
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@FKAHJGEE@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000ae	6a 02		 push	 2
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000b6	83 c4 18	 add	 esp, 24			; 00000018H
  000b9	83 f8 01	 cmp	 eax, 1
  000bc	75 01		 jne	 SHORT $LN20@operator
  000be	cc		 int	 3
$LN20@operator:
  000bf	6a 00		 push	 0
  000c1	6a 34		 push	 52			; 00000034H
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@OJBMIJHH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000c8	68 00 00 00 00	 push	 OFFSET ??_C@_1MG@DDPKBOFO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_1GC@JDCKOLAC@?$AA?$CC?$AAc?$AAa?$AAn?$AA?8?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000d8	83 c4 14	 add	 esp, 20			; 00000014H

; 52   : 			"can't dereference out of range vector iterator");

  000db	33 c9		 xor	 ecx, ecx
  000dd	75 bc		 jne	 SHORT $LN13@operator
$LN8@operator:
  000df	33 d2		 xor	 edx, edx
  000e1	75 9a		 jne	 SHORT $LN10@operator

; 53   :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 54   : 
; 55   : 		return (*_Ptr);

  000e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 56   : 		}

  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 41   : 		: _Ptr(_Parg)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR __Parg$[ebp]
  00020	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 43   : 		this->_Adopt(_Pvector);

  00023	8b 4d 0c	 mov	 ecx, DWORD PTR __Pvector$[ebp]
  00026	51		 push	 ecx
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 44   : 		}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1ByteBuffer@net@zl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ByteBuffer@net@zl@@QAE@XZ PROC			; zl::net::ByteBuffer::~ByteBuffer, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1ByteBuffer@net@zl@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 08	 add	 eax, 8
  0002e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 893  : 		{	// destroy the object

  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 894  : 		_Tidy();

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 460  : 		{	// destroy proxy

  00040	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 461  : 		_Free_proxy();

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 895  : 		}

  0004c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ByteBuffer@net@zl@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1ByteBuffer@net@zl@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1ByteBuffer@net@zl@@QAE@XZ ENDP			; zl::net::ByteBuffer::~ByteBuffer
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z
_TEXT	SEGMENT
__Lock$ = -44						; size = 4
$T1 = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
tv144 = -12						; size = 4
$T4 = -8						; size = 4
__Pnext$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1936 : 		{	// orphan iterators within specified (inclusive) range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1937 : 		_Lockit _Lock(_LOCK_DEBUG);

  00009	6a 03		 push	 3
  0000b	8d 4d d4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00014	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0001a	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0001d	89 4d f8	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

  00020	8b 55 f8	 mov	 edx, DWORD PTR $T4[ebp]
  00023	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00026	75 09		 jne	 SHORT $LN20@Orphan_ran
  00028	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv144[ebp], 0
  0002f	eb 0b		 jmp	 SHORT $LN21@Orphan_ran
$LN20@Orphan_ran:
  00031	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	83 c1 04	 add	 ecx, 4
  00039	89 4d f4	 mov	 DWORD PTR tv144[ebp], ecx
$LN21@Orphan_ran:
  0003c	8b 55 f4	 mov	 edx, DWORD PTR tv144[ebp]
  0003f	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1939 : 		const_iterator ** _Pnext = reinterpret_cast<const_iterator **>(this->_Getpfirst());

  00042	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00045	89 45 fc	 mov	 DWORD PTR __Pnext$[ebp], eax

; 1940 : 
; 1941 : 		if (_Pnext)

  00048	83 7d fc 00	 cmp	 DWORD PTR __Pnext$[ebp], 0
  0004c	74 63		 je	 SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1942 : 			{
; 1943 : 			while (*_Pnext)

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00051	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00054	74 5b		 je	 SHORT $LN4@Orphan_ran

; 1944 : 				{
; 1945 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

  00056	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0005e	3b 4d 08	 cmp	 ecx, DWORD PTR __First$[ebp]
  00061	72 0d		 jb	 SHORT $LN7@Orphan_ran
  00063	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00066	8b 02		 mov	 eax, DWORD PTR [edx]
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0006b	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006e	73 13		 jae	 SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1946 : 					{	// skip the iterator
; 1947 : 					_Pnext = reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());

  00070	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 187  : 		return (&_Mynextiter);

  00078	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	83 c1 04	 add	 ecx, 4
  0007e	89 4d fc	 mov	 DWORD PTR __Pnext$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1949 : 				else

  00081	eb 2c		 jmp	 SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1950 : 					{	// orphan the iterator
; 1951 : 					(*_Pnext)->_Clrcont();

  00083	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00086	8b 02		 mov	 eax, DWORD PTR [edx]
  00088	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 177  : 		_Myproxy = nullptr;

  0008b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1952 : 					*_Pnext = *reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());

  00094	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00097	8b 02		 mov	 eax, DWORD PTR [edx]
  00099	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 187  : 		return (&_Mynextiter);

  0009c	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 c1 04	 add	 ecx, 4
  000a2	89 4d d8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1952 : 					*_Pnext = *reinterpret_cast<const_iterator **>((*_Pnext)->_Getpnext());

  000a5	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$[ebp]
  000a8	8b 45 d8	 mov	 eax, DWORD PTR $T1[ebp]
  000ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ad	89 0a		 mov	 DWORD PTR [edx], ecx
$LN6@Orphan_ran:

; 1953 : 					}
; 1954 : 				}

  000af	eb 9d		 jmp	 SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1955 : 			}
; 1956 : 		}

  000b1	8d 4d d4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?_Orphan_range@?$vector@DV?$allocator@D@std@@@std@@ABEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ PROC ; std::vector<char,std::allocator<char> >::_Xlength, COMDAT

; 1925 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1926 : 		_Xlength_error("vector<T> too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1927 : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ENDP ; std::vector<char,std::allocator<char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -164						; size = 4
$T2 = -160						; size = 4
__First$ = -156						; size = 4
__Last$ = -152						; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
$T6 = -136						; size = 4
$T7 = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
$T10 = -120						; size = 4
$T11 = -116						; size = 4
__Ptr$ = -112						; size = 4
$T12 = -108						; size = 4
$T13 = -104						; size = 4
$T14 = -100						; size = 4
$T15 = -96						; size = 4
$T16 = -92						; size = 4
$T17 = -88						; size = 4
$T18 = -84						; size = 4
$T19 = -80						; size = 4
$T20 = -76						; size = 4
$T21 = -72						; size = 4
$T22 = -68						; size = 4
$T23 = -64						; size = 4
$T24 = -60						; size = 4
$T25 = -56						; size = 4
$T26 = -52						; size = 4
$T27 = -48						; size = 4
$T28 = -44						; size = 4
$T29 = -40						; size = 4
$T30 = -36						; size = 4
$T31 = -32						; size = 4
$T32 = -28						; size = 4
$T33 = -24						; size = 4
$T34 = -20						; size = 4
__Ptr$ = -16						; size = 4
__Bytes$ = -12						; size = 4
$T35 = -5						; size = 1
_this$ = -4						; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T34[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00012	8b 4d ec	 mov	 ecx, DWORD PTR $T34[ebp]
  00015	89 4d e8	 mov	 DWORD PTR $T33[ebp], ecx

; 535  : 		_Get_data()._Orphan_all();

  00018	8b 4d e8	 mov	 ecx, DWORD PTR $T33[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	89 55 e4	 mov	 DWORD PTR $T32[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00026	8b 45 e4	 mov	 eax, DWORD PTR $T32[ebp]
  00029	89 45 e0	 mov	 DWORD PTR $T31[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  0002c	8b 4d e0	 mov	 ecx, DWORD PTR $T31[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	89 4d dc	 mov	 DWORD PTR $T30[ebp], ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00035	8b 55 dc	 mov	 edx, DWORD PTR $T30[ebp]
  00038	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0003b	0f 84 64 01 00
	00		 je	 $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 d8	 mov	 DWORD PTR $T29[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00047	8b 4d d8	 mov	 ecx, DWORD PTR $T29[ebp]
  0004a	89 4d d4	 mov	 DWORD PTR $T28[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  0004d	8b 55 d4	 mov	 edx, DWORD PTR $T28[ebp]
  00050	83 c2 08	 add	 edx, 8
  00053	89 55 c8	 mov	 DWORD PTR $T25[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T27[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0005c	8b 4d d0	 mov	 ecx, DWORD PTR $T27[ebp]
  0005f	89 4d cc	 mov	 DWORD PTR $T26[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00062	8b 55 cc	 mov	 edx, DWORD PTR $T26[ebp]
  00065	83 c2 04	 add	 edx, 4
  00068	89 55 c4	 mov	 DWORD PTR $T24[ebp], edx

; 1914 : 			{	// destroy and deallocate old array
; 1915 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0006b	8b 45 c8	 mov	 eax, DWORD PTR $T25[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	89 8d 68 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], ecx
  00076	8b 55 c4	 mov	 edx, DWORD PTR $T24[ebp]
  00079	8b 02		 mov	 eax, DWORD PTR [edx]
  0007b	89 85 64 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 545  : 		return (_Mypair._Get_first());

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00084	89 4d c0	 mov	 DWORD PTR $T23[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  00087	8b 55 c0	 mov	 edx, DWORD PTR $T23[ebp]
  0008a	89 95 60 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

  00090	33 c0		 xor	 eax, eax
  00092	88 45 fb	 mov	 BYTE PTR $T35[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	89 4d bc	 mov	 DWORD PTR $T22[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0009b	8b 55 bc	 mov	 edx, DWORD PTR $T22[ebp]
  0009e	89 55 b8	 mov	 DWORD PTR $T21[ebp], edx

; 601  : 		return (_Get_data()._Myend);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR $T21[ebp]
  000a4	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a7	89 45 ac	 mov	 DWORD PTR $T18[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	89 4d b4	 mov	 DWORD PTR $T20[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  000b0	8b 55 b4	 mov	 edx, DWORD PTR $T20[ebp]
  000b3	89 55 b0	 mov	 DWORD PTR $T19[ebp], edx

; 581  : 		return (_Get_data()._Myfirst);

  000b6	8b 45 b0	 mov	 eax, DWORD PTR $T19[ebp]
  000b9	83 c0 04	 add	 eax, 4
  000bc	89 45 a8	 mov	 DWORD PTR $T17[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  000bf	8b 4d ac	 mov	 ecx, DWORD PTR $T18[ebp]
  000c2	8b 55 a8	 mov	 edx, DWORD PTR $T17[ebp]
  000c5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c7	2b 02		 sub	 eax, DWORD PTR [edx]
  000c9	89 45 94	 mov	 DWORD PTR $T12[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	89 4d a4	 mov	 DWORD PTR $T16[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  000d2	8b 55 a4	 mov	 edx, DWORD PTR $T16[ebp]
  000d5	89 55 a0	 mov	 DWORD PTR $T15[ebp], edx

; 576  : 		return (_Get_data()._Myfirst);

  000d8	8b 45 a0	 mov	 eax, DWORD PTR $T15[ebp]
  000db	83 c0 04	 add	 eax, 4
  000de	89 45 98	 mov	 DWORD PTR $T13[ebp], eax

; 545  : 		return (_Mypair._Get_first());

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  000e4	89 4d 9c	 mov	 DWORD PTR $T14[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  000e7	8b 55 9c	 mov	 edx, DWORD PTR $T14[ebp]
  000ea	89 95 5c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx

; 1916 : 			this->_Getal().deallocate(this->_Myfirst(), capacity());

  000f0	8b 45 98	 mov	 eax, DWORD PTR $T13[ebp]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	89 4d 90	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f8	8b 55 94	 mov	 edx, DWORD PTR $T12[ebp]
  000fb	89 55 f4	 mov	 DWORD PTR __Bytes$[ebp], edx
  000fe	8b 45 90	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00101	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00104	81 7d f4 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0010b	72 10		 jb	 SHORT $LN97@Tidy

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0010d	8d 4d f4	 lea	 ecx, DWORD PTR __Bytes$[ebp]
  00110	51		 push	 ecx
  00111	8d 55 f0	 lea	 edx, DWORD PTR __Ptr$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0011a	83 c4 08	 add	 esp, 8
$LN97@Tidy:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0011d	8b 45 f4	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00120	50		 push	 eax
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0012a	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0012d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00130	89 55 8c	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00133	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  00136	89 45 88	 mov	 DWORD PTR $T10[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  00139	8b 4d 88	 mov	 ecx, DWORD PTR $T10[ebp]
  0013c	83 c1 04	 add	 ecx, 4
  0013f	89 4d 84	 mov	 DWORD PTR $T9[ebp], ecx

; 1917 : 
; 1918 : 			this->_Myfirst() = pointer();

  00142	8b 55 84	 mov	 edx, DWORD PTR $T9[ebp]
  00145	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	89 45 80	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00151	8b 4d 80	 mov	 ecx, DWORD PTR $T8[ebp]
  00154	89 8d 7c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  0015a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR $T7[ebp]
  00160	83 c2 08	 add	 edx, 8
  00163	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], edx

; 1919 : 			this->_Mylast() = pointer();

  00169	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0016f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00175	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00178	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0017e	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T5[ebp]
  00184	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], edx

; 596  : 		return (_Get_data()._Myend);

  0018a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00190	83 c0 0c	 add	 eax, 12			; 0000000cH
  00193	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 1920 : 			this->_Myend() = pointer();

  00199	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  0019f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN1@Tidy:

; 1921 : 			}
; 1922 : 		}

  001a5	8b e5		 mov	 esp, ebp
  001a7	5d		 pop	 ebp
  001a8	c3		 ret	 0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AAEXQADII@Z
_TEXT	SEGMENT
$T1 = -164						; size = 4
$T2 = -160						; size = 4
__First$ = -156						; size = 4
__Last$ = -152						; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
$T6 = -136						; size = 4
$T7 = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
$T10 = -120						; size = 4
$T11 = -116						; size = 4
__Ptr$ = -112						; size = 4
$T12 = -108						; size = 4
$T13 = -104						; size = 4
$T14 = -100						; size = 4
$T15 = -96						; size = 4
$T16 = -92						; size = 4
$T17 = -88						; size = 4
$T18 = -84						; size = 4
$T19 = -80						; size = 4
$T20 = -76						; size = 4
$T21 = -72						; size = 4
$T22 = -68						; size = 4
$T23 = -64						; size = 4
$T24 = -60						; size = 4
$T25 = -56						; size = 4
$T26 = -52						; size = 4
$T27 = -48						; size = 4
$T28 = -44						; size = 4
$T29 = -40						; size = 4
$T30 = -36						; size = 4
$T31 = -32						; size = 4
$T32 = -28						; size = 4
$T33 = -24						; size = 4
$T34 = -20						; size = 4
__Ptr$ = -16						; size = 4
__Bytes$ = -12						; size = 4
$T35 = -5						; size = 1
_this$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AAEXQADII@Z PROC ; std::vector<char,std::allocator<char> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a4 00 00
	00		 sub	 esp, 164		; 000000a4H
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T34[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00012	8b 4d ec	 mov	 ecx, DWORD PTR $T34[ebp]
  00015	89 4d e8	 mov	 DWORD PTR $T33[ebp], ecx

; 535  : 		_Get_data()._Orphan_all();

  00018	8b 4d e8	 mov	 ecx, DWORD PTR $T33[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	89 55 e4	 mov	 DWORD PTR $T32[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00026	8b 45 e4	 mov	 eax, DWORD PTR $T32[ebp]
  00029	89 45 e0	 mov	 DWORD PTR $T31[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  0002c	8b 4d e0	 mov	 ecx, DWORD PTR $T31[ebp]
  0002f	83 c1 04	 add	 ecx, 4
  00032	89 4d dc	 mov	 DWORD PTR $T30[ebp], ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00035	8b 55 dc	 mov	 edx, DWORD PTR $T30[ebp]
  00038	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0003b	0f 84 ec 00 00
	00		 je	 $LN2@Change_arr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 d8	 mov	 DWORD PTR $T29[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00047	8b 4d d8	 mov	 ecx, DWORD PTR $T29[ebp]
  0004a	89 4d d4	 mov	 DWORD PTR $T28[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  0004d	8b 55 d4	 mov	 edx, DWORD PTR $T28[ebp]
  00050	83 c2 08	 add	 edx, 8
  00053	89 55 c8	 mov	 DWORD PTR $T25[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T27[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0005c	8b 4d d0	 mov	 ecx, DWORD PTR $T27[ebp]
  0005f	89 4d cc	 mov	 DWORD PTR $T26[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00062	8b 55 cc	 mov	 edx, DWORD PTR $T26[ebp]
  00065	83 c2 04	 add	 edx, 4
  00068	89 55 c4	 mov	 DWORD PTR $T24[ebp], edx

; 1899 : 			{	// destroy and deallocate old array
; 1900 : 			_Destroy(this->_Myfirst(), this->_Mylast());

  0006b	8b 45 c8	 mov	 eax, DWORD PTR $T25[ebp]
  0006e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00070	89 8d 68 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], ecx
  00076	8b 55 c4	 mov	 edx, DWORD PTR $T24[ebp]
  00079	8b 02		 mov	 eax, DWORD PTR [edx]
  0007b	89 85 64 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 545  : 		return (_Mypair._Get_first());

  00081	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00084	89 4d c0	 mov	 DWORD PTR $T23[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  00087	8b 55 c0	 mov	 edx, DWORD PTR $T23[ebp]
  0008a	89 95 60 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

  00090	33 c0		 xor	 eax, eax
  00092	88 45 fb	 mov	 BYTE PTR $T35[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	89 4d bc	 mov	 DWORD PTR $T22[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0009b	8b 55 bc	 mov	 edx, DWORD PTR $T22[ebp]
  0009e	89 55 b8	 mov	 DWORD PTR $T21[ebp], edx

; 601  : 		return (_Get_data()._Myend);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR $T21[ebp]
  000a4	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a7	89 45 ac	 mov	 DWORD PTR $T18[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	89 4d b4	 mov	 DWORD PTR $T20[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  000b0	8b 55 b4	 mov	 edx, DWORD PTR $T20[ebp]
  000b3	89 55 b0	 mov	 DWORD PTR $T19[ebp], edx

; 581  : 		return (_Get_data()._Myfirst);

  000b6	8b 45 b0	 mov	 eax, DWORD PTR $T19[ebp]
  000b9	83 c0 04	 add	 eax, 4
  000bc	89 45 a8	 mov	 DWORD PTR $T17[ebp], eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  000bf	8b 4d ac	 mov	 ecx, DWORD PTR $T18[ebp]
  000c2	8b 55 a8	 mov	 edx, DWORD PTR $T17[ebp]
  000c5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c7	2b 02		 sub	 eax, DWORD PTR [edx]
  000c9	89 45 94	 mov	 DWORD PTR $T12[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000cc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	89 4d a4	 mov	 DWORD PTR $T16[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  000d2	8b 55 a4	 mov	 edx, DWORD PTR $T16[ebp]
  000d5	89 55 a0	 mov	 DWORD PTR $T15[ebp], edx

; 576  : 		return (_Get_data()._Myfirst);

  000d8	8b 45 a0	 mov	 eax, DWORD PTR $T15[ebp]
  000db	83 c0 04	 add	 eax, 4
  000de	89 45 98	 mov	 DWORD PTR $T13[ebp], eax

; 545  : 		return (_Mypair._Get_first());

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  000e4	89 4d 9c	 mov	 DWORD PTR $T14[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  000e7	8b 55 9c	 mov	 edx, DWORD PTR $T14[ebp]
  000ea	89 95 5c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx

; 1901 : 			this->_Getal().deallocate(this->_Myfirst(), capacity());

  000f0	8b 45 98	 mov	 eax, DWORD PTR $T13[ebp]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	89 4d 90	 mov	 DWORD PTR __Ptr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f8	8b 55 94	 mov	 edx, DWORD PTR $T12[ebp]
  000fb	89 55 f4	 mov	 DWORD PTR __Bytes$[ebp], edx
  000fe	8b 45 90	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00101	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00104	81 7d f4 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0010b	72 10		 jb	 SHORT $LN97@Change_arr

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0010d	8d 4d f4	 lea	 ecx, DWORD PTR __Bytes$[ebp]
  00110	51		 push	 ecx
  00111	8d 55 f0	 lea	 edx, DWORD PTR __Ptr$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0011a	83 c4 08	 add	 esp, 8
$LN97@Change_arr:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0011d	8b 45 f4	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00120	50		 push	 eax
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0012a	83 c4 08	 add	 esp, 8
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0012d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00130	89 55 8c	 mov	 DWORD PTR $T11[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00133	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  00136	89 45 88	 mov	 DWORD PTR $T10[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  00139	8b 4d 88	 mov	 ecx, DWORD PTR $T10[ebp]
  0013c	83 c1 04	 add	 ecx, 4
  0013f	89 4d 84	 mov	 DWORD PTR $T9[ebp], ecx

; 1902 : 			}
; 1903 : 
; 1904 : 		this->_Myfirst() = _Newvec;

  00142	8b 55 84	 mov	 edx, DWORD PTR $T9[ebp]
  00145	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00148	89 02		 mov	 DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0014a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	89 4d 80	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00150	8b 55 80	 mov	 edx, DWORD PTR $T8[ebp]
  00153	89 95 7c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], edx

; 586  : 		return (_Get_data()._Mylast);

  00159	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0015f	83 c0 08	 add	 eax, 8
  00162	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00168	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0016b	03 4d 0c	 add	 ecx, DWORD PTR __Newsize$[ebp]
  0016e	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  00174	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00176	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00179	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0017f	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00185	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx

; 596  : 		return (_Get_data()._Myend);

  0018b	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00191	83 c2 0c	 add	 edx, 12			; 0000000cH
  00194	89 95 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], edx

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  0019a	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0019d	03 45 10	 add	 eax, DWORD PTR __Newcapacity$[ebp]
  001a0	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  001a6	89 01		 mov	 DWORD PTR [ecx], eax

; 1907 : 		}

  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@DV?$allocator@D@std@@@std@@AAEXQADII@Z ENDP ; std::vector<char,std::allocator<char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@AAE_NI@Z
_TEXT	SEGMENT
$T1 = -148						; size = 4
$T2 = -144						; size = 4
$T3 = -140						; size = 4
$T4 = -136						; size = 4
$T5 = -132						; size = 4
$T6 = -128						; size = 4
$T7 = -124						; size = 4
$T8 = -120						; size = 4
$T9 = -116						; size = 4
$T10 = -112						; size = 4
$T11 = -108						; size = 4
$T12 = -104						; size = 4
$T13 = -100						; size = 4
$T14 = -96						; size = 4
$T15 = -92						; size = 4
$T16 = -88						; size = 4
$T17 = -84						; size = 4
$T18 = -80						; size = 4
$T19 = -76						; size = 4
$T20 = -72						; size = 4
$T21 = -68						; size = 4
$T22 = -64						; size = 4
$T23 = -60						; size = 4
$T24 = -56						; size = 4
$T25 = -52						; size = 4
$T26 = -48						; size = 4
$T27 = -44						; size = 4
$T28 = -40						; size = 4
$T29 = -36						; size = 4
$T30 = -32						; size = 4
$T31 = -28						; size = 4
$T32 = -24						; size = 4
tv181 = -20						; size = 4
$T33 = -16						; size = 4
$T34 = -12						; size = 4
$T35 = -8						; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@AAE_NI@Z PROC	; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1872 : 		{	// allocate array with _Newcapacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 e8	 mov	 DWORD PTR $T32[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00012	8b 4d e8	 mov	 ecx, DWORD PTR $T32[ebp]
  00015	89 4d e4	 mov	 DWORD PTR $T31[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00018	8b 55 e4	 mov	 edx, DWORD PTR $T31[ebp]
  0001b	83 c2 04	 add	 edx, 4
  0001e	89 55 e0	 mov	 DWORD PTR $T30[ebp], edx

; 1873 : 		this->_Myfirst() = pointer();

  00021	8b 45 e0	 mov	 eax, DWORD PTR $T30[ebp]
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	89 4d dc	 mov	 DWORD PTR $T29[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00030	8b 55 dc	 mov	 edx, DWORD PTR $T29[ebp]
  00033	89 55 d8	 mov	 DWORD PTR $T28[ebp], edx

; 586  : 		return (_Get_data()._Mylast);

  00036	8b 45 d8	 mov	 eax, DWORD PTR $T28[ebp]
  00039	83 c0 08	 add	 eax, 8
  0003c	89 45 d4	 mov	 DWORD PTR $T27[ebp], eax

; 1874 : 		this->_Mylast() = pointer();

  0003f	8b 4d d4	 mov	 ecx, DWORD PTR $T27[ebp]
  00042	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00048	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	89 55 d0	 mov	 DWORD PTR $T26[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0004e	8b 45 d0	 mov	 eax, DWORD PTR $T26[ebp]
  00051	89 45 cc	 mov	 DWORD PTR $T25[ebp], eax

; 596  : 		return (_Get_data()._Myend);

  00054	8b 4d cc	 mov	 ecx, DWORD PTR $T25[ebp]
  00057	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0005a	89 4d c8	 mov	 DWORD PTR $T24[ebp], ecx

; 1875 : 		this->_Myend() = pointer();

  0005d	8b 55 c8	 mov	 edx, DWORD PTR $T24[ebp]
  00060	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1876 : 
; 1877 : 		if (_Newcapacity == 0)

  00066	83 7d 08 00	 cmp	 DWORD PTR __Newcapacity$[ebp], 0
  0006a	75 07		 jne	 SHORT $LN2@Buy

; 1878 : 			{
; 1879 : 			return (false);

  0006c	32 c0		 xor	 al, al
  0006e	e9 3d 01 00 00	 jmp	 $LN4@Buy
$LN2@Buy:

; 550  : 		return (_Mypair._Get_first());

  00073	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00076	89 45 c4	 mov	 DWORD PTR $T23[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 550  : 		return (_Mypair._Get_first());

  00079	8b 4d c4	 mov	 ecx, DWORD PTR $T23[ebp]
  0007c	89 8d 70 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00082	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR $T34[ebp], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits

; 617  : 		return (INT_MAX);

  00089	c7 45 c0 ff ff
	ff 7f		 mov	 DWORD PTR $T22[ebp], 2147483647 ; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00090	8b 55 c0	 mov	 edx, DWORD PTR $T22[ebp]
  00093	89 55 f0	 mov	 DWORD PTR $T33[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00096	8b 45 f4	 mov	 eax, DWORD PTR $T34[ebp]
  00099	3b 45 f0	 cmp	 eax, DWORD PTR $T33[ebp]
  0009c	73 08		 jae	 SHORT $LN49@Buy
  0009e	8d 4d f4	 lea	 ecx, DWORD PTR $T34[ebp]
  000a1	89 4d ec	 mov	 DWORD PTR tv181[ebp], ecx
  000a4	eb 06		 jmp	 SHORT $LN50@Buy
$LN49@Buy:
  000a6	8d 55 f0	 lea	 edx, DWORD PTR $T33[ebp]
  000a9	89 55 ec	 mov	 DWORD PTR tv181[ebp], edx
$LN50@Buy:
  000ac	8b 45 ec	 mov	 eax, DWORD PTR tv181[ebp]
  000af	89 45 bc	 mov	 DWORD PTR $T21[ebp], eax
  000b2	8b 4d bc	 mov	 ecx, DWORD PTR $T21[ebp]
  000b5	89 4d b8	 mov	 DWORD PTR $T20[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  000b8	8b 55 b8	 mov	 edx, DWORD PTR $T20[ebp]
  000bb	8b 02		 mov	 eax, DWORD PTR [edx]
  000bd	89 45 b4	 mov	 DWORD PTR $T19[ebp], eax

; 1880 : 			}
; 1881 : 
; 1882 : 		if (_Newcapacity > max_size())

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  000c3	3b 4d b4	 cmp	 ecx, DWORD PTR $T19[ebp]
  000c6	76 05		 jbe	 SHORT $LN3@Buy

; 1883 : 			{
; 1884 : 			_Xlength();

  000c8	e8 00 00 00 00	 call	 ?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
$LN3@Buy:

; 545  : 		return (_Mypair._Get_first());

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  000d0	89 55 b0	 mov	 DWORD PTR $T18[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  000d3	8b 45 b0	 mov	 eax, DWORD PTR $T18[ebp]
  000d6	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  000dc	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Newcapacity$[ebp], 4096 ; 00001000H
  000e3	72 11		 jb	 SHORT $LN63@Buy

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000e5	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ee	83 c4 04	 add	 esp, 4
  000f1	89 45 f8	 mov	 DWORD PTR $T35[ebp], eax
  000f4	eb 1e		 jmp	 SHORT $LN58@Buy
$LN63@Buy:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  000f6	83 7d 08 00	 cmp	 DWORD PTR __Newcapacity$[ebp], 0
  000fa	74 11		 je	 SHORT $LN64@Buy

; 52   : 		return (::operator new(_Bytes));

  000fc	8b 55 08	 mov	 edx, DWORD PTR __Newcapacity$[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00105	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00108	89 45 f8	 mov	 DWORD PTR $T35[ebp], eax
  0010b	eb 07		 jmp	 SHORT $LN58@Buy
$LN64@Buy:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  0010d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T35[ebp], 0
$LN58@Buy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00114	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00117	89 45 ac	 mov	 DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0011a	8b 4d ac	 mov	 ecx, DWORD PTR $T17[ebp]
  0011d	89 4d a8	 mov	 DWORD PTR $T16[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00120	8b 55 a8	 mov	 edx, DWORD PTR $T16[ebp]
  00123	83 c2 04	 add	 edx, 4
  00126	89 55 a4	 mov	 DWORD PTR $T15[ebp], edx

; 1885 : 			}
; 1886 : 
; 1887 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

  00129	8b 45 a4	 mov	 eax, DWORD PTR $T15[ebp]
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR $T35[ebp]
  0012f	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00131	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00134	89 55 a0	 mov	 DWORD PTR $T14[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00137	8b 45 a0	 mov	 eax, DWORD PTR $T14[ebp]
  0013a	89 45 9c	 mov	 DWORD PTR $T13[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  0013d	8b 4d 9c	 mov	 ecx, DWORD PTR $T13[ebp]
  00140	83 c1 04	 add	 ecx, 4
  00143	89 4d 8c	 mov	 DWORD PTR $T9[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00146	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00149	89 55 98	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0014c	8b 45 98	 mov	 eax, DWORD PTR $T12[ebp]
  0014f	89 45 94	 mov	 DWORD PTR $T11[ebp], eax

; 586  : 		return (_Get_data()._Mylast);

  00152	8b 4d 94	 mov	 ecx, DWORD PTR $T11[ebp]
  00155	83 c1 08	 add	 ecx, 8
  00158	89 4d 90	 mov	 DWORD PTR $T10[ebp], ecx

; 1888 : 		this->_Mylast() = this->_Myfirst();

  0015b	8b 55 90	 mov	 edx, DWORD PTR $T10[ebp]
  0015e	8b 45 8c	 mov	 eax, DWORD PTR $T9[ebp]
  00161	8b 08		 mov	 ecx, DWORD PTR [eax]
  00163	89 0a		 mov	 DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00165	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00168	89 55 88	 mov	 DWORD PTR $T8[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0016b	8b 45 88	 mov	 eax, DWORD PTR $T8[ebp]
  0016e	89 45 84	 mov	 DWORD PTR $T7[ebp], eax

; 576  : 		return (_Get_data()._Myfirst);

  00171	8b 4d 84	 mov	 ecx, DWORD PTR $T7[ebp]
  00174	83 c1 04	 add	 ecx, 4
  00177	89 8d 78 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0017d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00180	89 55 80	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00183	8b 45 80	 mov	 eax, DWORD PTR $T6[ebp]
  00186	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 596  : 		return (_Get_data()._Myend);

  0018c	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00192	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00195	89 8d 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx

; 1889 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

  0019b	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  001a1	8b 02		 mov	 eax, DWORD PTR [edx]
  001a3	03 45 08	 add	 eax, DWORD PTR __Newcapacity$[ebp]
  001a6	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  001ac	89 01		 mov	 DWORD PTR [ecx], eax

; 1890 : 
; 1891 : 		return (true);

  001ae	b0 01		 mov	 al, 1
$LN4@Buy:

; 1892 : 		}

  001b0	8b e5		 mov	 esp, ebp
  001b2	5d		 pop	 ebp
  001b3	c2 04 00	 ret	 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@AAE_NI@Z ENDP	; std::vector<char,std::allocator<char> >::_Buy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
__Geometric$ = -24					; size = 4
tv78 = -20						; size = 4
$T7 = -16						; size = 4
$T8 = -12						; size = 4
_this$ = -8						; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@ABEII@Z PROC ; std::vector<char,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1853 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1854 : 		const size_type _Oldcapacity = capacity();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
  00011	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 550  : 		return (_Mypair._Get_first());

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00017	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 550  : 		return (_Mypair._Get_first());

  0001a	8b 4d e4	 mov	 ecx, DWORD PTR $T6[ebp]
  0001d	89 4d d0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00020	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR $T8[ebp], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits

; 617  : 		return (INT_MAX);

  00027	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0002e	8b 55 e0	 mov	 edx, DWORD PTR $T5[ebp]
  00031	89 55 f0	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00034	8b 45 f4	 mov	 eax, DWORD PTR $T8[ebp]
  00037	3b 45 f0	 cmp	 eax, DWORD PTR $T7[ebp]
  0003a	73 08		 jae	 SHORT $LN43@Calculate_
  0003c	8d 4d f4	 lea	 ecx, DWORD PTR $T8[ebp]
  0003f	89 4d ec	 mov	 DWORD PTR tv78[ebp], ecx
  00042	eb 06		 jmp	 SHORT $LN44@Calculate_
$LN43@Calculate_:
  00044	8d 55 f0	 lea	 edx, DWORD PTR $T7[ebp]
  00047	89 55 ec	 mov	 DWORD PTR tv78[ebp], edx
$LN44@Calculate_:
  0004a	8b 45 ec	 mov	 eax, DWORD PTR tv78[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00050	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  00053	89 4d d8	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00056	8b 55 d8	 mov	 edx, DWORD PTR $T3[ebp]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Oldcapacity$[ebp]
  00061	d1 e9		 shr	 ecx, 1
  00063	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  00066	2b d1		 sub	 edx, ecx
  00068	39 55 fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], edx
  0006b	76 05		 jbe	 SHORT $LN2@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00070	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00072	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00075	d1 e8		 shr	 eax, 1
  00077	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  0007a	89 45 e8	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0007d	8b 4d e8	 mov	 ecx, DWORD PTR __Geometric$[ebp]
  00080	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  00083	73 05		 jae	 SHORT $LN3@Calculate_

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00085	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00088	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient

  0008a	8b 45 e8	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1869 : 		}

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@DV?$allocator@D@std@@@std@@ABEII@Z ENDP ; std::vector<char,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1848 : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<

  00015	33 d2		 xor	 edx, edx
  00017	88 55 ff	 mov	 BYTE PTR $T3[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1850 : 		}

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1842 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1843 : 		_Umove_if_noexcept1(_First, _Last, _Dest,

  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
  0000e	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00011	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl

; 545  : 		return (_Mypair._Get_first());

  00014	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00017	89 55 f0	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0001a	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0001d	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 1833 : 		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());

  00020	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  00023	51		 push	 ecx
  00024	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00027	52		 push	 edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PADPADV?$allocator@D@std@@@std@@YAPADQAD0PADAAV?$allocator@D@0@@Z ; std::_Uninitialized_move<char *,char *,std::allocator<char> >
  00035	83 c4 10	 add	 esp, 16			; 00000010H

; 1844 : 			bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1845 : 		}

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
__Last_ch$3 = -60					; size = 4
__Dest$ = -56						; size = 4
__Last$ = -52						; size = 4
__First$ = -48						; size = 4
__UDest$4 = -44						; size = 4
$T5 = -40						; size = 4
_this$ = -36						; size = 4
__Dest$ = -32						; size = 4
__Count$6 = -28						; size = 4
__Dest_ch$7 = -24					; size = 4
__First_ch$8 = -20					; size = 4
__UFirst$9 = -16					; size = 4
__ULast$10 = -12					; size = 4
___formal$ = -8						; size = 1
$T11 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1832 : 		{	// move [_First, _Last) to raw _Dest, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
  00012	89 4d c0	 mov	 DWORD PTR $T2[ebp], ecx

; 1833 : 		_Uninitialized_move(_First, _Last, _Dest, this->_Getal());

  00015	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00018	89 55 e0	 mov	 DWORD PTR __Dest$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 253  : 	const auto _UFirst = _Get_unwrapped(_First);

  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __UFirst$9[ebp], eax

; 254  : 	const auto _ULast = _Get_unwrapped(_Last);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00024	89 4d f4	 mov	 DWORD PTR __ULast$10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00027	8b 55 f4	 mov	 edx, DWORD PTR __ULast$10[ebp]
  0002a	2b 55 f0	 sub	 edx, DWORD PTR __UFirst$9[ebp]

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));

  0002d	89 55 bc	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 255  : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  00030	8b 45 e0	 mov	 eax, DWORD PTR __Dest$[ebp]
  00033	89 45 d4	 mov	 DWORD PTR __UDest$4[ebp], eax

; 256  : 	_Seek_wrapped(_Dest,

  00036	8a 4d ff	 mov	 cl, BYTE PTR $T11[ebp]
  00039	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl
  0003c	8b 55 d4	 mov	 edx, DWORD PTR __UDest$4[ebp]
  0003f	89 55 c8	 mov	 DWORD PTR __Dest$[ebp], edx
  00042	8b 45 f4	 mov	 eax, DWORD PTR __ULast$10[ebp]
  00045	89 45 cc	 mov	 DWORD PTR __Last$[ebp], eax
  00048	8b 4d f0	 mov	 ecx, DWORD PTR __UFirst$9[ebp]
  0004b	89 4d d0	 mov	 DWORD PTR __First$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

  0004e	8b 55 d0	 mov	 edx, DWORD PTR __First$[ebp]
  00051	89 55 ec	 mov	 DWORD PTR __First_ch$8[ebp], edx

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));

  00054	8b 45 cc	 mov	 eax, DWORD PTR __Last$[ebp]
  00057	89 45 c4	 mov	 DWORD PTR __Last_ch$3[ebp], eax

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

  0005a	8b 4d c8	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005d	89 4d e8	 mov	 DWORD PTR __Dest_ch$7[ebp], ecx

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00060	8b 55 c4	 mov	 edx, DWORD PTR __Last_ch$3[ebp]
  00063	2b 55 ec	 sub	 edx, DWORD PTR __First_ch$8[ebp]
  00066	89 55 e4	 mov	 DWORD PTR __Count$6[ebp], edx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00069	8b 45 e4	 mov	 eax, DWORD PTR __Count$6[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR __First_ch$8[ebp]
  00070	51		 push	 ecx
  00071	8b 55 e8	 mov	 edx, DWORD PTR __Dest_ch$7[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 _memmove
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0007d	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$7[ebp]
  00080	03 45 e4	 add	 eax, DWORD PTR __Count$6[ebp]

; 872  : 	_It = _UIt;

  00083	89 45 e0	 mov	 DWORD PTR __Dest$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1834 : 		}

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@DV?$allocator@D@std@@@std@@AAEXPAD00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Udefault@?$vector@DV?$allocator@D@std@@@std@@AAEPADPADI@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Last_ch$2 = -28					; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
__Last$4 = -16						; size = 4
__First_ch$5 = -12					; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@DV?$allocator@D@std@@@std@@AAEPADPADI@Z PROC ; std::vector<char,std::allocator<char> >::_Udefault, COMDAT
; _this$ = ecx

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d e0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00015	33 d2		 xor	 edx, edx
  00017	88 55 ff	 mov	 BYTE PTR $T6[ebp], dl
  0001a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0001d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00023	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	89 4d f0	 mov	 DWORD PTR __Last$4[ebp], ecx

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  00029	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  0002c	89 55 f4	 mov	 DWORD PTR __First_ch$5[ebp], edx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Last$4[ebp]
  00032	89 45 e4	 mov	 DWORD PTR __Last_ch$2[ebp], eax

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00035	8b 4d e4	 mov	 ecx, DWORD PTR __Last_ch$2[ebp]
  00038	2b 4d f4	 sub	 ecx, DWORD PTR __First_ch$5[ebp]
  0003b	51		 push	 ecx
  0003c	6a 00		 push	 0
  0003e	8b 55 f4	 mov	 edx, DWORD PTR __First_ch$5[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _memset
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  0004a	8b 45 f0	 mov	 eax, DWORD PTR __Last$4[ebp]

; 1813 : 		}

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?_Udefault@?$vector@DV?$allocator@D@std@@@std@@AAEPADPADI@Z ENDP ; std::vector<char,std::allocator<char> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 1714 : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T5[ebp], ecx

; 601  : 		return (_Get_data()._Myend);

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T5[ebp]
  00018	83 c2 0c	 add	 edx, 12			; 0000000cH
  0001b	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00024	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00027	89 4d ec	 mov	 DWORD PTR $T3[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  0002a	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  0002d	83 c2 04	 add	 edx, 4
  00030	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00033	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00036	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1716 : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv72 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1708 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 		return (_Mypair._Get_first());

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 550  : 		return (_Mypair._Get_first());

  0000f	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp]
  00012	89 4d dc	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00015	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR $T7[ebp], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits

; 617  : 		return (INT_MAX);

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00023	8b 55 e8	 mov	 edx, DWORD PTR $T4[ebp]
  00026	89 55 f8	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 4d fc	 lea	 ecx, DWORD PTR $T7[ebp]
  00034	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 55 f8	 lea	 edx, DWORD PTR $T6[ebp]
  0003c	89 55 f4	 mov	 DWORD PTR tv72[ebp], edx
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv72[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00048	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004b	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  0004e	8b 02		 mov	 eax, DWORD PTR [edx]

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1703 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T5[ebp], ecx

; 591  : 		return (_Get_data()._Mylast);

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T5[ebp]
  00018	83 c2 08	 add	 edx, 8
  0001b	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00024	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00027	89 4d ec	 mov	 DWORD PTR $T3[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  0002a	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  0002d	83 c2 04	 add	 edx, 4
  00030	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00033	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00036	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]

; 1705 : 		}

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Parg$ = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1618 : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T6[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T5[ebp]
  00018	89 55 e0	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00021	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00024	89 4d ec	 mov	 DWORD PTR $T3[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00027	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  0002a	83 c2 04	 add	 edx, 4
  0002d	89 55 e8	 mov	 DWORD PTR $T2[ebp], edx

; 1619 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));

  00030	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	89 4d e4	 mov	 DWORD PTR __Parg$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00038	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00044	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 41   : 		: _Ptr(_Parg)

  0004b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004e	8b 55 e4	 mov	 edx, DWORD PTR __Parg$[ebp]
  00051	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 42   : 		{	// construct with pointer _Parg
; 43   : 		this->_Adopt(_Pvector);

  00054	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 1619 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));

  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1620 : 		}

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Lambda_default$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z PROC ; std::vector<char,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1476 : 		{	// trim or append value-initialized elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1480 : 			};

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Lambda_default$[ebp], eax

; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __Lambda_default$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00016	52		 push	 edx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z ; std::vector<char,std::allocator<char> >::_Resize<<lambda_c82d6fc6887df3275822341e5972f698> >

; 1483 : 		}

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?resize@?$vector@DV?$allocator@D@std@@@std@@QAEXI@Z ENDP ; std::vector<char,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 894  : 		_Tidy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 460  : 		{	// destroy proxy

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 461  : 		_Free_proxy();

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 462  : 		}

  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 895  : 		}

  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
__Last_ch$6 = -60					; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
$T10 = -44						; size = 4
__Last$11 = -40						; size = 4
__First_ch$12 = -36					; size = 4
__Dest$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$13 = -24					; size = 1
$T14 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 661  : 		{	// construct from _Count * _Ty(), optional allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 587  : 		}
; 588  : 
; 589  : 	const pointer& _Mylast() const noexcept
; 590  : 		{	// return const reference to _Mylast
; 591  : 		return (_Get_data()._Mylast);
; 592  : 		}
; 593  : 
; 594  : 	pointer& _Myend() noexcept
; 595  : 		{	// return reference to _Myend
; 596  : 		return (_Get_data()._Myend);
; 597  : 		}
; 598  : 
; 599  : 	const pointer& _Myend() const noexcept
; 600  : 		{	// return const reference to _Myend
; 601  : 		return (_Get_data()._Myend);
; 602  : 		}
; 603  : 
; 604  : private:
; 605  : 	_Compressed_pair<_Alty, _Vector_val<_Val_types>> _Mypair;
; 606  : 	};
; 607  : 
; 608  : 		// FUNCTION TEMPLATE _Unfancy_maybe_null
; 609  : template<class _Ptrty> inline
; 610  : 	auto _Unfancy_maybe_null(_Ptrty _Ptr)
; 611  : 	{	// converts from a (potentially null) fancy pointer to a plain pointer
; 612  : 	return (_Ptr ? _STD addressof(*_Ptr) : nullptr);
; 613  : 	}
; 614  : 
; 615  : template<class _Ty> inline
; 616  : 	_Ty * _Unfancy_maybe_null(_Ty * _Ptr)
; 617  : 	{	// do nothing for plain pointers
; 618  : 	return (_Ptr);
; 619  : 	}
; 620  : 
; 621  : 		// CLASS TEMPLATE vector
; 622  : template<class _Ty,
; 623  : 	class _Alloc = allocator<_Ty>>
; 624  : 	class vector
; 625  : 		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>
; 626  : 	{	// varying size array of values
; 627  : private:
; 628  : 	using _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>;
; 629  : 	using _Alty = typename _Mybase::_Alty;
; 630  : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 631  : 
; 632  : public:
; 633  : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Ty, typename _Alloc::value_type>,
; 634  : 		_MISMATCHED_ALLOCATOR_MESSAGE("vector<T, Allocator>", "T"));
; 635  : 
; 636  : 	using value_type = _Ty;
; 637  : 	using allocator_type = _Alloc;
; 638  : 	using pointer = typename _Mybase::pointer;
; 639  : 	using const_pointer = typename _Mybase::const_pointer;
; 640  : 	using reference = _Ty&;
; 641  : 	using const_reference = const _Ty&;
; 642  : 	using size_type = typename _Mybase::size_type;
; 643  : 	using difference_type = typename _Mybase::difference_type;
; 644  : 	using iterator = typename _Mybase::iterator;
; 645  : 	using const_iterator = typename _Mybase::const_iterator;
; 646  : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 647  : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 648  : 
; 649  : 	vector() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
; 650  : 		: _Mybase()
; 651  : 		{	// construct empty vector
; 652  : 		}
; 653  : 
; 654  : 	explicit vector(const _Alloc& _Al) noexcept
; 655  : 		: _Mybase(_Al)
; 656  : 		{	// construct empty vector, allocator
; 657  : 		}
; 658  : 
; 659  : 	explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())
; 660  : 		: _Mybase(_Al)

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00032	50		 push	 eax
  00033	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@D@std@@X@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 662  : 		if (_Buy(_Count))

  00042	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00045	51		 push	 ecx
  00046	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Buy@?$vector@DV?$allocator@D@std@@@std@@AAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
  0004e	0f b6 d0	 movzx	 edx, al
  00051	85 d2		 test	 edx, edx
  00053	0f 84 a8 00 00
	00		 je	 $LN1@vector

; 663  : 			{	// nonzero, fill it
; 664  : 			_TRY_BEGIN

  00059	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0005d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	89 45 d4	 mov	 DWORD PTR $T10[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00063	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp]
  00066	89 4d d0	 mov	 DWORD PTR $T9[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00069	8b 55 d0	 mov	 edx, DWORD PTR $T9[ebp]
  0006c	83 c2 04	 add	 edx, 4
  0006f	89 55 cc	 mov	 DWORD PTR $T8[ebp], edx

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  00072	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	89 4d e0	 mov	 DWORD PTR __Dest$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  0007a	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0007d	89 55 c8	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  00083	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00086	33 c9		 xor	 ecx, ecx
  00088	88 4d ef	 mov	 BYTE PTR $T14[ebp], cl
  0008b	8a 55 ef	 mov	 dl, BYTE PTR $T14[ebp]
  0008e	88 55 e8	 mov	 BYTE PTR ___formal$13[ebp], dl

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00091	8b 45 e0	 mov	 eax, DWORD PTR __Dest$[ebp]
  00094	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00097	89 45 d8	 mov	 DWORD PTR __Last$11[ebp], eax

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);

  0009a	8b 4d e0	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0009d	89 4d dc	 mov	 DWORD PTR __First_ch$12[ebp], ecx

; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);

  000a0	8b 55 d8	 mov	 edx, DWORD PTR __Last$11[ebp]
  000a3	89 55 c4	 mov	 DWORD PTR __Last_ch$6[ebp], edx

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000a6	8b 45 c4	 mov	 eax, DWORD PTR __Last_ch$6[ebp]
  000a9	2b 45 dc	 sub	 eax, DWORD PTR __First_ch$12[ebp]
  000ac	50		 push	 eax
  000ad	6a 00		 push	 0
  000af	8b 4d dc	 mov	 ecx, DWORD PTR __First_ch$12[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _memset
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000bb	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  000be	89 55 c0	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  000c1	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000c4	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 586  : 		return (_Get_data()._Mylast);

  000c7	8b 4d bc	 mov	 ecx, DWORD PTR $T4[ebp]
  000ca	83 c1 08	 add	 ecx, 8
  000cd	89 4d b8	 mov	 DWORD PTR $T3[ebp], ecx

; 665  : 			this->_Mylast() = _Udefault(this->_Myfirst(), _Count);

  000d0	8b 55 b8	 mov	 edx, DWORD PTR $T3[ebp]
  000d3	8b 45 d8	 mov	 eax, DWORD PTR __Last$11[ebp]
  000d6	89 02		 mov	 DWORD PTR [edx], eax
  000d8	eb 17		 jmp	 SHORT $LN5@vector
__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$0:

; 666  : 			_CATCH_ALL
; 667  : 			_Tidy();

  000da	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 668  : 			_RERAISE;

  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 669  : 			_CATCH_END

  000eb	b8 00 00 00 00	 mov	 eax, $LN9@vector
  000f0	c3		 ret	 0
$LN5@vector:
  000f1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000f8	eb 07		 jmp	 SHORT $LN1@vector
$LN9@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
  000fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN1@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 670  : 			}
; 671  : 		}

  00101	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00108	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
$LN4@vector:
  0010b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0010e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00115	59		 pop	 ecx
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5b		 pop	 ebx
  00119	8b e5		 mov	 esp, ebp
  0011b	5d		 pop	 ebp
  0011c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z$2:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::~_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >
__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 303  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 298  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 293  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 392  : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 389  : 		: _Myfirst(),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 390  : 		_Mylast(),

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 391  : 		_Myend()

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 393  : 		}

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend, COMDAT
; _this$ = ecx

; 600  : 		{	// return const reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 601  : 		return (_Get_data()._Myend);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 0c	 add	 eax, 12			; 0000000cH

; 602  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend, COMDAT
; _this$ = ecx

; 595  : 		{	// return reference to _Myend

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 596  : 		return (_Get_data()._Myend);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 0c	 add	 eax, 12			; 0000000cH

; 597  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast, COMDAT
; _this$ = ecx

; 590  : 		{	// return const reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 591  : 		return (_Get_data()._Mylast);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 08	 add	 eax, 8

; 592  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast, COMDAT
; _this$ = ecx

; 585  : 		{	// return reference to _Mylast

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 586  : 		return (_Get_data()._Mylast);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 08	 add	 eax, 8

; 587  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 580  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 04	 add	 eax, 4

; 582  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABQADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst, COMDAT
; _this$ = ecx

; 575  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00018	83 c0 04	 add	 eax, 4

; 577  : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPADXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 559  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 561  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 554  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 556  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 549  : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 550  : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 550  : 		return (_Mypair._Get_first());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 551  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 544  : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 546  : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 534  : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 535  : 		_Get_data()._Orphan_all();

  00015	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 536  : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 523  : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 524  : 		return (_Get_data()._Myproxy);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 525  : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_this$ = -12						; size = 4
tv78 = -8						; size = 4
$T3 = -4						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 518  : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

  00015	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00018	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0001b	75 09		 jne	 SHORT $LN11@Getpfirst
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00024	eb 0b		 jmp	 SHORT $LN12@Getpfirst
$LN11@Getpfirst:
  00026	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	83 c1 04	 add	 ecx, 4
  0002e	89 4d f8	 mov	 DWORD PTR tv78[ebp], ecx
$LN12@Getpfirst:
  00031	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00034	89 55 ec	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 519  : 		return (_Get_data()._Getpfirst());

  00037	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]

; 520  : 		}

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
$T9 = -32						; size = 4
$T10 = -28						; size = 4
$T11 = -24						; size = 4
$T12 = -20						; size = 4
$T13 = -16						; size = 4
__Ptr$14 = -12						; size = 4
__Bytes$15 = -8						; size = 4
_this$ = -4						; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 509  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f0	 mov	 DWORD PTR $T13[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T13[ebp]
  00012	89 4d c0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 55 ec	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T12[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T11[ebp], eax

; 535  : 		_Get_data()._Orphan_all();

  00021	8b 4d e8	 mov	 ecx, DWORD PTR $T11[ebp]
  00024	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	89 4d e4	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  0002f	8b 55 e4	 mov	 edx, DWORD PTR $T10[ebp]
  00032	89 55 e0	 mov	 DWORD PTR $T9[ebp], edx

; 524  : 		return (_Get_data()._Myproxy);

  00035	8b 45 e0	 mov	 eax, DWORD PTR $T9[ebp]
  00038	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 4d dc	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00041	8b 55 dc	 mov	 edx, DWORD PTR $T8[ebp]
  00044	89 55 d8	 mov	 DWORD PTR $T7[ebp], edx

; 524  : 		return (_Get_data()._Myproxy);

  00047	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  0004a	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax

; 510  : 		_Alproxy _Proxy_allocator(_Getal());
; 511  : 		_Orphan_all();
; 512  : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
; 513  : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

  0004d	8b 4d d4	 mov	 ecx, DWORD PTR $T6[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	89 55 d0	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 03	 shl	 eax, 3
  0005d	89 45 f8	 mov	 DWORD PTR __Bytes$15[ebp], eax
  00060	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00063	89 4d f4	 mov	 DWORD PTR __Ptr$14[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00066	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __Bytes$15[ebp], 4096 ; 00001000H
  0006d	72 10		 jb	 SHORT $LN52@Free_proxy

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0006f	8d 55 f8	 lea	 edx, DWORD PTR __Bytes$15[ebp]
  00072	52		 push	 edx
  00073	8d 45 f4	 lea	 eax, DWORD PTR __Ptr$14[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0007c	83 c4 08	 add	 esp, 8
$LN52@Free_proxy:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR __Bytes$15[ebp]
  00082	51		 push	 ecx
  00083	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$14[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008c	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00095	8b 4d cc	 mov	 ecx, DWORD PTR $T5[ebp]
  00098	89 4d c8	 mov	 DWORD PTR $T4[ebp], ecx

; 524  : 		return (_Get_data()._Myproxy);

  0009b	8b 55 c8	 mov	 edx, DWORD PTR $T4[ebp]
  0009e	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx

; 514  : 		_Myproxy() = nullptr;

  000a1	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 515  : 		}

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -88						; size = 8
$T2 = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
$T6 = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
__Ptr$ = -44						; size = 4
$T11 = -40						; size = 4
$T12 = -36						; size = 4
$T13 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T14 = -24						; size = 4
$T15 = -20						; size = 4
$T16 = -16						; size = 4
$T17 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 501  : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 545  : 		return (_Mypair._Get_first());

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f4	 mov	 DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 545  : 		return (_Mypair._Get_first());

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T17[ebp]
  00012	89 4d b0	 mov	 DWORD PTR $T2[ebp], ecx

; 502  : 		_Alproxy _Proxy_allocator(_Getal());
; 503  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00015	6a 01		 push	 1
  00017	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy_allocator$[ebp]
  0001a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0001f	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00022	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00025	89 55 f0	 mov	 DWORD PTR $T16[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00028	8b 45 f0	 mov	 eax, DWORD PTR $T16[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR $T15[ebp], eax

; 524  : 		return (_Get_data()._Myproxy);

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR $T15[ebp]
  00031	89 4d e8	 mov	 DWORD PTR $T14[ebp], ecx

; 502  : 		_Alproxy _Proxy_allocator(_Getal());
; 503  : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00034	8b 55 e8	 mov	 edx, DWORD PTR $T14[ebp]
  00037	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	89 02		 mov	 DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  0003c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00043	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], 0

; 302  : 		return (_Myval2);

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 4d e0	 mov	 DWORD PTR $T13[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00050	8b 55 e0	 mov	 edx, DWORD PTR $T13[ebp]
  00053	89 55 dc	 mov	 DWORD PTR $T12[ebp], edx

; 524  : 		return (_Get_data()._Myproxy);

  00056	8b 45 dc	 mov	 eax, DWORD PTR $T12[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T11[ebp], eax

; 504  : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

  0005c	8b 4d d8	 mov	 ecx, DWORD PTR $T11[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	89 55 d4	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00064	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00067	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0006a	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  0006d	89 4d d0	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00070	8b 55 d0	 mov	 edx, DWORD PTR $T10[ebp]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00078	8b 55 cc	 mov	 edx, DWORD PTR $T9[ebp]
  0007b	89 02		 mov	 DWORD PTR [edx], eax
  0007d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00086	8b 4d c8	 mov	 ecx, DWORD PTR $T8[ebp]
  00089	89 4d c4	 mov	 DWORD PTR $T7[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0008c	8b 55 c4	 mov	 edx, DWORD PTR $T7[ebp]
  0008f	89 55 b4	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 45 c0	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 555  : 		return (_Mypair._Get_second());

  00098	8b 4d c0	 mov	 ecx, DWORD PTR $T6[ebp]
  0009b	89 4d bc	 mov	 DWORD PTR $T5[ebp], ecx

; 524  : 		return (_Get_data()._Myproxy);

  0009e	8b 55 bc	 mov	 edx, DWORD PTR $T5[ebp]
  000a1	89 55 b8	 mov	 DWORD PTR $T4[ebp], edx

; 505  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  000a4	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	8b 55 b4	 mov	 edx, DWORD PTR $T3[ebp]
  000ac	89 11		 mov	 DWORD PTR [ecx], edx

; 506  : 		}

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::~_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 460  : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 461  : 		_Free_proxy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::_Free_proxy

; 462  : 		}

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >::~_Vector_alloc<std::_Vec_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?makeSpace@ByteBuffer@net@zl@@AAEXI@Z
_TEXT	SEGMENT
__Newsize$ = -32					; size = 4
__Lambda_default$1 = -28				; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_readable$4 = -16					; size = 4
_this$ = -12						; size = 4
_i$5 = -8						; size = 4
_this$ = -4						; size = 4
_len$ = 8						; size = 4
?makeSpace@ByteBuffer@net@zl@@AAEXI@Z PROC		; zl::net::ByteBuffer::makeSpace, COMDAT
; _this$ = ecx

; 293  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         return buffer_.size() - writerIndex_;

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	83 c1 08	 add	 ecx, 8
  00010	e8 00 00 00 00	 call	 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  0001b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 60   :         return readerIndex_;

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax

; 294  :         if (writableBytes() + prependableBytes() < len + kCheapPrepend)

  00026	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00029	03 4d e8	 add	 ecx, DWORD PTR $T2[ebp]
  0002c	8b 55 08	 mov	 edx, DWORD PTR _len$[ebp]
  0002f	83 c2 08	 add	 edx, 8
  00032	3b ca		 cmp	 ecx, edx
  00034	73 30		 jae	 SHORT $LN5@makeSpace

; 295  :         {
; 296  :             // FIXME: move readable data
; 297  :             buffer_.resize(writerIndex_ + len);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003c	03 4d 08	 add	 ecx, DWORD PTR _len$[ebp]
  0003f	89 4d e0	 mov	 DWORD PTR __Newsize$[ebp], ecx
  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	83 c2 08	 add	 edx, 8
  00048	89 55 f4	 mov	 DWORD PTR _this$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 1480 : 			};

  0004b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR __Lambda_default$1[ebp], eax

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00051	8b 4d e4	 mov	 ecx, DWORD PTR __Lambda_default$1[ebp]
  00054	51		 push	 ecx
  00055	8b 55 e0	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00058	52		 push	 edx
  00059	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_c82d6fc6887df3275822341e5972f698>@@@?$vector@DV?$allocator@D@std@@@std@@AAEXIV<lambda_c82d6fc6887df3275822341e5972f698>@@@Z ; std::vector<char,std::allocator<char> >::_Resize<<lambda_c82d6fc6887df3275822341e5972f698> >
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h

; 299  :         else

  00061	e9 b5 00 00 00	 jmp	 $LN1@makeSpace
$LN5@makeSpace:

; 300  :         {
; 301  :             // move readable data to the front, make space inside buffer
; 302  :             assert(kCheapPrepend < readerIndex_);

  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	83 38 08	 cmp	 DWORD PTR [eax], 8
  0006c	77 18		 ja	 SHORT $LN39@makeSpace
  0006e	68 2e 01 00 00	 push	 302			; 0000012eH
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_1DK@JBKPABMM@?$AAk?$AAC?$AAh?$AAe?$AAa?$AAp?$AAP?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DM@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN39@makeSpace:

; 50   :         return writerIndex_ - readerIndex_;

  00086	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0008f	2b 08		 sub	 ecx, DWORD PTR [eax]

; 303  :             size_t readable = readableBytes();

  00091	89 4d f0	 mov	 DWORD PTR _readable$4[ebp], ecx

; 304  : 			for (size_t i = 0; i < writerIndex_ - readerIndex_; i++)

  00094	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$5[ebp], 0
  0009b	eb 09		 jmp	 SHORT $LN4@makeSpace
$LN2@makeSpace:
  0009d	8b 55 f8	 mov	 edx, DWORD PTR _i$5[ebp]
  000a0	83 c2 01	 add	 edx, 1
  000a3	89 55 f8	 mov	 DWORD PTR _i$5[ebp], edx
$LN4@makeSpace:
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000af	2b 11		 sub	 edx, DWORD PTR [ecx]
  000b1	39 55 f8	 cmp	 DWORD PTR _i$5[ebp], edx
  000b4	73 26		 jae	 SHORT $LN3@makeSpace

; 305  : 			{
; 306  : 				(begin() + kCheapPrepend)[i] = (begin() + readerIndex_)[i];

  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?begin@ByteBuffer@net@zl@@AAEPADXZ ; zl::net::ByteBuffer::begin
  000be	8b f0		 mov	 esi, eax
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c3	03 30		 add	 esi, DWORD PTR [eax]
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?begin@ByteBuffer@net@zl@@AAEPADXZ ; zl::net::ByteBuffer::begin
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _i$5[ebp]
  000d0	8b 55 f8	 mov	 edx, DWORD PTR _i$5[ebp]
  000d3	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000d6	88 54 08 08	 mov	 BYTE PTR [eax+ecx+8], dl

; 307  : 			}

  000da	eb c1		 jmp	 SHORT $LN2@makeSpace
$LN3@makeSpace:

; 308  :             //std::copy(begin() + readerIndex_, begin() + writerIndex_, begin() + kCheapPrepend);
; 309  :             readerIndex_ = kCheapPrepend;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000df	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8

; 310  :             writerIndex_ = readerIndex_ + readable;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ea	03 55 f0	 add	 edx, DWORD PTR _readable$4[ebp]
  000ed	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 50   :         return writerIndex_ - readerIndex_;

  000f3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000f9	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000fc	2b 02		 sub	 eax, DWORD PTR [edx]

; 311  :             assert(readable == readableBytes());

  000fe	39 45 f0	 cmp	 DWORD PTR _readable$4[ebp], eax
  00101	74 18		 je	 SHORT $LN1@makeSpace
  00103	68 37 01 00 00	 push	 311			; 00000137H
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_1DI@FLADJBMA@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAa@
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@makeSpace:

; 312  :         }
; 313  :     }

  0011b	5e		 pop	 esi
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c2 04 00	 ret	 4
?makeSpace@ByteBuffer@net@zl@@AAEXI@Z ENDP		; zl::net::ByteBuffer::makeSpace
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?begin@ByteBuffer@net@zl@@AAEPADXZ
_TEXT	SEGMENT
$T2 = -44						; size = 12
$T3 = -32						; size = 4
__Lock$4 = -28						; size = 4
$T5 = -24						; size = 4
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?begin@ByteBuffer@net@zl@@AAEPADXZ PROC			; zl::net::ByteBuffer::begin, COMDAT
; _this$ = ecx

; 283  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?begin@ByteBuffer@net@zl@@AAEPADXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 284  :         return &*buffer_.begin();

  00028	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 08	 add	 ecx, 8
  00032	e8 00 00 00 00	 call	 ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
  00037	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  0003d	89 4d e8	 mov	 DWORD PTR $T5[ebp], ecx
  00040	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 258  : 		return (const_cast<reference>(_Mybase::operator*()));

  00047	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  0004a	e8 00 00 00 00	 call	 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<char> > >::operator*
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h

; 284  :         return &*buffer_.begin();

  0004f	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  00052	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 139  : 		{	// destroy the iterator

  00059	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00060	6a 03		 push	 3
  00062	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  0006b	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  0006e	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  00073	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$4[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h

; 284  :         return &*buffer_.begin();

  00083	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]

; 285  :     }

  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?begin@ByteBuffer@net@zl@@AAEPADXZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@XZ
__ehhandler$?begin@ByteBuffer@net@zl@@AAEPADXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?begin@ByteBuffer@net@zl@@AAEPADXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?begin@ByteBuffer@net@zl@@AAEPADXZ ENDP			; zl::net::ByteBuffer::begin
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?hasWritten@ByteBuffer@net@zl@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_len$ = 8						; size = 4
?hasWritten@ByteBuffer@net@zl@@QAEXI@Z PROC		; zl::net::ByteBuffer::hasWritten, COMDAT
; _this$ = ecx

; 250  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         return buffer_.size() - writerIndex_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 251  :         assert(len <= writableBytes());

  00018	39 45 08	 cmp	 DWORD PTR _len$[ebp], eax
  0001b	76 18		 jbe	 SHORT $LN3@hasWritten
  0001d	68 fb 00 00 00	 push	 251			; 000000fbH
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@OAPHHNA@?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe@
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@hasWritten:

; 252  :         writerIndex_ += len;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	03 4d 08	 add	 ecx, DWORD PTR _len$[ebp]
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 253  :     }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?hasWritten@ByteBuffer@net@zl@@QAEXI@Z ENDP		; zl::net::ByteBuffer::hasWritten
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?beginWrite@ByteBuffer@net@zl@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?beginWrite@ByteBuffer@net@zl@@QAEPADXZ PROC		; zl::net::ByteBuffer::beginWrite, COMDAT
; _this$ = ecx

; 240  :     { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 241  :         return begin() + writerIndex_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?begin@ByteBuffer@net@zl@@AAEPADXZ ; zl::net::ByteBuffer::begin
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	03 41 04	 add	 eax, DWORD PTR [ecx+4]

; 242  :     }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?beginWrite@ByteBuffer@net@zl@@QAEPADXZ ENDP		; zl::net::ByteBuffer::beginWrite
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?ensureWritableBytes@ByteBuffer@net@zl@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_len$ = 8						; size = 4
?ensureWritableBytes@ByteBuffer@net@zl@@QAEXI@Z PROC	; zl::net::ByteBuffer::ensureWritableBytes, COMDAT
; _this$ = ecx

; 231  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         return buffer_.size() - writerIndex_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 232  :         if (writableBytes() < len)

  00018	3b 45 08	 cmp	 eax, DWORD PTR _len$[ebp]
  0001b	73 0c		 jae	 SHORT $LN155@ensureWrit

; 233  :         {
; 234  :             makeSpace(len);

  0001d	8b 55 08	 mov	 edx, DWORD PTR _len$[ebp]
  00020	52		 push	 edx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?makeSpace@ByteBuffer@net@zl@@AAEXI@Z ; zl::net::ByteBuffer::makeSpace
$LN155@ensureWrit:

; 55   :         return buffer_.size() - writerIndex_;

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 08	 add	 ecx, 8
  0002f	e8 00 00 00 00	 call	 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 235  :         }
; 236  :         assert(writableBytes() >= len);

  0003a	3b 45 08	 cmp	 eax, DWORD PTR _len$[ebp]
  0003d	73 18		 jae	 SHORT $LN1@ensureWrit
  0003f	68 ec 00 00 00	 push	 236			; 000000ecH
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1CO@EOJCKDIM@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ensureWrit:

; 237  :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
?ensureWritableBytes@ByteBuffer@net@zl@@QAEXI@Z ENDP	; zl::net::ByteBuffer::ensureWritableBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?write@ByteBuffer@net@zl@@QAEXPBDI@Z
_TEXT	SEGMENT
_begin$ = -12						; size = 4
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_data$ = 8						; size = 4
_len$ = 12						; size = 4
?write@ByteBuffer@net@zl@@QAEXPBDI@Z PROC		; zl::net::ByteBuffer::write, COMDAT
; _this$ = ecx

; 80   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 81   :         ensureWritableBytes(len);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?ensureWritableBytes@ByteBuffer@net@zl@@QAEXI@Z ; zl::net::ByteBuffer::ensureWritableBytes

; 241  :         return begin() + writerIndex_;

  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?begin@ByteBuffer@net@zl@@AAEPADXZ ; zl::net::ByteBuffer::begin
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	03 41 04	 add	 eax, DWORD PTR [ecx+4]

; 82   : 		char* begin = beginWrite();

  00023	89 45 f4	 mov	 DWORD PTR _begin$[ebp], eax

; 83   : 		for (size_t i = 0; i < len; i++)

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  0002d	eb 09		 jmp	 SHORT $LN4@write
$LN2@write:
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _i$1[ebp]
  00032	83 c2 01	 add	 edx, 1
  00035	89 55 fc	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@write:
  00038	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0003b	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  0003e	73 12		 jae	 SHORT $LN3@write

; 84   : 			begin[i] = data[i];

  00040	8b 4d f4	 mov	 ecx, DWORD PTR _begin$[ebp]
  00043	03 4d fc	 add	 ecx, DWORD PTR _i$1[ebp]
  00046	8b 55 08	 mov	 edx, DWORD PTR _data$[ebp]
  00049	03 55 fc	 add	 edx, DWORD PTR _i$1[ebp]
  0004c	8a 02		 mov	 al, BYTE PTR [edx]
  0004e	88 01		 mov	 BYTE PTR [ecx], al
  00050	eb dd		 jmp	 SHORT $LN2@write
$LN3@write:

; 85   : 
; 86   :         //std::copy(data, data+len, beginWrite());
; 87   :         hasWritten(len);

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00055	51		 push	 ecx
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?hasWritten@ByteBuffer@net@zl@@QAEXI@Z ; zl::net::ByteBuffer::hasWritten

; 88   :     }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 08 00	 ret	 8
?write@ByteBuffer@net@zl@@QAEXPBDI@Z ENDP		; zl::net::ByteBuffer::write
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?prependableBytes@ByteBuffer@net@zl@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?prependableBytes@ByteBuffer@net@zl@@QBEIXZ PROC	; zl::net::ByteBuffer::prependableBytes, COMDAT
; _this$ = ecx

; 59   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 60   :         return readerIndex_;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 61   :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?prependableBytes@ByteBuffer@net@zl@@QBEIXZ ENDP	; zl::net::ByteBuffer::prependableBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?writableBytes@ByteBuffer@net@zl@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?writableBytes@ByteBuffer@net@zl@@QBEIXZ PROC		; zl::net::ByteBuffer::writableBytes, COMDAT
; _this$ = ecx

; 54   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         return buffer_.size() - writerIndex_;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]

; 56   :     }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?writableBytes@ByteBuffer@net@zl@@QBEIXZ ENDP		; zl::net::ByteBuffer::writableBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ?readableBytes@ByteBuffer@net@zl@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?readableBytes@ByteBuffer@net@zl@@QBEIXZ PROC		; zl::net::ByteBuffer::readableBytes, COMDAT
; _this$ = ecx

; 49   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   :         return writerIndex_ - readerIndex_;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]

; 51   :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?readableBytes@ByteBuffer@net@zl@@QBEIXZ ENDP		; zl::net::ByteBuffer::readableBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h
;	COMDAT ??0ByteBuffer@net@zl@@QAE@XZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
$T8 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T9 = -1						; size = 1
??0ByteBuffer@net@zl@@QAE@XZ PROC			; zl::net::ByteBuffer::ByteBuffer, COMDAT
; _this$ = ecx

; 42   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :         : readerIndex_(kCheapPrepend)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8

; 40   :         , writerIndex_(kCheapPrepend)

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	c7 41 04 08 00
	00 00		 mov	 DWORD PTR [ecx+4], 8

; 41   :         , buffer_(kCheapPrepend + kInitialSize)

  0001c	8d 55 ff	 lea	 edx, DWORD PTR $T9[ebp]
  0001f	52		 push	 edx
  00020	68 08 04 00 00	 push	 1032			; 00000408H
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 08	 add	 ecx, 8
  0002b	e8 00 00 00 00	 call	 ??0?$vector@DV?$allocator@D@std@@@std@@QAE@IABV?$allocator@D@1@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >

; 50   :         return writerIndex_ - readerIndex_;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00039	2b 11		 sub	 edx, DWORD PTR [ecx]

; 43   :         assert(readableBytes() == 0);

  0003b	74 15		 je	 SHORT $LN3@ByteBuffer
  0003d	6a 2b		 push	 43			; 0000002bH
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@HLKMELIP@?$AAr?$AAe?$AAa?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@ByteBuffer:

; 55   :         return buffer_.size() - writerIndex_;

  00052	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	83 c1 08	 add	 ecx, 8
  00058	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0005b	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005e	89 55 f0	 mov	 DWORD PTR $T8[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00061	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00064	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax

; 591  : 		return (_Get_data()._Mylast);

  00067	8b 4d ec	 mov	 ecx, DWORD PTR $T7[ebp]
  0006a	83 c1 08	 add	 ecx, 8
  0006d	89 4d e0	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00070	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00073	89 55 e8	 mov	 DWORD PTR $T6[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vector

; 560  : 		return (_Mypair._Get_second());

  00076	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00079	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 581  : 		return (_Get_data()._Myfirst);

  0007c	8b 4d e4	 mov	 ecx, DWORD PTR $T5[ebp]
  0007f	83 c1 04	 add	 ecx, 4
  00082	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00085	8b 55 e0	 mov	 edx, DWORD PTR $T4[ebp]
  00088	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0008b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0008f	89 4d d8	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\bytebuffer.h

; 55   :         return buffer_.size() - writerIndex_;

  00092	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00095	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00098	2b 42 04	 sub	 eax, DWORD PTR [edx+4]

; 44   :         assert(writableBytes() == kInitialSize);

  0009b	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  000a0	74 15		 je	 SHORT $LN4@ByteBuffer
  000a2	6a 2c		 push	 44			; 0000002cH
  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@MNNKLKHL@?$AAw?$AAr?$AAi?$AAt?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe?$AAs?$AA?$CI?$AA?$CJ@
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@ByteBuffer:

; 60   :         return readerIndex_;

  000b7	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ba	8b 02		 mov	 eax, DWORD PTR [edx]
  000bc	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 45   :         assert(prependableBytes() == kCheapPrepend);

  000bf	83 7d d4 08	 cmp	 DWORD PTR $T1[ebp], 8
  000c3	74 15		 je	 SHORT $LN1@ByteBuffer
  000c5	6a 2d		 push	 45			; 0000002dH
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@JAGCKFE@?$AAg?$AA?3?$AA?2?$AAQ?$PP?P?$AA?2?$AAh?$AAa?$AAp?$AAp?$AAy?$AAg?$AAa?$AAm?$AAe@
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_1EI@GKCFLMIJ@?$AAp?$AAr?$AAe?$AAp?$AAe?$AAn?$AAd?$AAa?$AAb?$AAl?$AAe?$AAB?$AAy?$AAt?$AAe@
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___wassert
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ByteBuffer:

; 46   :     }

  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??0ByteBuffer@net@zl@@QAE@XZ ENDP			; zl::net::ByteBuffer::ByteBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ITCPNetworkEngine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITCPNetworkEngine@@QAE@XZ PROC			; ITCPNetworkEngine::ITCPNetworkEngine, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ITCPNetworkEngine@@6B@
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ITCPNetworkEngine@@QAE@XZ ENDP			; ITCPNetworkEngine::ITCPNetworkEngine
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IAsynchronismEngineSink@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IAsynchronismEngineSink@@QAE@XZ PROC			; IAsynchronismEngineSink::IAsynchronismEngineSink, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IAsynchronismEngineSink@@6B@
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0IAsynchronismEngineSink@@QAE@XZ ENDP			; IAsynchronismEngineSink::IAsynchronismEngineSink
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IServiceModule@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IServiceModule@@QAE@XZ PROC				; IServiceModule::IServiceModule, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0IServiceModule@@QAE@XZ ENDP				; IServiceModule::IServiceModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 216  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00022	8b 7d cc	 mov	 edi, DWORD PTR _this$[ebp]
  00025	83 c7 18	 add	 edi, 24			; 00000018H
  00028	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0002d	8b f0		 mov	 esi, eax
  0002f	f3 a5		 rep movsd

; 218  : 
; 219  : 		if (is_same_v<_Elem2, wchar_t>)

  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 45		 je	 SHORT $LN2@Getvals

; 220  : 			{
; 221  : 			_Days = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getdays());

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 222  : 			_Months = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getmonths());

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 223  : 			_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 224  : 			}
; 225  : 		else

  0007d	eb 5e		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 226  : 			{
; 227  : 			_Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem *>(nullptr), _Cvt);

  0007f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 18	 add	 eax, 24			; 00000018H
  00085	50		 push	 eax
  00086	6a 00		 push	 0
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 228  : 			_Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem *>(nullptr), _Cvt);

  000a0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	83 c2 18	 add	 edx, 24			; 00000018H
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 229  : 			_Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem *>(nullptr), _Cvt);

  000c1	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	83 c2 18	 add	 edx, 24			; 00000018H
  000c7	52		 push	 edx
  000c8	6a 00		 push	 0
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 230  : 			}
; 231  : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 216  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00022	8b 7d cc	 mov	 edi, DWORD PTR _this$[ebp]
  00025	83 c7 18	 add	 edi, 24			; 00000018H
  00028	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0002d	8b f0		 mov	 esi, eax
  0002f	f3 a5		 rep movsd

; 218  : 
; 219  : 		if (is_same_v<_Elem2, wchar_t>)

  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 45		 je	 SHORT $LN2@Getvals

; 220  : 			{
; 221  : 			_Days = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getdays());

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 222  : 			_Months = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getmonths());

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 223  : 			_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 224  : 			}
; 225  : 		else

  0007d	eb 5e		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 226  : 			{
; 227  : 			_Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem *>(nullptr), _Cvt);

  0007f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 18	 add	 eax, 24			; 00000018H
  00085	50		 push	 eax
  00086	6a 00		 push	 0
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 228  : 			_Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem *>(nullptr), _Cvt);

  000a0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	83 c2 18	 add	 edx, 24			; 00000018H
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 229  : 			_Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem *>(nullptr), _Cvt);

  000c1	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	83 c2 18	 add	 edx, 24			; 00000018H
  000c7	52		 push	 edx
  000c8	6a 00		 push	 0
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 230  : 			}
; 231  : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?InterfaceVersionCompare@@YA_NKK@Z
_TEXT	SEGMENT
_dwVersion$ = -40					; size = 4
_dwVersion$ = -36					; size = 4
_dwVersion$ = -32					; size = 4
_dwVersion$ = -28					; size = 4
_dwVersion$ = -24					; size = 4
_dwVersion$ = -20					; size = 4
_dwVersion$ = -16					; size = 4
_dwVersion$ = -12					; size = 4
$T1 = -8						; size = 1
$T2 = -7						; size = 1
$T3 = -6						; size = 1
$T4 = -5						; size = 1
$T5 = -4						; size = 1
$T6 = -3						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_dwQueryVer$ = 8					; size = 4
_dwInterfaceVer$ = 12					; size = 4
?InterfaceVersionCompare@@YA_NKK@Z PROC			; InterfaceVersionCompare, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 57   : 	return ((BYTE *)&dwVersion)[1];

  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	c1 e1 00	 shl	 ecx, 0
  00014	8a 54 0d f4	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  00018	88 55 ff	 mov	 BYTE PTR $T8[ebp], dl

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _dwInterfaceVer$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 57   : 	return ((BYTE *)&dwVersion)[1];

  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8a 54 0d f0	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  0002d	88 55 fe	 mov	 BYTE PTR $T7[ebp], dl

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  00030	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  00034	0f b6 4d fe	 movzx	 ecx, BYTE PTR $T7[ebp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7e 07		 jle	 SHORT $LN2@InterfaceV
  0003c	32 c0		 xor	 al, al
  0003e	e9 ae 00 00 00	 jmp	 $LN1@InterfaceV
$LN2@InterfaceV:

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  00043	8b 55 08	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  00046	89 55 ec	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 51   : 	return ((BYTE *)&dwVersion)[2];

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	d1 e0		 shl	 eax, 1
  00050	8a 4c 05 ec	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  00054	88 4d fd	 mov	 BYTE PTR $T6[ebp], cl

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  00057	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  0005a	89 55 e8	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 51   : 	return ((BYTE *)&dwVersion)[2];

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	d1 e0		 shl	 eax, 1
  00064	8a 4c 05 e8	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  00068	88 4d fc	 mov	 BYTE PTR $T5[ebp], cl

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  0006b	0f b6 55 fd	 movzx	 edx, BYTE PTR $T6[ebp]
  0006f	0f b6 45 fc	 movzx	 eax, BYTE PTR $T5[ebp]
  00073	3b d0		 cmp	 edx, eax
  00075	74 04		 je	 SHORT $LN3@InterfaceV
  00077	32 c0		 xor	 al, al
  00079	eb 76		 jmp	 SHORT $LN1@InterfaceV
$LN3@InterfaceV:

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _dwQueryVer$[ebp]
  0007e	89 4d e4	 mov	 DWORD PTR _dwVersion$[ebp], ecx

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	6b c2 00	 imul	 eax, edx, 0
  00089	8a 4c 05 e4	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  0008d	88 4d fb	 mov	 BYTE PTR $T4[ebp], cl

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  00090	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  00093	89 55 e0	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	6b c8 00	 imul	 ecx, eax, 0
  0009e	8a 54 0d e0	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  000a2	88 55 fa	 mov	 BYTE PTR $T3[ebp], dl

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  000a5	0f b6 45 fb	 movzx	 eax, BYTE PTR $T4[ebp]
  000a9	0f b6 4d fa	 movzx	 ecx, BYTE PTR $T3[ebp]
  000ad	3b c1		 cmp	 eax, ecx
  000af	74 04		 je	 SHORT $LN4@InterfaceV
  000b1	32 c0		 xor	 al, al
  000b3	eb 3c		 jmp	 SHORT $LN1@InterfaceV
$LN4@InterfaceV:

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000b5	8b 55 08	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  000b8	89 55 dc	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 45   : 	return ((BYTE *)&dwVersion)[3];

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	6b c8 03	 imul	 ecx, eax, 3
  000c3	8a 54 0d dc	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  000c7	88 55 f9	 mov	 BYTE PTR $T2[ebp], dl

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _dwInterfaceVer$[ebp]
  000cd	89 45 d8	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 45   : 	return ((BYTE *)&dwVersion)[3];

  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	6b d1 03	 imul	 edx, ecx, 3
  000d8	8a 44 15 d8	 mov	 al, BYTE PTR _dwVersion$[ebp+edx]
  000dc	88 45 f8	 mov	 BYTE PTR $T1[ebp], al

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000df	0f b6 4d f9	 movzx	 ecx, BYTE PTR $T2[ebp]
  000e3	0f b6 55 f8	 movzx	 edx, BYTE PTR $T1[ebp]
  000e7	3b ca		 cmp	 ecx, edx
  000e9	74 04		 je	 SHORT $LN5@InterfaceV
  000eb	32 c0		 xor	 al, al
  000ed	eb 02		 jmp	 SHORT $LN1@InterfaceV
$LN5@InterfaceV:

; 73   : 	return true;

  000ef	b0 01		 mov	 al, 1
$LN1@InterfaceV:

; 74   : };

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?InterfaceVersionCompare@@YA_NKK@Z ENDP			; InterfaceVersionCompare
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetBuildVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetBuildVer@@YAEK@Z PROC				; GetBuildVer, COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 00	 imul	 ecx, eax, 0
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 64   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBuildVer@@YAEK@Z ENDP				; GetBuildVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetSubVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetSubVer@@YAEK@Z PROC					; GetSubVer, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return ((BYTE *)&dwVersion)[1];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	c1 e0 00	 shl	 eax, 0
  0000b	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 58   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSubVer@@YAEK@Z ENDP					; GetSubVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetMainVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetMainVer@@YAEK@Z PROC				; GetMainVer, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	return ((BYTE *)&dwVersion)[2];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	d1 e0		 shl	 eax, 1
  0000a	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 52   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetMainVer@@YAEK@Z ENDP				; GetMainVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetProductVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetProductVer@@YAEK@Z PROC				; GetProductVer, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 	return ((BYTE *)&dwVersion)[3];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 03	 imul	 ecx, eax, 3
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 46   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetProductVer@@YAEK@Z ENDP				; GetProductVer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IUnknownEx@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknownEx@@QAE@XZ PROC				; IUnknownEx::IUnknownEx, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IUnknownEx@@QAE@XZ ENDP				; IUnknownEx::IUnknownEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv86 = -20						; size = 4
__Count$ = -16						; size = 4
__Ptrdest$ = -12					; size = 4
tv79 = -8						; size = 4
tv89 = -2						; size = 2
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 97   : 	{	// copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 98   : 	const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  0000f	83 c1 02	 add	 ecx, 2
  00012	89 4d ec	 mov	 DWORD PTR tv86[ebp], ecx
$LL6@Maklocwcs:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv79[ebp]
  00018	66 8b 02	 mov	 ax, WORD PTR [edx]
  0001b	66 89 45 fe	 mov	 WORD PTR tv89[ebp], ax
  0001f	83 45 f8 02	 add	 DWORD PTR tv79[ebp], 2
  00023	66 83 7d fe 00	 cmp	 WORD PTR tv89[ebp], 0
  00028	75 eb		 jne	 SHORT $LL6@Maklocwcs
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  0002d	2b 4d ec	 sub	 ecx, DWORD PTR tv86[ebp]
  00030	d1 f9		 sar	 ecx, 1
  00032	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00035	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 f0	 mov	 DWORD PTR __Count$[ebp], edx

; 99   : 
; 100  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),

  0003e	6a 65		 push	 101			; 00000065H
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00045	6a 02		 push	 2
  00047	6a 02		 push	 2
  00049	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	89 45 f4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 101  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 102  : 
; 103  : 	if (!_Ptrdest)

  00059	83 7d f4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  0005d	75 05		 jne	 SHORT $LN2@Maklocwcs

; 104  : 		_Xbad_alloc();

  0005f	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00064	8b 4d f0	 mov	 ecx, DWORD PTR __Count$[ebp]
  00067	d1 e1		 shl	 ecx, 1
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _memcpy
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum

; 106  : 	return (_Ptrdest);

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 107  : 	}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$swap@HX@std@@YAXAAH0@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Tmp$ = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@HX@std@@YAXAAH0@Z PROC				; std::swap<int,void>, COMDAT

; 66   : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 67   : 	_Ty _Tmp = _STD move(_Left);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 55 f4	 mov	 DWORD PTR __Tmp$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 68   : 	_Left = _STD move(_Right);

  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	89 01		 mov	 DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00024	8d 4d f4	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00027	89 4d f0	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 69   : 	_Right = _STD move(_Tmp);

  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	89 0a		 mov	 DWORD PTR [edx], ecx

; 70   : 	}

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$swap@HX@std@@YAXAAH0@Z ENDP				; std::swap<int,void>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z
_TEXT	SEGMENT
___formal$ = -8						; size = 1
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z PROC	; std::_Adl_verify_range<char *,char *>, COMDAT

; 615  : 	{	// check that [_First, _Last) forms an iterator range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0000b	8a 4d ff	 mov	 cl, BYTE PTR $T1[ebp]
  0000e	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl

; 603  : 	_Verify_range(_First, _Last);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  00022	83 c4 08	 add	 esp, 8

; 617  : 	}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Adl_verify_range@PADPAD@std@@YAXABQAD0@Z ENDP	; std::_Adl_verify_range<char *,char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
___formal$ = -8						; size = 1
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 615  : 	{	// check that [_First, _Last) forms an iterator range

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0000b	8a 4d ff	 mov	 cl, BYTE PTR $T1[ebp]
  0000e	88 4d f8	 mov	 BYTE PTR ___formal$[ebp], cl

; 603  : 	_Verify_range(_First, _Last);

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	52		 push	 edx
  0001d	e8 00 00 00 00	 call	 ??$_Verify_range@D@std@@YAXQBD0@Z ; std::_Verify_range<char>
  00022	83 c4 08	 add	 esp, 8

; 617  : 	}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 23   : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@Min_value
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@Min_value
$LN3@Min_value:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@Min_value:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 25   : 	}

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -64						; size = 8
__Mbst1$ = -56						; size = 8
tv69 = -48						; size = 4
tv146 = -44						; size = 4
__Count1$ = -40						; size = 4
__Ptrdest$ = -36					; size = 4
__Ptr1$ = -32						; size = 4
__Ptrnext$ = -28					; size = 4
tv143 = -24						; size = 4
__Count$ = -20						; size = 4
__Bytes$ = -16						; size = 4
__Wchars$ = -12						; size = 4
__Wc$ = -8						; size = 2
tv149 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 682  : 	{	// convert C string to wchar_t sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 683  : 	size_t _Count, _Count1;
; 684  : 	size_t _Wchars;
; 685  : 	const char *_Ptr1;
; 686  : 	int _Bytes;
; 687  : 	wchar_t _Wc;
; 688  : 	mbstate_t _Mbst1 = {};

  00006	33 c0		 xor	 eax, eax
  00008	89 45 c8	 mov	 DWORD PTR __Mbst1$[ebp], eax
  0000b	89 45 cc	 mov	 DWORD PTR __Mbst1$[ebp+4], eax

; 689  : 
; 690  : 	_Count1 = _CSTD strlen(_Ptr) + 1;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	89 4d e8	 mov	 DWORD PTR tv143[ebp], ecx
  00014	8b 55 e8	 mov	 edx, DWORD PTR tv143[ebp]
  00017	83 c2 01	 add	 edx, 1
  0001a	89 55 d4	 mov	 DWORD PTR tv146[ebp], edx
$LL12@Maklocstr:
  0001d	8b 45 e8	 mov	 eax, DWORD PTR tv143[ebp]
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	88 4d ff	 mov	 BYTE PTR tv149[ebp], cl
  00025	83 45 e8 01	 add	 DWORD PTR tv143[ebp], 1
  00029	80 7d ff 00	 cmp	 BYTE PTR tv149[ebp], 0
  0002d	75 ee		 jne	 SHORT $LL12@Maklocstr
  0002f	8b 55 e8	 mov	 edx, DWORD PTR tv143[ebp]
  00032	2b 55 d4	 sub	 edx, DWORD PTR tv146[ebp]
  00035	89 55 d0	 mov	 DWORD PTR tv69[ebp], edx
  00038	8b 45 d0	 mov	 eax, DWORD PTR tv69[ebp]
  0003b	83 c0 01	 add	 eax, 1
  0003e	89 45 d8	 mov	 DWORD PTR __Count1$[ebp], eax

; 691  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00041	8b 4d d8	 mov	 ecx, DWORD PTR __Count1$[ebp]
  00044	89 4d ec	 mov	 DWORD PTR __Count$[ebp], ecx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00051	89 55 e0	 mov	 DWORD PTR __Ptr1$[ebp], edx
  00054	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:

; 692  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR __Bytes$[ebp]
  0005c	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
  0005f	8b 4d e0	 mov	 ecx, DWORD PTR __Ptr1$[ebp]
  00062	03 4d f0	 add	 ecx, DWORD PTR __Bytes$[ebp]
  00065	89 4d e0	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx
$LN4@Maklocstr:

; 691  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00071	83 7d ec 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00075	76 29		 jbe	 SHORT $LN3@Maklocstr

; 693  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)

  00077	8b 45 10	 mov	 eax, DWORD PTR __Cvt$[ebp]
  0007a	50		 push	 eax
  0007b	8d 4d c8	 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 ec	 mov	 edx, DWORD PTR __Count$[ebp]
  00082	52		 push	 edx
  00083	8b 45 e0	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  00086	50		 push	 eax
  00087	8d 4d f8	 lea	 ecx, DWORD PTR __Wc$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 __Mbrtowc
  00090	83 c4 14	 add	 esp, 20			; 00000014H
  00093	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00096	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0009a	7f 02		 jg	 SHORT $LN8@Maklocstr

; 694  : 			break;

  0009c	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 695  : 	++_Wchars;	// count terminating nul

  0009e	eb b6		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:
  000a0	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  000a3	83 c2 01	 add	 edx, 1
  000a6	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx

; 696  : 
; 697  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),

  000a9	68 ba 02 00 00	 push	 698			; 000002baH
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000b3	6a 02		 push	 2
  000b5	6a 02		 push	 2
  000b7	8b 45 f4	 mov	 eax, DWORD PTR __Wchars$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  000c1	83 c4 14	 add	 esp, 20			; 00000014H
  000c4	89 45 dc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 698  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 699  : 
; 700  : 	if (!_Ptrdest)

  000c7	83 7d dc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  000cb	75 05		 jne	 SHORT $LN9@Maklocstr

; 701  : 		_Xbad_alloc();

  000cd	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 702  : 	wchar_t *_Ptrnext = _Ptrdest;

  000d2	8b 4d dc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  000d5	89 4d e4	 mov	 DWORD PTR __Ptrnext$[ebp], ecx

; 703  : 	mbstate_t _Mbst2 = {};

  000d8	33 d2		 xor	 edx, edx
  000da	89 55 c0	 mov	 DWORD PTR __Mbst2$[ebp], edx
  000dd	89 55 c4	 mov	 DWORD PTR __Mbst2$[ebp+4], edx

; 704  : 
; 705  : 	for (; 0 < _Wchars;

  000e0	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:

; 706  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)

  000e2	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  000e5	2b 45 f0	 sub	 eax, DWORD PTR __Bytes$[ebp]
  000e8	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ee	03 4d f0	 add	 ecx, DWORD PTR __Bytes$[ebp]
  000f1	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000f4	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  000f7	83 ea 01	 sub	 edx, 1
  000fa	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx
  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  00100	83 c0 02	 add	 eax, 2
  00103	89 45 e4	 mov	 DWORD PTR __Ptrnext$[ebp], eax
$LN7@Maklocstr:

; 704  : 
; 705  : 	for (; 0 < _Wchars;

  00106	83 7d f4 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0010a	76 29		 jbe	 SHORT $LN6@Maklocstr

; 707  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)

  0010c	8b 4d 10	 mov	 ecx, DWORD PTR __Cvt$[ebp]
  0010f	51		 push	 ecx
  00110	8d 55 c0	 lea	 edx, DWORD PTR __Mbst2$[ebp]
  00113	52		 push	 edx
  00114	8b 45 d8	 mov	 eax, DWORD PTR __Count1$[ebp]
  00117	50		 push	 eax
  00118	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 e4	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 __Mbrtowc
  00125	83 c4 14	 add	 esp, 20			; 00000014H
  00128	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  0012b	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0012f	7f 02		 jg	 SHORT $LN10@Maklocstr

; 708  : 			break;

  00131	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 709  : 	*_Ptrnext = L'\0';

  00133	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:
  00135	33 c0		 xor	 eax, eax
  00137	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  0013a	66 89 01	 mov	 WORD PTR [ecx], ax

; 710  : 
; 711  : 	return (_Ptrdest);

  0013d	8b 45 dc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN11@Maklocstr:

; 712  : 	}

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT
; _this$ = ecx

; 866  : 		{	// return address of deleter object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 867  : 		return (nullptr);

  00007	33 c0		 xor	 eax, eax

; 868  : 		}

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decwref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT
; _this$ = ecx

; 853  : 		{	// decrement weak reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 854  : 		if (_MT_DECR(_Weaks) == 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 0d		 jne	 SHORT $LN1@Decwref

; 855  : 			{
; 856  : 			_Delete_this();

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	ff d2		 call	 edx
$LN1@Decwref:

; 857  : 			}
; 858  : 		}

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?_Decwref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT
; _this$ = ecx

; 844  : 		{	// decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 845  : 		if (_MT_DECR(_Uses) == 0)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 29		 jne	 SHORT $LN1@Decref

; 846  : 			{	// destroy managed resource, decrement weak reference count
; 847  : 			_Destroy();

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	ff d2		 call	 edx

; 854  : 		if (_MT_DECR(_Weaks) == 0)

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	83 c9 ff	 or	 ecx, -1
  0002c	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00030	49		 dec	 ecx
  00031	75 0d		 jne	 SHORT $LN1@Decref

; 855  : 			{
; 856  : 			_Delete_this();

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003e	ff d2		 call	 edx
$LN1@Decref:

; 848  : 			_Decwref();
; 849  : 			}
; 850  : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??1_Ref_count_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Ref_count_base@std@@UAE@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT
; _this$ = ecx

; 801  : 		{	// TRANSITION, should be non-virtual

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Ref_count_base@std@@UAE@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\memory
;	COMDAT ??0_Ref_count_base@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ref_count_base@std@@IAE@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT
; _this$ = ecx

; 796  : 		{	// construct

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 795  : 		: _Uses(1), _Weaks(1)	// non-atomic initializations

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1

; 797  : 		}

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0_Ref_count_base@std@@IAE@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2459 : 		{	// destroy the string

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2460 : 		_Tidy_deallocate();

  0002d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  00035	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1949 : 		_Free_proxy();

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 2461 : 		}

  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0004b	83 e0 01	 and	 eax, 1
  0004e	74 0e		 je	 SHORT $LN2@scalar
  00050	6a 1c		 push	 28			; 0000001cH
  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005b	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4003 : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4004 : 		_Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 4005 : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -56						; size = 4
__Al$2 = -52						; size = 4
__Ptr$3 = -48						; size = 4
__Count$ = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
__Ptr$ = -24						; size = 4
tv152 = -20						; size = 4
__Bytes$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T8 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3984 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  00012	89 4d e0	 mov	 DWORD PTR $T6[ebp], ecx

; 2023 : 		_Get_data()._Orphan_all();

  00015	8b 4d e0	 mov	 ecx, DWORD PTR $T6[ebp]
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0001d	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00020	89 55 dc	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00023	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00029	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002c	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00030	72 09		 jb	 SHORT $LN27@Tidy_deall
  00032	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
  00039	eb 07		 jmp	 SHORT $LN25@Tidy_deall
$LN27@Tidy_deall:
  0003b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv152[ebp], 0
$LN25@Tidy_deall:

; 3985 : 		this->_Orphan_all();
; 3986 : 		auto& _My_data = this->_Get_data();
; 3987 : 		if (_My_data._Large_string_engaged())

  00042	0f b6 55 ec	 movzx	 edx, BYTE PTR tv152[ebp]
  00046	85 d2		 test	 edx, edx
  00048	74 5f		 je	 SHORT $LN2@Tidy_deall

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00050	89 4d d0	 mov	 DWORD PTR __Ptr$3[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

  00053	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00056	89 55 d8	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00059	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	89 45 cc	 mov	 DWORD PTR __Al$2[ebp], eax

; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));

  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00062	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00065	89 4d c8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00068	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0006b	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0006e	83 c0 01	 add	 eax, 1
  00071	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00074	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00077	89 4d f0	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0007a	8b 55 d0	 mov	 edx, DWORD PTR __Ptr$3[ebp]
  0007d	89 55 e8	 mov	 DWORD PTR __Ptr$[ebp], edx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00080	81 7d f0 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00087	72 10		 jb	 SHORT $LN43@Tidy_deall

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  00089	8d 45 f0	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4d e8	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00096	83 c4 08	 add	 esp, 8
$LN43@Tidy_deall:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  00099	8b 55 f0	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0009c	52		 push	 edx
  0009d	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a6	83 c4 08	 add	 esp, 8
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  000a9	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ac	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000b3	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000b6	c7 42 18 0f 00
	00 00		 mov	 DWORD PTR [edx+24], 15	; 0000000fH

; 3997 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3998 : 		// write can alias this
; 3999 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000bd	c6 45 ff 00	 mov	 BYTE PTR $T8[ebp], 0
  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	6b c8 00	 imul	 ecx, eax, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000c9	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000cc	8a 45 ff	 mov	 al, BYTE PTR $T8[ebp]
  000cf	88 44 0a 04	 mov	 BYTE PTR [edx+ecx+4], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 4000 : 		}

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3974 : 		{	// initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __My_data$[ebp], ecx

; 3975 : 		auto& _My_data = this->_Get_data();
; 3976 : 		_My_data._Mysize = 0;

  00015	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00018	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00022	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00029	c6 45 ff 00	 mov	 BYTE PTR $T2[ebp], 0
  0002d	b9 01 00 00 00	 mov	 ecx, 1
  00032	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00035	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	8a 4d ff	 mov	 cl, BYTE PTR $T2[ebp]
  0003b	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3981 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv90 = -12						; size = 4
__My_data$ = -8						; size = 4
$T3 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3968 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __My_data$[ebp], ecx

; 3969 : 		auto& _My_data = this->_Get_data();
; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00015	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00019	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0001f	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  00022	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d f0	 mov	 DWORD PTR __Result$2[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0002b	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002e	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  00032	72 09		 jb	 SHORT $LN14@Eos
  00034	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv90[ebp], 1
  0003b	eb 07		 jmp	 SHORT $LN12@Eos
$LN14@Eos:
  0003d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN12@Eos:

; 1804 : 		if (_Large_string_engaged())

  00044	0f b6 45 f4	 movzx	 eax, BYTE PTR tv90[ebp]
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN9@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0004c	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00052	89 55 f0	 mov	 DWORD PTR __Result$2[ebp], edx
$LN9@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00055	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  00058	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  0005b	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  0005e	88 08		 mov	 BYTE PTR [eax], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3971 : 		}

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
__My_data$ = -32					; size = 4
$T3 = -28						; size = 4
tv70 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__Masked$ = -12						; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3866 : 		{	// determines the next array size to allocate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3867 : 		const size_type _Max = max_size();

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00014	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0001a	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  0001d	89 4d e0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00020	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  00023	83 ca 0f	 or	 edx, 15			; 0000000fH
  00026	89 55 f4	 mov	 DWORD PTR __Masked$[ebp], edx

; 3870 : 		if (_Masked > _Max)

  00029	8b 45 f4	 mov	 eax, DWORD PTR __Masked$[ebp]
  0002c	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002f	76 05		 jbe	 SHORT $LN2@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00034	eb 4f		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

  00036	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003c	89 55 f8	 mov	 DWORD PTR __Old$[ebp], edx

; 3876 : 		if (_Old > _Max - _Old / 2)

  0003f	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00042	d1 e8		 shr	 eax, 1
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  00047	2b c8		 sub	 ecx, eax
  00049	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  0004c	76 05		 jbe	 SHORT $LN3@Calculate_

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00051	eb 32		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00053	8b 55 f8	 mov	 edx, DWORD PTR __Old$[ebp]
  00056	d1 ea		 shr	 edx, 1
  00058	03 55 f8	 add	 edx, DWORD PTR __Old$[ebp]
  0005b	89 55 ec	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  0005e	8b 45 f4	 mov	 eax, DWORD PTR __Masked$[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T4[ebp]
  00064	73 08		 jae	 SHORT $LN38@Calculate_
  00066	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  00069	89 4d e8	 mov	 DWORD PTR tv70[ebp], ecx
  0006c	eb 06		 jmp	 SHORT $LN39@Calculate_
$LN38@Calculate_:
  0006e	8d 55 f4	 lea	 edx, DWORD PTR __Masked$[ebp]
  00071	89 55 e8	 mov	 DWORD PTR tv70[ebp], edx
$LN39@Calculate_:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0007d	89 4d d8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00080	8b 55 d8	 mov	 edx, DWORD PTR $T1[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
$LN1@Calculate_:

; 3882 : 		}

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 3861 : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2038 : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3862 : 		return (static_cast<allocator_type>(this->_Getal()));

  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3863 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 3755 : 		{	// return [_Off, _Off + _Count) as new string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 2038 : 		return (_Mypair._Get_first());

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  00013	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3862 : 		return (static_cast<allocator_type>(this->_Getal()));

  00016	8d 4d ff	 lea	 ecx, DWORD PTR $T4[ebp]
  00019	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx

; 3756 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  0001c	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  0001f	52		 push	 edx
  00020	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	52		 push	 edx
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00034	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00037	83 c8 01	 or	 eax, 1
  0003a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3757 : 		}

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 3370 : 		{	// test if sequence is empty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  00015	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  00018	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 3371 : 		return (size() == 0);

  0001e	83 7d ec 00	 cmp	 DWORD PTR $T1[ebp], 0
  00022	75 09		 jne	 SHORT $LN3@empty
  00024	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@empty:
  00034	8a 45 fc	 mov	 al, BYTE PTR tv67[ebp]

; 3372 : 		}

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv74 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv71 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3306 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2038 : 		return (_Mypair._Get_first());

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  0000f	8b 4d e0	 mov	 ecx, DWORD PTR $T7[ebp]
  00012	89 4d c4	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00015	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR __Alloc_max$[ebp], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));

  0001c	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00023	8b 55 f8	 mov	 edx, DWORD PTR __Alloc_max$[ebp]
  00026	3b 55 fc	 cmp	 edx, DWORD PTR $T10[ebp]
  00029	73 08		 jae	 SHORT $LN14@max_size
  0002b	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00031	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00033	8d 4d f8	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  00036	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
$LN15@max_size:
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  0003c	89 55 dc	 mov	 DWORD PTR $T6[ebp], edx
  0003f	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00042	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));

  00045	8b 4d d8	 mov	 ecx, DWORD PTR $T5[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	89 55 d4	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 3310 : 		return (_Min_value(

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00050	83 e8 01	 sub	 eax, 1
  00053	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits

; 617  : 		return (INT_MAX);

  00056	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3310 : 		return (_Min_value(

  0005d	8b 4d d0	 mov	 ecx, DWORD PTR $T4[ebp]
  00060	89 4d ec	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00063	8b 55 f0	 mov	 edx, DWORD PTR $T9[ebp]
  00066	3b 55 ec	 cmp	 edx, DWORD PTR $T8[ebp]
  00069	73 08		 jae	 SHORT $LN22@max_size
  0006b	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  0006e	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  00071	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  00073	8d 4d ec	 lea	 ecx, DWORD PTR $T8[ebp]
  00076	89 4d e8	 mov	 DWORD PTR tv74[ebp], ecx
$LN23@max_size:
  00079	8b 55 e8	 mov	 edx, DWORD PTR tv74[ebp]
  0007c	89 55 cc	 mov	 DWORD PTR $T3[ebp], edx
  0007f	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00082	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3310 : 		return (_Min_value(

  00085	8b 4d c8	 mov	 ecx, DWORD PTR $T2[ebp]
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3301 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T1[ebp]
  00018	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 3303 : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 3296 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 3297 : 		return (this->_Get_data()._Mysize);

  00015	8b 55 f4	 mov	 edx, DWORD PTR $T1[ebp]
  00018	8b 42 14	 mov	 eax, DWORD PTR [edx+20]

; 3298 : 		}

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
__Result$2 = -12					; size = 4
tv86 = -8						; size = 4
$T3 = -4						; size = 4
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 3284 : 		{	// return pointer to immutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00015	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00018	83 c2 04	 add	 edx, 4
  0001b	89 55 f4	 mov	 DWORD PTR __Result$2[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00021	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00025	72 09		 jb	 SHORT $LN14@data
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  0002e	eb 07		 jmp	 SHORT $LN12@data
$LN14@data:
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN12@data:

; 1815 : 		if (_Large_string_engaged())

  00037	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv86[ebp]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 09		 je	 SHORT $LN9@data
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0003f	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	89 45 f4	 mov	 DWORD PTR __Result$2[ebp], eax
$LN9@data:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3285 : 		return (this->_Get_data()._Myptr());

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Result$2[ebp]

; 3286 : 		}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
_this$ = -16						; size = 4
__Result$2 = -12					; size = 4
tv86 = -8						; size = 4
$T3 = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3279 : 		{	// return pointer to null-terminated immutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00015	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00018	83 c2 04	 add	 edx, 4
  0001b	89 55 f4	 mov	 DWORD PTR __Result$2[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00021	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00025	72 09		 jb	 SHORT $LN14@c_str
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  0002e	eb 07		 jmp	 SHORT $LN12@c_str
$LN14@c_str:
  00030	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN12@c_str:

; 1815 : 		if (_Large_string_engaged())

  00037	0f b6 4d f8	 movzx	 ecx, BYTE PTR tv86[ebp]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 09		 je	 SHORT $LN9@c_str
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0003f	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00042	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00045	89 45 f4	 mov	 DWORD PTR __Result$2[ebp], eax
$LN9@c_str:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3280 : 		return (this->_Get_data()._Myptr());

  00048	8b 45 f4	 mov	 eax, DWORD PTR __Result$2[ebp]

; 3281 : 		}

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parg$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Result$3 = -12					; size = 4
tv130 = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 3091 : 		{	// return iterator for end of immutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00015	8b 55 e8	 mov	 edx, DWORD PTR $T1[ebp]
  00018	89 55 fc	 mov	 DWORD PTR __My_data$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 f4	 mov	 DWORD PTR __Result$3[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00024	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00027	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  0002b	72 09		 jb	 SHORT $LN17@end
  0002d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00034	eb 07		 jmp	 SHORT $LN15@end
$LN17@end:
  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN15@end:

; 1815 : 		if (_Large_string_engaged())

  0003d	0f b6 55 f8	 movzx	 edx, BYTE PTR tv130[ebp]
  00041	85 d2		 test	 edx, edx
  00043	74 09		 je	 SHORT $LN21@end
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00045	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	89 4d f4	 mov	 DWORD PTR __Result$3[ebp], ecx
$LN21@end:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3093 : 		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr())

  0004e	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00051	8b 45 f4	 mov	 eax, DWORD PTR __Result$3[ebp]
  00054	03 42 14	 add	 eax, DWORD PTR [edx+20]
  00057	89 45 e4	 mov	 DWORD PTR __Parg$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00063	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00066	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1416 : 		: _Ptr(_Parg)

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	8b 4d e4	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00073	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1417 : 		{	// construct with pointer _Parg
; 1418 : 		this->_Adopt(_Pstring);

  00076	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00079	52		 push	 edx
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 3093 : 		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr())

  00082	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3094 : 			+ static_cast<difference_type>(_My_data->_Mysize), _My_data));
; 3095 : 		}

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__Result$3 = -12					; size = 4
tv128 = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 3078 : 		{	// return iterator for beginning of immutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00015	8b 55 e8	 mov	 edx, DWORD PTR $T1[ebp]
  00018	89 55 fc	 mov	 DWORD PTR __My_data$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 f4	 mov	 DWORD PTR __Result$3[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00024	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00027	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  0002b	72 09		 jb	 SHORT $LN17@begin
  0002d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  00034	eb 07		 jmp	 SHORT $LN15@begin
$LN17@begin:
  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv128[ebp], 0
$LN15@begin:

; 1815 : 		if (_Large_string_engaged())

  0003d	0f b6 55 f8	 movzx	 edx, BYTE PTR tv128[ebp]
  00041	85 d2		 test	 edx, edx
  00043	74 09		 je	 SHORT $LN21@begin
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00045	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004b	89 4d f4	 mov	 DWORD PTR __Result$3[ebp], ecx
$LN21@begin:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  0004e	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00051	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00057	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1416 : 		: _Ptr(_Parg)

  00061	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00064	8b 55 f4	 mov	 edx, DWORD PTR __Result$3[ebp]
  00067	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1417 : 		{	// construct with pointer _Parg
; 1418 : 		this->_Adopt(_Pstring);

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 3079 : 		auto _My_data = _STD addressof(this->_Get_data());
; 3080 : 		return (const_iterator(_Refancy<const_pointer>(_My_data->_Myptr()), _My_data));

  00076	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3081 : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 2870 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2871 : 		_Eos(0);

  00026	6a 00		 push	 0
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 2872 : 		}

  00030	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00033	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003a	59		 pop	 ecx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T1 = -20						; size = 4
tv74 = -16						; size = 4
tv93 = -12						; size = 4
tv91 = -8						; size = 4
tv95 = -1						; size = 1
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2675 : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 464  : 		return (_CSTD strlen(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv91[ebp], eax
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR tv91[ebp]
  00012	83 c1 01	 add	 ecx, 1
  00015	89 4d f4	 mov	 DWORD PTR tv93[ebp], ecx
$LL152@assign:
  00018	8b 55 f8	 mov	 edx, DWORD PTR tv91[ebp]
  0001b	8a 02		 mov	 al, BYTE PTR [edx]
  0001d	88 45 ff	 mov	 BYTE PTR tv95[ebp], al
  00020	83 45 f8 01	 add	 DWORD PTR tv91[ebp], 1
  00024	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  00028	75 ee		 jne	 SHORT $LL152@assign
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR tv91[ebp]
  0002d	2b 4d f4	 sub	 ecx, DWORD PTR tv93[ebp]
  00030	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  00036	89 55 ec	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00039	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00040	51		 push	 ecx
  00041	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2677 : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Old_ptr$2 = -24					; size = 4
__Result$3 = -20					; size = 4
tv135 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2657 : 		{	// assign [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __My_data$[ebp], ecx

; 2658 : 		auto& _My_data = this->_Get_data();
; 2659 : 		if (_Count <= _My_data._Myres)

  00015	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0001e	77 6a		 ja	 SHORT $LN2@assign

; 1803 : 		value_type * _Result = _Bx._Buf;

  00020	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	89 4d ec	 mov	 DWORD PTR __Result$3[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00029	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002c	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  00030	72 09		 jb	 SHORT $LN15@assign
  00032	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
  00039	eb 07		 jmp	 SHORT $LN13@assign
$LN15@assign:
  0003b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv135[ebp], 0
$LN13@assign:

; 1804 : 		if (_Large_string_engaged())

  00042	0f b6 45 f0	 movzx	 eax, BYTE PTR tv135[ebp]
  00046	85 c0		 test	 eax, eax
  00048	74 09		 je	 SHORT $LN10@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00050	89 55 ec	 mov	 DWORD PTR __Result$3[ebp], edx
$LN10@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2661 : 			_Elem * const _Old_ptr = _My_data._Myptr();

  00053	8b 45 ec	 mov	 eax, DWORD PTR __Result$3[ebp]
  00056	89 45 e8	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2662 : 			_My_data._Mysize = _Count;

  00059	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0005c	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0005f	89 51 14	 mov	 DWORD PTR [ecx+20], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00062	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 e8	 mov	 edx, DWORD PTR __Old_ptr$2[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _memmove
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2664 : 			_Traits::assign(_Old_ptr[_Count], _Elem());

  00076	c6 45 ff 00	 mov	 BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0007a	8b 45 e8	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0007d	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00080	8a 4d ff	 mov	 cl, BYTE PTR $T5[ebp]
  00083	88 08		 mov	 BYTE PTR [eax], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2665 : 			return (*this);

  00085	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00088	eb 1a		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 2666 : 			}
; 2667 : 
; 2668 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0008a	33 d2		 xor	 edx, edx
  0008c	88 55 fe	 mov	 BYTE PTR $T4[ebp], dl
  0008f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00092	50		 push	 eax
  00093	0f b6 4d fe	 movzx	 ecx, BYTE PTR $T4[ebp]
  00097	51		 push	 ecx
  00098	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0009b	52		 push	 edx
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 2669 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2670 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2671 : 			}, _Ptr));
; 2672 : 		}

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
__Result$4 = -24					; size = 4
tv129 = -20						; size = 4
tv90 = -16						; size = 4
__Size$ = -12						; size = 4
$T5 = -8						; size = 4
__Right_data$ = -4					; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2631 : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00012	89 4d fc	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 1830 : 		if (_Mysize < _Off)

  00015	8b 55 fc	 mov	 edx, DWORD PTR __Right_data$[ebp]
  00018	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001b	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  0001e	73 05		 jae	 SHORT $LN11@assign

; 1831 : 			{
; 1832 : 			_Xran();

  00020	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN11@assign:

; 2632 : 		auto& _Right_data = _Right._Get_data();
; 2633 : 		_Right_data._Check_offset(_Roff);
; 2634 : 		_Count = _Right_data._Clamp_suffix_size(_Roff, _Count);

  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00028	89 4d f4	 mov	 DWORD PTR __Size$[ebp], ecx

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

  0002b	8b 55 fc	 mov	 edx, DWORD PTR __Right_data$[ebp]
  0002e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00031	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00034	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00037	8b 4d f8	 mov	 ecx, DWORD PTR $T5[ebp]
  0003a	3b 4d f4	 cmp	 ecx, DWORD PTR __Size$[ebp]
  0003d	73 08		 jae	 SHORT $LN18@assign
  0003f	8d 55 f8	 lea	 edx, DWORD PTR $T5[ebp]
  00042	89 55 f0	 mov	 DWORD PTR tv90[ebp], edx
  00045	eb 06		 jmp	 SHORT $LN19@assign
$LN18@assign:
  00047	8d 45 f4	 lea	 eax, DWORD PTR __Size$[ebp]
  0004a	89 45 f0	 mov	 DWORD PTR tv90[ebp], eax
$LN19@assign:
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR tv90[ebp]
  00050	89 4d e0	 mov	 DWORD PTR $T2[ebp], ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR $T2[ebp]
  00056	89 55 dc	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

  00059	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	89 4d 10	 mov	 DWORD PTR __Count$[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00061	8b 55 fc	 mov	 edx, DWORD PTR __Right_data$[ebp]
  00064	83 c2 04	 add	 edx, 4
  00067	89 55 e8	 mov	 DWORD PTR __Result$4[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0006d	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00071	72 09		 jb	 SHORT $LN26@assign
  00073	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  0007a	eb 07		 jmp	 SHORT $LN24@assign
$LN26@assign:
  0007c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN24@assign:

; 1815 : 		if (_Large_string_engaged())

  00083	0f b6 4d ec	 movzx	 ecx, BYTE PTR tv129[ebp]
  00087	85 c9		 test	 ecx, ecx
  00089	74 09		 je	 SHORT $LN21@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0008b	8b 55 fc	 mov	 edx, DWORD PTR __Right_data$[ebp]
  0008e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00091	89 45 e8	 mov	 DWORD PTR __Result$4[ebp], eax
$LN21@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2635 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00094	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 e8	 mov	 edx, DWORD PTR __Result$4[ebp]
  0009b	03 55 0c	 add	 edx, DWORD PTR __Roff$[ebp]
  0009e	52		 push	 edx
  0009f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN12@assign:

; 2636 : 		}

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Result$7 = -20					; size = 4
tv245 = -16						; size = 4
__Right_data$8 = -12					; size = 4
_this$ = -8						; size = 4
__Reload$9 = -1						; size = 1
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2466 : 		{	// assign _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2467 : 		if (this != _STD addressof(_Right))

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	3b 4d e8	 cmp	 ecx, DWORD PTR $T6[ebp]
  00015	0f 84 92 00 00
	00		 je	 $LN2@operator

; 2468 : 			{	// different, assign it
; 2469 : #pragma warning(push)
; 2470 : #pragma warning(disable: 4127)	// conditional expression is constant
; 2471 : 			if (_Alty_traits::propagate_on_container_copy_assignment::value
; 2472 : 				&& this->_Getal() != _Right._Getal())

  0001b	33 d2		 xor	 edx, edx
  0001d	74 08		 je	 SHORT $LN3@operator

; 2473 : 				{	// change allocator before copying
; 2474 : 				_Tidy_deallocate();

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN3@operator:

; 2038 : 		return (_Mypair._Get_first());

  00027	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0002a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  0002d	8b 4d e4	 mov	 ecx, DWORD PTR $T5[ebp]
  00030	89 4d d8	 mov	 DWORD PTR $T2[ebp], ecx

; 1955 : 			&& _Getal() != _Al;

  00033	c6 45 ff 00	 mov	 BYTE PTR __Reload$9[ebp], 0

; 1956 : 
; 1957 : 		if (_Reload)

  00037	33 d2		 xor	 edx, edx
  00039	74 08		 je	 SHORT $LN55@operator

; 1958 : 			{
; 1959 : 			_Free_proxy();

  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
$LN55@operator:

; 2033 : 		return (_Mypair._Get_first());

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00046	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00049	8b 4d e0	 mov	 ecx, DWORD PTR $T4[ebp]
  0004c	89 4d d4	 mov	 DWORD PTR $T1[ebp], ecx

; 1964 : 		if (_Reload)

  0004f	33 d2		 xor	 edx, edx
  00051	74 08		 je	 SHORT $LN54@operator

; 1965 : 			{
; 1966 : 			_Alloc_proxy();

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
$LN54@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0005e	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  00061	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00064	89 4d f4	 mov	 DWORD PTR __Right_data$8[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00067	8b 55 f4	 mov	 edx, DWORD PTR __Right_data$8[ebp]
  0006a	83 c2 04	 add	 edx, 4
  0006d	89 55 ec	 mov	 DWORD PTR __Result$7[ebp], edx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00070	8b 45 f4	 mov	 eax, DWORD PTR __Right_data$8[ebp]
  00073	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00077	72 09		 jb	 SHORT $LN207@operator
  00079	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv245[ebp], 1
  00080	eb 07		 jmp	 SHORT $LN205@operator
$LN207@operator:
  00082	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv245[ebp], 0
$LN205@operator:

; 1815 : 		if (_Large_string_engaged())

  00089	0f b6 4d f0	 movzx	 ecx, BYTE PTR tv245[ebp]
  0008d	85 c9		 test	 ecx, ecx
  0008f	74 09		 je	 SHORT $LN202@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00091	8b 55 f4	 mov	 edx, DWORD PTR __Right_data$8[ebp]
  00094	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00097	89 45 ec	 mov	 DWORD PTR __Result$7[ebp], eax
$LN202@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2481 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR __Right_data$8[ebp]
  0009d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000a0	52		 push	 edx
  000a1	8b 45 ec	 mov	 eax, DWORD PTR __Result$7[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@operator:

; 2482 : 			}
; 2483 : 
; 2484 : 		return (*this);

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 2485 : 		}

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2459 : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2460 : 		_Tidy_deallocate();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1948 : 		{	// destroy the object

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1949 : 		_Free_proxy();

  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 1950 : 		}

  0003d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 2461 : 		}

  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -96						; size = 4
__First1$ = -92						; size = 4
$T1 = -88						; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -60						; size = 4
__New_capacity$ = -56					; size = 4
__Right_ptr$ = -52					; size = 4
__New_array$ = -48					; size = 4
tv178 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
__Result$11 = -32					; size = 4
tv167 = -28						; size = 4
$T12 = -24						; size = 4
_this$ = -20						; size = 4
__Count$ = -16						; size = 4
__Right_data$ = -12					; size = 4
__Right_size$ = -8					; size = 4
__My_data$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2394 : 		{	// assign by copying data stored in _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 c4	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d c4	 mov	 ecx, DWORD PTR $T8[ebp]
  00012	89 4d fc	 mov	 DWORD PTR __My_data$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00015	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00018	89 55 c0	 mov	 DWORD PTR $T7[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0001b	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2395 : 			// pre: this != &_Right
; 2396 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2397 : 		auto& _My_data = this->_Get_data();
; 2398 : 		auto& _Right_data = _Right._Get_data();
; 2399 : 		const size_type _Right_size = _Right_data._Mysize;

  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	89 55 f8	 mov	 DWORD PTR __Right_size$[ebp], edx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0002a	8b 45 f4	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	89 45 e0	 mov	 DWORD PTR __Result$11[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00033	8b 4d f4	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00036	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  0003a	72 09		 jb	 SHORT $LN21@Construct_
  0003c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00043	eb 07		 jmp	 SHORT $LN19@Construct_
$LN21@Construct_:
  00045	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv167[ebp], 0
$LN19@Construct_:

; 1815 : 		if (_Large_string_engaged())

  0004c	0f b6 55 e4	 movzx	 edx, BYTE PTR tv167[ebp]
  00050	85 d2		 test	 edx, edx
  00052	74 09		 je	 SHORT $LN16@Construct_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00057	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005a	89 4d e0	 mov	 DWORD PTR __Result$11[ebp], ecx
$LN16@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2400 : 		const _Elem * const _Right_ptr = _Right_data._Myptr();

  0005d	8b 55 e0	 mov	 edx, DWORD PTR __Result$11[ebp]
  00060	89 55 cc	 mov	 DWORD PTR __Right_ptr$[ebp], edx

; 2401 : 		if (_Right_size < this->_BUF_SIZE)

  00063	83 7d f8 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  00067	73 37		 jae	 SHORT $LN2@Construct_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00069	8b 45 cc	 mov	 eax, DWORD PTR __Right_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2403 : 			_Traits::copy(_My_data._Bx._Buf, _Right_ptr, this->_BUF_SIZE);

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	83 c1 04	 add	 ecx, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00072	8b 10		 mov	 edx, DWORD PTR [eax]
  00074	89 11		 mov	 DWORD PTR [ecx], edx
  00076	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00079	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0007c	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00082	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00085	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2404 : 			_My_data._Mysize = _Right_size;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0008b	8b 55 f8	 mov	 edx, DWORD PTR __Right_size$[ebp]
  0008e	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 2405 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00094	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 2406 : 			return;

  0009b	e9 df 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 2033 : 		return (_Mypair._Get_first());

  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  000a3	89 4d bc	 mov	 DWORD PTR $T6[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  000a6	8b 55 bc	 mov	 edx, DWORD PTR $T6[ebp]
  000a9	89 55 a0	 mov	 DWORD PTR __Al$[ebp], edx

; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  000ac	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000b4	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  000b7	8b 45 f8	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000ba	83 c8 0f	 or	 eax, 15			; 0000000fH
  000bd	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  000c0	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  000c3	3b 4d d8	 cmp	 ecx, DWORD PTR $T9[ebp]
  000c6	73 08		 jae	 SHORT $LN61@Construct_
  000c8	8d 55 dc	 lea	 edx, DWORD PTR $T10[ebp]
  000cb	89 55 d4	 mov	 DWORD PTR tv178[ebp], edx
  000ce	eb 06		 jmp	 SHORT $LN62@Construct_
$LN61@Construct_:
  000d0	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  000d3	89 45 d4	 mov	 DWORD PTR tv178[ebp], eax
$LN62@Construct_:
  000d6	8b 4d d4	 mov	 ecx, DWORD PTR tv178[ebp]
  000d9	89 4d b8	 mov	 DWORD PTR $T5[ebp], ecx
  000dc	8b 55 b8	 mov	 edx, DWORD PTR $T5[ebp]
  000df	89 55 b4	 mov	 DWORD PTR $T4[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2410 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  000e2	8b 45 b4	 mov	 eax, DWORD PTR $T4[ebp]
  000e5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e7	89 4d c8	 mov	 DWORD PTR __New_capacity$[ebp], ecx

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  000ea	8b 55 c8	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  000ed	83 c2 01	 add	 edx, 1
  000f0	89 55 f0	 mov	 DWORD PTR __Count$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  000f3	81 7d f0 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  000fa	72 11		 jb	 SHORT $LN69@Construct_

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  000fc	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00105	83 c4 04	 add	 esp, 4
  00108	89 45 e8	 mov	 DWORD PTR $T12[ebp], eax
  0010b	eb 1e		 jmp	 SHORT $LN64@Construct_
$LN69@Construct_:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  0010d	83 7d f0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00111	74 11		 je	 SHORT $LN70@Construct_

; 52   : 		return (::operator new(_Bytes));

  00113	8b 4d f0	 mov	 ecx, DWORD PTR __Count$[ebp]
  00116	51		 push	 ecx
  00117	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0011c	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  0011f	89 45 e8	 mov	 DWORD PTR $T12[ebp], eax
  00122	eb 07		 jmp	 SHORT $LN64@Construct_
$LN70@Construct_:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00124	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], 0
$LN64@Construct_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2411 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  0012b	8b 55 e8	 mov	 edx, DWORD PTR $T12[ebp]
  0012e	89 55 d0	 mov	 DWORD PTR __New_array$[ebp], edx

; 2412 : 		_Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_array);

  00131	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00134	83 c0 04	 add	 eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00137	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  0013a	8b 4d b0	 mov	 ecx, DWORD PTR $T3[ebp]
  0013d	89 4d ac	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00140	8d 55 d0	 lea	 edx, DWORD PTR __New_array$[ebp]
  00143	89 55 a8	 mov	 DWORD PTR $T1[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00146	8b 45 ac	 mov	 eax, DWORD PTR $T2[ebp]
  00149	8b 4d a8	 mov	 ecx, DWORD PTR $T1[ebp]
  0014c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014e	89 10		 mov	 DWORD PTR [eax], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2413 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00150	8b 45 d0	 mov	 eax, DWORD PTR __New_array$[ebp]
  00153	89 45 a4	 mov	 DWORD PTR __First1$[ebp], eax
  00156	8b 4d f8	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  00159	83 c1 01	 add	 ecx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0015c	51		 push	 ecx
  0015d	8b 55 cc	 mov	 edx, DWORD PTR __Right_ptr$[ebp]
  00160	52		 push	 edx
  00161	8b 45 a4	 mov	 eax, DWORD PTR __First1$[ebp]
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2414 : 		_My_data._Mysize = _Right_size;

  0016d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00170	8b 55 f8	 mov	 edx, DWORD PTR __Right_size$[ebp]
  00173	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 2415 : 		_My_data._Myres = _New_capacity;

  00176	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00179	8b 4d c8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0017c	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN1@Construct_:

; 2416 : 		}

  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
__My_data_mem$ = -72					; size = 4
__Right_data_mem$ = -68					; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
$T11 = -28						; size = 4
$T12 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
tv140 = -12						; size = 4
__My_data$13 = -8					; size = 4
$T14 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2344 : 		{	// assign by stealing _Right's buffer, memcpy optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T12[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d e8	 mov	 ecx, DWORD PTR $T12[ebp]
  00012	89 4d ec	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00015	8b 55 ec	 mov	 edx, DWORD PTR __Right_data$[ebp]
  00018	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN13@Assign_rv_
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
  00025	eb 07		 jmp	 SHORT $LN11@Assign_rv_
$LN13@Assign_rv_:
  00027	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv140[ebp], 0
$LN11@Assign_rv_:

; 2345 : 			// pre: this != &_Right
; 2346 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2347 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2348 : 		auto& _Right_data = _Right._Get_data();
; 2349 : 
; 2350 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2351 : 		if (_Right_data._Large_string_engaged())

  0002e	0f b6 45 f4	 movzx	 eax, BYTE PTR tv140[ebp]
  00032	85 c0		 test	 eax, eax
  00034	74 26		 je	 SHORT $LN2@Assign_rv_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	89 4d e4	 mov	 DWORD PTR $T11[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0003c	8b 55 e4	 mov	 edx, DWORD PTR $T11[ebp]
  0003f	89 55 dc	 mov	 DWORD PTR $T9[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00045	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00048	8b 4d e0	 mov	 ecx, DWORD PTR $T10[ebp]
  0004b	89 4d d8	 mov	 DWORD PTR $T8[ebp], ecx

; 2028 : 		_Get_data()._Swap_all(_Right._Get_data());

  0004e	8b 55 dc	 mov	 edx, DWORD PTR $T9[ebp]
  00051	52		 push	 edx
  00052	8b 4d d8	 mov	 ecx, DWORD PTR $T8[ebp]
  00055	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all

; 2352 : 			{	// take ownership of _Right's iterators along with its buffer
; 2353 : 			this->_Swap_all(_Right);
; 2354 : 			}
; 2355 : 		else

  0005a	eb 14		 jmp	 SHORT $LN3@Assign_rv_
$LN2@Assign_rv_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0005f	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00062	8b 4d d4	 mov	 ecx, DWORD PTR $T7[ebp]
  00065	89 4d d0	 mov	 DWORD PTR $T6[ebp], ecx

; 2023 : 		_Get_data()._Orphan_all();

  00068	8b 4d d0	 mov	 ecx, DWORD PTR $T6[ebp]
  0006b	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Assign_rv_:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00070	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00073	89 55 cc	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00076	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  00079	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0007c	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp]
  0007f	89 4d c4	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2362 : 			+ _Memcpy_move_offset;

  00082	8b 55 c4	 mov	 edx, DWORD PTR $T3[ebp]
  00085	83 c2 04	 add	 edx, 4
  00088	89 55 b8	 mov	 DWORD PTR __My_data_mem$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0008b	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  0008e	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2364 : 			+ _Memcpy_move_offset;

  00091	8b 4d c0	 mov	 ecx, DWORD PTR $T2[ebp]
  00094	83 c1 04	 add	 ecx, 4
  00097	89 4d bc	 mov	 DWORD PTR __Right_data_mem$[ebp], ecx

; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0009a	8b 55 bc	 mov	 edx, DWORD PTR __Right_data_mem$[ebp]
  0009d	8b 45 b8	 mov	 eax, DWORD PTR __My_data_mem$[ebp]
  000a0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
  000a4	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000a7	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000aa	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  000ad	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000b0	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  000b3	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000b6	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  000b9	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000bc	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  000bf	89 50 14	 mov	 DWORD PTR [eax+20], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  000c2	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  000c5	89 45 b4	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  000c8	8b 4d b4	 mov	 ecx, DWORD PTR $T1[ebp]
  000cb	89 4d f8	 mov	 DWORD PTR __My_data$13[ebp], ecx

; 3976 : 		_My_data._Mysize = 0;

  000ce	8b 55 f8	 mov	 edx, DWORD PTR __My_data$13[ebp]
  000d1	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000d8	8b 45 f8	 mov	 eax, DWORD PTR __My_data$13[ebp]
  000db	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000e2	c6 45 ff 00	 mov	 BYTE PTR $T14[ebp], 0
  000e6	b9 01 00 00 00	 mov	 ecx, 1
  000eb	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000ee	8b 45 f8	 mov	 eax, DWORD PTR __My_data$13[ebp]
  000f1	8a 4d ff	 mov	 cl, BYTE PTR $T14[ebp]
  000f4	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2367 : 		}

  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT
; _this$ = ecx

; 2321 : 		{	// assign either as an rvalue or as an lvalue copy, allocators always equal optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2325 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2325 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00014	0f b6 55 ff	 movzx	 edx, BYTE PTR $T2[ebp]
  00018	52		 push	 edx
  00019	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2326 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
_this$ = -24						; size = 4
___formal$ = -20					; size = 1
$T7 = -14						; size = 1
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2301 : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2302 : 		if (this != _STD addressof(_Right))

  0002e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	3b 4d e4	 cmp	 ecx, DWORD PTR $T6[ebp]
  00034	74 4d		 je	 SHORT $LN2@operator

; 2303 : 			{	// different, assign it
; 2304 : 			_Tidy_deallocate();

  00036	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2033 : 		return (_Mypair._Get_first());

  0003e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00041	89 55 e0	 mov	 DWORD PTR $T5[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00047	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 2305 : 			this->_Move_alloc(_Right._Getal());

  0004a	8b 4d dc	 mov	 ecx, DWORD PTR $T4[ebp]
  0004d	51		 push	 ecx
  0004e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc

; 2308 : 			_Assign_rv_contents(_STD move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});

  00056	33 d2		 xor	 edx, edx
  00058	88 55 f3	 mov	 BYTE PTR $T8[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0005e	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2308 : 			_Assign_rv_contents(_STD move(_Right), bool_constant<_Always_equal_after_move<_Alty>>{});

  00061	8a 4d f3	 mov	 cl, BYTE PTR $T8[ebp]
  00064	88 4d ec	 mov	 BYTE PTR ___formal$[ebp], cl

; 2325 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00067	33 d2		 xor	 edx, edx
  00069	88 55 f2	 mov	 BYTE PTR $T7[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  0006c	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2325 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00072	0f b6 4d f2	 movzx	 ecx, BYTE PTR $T7[ebp]
  00076	51		 push	 ecx
  00077	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  0007a	52		 push	 edx
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
$LN2@operator:

; 2309 : 			}
; 2310 : 
; 2311 : 		return (*this);

  00083	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]

; 2312 : 		}

  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
_this$ = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
_this$7 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2268 : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  0002e	8b 4d e4	 mov	 ecx, DWORD PTR $T6[ebp]
  00031	89 4d e0	 mov	 DWORD PTR $T5[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00034	8b 55 e0	 mov	 edx, DWORD PTR $T5[ebp]
  00037	89 55 dc	 mov	 DWORD PTR $T4[ebp], edx

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0003a	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  00040	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00046	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00049	89 55 e8	 mov	 DWORD PTR _this$7[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  0004c	8b 45 e8	 mov	 eax, DWORD PTR _this$7[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00055	8b 4d e8	 mov	 ecx, DWORD PTR _this$7[ebp]
  00058	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0005f	8b 55 e8	 mov	 edx, DWORD PTR _this$7[ebp]
  00062	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1944 : 		_Alloc_proxy();

  00069	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00071	33 c0		 xor	 eax, eax
  00073	88 45 f3	 mov	 BYTE PTR $T8[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00079	89 4d d4	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  0007c	0f b6 55 f3	 movzx	 edx, BYTE PTR $T8[ebp]
  00080	52		 push	 edx
  00081	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00084	50		 push	 eax
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2270 : 		}

  0008d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
tv173 = -40						; size = 4
tv236 = -36						; size = 4
$T3 = -32						; size = 4
__My_data$4 = -28					; size = 4
_this$ = -24						; size = 4
tv234 = -20						; size = 4
tv228 = -14						; size = 1
$T5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2183 : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2044 : 		}
; 2045 : 
; 2046 : 	const _Mydata_t& _Get_data() const noexcept
; 2047 : 		{	// return const reference to _String_val
; 2048 : 		return (_Mypair._Get_second());
; 2049 : 		}
; 2050 : 
; 2051 : private:
; 2052 : 	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
; 2053 : 	};
; 2054 : 
; 2055 : 
; 2056 : 		// CLASS TEMPLATE basic_string
; 2057 : template<class _Ty>
; 2058 : 	constexpr size_t _Size_after_ebco_v
; 2059 : 		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd
; 2060 : 
; 2061 : template<class _Elem,
; 2062 : 	class _Traits = char_traits<_Elem>,
; 2063 : 	class _Alloc = allocator<_Elem>>
; 2064 : 	class basic_string
; 2065 : 		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
; 2066 : 	{	// null-terminated transparent array of elements
; 2067 : public:
; 2068 : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2069 : 		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2070 : 
; 2071 : 	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2072 : 		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2073 : 		"char_traits character type match the string's character type.");
; 2074 : 
; 2075 : 	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
; 2076 : 	using traits_type = _Traits;
; 2077 : 	using allocator_type = _Alloc;
; 2078 : 
; 2079 : 	using _Alty = typename _Mybase::_Alty;
; 2080 : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 2081 : 	using _Mydata_t = typename _Mybase::_Mydata_t;
; 2082 : 
; 2083 : 	using value_type = typename _Mybase::value_type;
; 2084 : 	using size_type = typename _Mybase::size_type;
; 2085 : 	using difference_type = typename _Mybase::difference_type;
; 2086 : 	using pointer = typename _Mybase::pointer;
; 2087 : 	using const_pointer = typename _Mybase::const_pointer;
; 2088 : 	using reference = value_type&;
; 2089 : 	using const_reference = const value_type&;
; 2090 : 
; 2091 : 	using iterator = typename _Mybase::iterator;
; 2092 : 	using const_iterator = typename _Mybase::const_iterator;
; 2093 : 
; 2094 : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 2095 : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2096 : 
; 2097 : 	// When doing swap / move by memcpy, we are touching:
; 2098 : 	//   _String_val::_Bx::_Buf (type is array of _Elem)
; 2099 : 	//   _String_val::_Bx::_Ptr (type is pointer)
; 2100 : 	//   _String_val::_Mysize   (type is size_type)
; 2101 : 	//   _String_val::_Myres    (type is size_type)
; 2102 : 	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
; 2103 : 	// We need to ask if pointer is safe to memcpy.
; 2104 : 	// size_type must be an unsigned integral type so memcpy is safe.
; 2105 : 	// We also need to disable memcpy if the user has supplied _Traits, since
; 2106 : 	//   they can observe traits::assign and similar.
; 2107 : 	using _Use_memcpy_move = bool_constant<
; 2108 : 		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
; 2109 : 	// This offset skips over the _Container_base members, if any
; 2110 : 	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
; 2111 : 	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;
; 2112 : 
; 2113 : 	template<class _Iter>
; 2114 : 		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
; 2115 : 			const _Elem * const,
; 2116 : 			_Elem * const,
; 2117 : 			const _Elem *,
; 2118 : 			_Elem *>>;
; 2119 : 
; 2120 : #if _HAS_CXX17
; 2121 : 	template<class _StringViewIsh>
; 2122 : 		using _Is_string_view_ish = enable_if_t<conjunction_v<
; 2123 : 			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2124 : 			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
; 2125 : #endif /* _HAS_CXX17 */
; 2126 : 
; 2127 : 
; 2128 : 	basic_string(const basic_string& _Right)
; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
; 2130 : 		{	// construct by copying _Right
; 2131 : 		_Construct_lv_contents(_Right);
; 2132 : 		}
; 2133 : 
; 2134 : 	basic_string(const basic_string& _Right, const _Alloc& _Al)
; 2135 : 		: _Mybase(_Al)
; 2136 : 		{	// construct by copying with allocator
; 2137 : 		_Construct_lv_contents(_Right);
; 2138 : 		}
; 2139 : 
; 2140 : 	basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
; 2141 : 		: _Mybase()
; 2142 : 		{	// construct empty string
; 2143 : 		_Tidy_init();
; 2144 : 		}
; 2145 : 
; 2146 : 	explicit basic_string(const _Alloc& _Al) noexcept
; 2147 : 		: _Mybase(_Al)
; 2148 : 		{	// construct empty string with allocator
; 2149 : 		_Tidy_init();
; 2150 : 		}
; 2151 : 
; 2152 : 	basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2153 : 		: _Mybase(_Al)
; 2154 : 		{	// construct from _Right [_Roff, <end>)
; 2155 : 		_Tidy_init();
; 2156 : 		assign(_Right, _Roff, npos);
; 2157 : 		}
; 2158 : 
; 2159 : 	basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2160 : 		: _Mybase(_Al)
; 2161 : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 2162 : 		_Tidy_init();
; 2163 : 		assign(_Right, _Roff, _Count);
; 2164 : 		}
; 2165 : 
; 2166 : 	basic_string(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2167 : 		: _Mybase()
; 2168 : 		{	// construct from [_Ptr, _Ptr + _Count)
; 2169 : 		_Tidy_init();
; 2170 : 		assign(_Ptr, _Count);
; 2171 : 		}
; 2172 : 
; 2173 : 	basic_string(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count,
; 2174 : 		const _Alloc& _Al)
; 2175 : 		: _Mybase(_Al)
; 2176 : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 2177 : 		_Tidy_init();
; 2178 : 		assign(_Ptr, _Count);
; 2179 : 		}
; 2180 : 
; 2181 : 	basic_string(_In_z_ const _Elem * const _Ptr)
; 2182 : 		: _Mybase()

  00028	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00037	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0003d	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  00040	89 4d e4	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 3976 : 		_My_data._Mysize = 0;

  00043	8b 55 e4	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00046	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004d	8b 45 e4	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00050	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00057	c6 45 f3 00	 mov	 BYTE PTR $T5[ebp], 0
  0005b	b9 01 00 00 00	 mov	 ecx, 1
  00060	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00063	8b 45 e4	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00066	8a 4d f3	 mov	 cl, BYTE PTR $T5[ebp]
  00069	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl

; 464  : 		return (_CSTD strlen(_First));

  0006d	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00070	89 55 ec	 mov	 DWORD PTR tv234[ebp], edx
  00073	8b 45 ec	 mov	 eax, DWORD PTR tv234[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 dc	 mov	 DWORD PTR tv236[ebp], eax
$LL233@basic_stri:
  0007c	8b 4d ec	 mov	 ecx, DWORD PTR tv234[ebp]
  0007f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00081	88 55 f2	 mov	 BYTE PTR tv228[ebp], dl
  00084	83 45 ec 01	 add	 DWORD PTR tv234[ebp], 1
  00088	80 7d f2 00	 cmp	 BYTE PTR tv228[ebp], 0
  0008c	75 ee		 jne	 SHORT $LL233@basic_stri
  0008e	8b 45 ec	 mov	 eax, DWORD PTR tv234[ebp]
  00091	2b 45 dc	 sub	 eax, DWORD PTR tv236[ebp]
  00094	89 45 d8	 mov	 DWORD PTR tv173[ebp], eax
  00097	8b 4d d8	 mov	 ecx, DWORD PTR tv173[ebp]
  0009a	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2676 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0009d	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a4	50		 push	 eax
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2184 : 		_Tidy_init();
; 2185 : 		assign(_Ptr);
; 2186 : 		}

  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b4	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ba	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c1	59		 pop	 ecx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
$T2 = -28						; size = 4
__My_data$3 = -24					; size = 4
_this$ = -20						; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2168 : 		{	// construct from [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2044 : 		}
; 2045 : 
; 2046 : 	const _Mydata_t& _Get_data() const noexcept
; 2047 : 		{	// return const reference to _String_val
; 2048 : 		return (_Mypair._Get_second());
; 2049 : 		}
; 2050 : 
; 2051 : private:
; 2052 : 	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
; 2053 : 	};
; 2054 : 
; 2055 : 
; 2056 : 		// CLASS TEMPLATE basic_string
; 2057 : template<class _Ty>
; 2058 : 	constexpr size_t _Size_after_ebco_v
; 2059 : 		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd
; 2060 : 
; 2061 : template<class _Elem,
; 2062 : 	class _Traits = char_traits<_Elem>,
; 2063 : 	class _Alloc = allocator<_Elem>>
; 2064 : 	class basic_string
; 2065 : 		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
; 2066 : 	{	// null-terminated transparent array of elements
; 2067 : public:
; 2068 : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2069 : 		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2070 : 
; 2071 : 	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2072 : 		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2073 : 		"char_traits character type match the string's character type.");
; 2074 : 
; 2075 : 	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
; 2076 : 	using traits_type = _Traits;
; 2077 : 	using allocator_type = _Alloc;
; 2078 : 
; 2079 : 	using _Alty = typename _Mybase::_Alty;
; 2080 : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 2081 : 	using _Mydata_t = typename _Mybase::_Mydata_t;
; 2082 : 
; 2083 : 	using value_type = typename _Mybase::value_type;
; 2084 : 	using size_type = typename _Mybase::size_type;
; 2085 : 	using difference_type = typename _Mybase::difference_type;
; 2086 : 	using pointer = typename _Mybase::pointer;
; 2087 : 	using const_pointer = typename _Mybase::const_pointer;
; 2088 : 	using reference = value_type&;
; 2089 : 	using const_reference = const value_type&;
; 2090 : 
; 2091 : 	using iterator = typename _Mybase::iterator;
; 2092 : 	using const_iterator = typename _Mybase::const_iterator;
; 2093 : 
; 2094 : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 2095 : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2096 : 
; 2097 : 	// When doing swap / move by memcpy, we are touching:
; 2098 : 	//   _String_val::_Bx::_Buf (type is array of _Elem)
; 2099 : 	//   _String_val::_Bx::_Ptr (type is pointer)
; 2100 : 	//   _String_val::_Mysize   (type is size_type)
; 2101 : 	//   _String_val::_Myres    (type is size_type)
; 2102 : 	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
; 2103 : 	// We need to ask if pointer is safe to memcpy.
; 2104 : 	// size_type must be an unsigned integral type so memcpy is safe.
; 2105 : 	// We also need to disable memcpy if the user has supplied _Traits, since
; 2106 : 	//   they can observe traits::assign and similar.
; 2107 : 	using _Use_memcpy_move = bool_constant<
; 2108 : 		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
; 2109 : 	// This offset skips over the _Container_base members, if any
; 2110 : 	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
; 2111 : 	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;
; 2112 : 
; 2113 : 	template<class _Iter>
; 2114 : 		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
; 2115 : 			const _Elem * const,
; 2116 : 			_Elem * const,
; 2117 : 			const _Elem *,
; 2118 : 			_Elem *>>;
; 2119 : 
; 2120 : #if _HAS_CXX17
; 2121 : 	template<class _StringViewIsh>
; 2122 : 		using _Is_string_view_ish = enable_if_t<conjunction_v<
; 2123 : 			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2124 : 			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
; 2125 : #endif /* _HAS_CXX17 */
; 2126 : 
; 2127 : 
; 2128 : 	basic_string(const basic_string& _Right)
; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
; 2130 : 		{	// construct by copying _Right
; 2131 : 		_Construct_lv_contents(_Right);
; 2132 : 		}
; 2133 : 
; 2134 : 	basic_string(const basic_string& _Right, const _Alloc& _Al)
; 2135 : 		: _Mybase(_Al)
; 2136 : 		{	// construct by copying with allocator
; 2137 : 		_Construct_lv_contents(_Right);
; 2138 : 		}
; 2139 : 
; 2140 : 	basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
; 2141 : 		: _Mybase()
; 2142 : 		{	// construct empty string
; 2143 : 		_Tidy_init();
; 2144 : 		}
; 2145 : 
; 2146 : 	explicit basic_string(const _Alloc& _Al) noexcept
; 2147 : 		: _Mybase(_Al)
; 2148 : 		{	// construct empty string with allocator
; 2149 : 		_Tidy_init();
; 2150 : 		}
; 2151 : 
; 2152 : 	basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2153 : 		: _Mybase(_Al)
; 2154 : 		{	// construct from _Right [_Roff, <end>)
; 2155 : 		_Tidy_init();
; 2156 : 		assign(_Right, _Roff, npos);
; 2157 : 		}
; 2158 : 
; 2159 : 	basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2160 : 		: _Mybase(_Al)
; 2161 : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 2162 : 		_Tidy_init();
; 2163 : 		assign(_Right, _Roff, _Count);
; 2164 : 		}
; 2165 : 
; 2166 : 	basic_string(_In_reads_(_Count) const _Elem * const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2167 : 		: _Mybase()

  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00037	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0003d	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00040	89 4d e8	 mov	 DWORD PTR __My_data$3[ebp], ecx

; 3976 : 		_My_data._Mysize = 0;

  00043	8b 55 e8	 mov	 edx, DWORD PTR __My_data$3[ebp]
  00046	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __My_data$3[ebp]
  00050	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00057	c6 45 f3 00	 mov	 BYTE PTR $T4[ebp], 0
  0005b	b9 01 00 00 00	 mov	 ecx, 1
  00060	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00063	8b 45 e8	 mov	 eax, DWORD PTR __My_data$3[ebp]
  00066	8a 4d f3	 mov	 cl, BYTE PTR $T4[ebp]
  00069	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2170 : 		assign(_Ptr, _Count);

  0006d	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00074	50		 push	 eax
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2171 : 		}

  0007d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00084	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00091	59		 pop	 ecx
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 4
_this$ = -32						; size = 4
__My_data$4 = -28					; size = 4
_this$5 = -24						; size = 4
_this$ = -20						; size = 4
$T6 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2161 : 		{	// construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00028	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0002b	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00034	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00037	89 55 e8	 mov	 DWORD PTR _this$5[ebp], edx

; 80   : 		: _Myproxy(nullptr)

  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$5[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00043	8b 4d e8	 mov	 ecx, DWORD PTR _this$5[ebp]
  00046	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0004d	8b 55 e8	 mov	 edx, DWORD PTR _this$5[ebp]
  00050	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1942 : 			_STD forward<_Any_alloc>(_Al))
; 1943 : 		{	// construct allocator from _Al
; 1944 : 		_Alloc_proxy();

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 2044 : 		}
; 2045 : 
; 2046 : 	const _Mydata_t& _Get_data() const noexcept
; 2047 : 		{	// return const reference to _String_val
; 2048 : 		return (_Mypair._Get_second());
; 2049 : 		}
; 2050 : 
; 2051 : private:
; 2052 : 	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
; 2053 : 	};
; 2054 : 
; 2055 : 
; 2056 : 		// CLASS TEMPLATE basic_string
; 2057 : template<class _Ty>
; 2058 : 	constexpr size_t _Size_after_ebco_v
; 2059 : 		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd
; 2060 : 
; 2061 : template<class _Elem,
; 2062 : 	class _Traits = char_traits<_Elem>,
; 2063 : 	class _Alloc = allocator<_Elem>>
; 2064 : 	class basic_string
; 2065 : 		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
; 2066 : 	{	// null-terminated transparent array of elements
; 2067 : public:
; 2068 : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2069 : 		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2070 : 
; 2071 : 	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2072 : 		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2073 : 		"char_traits character type match the string's character type.");
; 2074 : 
; 2075 : 	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
; 2076 : 	using traits_type = _Traits;
; 2077 : 	using allocator_type = _Alloc;
; 2078 : 
; 2079 : 	using _Alty = typename _Mybase::_Alty;
; 2080 : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 2081 : 	using _Mydata_t = typename _Mybase::_Mydata_t;
; 2082 : 
; 2083 : 	using value_type = typename _Mybase::value_type;
; 2084 : 	using size_type = typename _Mybase::size_type;
; 2085 : 	using difference_type = typename _Mybase::difference_type;
; 2086 : 	using pointer = typename _Mybase::pointer;
; 2087 : 	using const_pointer = typename _Mybase::const_pointer;
; 2088 : 	using reference = value_type&;
; 2089 : 	using const_reference = const value_type&;
; 2090 : 
; 2091 : 	using iterator = typename _Mybase::iterator;
; 2092 : 	using const_iterator = typename _Mybase::const_iterator;
; 2093 : 
; 2094 : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 2095 : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2096 : 
; 2097 : 	// When doing swap / move by memcpy, we are touching:
; 2098 : 	//   _String_val::_Bx::_Buf (type is array of _Elem)
; 2099 : 	//   _String_val::_Bx::_Ptr (type is pointer)
; 2100 : 	//   _String_val::_Mysize   (type is size_type)
; 2101 : 	//   _String_val::_Myres    (type is size_type)
; 2102 : 	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
; 2103 : 	// We need to ask if pointer is safe to memcpy.
; 2104 : 	// size_type must be an unsigned integral type so memcpy is safe.
; 2105 : 	// We also need to disable memcpy if the user has supplied _Traits, since
; 2106 : 	//   they can observe traits::assign and similar.
; 2107 : 	using _Use_memcpy_move = bool_constant<
; 2108 : 		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
; 2109 : 	// This offset skips over the _Container_base members, if any
; 2110 : 	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
; 2111 : 	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;
; 2112 : 
; 2113 : 	template<class _Iter>
; 2114 : 		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
; 2115 : 			const _Elem * const,
; 2116 : 			_Elem * const,
; 2117 : 			const _Elem *,
; 2118 : 			_Elem *>>;
; 2119 : 
; 2120 : #if _HAS_CXX17
; 2121 : 	template<class _StringViewIsh>
; 2122 : 		using _Is_string_view_ish = enable_if_t<conjunction_v<
; 2123 : 			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2124 : 			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
; 2125 : #endif /* _HAS_CXX17 */
; 2126 : 
; 2127 : 
; 2128 : 	basic_string(const basic_string& _Right)
; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
; 2130 : 		{	// construct by copying _Right
; 2131 : 		_Construct_lv_contents(_Right);
; 2132 : 		}
; 2133 : 
; 2134 : 	basic_string(const basic_string& _Right, const _Alloc& _Al)
; 2135 : 		: _Mybase(_Al)
; 2136 : 		{	// construct by copying with allocator
; 2137 : 		_Construct_lv_contents(_Right);
; 2138 : 		}
; 2139 : 
; 2140 : 	basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
; 2141 : 		: _Mybase()
; 2142 : 		{	// construct empty string
; 2143 : 		_Tidy_init();
; 2144 : 		}
; 2145 : 
; 2146 : 	explicit basic_string(const _Alloc& _Al) noexcept
; 2147 : 		: _Mybase(_Al)
; 2148 : 		{	// construct empty string with allocator
; 2149 : 		_Tidy_init();
; 2150 : 		}
; 2151 : 
; 2152 : 	basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2153 : 		: _Mybase(_Al)
; 2154 : 		{	// construct from _Right [_Roff, <end>)
; 2155 : 		_Tidy_init();
; 2156 : 		assign(_Right, _Roff, npos);
; 2157 : 		}
; 2158 : 
; 2159 : 	basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2160 : 		: _Mybase(_Al)

  00066	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00073	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00076	89 4d e4	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 3976 : 		_My_data._Mysize = 0;

  00079	8b 55 e4	 mov	 edx, DWORD PTR __My_data$4[ebp]
  0007c	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00083	8b 45 e4	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00086	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0008d	c6 45 f3 00	 mov	 BYTE PTR $T6[ebp], 0
  00091	b9 01 00 00 00	 mov	 ecx, 1
  00096	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00099	8b 45 e4	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0009c	8a 4d f3	 mov	 cl, BYTE PTR $T6[ebp]
  0009f	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2163 : 		assign(_Right, _Roff, _Count);

  000a3	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  000a6	52		 push	 edx
  000a7	8b 45 0c	 mov	 eax, DWORD PTR __Roff$[ebp]
  000aa	50		 push	 eax
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000ae	51		 push	 ecx
  000af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2164 : 		}

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cb	59		 pop	 ecx
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$1:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
_this$ = -24						; size = 4
__My_data$3 = -20					; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2142 : 		{	// construct empty string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2044 : 		}
; 2045 : 
; 2046 : 	const _Mydata_t& _Get_data() const noexcept
; 2047 : 		{	// return const reference to _String_val
; 2048 : 		return (_Mypair._Get_second());
; 2049 : 		}
; 2050 : 
; 2051 : private:
; 2052 : 	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
; 2053 : 	};
; 2054 : 
; 2055 : 
; 2056 : 		// CLASS TEMPLATE basic_string
; 2057 : template<class _Ty>
; 2058 : 	constexpr size_t _Size_after_ebco_v
; 2059 : 		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd
; 2060 : 
; 2061 : template<class _Elem,
; 2062 : 	class _Traits = char_traits<_Elem>,
; 2063 : 	class _Alloc = allocator<_Elem>>
; 2064 : 	class basic_string
; 2065 : 		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
; 2066 : 	{	// null-terminated transparent array of elements
; 2067 : public:
; 2068 : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2069 : 		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2070 : 
; 2071 : 	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2072 : 		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2073 : 		"char_traits character type match the string's character type.");
; 2074 : 
; 2075 : 	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
; 2076 : 	using traits_type = _Traits;
; 2077 : 	using allocator_type = _Alloc;
; 2078 : 
; 2079 : 	using _Alty = typename _Mybase::_Alty;
; 2080 : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 2081 : 	using _Mydata_t = typename _Mybase::_Mydata_t;
; 2082 : 
; 2083 : 	using value_type = typename _Mybase::value_type;
; 2084 : 	using size_type = typename _Mybase::size_type;
; 2085 : 	using difference_type = typename _Mybase::difference_type;
; 2086 : 	using pointer = typename _Mybase::pointer;
; 2087 : 	using const_pointer = typename _Mybase::const_pointer;
; 2088 : 	using reference = value_type&;
; 2089 : 	using const_reference = const value_type&;
; 2090 : 
; 2091 : 	using iterator = typename _Mybase::iterator;
; 2092 : 	using const_iterator = typename _Mybase::const_iterator;
; 2093 : 
; 2094 : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 2095 : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2096 : 
; 2097 : 	// When doing swap / move by memcpy, we are touching:
; 2098 : 	//   _String_val::_Bx::_Buf (type is array of _Elem)
; 2099 : 	//   _String_val::_Bx::_Ptr (type is pointer)
; 2100 : 	//   _String_val::_Mysize   (type is size_type)
; 2101 : 	//   _String_val::_Myres    (type is size_type)
; 2102 : 	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
; 2103 : 	// We need to ask if pointer is safe to memcpy.
; 2104 : 	// size_type must be an unsigned integral type so memcpy is safe.
; 2105 : 	// We also need to disable memcpy if the user has supplied _Traits, since
; 2106 : 	//   they can observe traits::assign and similar.
; 2107 : 	using _Use_memcpy_move = bool_constant<
; 2108 : 		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
; 2109 : 	// This offset skips over the _Container_base members, if any
; 2110 : 	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
; 2111 : 	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;
; 2112 : 
; 2113 : 	template<class _Iter>
; 2114 : 		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
; 2115 : 			const _Elem * const,
; 2116 : 			_Elem * const,
; 2117 : 			const _Elem *,
; 2118 : 			_Elem *>>;
; 2119 : 
; 2120 : #if _HAS_CXX17
; 2121 : 	template<class _StringViewIsh>
; 2122 : 		using _Is_string_view_ish = enable_if_t<conjunction_v<
; 2123 : 			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2124 : 			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
; 2125 : #endif /* _HAS_CXX17 */
; 2126 : 
; 2127 : 
; 2128 : 	basic_string(const basic_string& _Right)
; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))
; 2130 : 		{	// construct by copying _Right
; 2131 : 		_Construct_lv_contents(_Right);
; 2132 : 		}
; 2133 : 
; 2134 : 	basic_string(const basic_string& _Right, const _Alloc& _Al)
; 2135 : 		: _Mybase(_Al)
; 2136 : 		{	// construct by copying with allocator
; 2137 : 		_Construct_lv_contents(_Right);
; 2138 : 		}
; 2139 : 
; 2140 : 	basic_string() _NOEXCEPT_COND(is_nothrow_default_constructible_v<_Alty>)
; 2141 : 		: _Mybase()

  00028	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00030	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00036	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00039	89 4d ec	 mov	 DWORD PTR __My_data$3[ebp], ecx

; 3976 : 		_My_data._Mysize = 0;

  0003c	8b 55 ec	 mov	 edx, DWORD PTR __My_data$3[ebp]
  0003f	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00046	8b 45 ec	 mov	 eax, DWORD PTR __My_data$3[ebp]
  00049	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3978 : 		// the _Traits::assign is last so the codegen doesn't think the char
; 3979 : 		// write can alias this
; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00050	c6 45 f3 00	 mov	 BYTE PTR $T4[ebp], 0
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	6b d1 00	 imul	 edx, ecx, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0005c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$3[ebp]
  0005f	8a 4d f3	 mov	 cl, BYTE PTR $T4[ebp]
  00062	88 4c 10 04	 mov	 BYTE PTR [eax+edx+4], cl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2144 : 		}

  00066	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
$T3 = -36						; size = 4
_this$ = -32						; size = 4
$T4 = -28						; size = 4
_this$5 = -24						; size = 4
_this$ = -20						; size = 4
$T6 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2130 : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2038 : 		return (_Mypair._Get_first());

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0002b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  0002e	8b 4d e4	 mov	 ecx, DWORD PTR $T4[ebp]
  00031	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00034	8d 55 f3	 lea	 edx, DWORD PTR $T6[ebp]
  00037	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 286  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

  00040	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	89 4d e8	 mov	 DWORD PTR _this$5[ebp], ecx

; 80   : 		: _Myproxy(nullptr)

  00046	8b 55 e8	 mov	 edx, DWORD PTR _this$5[ebp]
  00049	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0004f	8b 45 e8	 mov	 eax, DWORD PTR _this$5[ebp]
  00052	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1785 : 		_Myres(0)

  00059	8b 4d e8	 mov	 ecx, DWORD PTR _this$5[ebp]
  0005c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 1941 : 		: _Mypair(_One_then_variadic_args_t(),

  00063	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1942 : 			_STD forward<_Any_alloc>(_Al))
; 1943 : 		{	// construct allocator from _Al
; 1944 : 		_Alloc_proxy();

  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 2039 : 		}
; 2040 : 
; 2041 : 	_Mydata_t& _Get_data() noexcept
; 2042 : 		{	// return reference to _String_val
; 2043 : 		return (_Mypair._Get_second());
; 2044 : 		}
; 2045 : 
; 2046 : 	const _Mydata_t& _Get_data() const noexcept
; 2047 : 		{	// return const reference to _String_val
; 2048 : 		return (_Mypair._Get_second());
; 2049 : 		}
; 2050 : 
; 2051 : private:
; 2052 : 	_Compressed_pair<_Alty, _Mydata_t> _Mypair;
; 2053 : 	};
; 2054 : 
; 2055 : 
; 2056 : 		// CLASS TEMPLATE basic_string
; 2057 : template<class _Ty>
; 2058 : 	constexpr size_t _Size_after_ebco_v
; 2059 : 		= is_empty_v<_Ty> ? 0 : sizeof(_Ty);	// get _Ty's size after being EBCO'd
; 2060 : 
; 2061 : template<class _Elem,
; 2062 : 	class _Traits = char_traits<_Elem>,
; 2063 : 	class _Alloc = allocator<_Elem>>
; 2064 : 	class basic_string
; 2065 : 		: public _String_alloc<_String_base_types<_Elem, _Alloc>>
; 2066 : 	{	// null-terminated transparent array of elements
; 2067 : public:
; 2068 : 	static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2069 : 		_MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2070 : 
; 2071 : 	static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2072 : 		"N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2073 : 		"char_traits character type match the string's character type.");
; 2074 : 
; 2075 : 	using _Mybase = _String_alloc<_String_base_types<_Elem, _Alloc>>;
; 2076 : 	using traits_type = _Traits;
; 2077 : 	using allocator_type = _Alloc;
; 2078 : 
; 2079 : 	using _Alty = typename _Mybase::_Alty;
; 2080 : 	using _Alty_traits = typename _Mybase::_Alty_traits;
; 2081 : 	using _Mydata_t = typename _Mybase::_Mydata_t;
; 2082 : 
; 2083 : 	using value_type = typename _Mybase::value_type;
; 2084 : 	using size_type = typename _Mybase::size_type;
; 2085 : 	using difference_type = typename _Mybase::difference_type;
; 2086 : 	using pointer = typename _Mybase::pointer;
; 2087 : 	using const_pointer = typename _Mybase::const_pointer;
; 2088 : 	using reference = value_type&;
; 2089 : 	using const_reference = const value_type&;
; 2090 : 
; 2091 : 	using iterator = typename _Mybase::iterator;
; 2092 : 	using const_iterator = typename _Mybase::const_iterator;
; 2093 : 
; 2094 : 	using reverse_iterator = _STD reverse_iterator<iterator>;
; 2095 : 	using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2096 : 
; 2097 : 	// When doing swap / move by memcpy, we are touching:
; 2098 : 	//   _String_val::_Bx::_Buf (type is array of _Elem)
; 2099 : 	//   _String_val::_Bx::_Ptr (type is pointer)
; 2100 : 	//   _String_val::_Mysize   (type is size_type)
; 2101 : 	//   _String_val::_Myres    (type is size_type)
; 2102 : 	// N4659 24.1 [strings.general]/1 says _Elem must be a non-array POD, so memcpy is safe.
; 2103 : 	// We need to ask if pointer is safe to memcpy.
; 2104 : 	// size_type must be an unsigned integral type so memcpy is safe.
; 2105 : 	// We also need to disable memcpy if the user has supplied _Traits, since
; 2106 : 	//   they can observe traits::assign and similar.
; 2107 : 	using _Use_memcpy_move = bool_constant<
; 2108 : 		_Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>>;
; 2109 : 	// This offset skips over the _Container_base members, if any
; 2110 : 	static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v<_Container_base>;
; 2111 : 	static constexpr size_t _Memcpy_move_size = sizeof(_Mydata_t) - _Memcpy_move_offset;
; 2112 : 
; 2113 : 	template<class _Iter>
; 2114 : 		using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter,
; 2115 : 			const _Elem * const,
; 2116 : 			_Elem * const,
; 2117 : 			const _Elem *,
; 2118 : 			_Elem *>>;
; 2119 : 
; 2120 : #if _HAS_CXX17
; 2121 : 	template<class _StringViewIsh>
; 2122 : 		using _Is_string_view_ish = enable_if_t<conjunction_v<
; 2123 : 			is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2124 : 			negation<is_convertible<const _StringViewIsh&, const _Elem *>>>>;
; 2125 : #endif /* _HAS_CXX17 */
; 2126 : 
; 2127 : 
; 2128 : 	basic_string(const basic_string& _Right)
; 2129 : 		: _Mybase(_Alty_traits::select_on_container_copy_construction(_Right._Getal()))

  00072	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 2131 : 		_Construct_lv_contents(_Right);

  00079	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0007c	52		 push	 edx
  0007d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2132 : 		}

  00085	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$3:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 303  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 296  : 		{	// return const reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 297  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 298  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 291  : 		{	// return reference to first

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  : 		return (*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 293  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2047 : 		{	// return const reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 307  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2048 : 		return (_Mypair._Get_second());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 2049 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2042 : 		{	// return reference to _String_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 2044 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2037 : 		{	// return const reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2038 : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 297  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2038 : 		return (_Mypair._Get_first());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 2039 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2032 : 		{	// return reference to allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 2034 : 		}

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all, COMDAT
; _this$ = ecx

; 2027 : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  00012	89 4d f0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00015	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 55 f4	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2028 : 		_Get_data()._Swap_all(_Right._Get_data());

  00021	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00024	51		 push	 ecx
  00025	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  00028	e8 00 00 00 00	 call	 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all

; 2029 : 		}

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 2022 : 		{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 2023 : 		_Get_data()._Orphan_all();

  00015	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00018	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2024 : 		}

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 2011 : 		{	// return reference to _Myproxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00012	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx

; 2012 : 		return (_Get_data()._Myproxy);

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 2013 : 		}

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
$T9 = -32						; size = 4
$T10 = -28						; size = 4
$T11 = -24						; size = 4
$T12 = -20						; size = 4
$T13 = -16						; size = 4
__Ptr$14 = -12						; size = 4
__Bytes$15 = -8						; size = 4
_this$ = -4						; size = 4
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 1997 : 		{	// destroy proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f0	 mov	 DWORD PTR $T13[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR $T13[ebp]
  00012	89 4d c0	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	89 55 ec	 mov	 DWORD PTR $T12[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T12[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T11[ebp], eax

; 2023 : 		_Get_data()._Orphan_all();

  00021	8b 4d e8	 mov	 ecx, DWORD PTR $T11[ebp]
  00024	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	89 4d e4	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  0002f	8b 55 e4	 mov	 edx, DWORD PTR $T10[ebp]
  00032	89 55 e0	 mov	 DWORD PTR $T9[ebp], edx

; 2012 : 		return (_Get_data()._Myproxy);

  00035	8b 45 e0	 mov	 eax, DWORD PTR $T9[ebp]
  00038	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 4d dc	 mov	 DWORD PTR $T8[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00041	8b 55 dc	 mov	 edx, DWORD PTR $T8[ebp]
  00044	89 55 d8	 mov	 DWORD PTR $T7[ebp], edx

; 2012 : 		return (_Get_data()._Myproxy);

  00047	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  0004a	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax

; 1998 : 		_Alproxy _Proxy_allocator(_Getal());
; 1999 : 		_Orphan_all();
; 2000 : 		_Alproxy_traits::destroy(_Proxy_allocator, _Myproxy());
; 2001 : 		_Deallocate_plain(_Proxy_allocator, _Myproxy());

  0004d	8b 4d d4	 mov	 ecx, DWORD PTR $T6[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	89 55 d0	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00055	b8 01 00 00 00	 mov	 eax, 1
  0005a	c1 e0 03	 shl	 eax, 3
  0005d	89 45 f8	 mov	 DWORD PTR __Bytes$15[ebp], eax
  00060	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00063	89 4d f4	 mov	 DWORD PTR __Ptr$14[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00066	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR __Bytes$15[ebp], 4096 ; 00001000H
  0006d	72 10		 jb	 SHORT $LN52@Free_proxy

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0006f	8d 55 f8	 lea	 edx, DWORD PTR __Bytes$15[ebp]
  00072	52		 push	 edx
  00073	8d 45 f4	 lea	 eax, DWORD PTR __Ptr$14[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0007c	83 c4 08	 add	 esp, 8
$LN52@Free_proxy:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0007f	8b 4d f8	 mov	 ecx, DWORD PTR __Bytes$15[ebp]
  00082	51		 push	 ecx
  00083	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$14[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008c	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00092	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00095	8b 4d cc	 mov	 ecx, DWORD PTR $T5[ebp]
  00098	89 4d c8	 mov	 DWORD PTR $T4[ebp], ecx

; 2012 : 		return (_Get_data()._Myproxy);

  0009b	8b 55 c8	 mov	 edx, DWORD PTR $T4[ebp]
  0009e	89 55 c4	 mov	 DWORD PTR $T3[ebp], edx

; 2002 : 		_Myproxy() = nullptr;

  000a1	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2003 : 		}

  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -88						; size = 8
$T2 = -80						; size = 4
$T3 = -76						; size = 4
$T4 = -72						; size = 4
$T5 = -68						; size = 4
$T6 = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
$T9 = -52						; size = 4
$T10 = -48						; size = 4
__Ptr$ = -44						; size = 4
$T11 = -40						; size = 4
$T12 = -36						; size = 4
$T13 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T14 = -24						; size = 4
$T15 = -20						; size = 4
$T16 = -16						; size = 4
$T17 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1989 : 		{	// construct proxy

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2033 : 		return (_Mypair._Get_first());

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0000c	89 45 f4	 mov	 DWORD PTR $T17[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T17[ebp]
  00012	89 4d b0	 mov	 DWORD PTR $T2[ebp], ecx

; 1990 : 		_Alproxy _Proxy_allocator(_Getal());
; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00015	6a 01		 push	 1
  00017	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy_allocator$[ebp]
  0001a	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0001f	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00022	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00025	89 55 f0	 mov	 DWORD PTR $T16[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00028	8b 45 f0	 mov	 eax, DWORD PTR $T16[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR $T15[ebp], eax

; 2012 : 		return (_Get_data()._Myproxy);

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR $T15[ebp]
  00031	89 4d e8	 mov	 DWORD PTR $T14[ebp], ecx

; 1990 : 		_Alproxy _Proxy_allocator(_Getal());
; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00034	8b 55 e8	 mov	 edx, DWORD PTR $T14[ebp]
  00037	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	89 02		 mov	 DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  0003c	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00043	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T1[ebp+4], 0

; 302  : 		return (_Myval2);

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 4d e0	 mov	 DWORD PTR $T13[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00050	8b 55 e0	 mov	 edx, DWORD PTR $T13[ebp]
  00053	89 55 dc	 mov	 DWORD PTR $T12[ebp], edx

; 2012 : 		return (_Get_data()._Myproxy);

  00056	8b 45 dc	 mov	 eax, DWORD PTR $T12[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T11[ebp], eax

; 1992 : 		_Alproxy_traits::construct(_Proxy_allocator, _Myproxy(), _Container_proxy());

  0005c	8b 4d d8	 mov	 ecx, DWORD PTR $T11[ebp]
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	89 55 d4	 mov	 DWORD PTR __Ptr$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00064	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00067	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  0006a	8d 4d a8	 lea	 ecx, DWORD PTR $T1[ebp]
  0006d	89 4d d0	 mov	 DWORD PTR $T10[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00070	8b 55 d0	 mov	 edx, DWORD PTR $T10[ebp]
  00073	8b 02		 mov	 eax, DWORD PTR [edx]
  00075	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00078	8b 55 cc	 mov	 edx, DWORD PTR $T9[ebp]
  0007b	89 02		 mov	 DWORD PTR [edx], eax
  0007d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00086	8b 4d c8	 mov	 ecx, DWORD PTR $T8[ebp]
  00089	89 4d c4	 mov	 DWORD PTR $T7[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 330  : 	return (__builtin_addressof(_Val));

  0008c	8b 55 c4	 mov	 edx, DWORD PTR $T7[ebp]
  0008f	89 55 b4	 mov	 DWORD PTR $T3[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 302  : 		return (_Myval2);

  00092	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 45 c0	 mov	 DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2043 : 		return (_Mypair._Get_second());

  00098	8b 4d c0	 mov	 ecx, DWORD PTR $T6[ebp]
  0009b	89 4d bc	 mov	 DWORD PTR $T5[ebp], ecx

; 2012 : 		return (_Get_data()._Myproxy);

  0009e	8b 55 bc	 mov	 edx, DWORD PTR $T5[ebp]
  000a1	89 55 b8	 mov	 DWORD PTR $T4[ebp], edx

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  000a4	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  000a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a9	8b 55 b4	 mov	 edx, DWORD PTR $T3[ebp]
  000ac	89 11		 mov	 DWORD PTR [ecx], edx

; 1994 : 		}

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -3						; size = 1
__Reload$ = -2						; size = 1
tv72 = -1						; size = 1
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 1971 : 		{	// replace old allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1973 : 			&& _Getal() != _Al;

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 1e		 je	 SHORT $LN5@Move_alloc

; 2033 : 		return (_Mypair._Get_first());

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  00015	89 4d f4	 mov	 DWORD PTR $T4[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00018	8b 55 f4	 mov	 edx, DWORD PTR $T4[ebp]
  0001b	89 55 ec	 mov	 DWORD PTR $T2[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 1055 : 	return (false);

  0001e	c6 45 fd 00	 mov	 BYTE PTR $T5[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1973 : 			&& _Getal() != _Al;

  00022	0f b6 45 fd	 movzx	 eax, BYTE PTR $T5[ebp]
  00026	85 c0		 test	 eax, eax
  00028	74 06		 je	 SHORT $LN5@Move_alloc
  0002a	c6 45 ff 01	 mov	 BYTE PTR tv72[ebp], 1
  0002e	eb 04		 jmp	 SHORT $LN6@Move_alloc
$LN5@Move_alloc:
  00030	c6 45 ff 00	 mov	 BYTE PTR tv72[ebp], 0
$LN6@Move_alloc:
  00034	8a 4d ff	 mov	 cl, BYTE PTR tv72[ebp]
  00037	88 4d fe	 mov	 BYTE PTR __Reload$[ebp], cl

; 1974 : 
; 1975 : 		if (_Reload)

  0003a	0f b6 55 fe	 movzx	 edx, BYTE PTR __Reload$[ebp]
  0003e	85 d2		 test	 edx, edx
  00040	74 08		 je	 SHORT $LN2@Move_alloc

; 1976 : 			{
; 1977 : 			_Free_proxy();

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
$LN2@Move_alloc:

; 2033 : 		return (_Mypair._Get_first());

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0004d	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  00050	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00053	89 4d e8	 mov	 DWORD PTR $T1[ebp], ecx

; 1978 : 			}
; 1979 : 
; 1980 : 		_Pocma(_Getal(), _Al);
; 1981 : 
; 1982 : 		if (_Reload)

  00056	0f b6 55 fe	 movzx	 edx, BYTE PTR __Reload$[ebp]
  0005a	85 d2		 test	 edx, edx
  0005c	74 08		 je	 SHORT $LN1@Move_alloc

; 1983 : 			{
; 1984 : 			_Alloc_proxy();

  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
$LN1@Move_alloc:

; 1985 : 			}
; 1986 : 		}

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__Reload$ = -1						; size = 1
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 1953 : 		{	// replace old allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1954 : 		const bool _Reload = _Alty_traits::propagate_on_container_copy_assignment::value
; 1955 : 			&& _Getal() != _Al;

  00009	c6 45 ff 00	 mov	 BYTE PTR __Reload$[ebp], 0

; 1956 : 
; 1957 : 		if (_Reload)

  0000d	33 c0		 xor	 eax, eax
  0000f	74 08		 je	 SHORT $LN2@Copy_alloc

; 1958 : 			{
; 1959 : 			_Free_proxy();

  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
$LN2@Copy_alloc:

; 2033 : 		return (_Mypair._Get_first());

  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 292  : 		return (*this);

  0001c	89 4d f4	 mov	 DWORD PTR $T2[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2033 : 		return (_Mypair._Get_first());

  0001f	8b 55 f4	 mov	 edx, DWORD PTR $T2[ebp]
  00022	89 55 f0	 mov	 DWORD PTR $T1[ebp], edx

; 1960 : 			}
; 1961 : 
; 1962 : 		_Pocca(_Getal(), _Al);
; 1963 : 
; 1964 : 		if (_Reload)

  00025	33 c0		 xor	 eax, eax
  00027	74 08		 je	 SHORT $LN1@Copy_alloc

; 1965 : 			{
; 1966 : 			_Alloc_proxy();

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
$LN1@Copy_alloc:

; 1967 : 			}
; 1968 : 		}

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1948 : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1949 : 		_Free_proxy();

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy

; 1950 : 		}

  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00031	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00038	59		 pop	 ecx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1934 : 		{	// default construct allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1786 : 		{	// initialize values
; 1787 : 		}
; 1788 : 
; 1789 : 	enum
; 1790 : 		{	// length of internal buffer, [1, 16]
; 1791 : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 1792 : 			: 16 / sizeof (value_type)};
; 1793 : 	enum
; 1794 : 		{	// roundup mask for allocated buffers, [0, 15]
; 1795 : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 1796 : 			: sizeof (value_type) <= 2 ? 7
; 1797 : 			: sizeof (value_type) <= 4 ? 3
; 1798 : 			: sizeof (value_type) <= 8 ? 1 : 0
; 1799 : 		};
; 1800 : 
; 1801 : 	value_type *_Myptr()
; 1802 : 		{	// determine current pointer to buffer for mutable string
; 1803 : 		value_type * _Result = _Bx._Buf;
; 1804 : 		if (_Large_string_engaged())
; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);
; 1810 : 		}
; 1811 : 
; 1812 : 	const value_type *_Myptr() const
; 1813 : 		{	// determine current pointer to buffer for immutable string
; 1814 : 		const value_type * _Result = _Bx._Buf;
; 1815 : 		if (_Large_string_engaged())
; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);
; 1821 : 		}
; 1822 : 
; 1823 : 	bool _Large_string_engaged() const
; 1824 : 		{	// returns whether the large string mode (allocated memory) is engaged
; 1825 : 		return (_BUF_SIZE <= _Myres);
; 1826 : 		}
; 1827 : 
; 1828 : 	void _Check_offset(const size_type _Off) const
; 1829 : 		{	// checks whether _Off is in the bounds of [0, this->size()]
; 1830 : 		if (_Mysize < _Off)
; 1831 : 			{
; 1832 : 			_Xran();
; 1833 : 			}
; 1834 : 		}
; 1835 : 
; 1836 : 	void _Check_offset_exclusive(const size_type _Off) const
; 1837 : 		{	// checks whether _Off is in the bounds of [0, this->size())
; 1838 : 		if (_Mysize <= _Off)
; 1839 : 			{
; 1840 : 			_Xran();
; 1841 : 			}
; 1842 : 		}
; 1843 : 
; 1844 : 	[[noreturn]] static void _Xran()
; 1845 : 		{	// report an out_of_range error
; 1846 : 		_Xout_of_range("invalid string position");
; 1847 : 		}
; 1848 : 
; 1849 : 	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
; 1850 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off
; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));
; 1852 : 		}
; 1853 : 
; 1854 : 	union _Bxty
; 1855 : 		{	// storage for small buffer or pointer to larger one
; 1856 : 		_Bxty()
; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}
; 1859 : 
; 1860 : 		~_Bxty() noexcept
; 1861 : 			{	// user-provided, for fancy pointers
; 1862 : 			}
; 1863 : 
; 1864 : 		value_type _Buf[_BUF_SIZE];
; 1865 : 		pointer _Ptr;
; 1866 : 		char _Alias[_BUF_SIZE];	// retained for /clr bincompat; unused
; 1867 : 		} _Bx;
; 1868 : 
; 1869 : 	size_type _Mysize;	// current length of string
; 1870 : 	size_type _Myres;	// current storage reserved for string
; 1871 : 	};
; 1872 : 
; 1873 : 		// CLASS TEMPLATE _String_alloc
; 1874 : template<class _Alloc_types>
; 1875 : 	class _String_alloc
; 1876 : 	{	// base class for basic_string to hold allocator
; 1877 : public:
; 1878 : 	using _Alty = typename _Alloc_types::_Alty;
; 1879 : 	using _Alty_traits = typename _Alloc_types::_Alty_traits;
; 1880 : 	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
; 1881 : 	using _Alproxy_traits = allocator_traits<_Alproxy>;
; 1882 : 	using _Val_types = typename _Alloc_types::_Val_types;
; 1883 : 	using _Mydata_t = _String_val<_Val_types>;
; 1884 : 	using _Bxty = typename _Mydata_t::_Bxty;
; 1885 : 
; 1886 : 	using value_type = typename _Val_types::value_type;
; 1887 : 	using size_type = typename _Val_types::size_type;
; 1888 : 	using difference_type = typename _Val_types::difference_type;
; 1889 : 	using pointer = typename _Val_types::pointer;
; 1890 : 	using const_pointer = typename _Val_types::const_pointer;
; 1891 : 	using reference = value_type&;
; 1892 : 	using const_reference = const value_type&;
; 1893 : 
; 1894 : 	using iterator = _String_iterator<_Mydata_t>;
; 1895 : 	using const_iterator = _String_const_iterator<_Mydata_t>;
; 1896 : 
; 1897 : 	enum
; 1898 : 		{	// length of internal buffer, [1, 16]
; 1899 : 		_BUF_SIZE = _Mydata_t::_BUF_SIZE
; 1900 : 		};
; 1901 : 
; 1902 : 	enum
; 1903 : 		{	// roundup mask for allocated buffers, [0, 15]
; 1904 : 		_ALLOC_MASK = _Mydata_t::_ALLOC_MASK
; 1905 : 		};
; 1906 : 
; 1907 : #if _ITERATOR_DEBUG_LEVEL == 0
; 1908 : 	_String_alloc()
; 1909 : 		: _Mypair(_Zero_then_variadic_args_t())
; 1910 : 		{	// default construct allocator
; 1911 : 		}
; 1912 : 
; 1913 : 	template<class _Any_alloc,
; 1914 : 		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _String_alloc>>>
; 1915 : 		_String_alloc(_Any_alloc&& _Al)
; 1916 : 		: _Mypair(_One_then_variadic_args_t(),
; 1917 : 			_STD forward<_Any_alloc>(_Al))
; 1918 : 		{	// construct allocator from _Al
; 1919 : 		}
; 1920 : 
; 1921 : 	void _Copy_alloc(const _Alty& _Al)
; 1922 : 		{	// replace old allocator
; 1923 : 		_Pocca(_Getal(), _Al);
; 1924 : 		}
; 1925 : 
; 1926 : 	void _Move_alloc(_Alty& _Al)
; 1927 : 		{	// replace old allocator
; 1928 : 		_Pocma(_Getal(), _Al);
; 1929 : 		}
; 1930 : 
; 1931 : #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1932 : 	_String_alloc()
; 1933 : 		: _Mypair(_Zero_then_variadic_args_t())

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 277  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

  0002e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 		: _Myproxy(nullptr)

  00034	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00037	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1785 : 		_Myres(0)

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 1786 : 		{	// initialize values
; 1787 : 		}
; 1788 : 
; 1789 : 	enum
; 1790 : 		{	// length of internal buffer, [1, 16]
; 1791 : 		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
; 1792 : 			: 16 / sizeof (value_type)};
; 1793 : 	enum
; 1794 : 		{	// roundup mask for allocated buffers, [0, 15]
; 1795 : 		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
; 1796 : 			: sizeof (value_type) <= 2 ? 7
; 1797 : 			: sizeof (value_type) <= 4 ? 3
; 1798 : 			: sizeof (value_type) <= 8 ? 1 : 0
; 1799 : 		};
; 1800 : 
; 1801 : 	value_type *_Myptr()
; 1802 : 		{	// determine current pointer to buffer for mutable string
; 1803 : 		value_type * _Result = _Bx._Buf;
; 1804 : 		if (_Large_string_engaged())
; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);
; 1810 : 		}
; 1811 : 
; 1812 : 	const value_type *_Myptr() const
; 1813 : 		{	// determine current pointer to buffer for immutable string
; 1814 : 		const value_type * _Result = _Bx._Buf;
; 1815 : 		if (_Large_string_engaged())
; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);
; 1821 : 		}
; 1822 : 
; 1823 : 	bool _Large_string_engaged() const
; 1824 : 		{	// returns whether the large string mode (allocated memory) is engaged
; 1825 : 		return (_BUF_SIZE <= _Myres);
; 1826 : 		}
; 1827 : 
; 1828 : 	void _Check_offset(const size_type _Off) const
; 1829 : 		{	// checks whether _Off is in the bounds of [0, this->size()]
; 1830 : 		if (_Mysize < _Off)
; 1831 : 			{
; 1832 : 			_Xran();
; 1833 : 			}
; 1834 : 		}
; 1835 : 
; 1836 : 	void _Check_offset_exclusive(const size_type _Off) const
; 1837 : 		{	// checks whether _Off is in the bounds of [0, this->size())
; 1838 : 		if (_Mysize <= _Off)
; 1839 : 			{
; 1840 : 			_Xran();
; 1841 : 			}
; 1842 : 		}
; 1843 : 
; 1844 : 	[[noreturn]] static void _Xran()
; 1845 : 		{	// report an out_of_range error
; 1846 : 		_Xout_of_range("invalid string position");
; 1847 : 		}
; 1848 : 
; 1849 : 	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
; 1850 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off
; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));
; 1852 : 		}
; 1853 : 
; 1854 : 	union _Bxty
; 1855 : 		{	// storage for small buffer or pointer to larger one
; 1856 : 		_Bxty()
; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}
; 1859 : 
; 1860 : 		~_Bxty() noexcept
; 1861 : 			{	// user-provided, for fancy pointers
; 1862 : 			}
; 1863 : 
; 1864 : 		value_type _Buf[_BUF_SIZE];
; 1865 : 		pointer _Ptr;
; 1866 : 		char _Alias[_BUF_SIZE];	// retained for /clr bincompat; unused
; 1867 : 		} _Bx;
; 1868 : 
; 1869 : 	size_type _Mysize;	// current length of string
; 1870 : 	size_type _Myres;	// current storage reserved for string
; 1871 : 	};
; 1872 : 
; 1873 : 		// CLASS TEMPLATE _String_alloc
; 1874 : template<class _Alloc_types>
; 1875 : 	class _String_alloc
; 1876 : 	{	// base class for basic_string to hold allocator
; 1877 : public:
; 1878 : 	using _Alty = typename _Alloc_types::_Alty;
; 1879 : 	using _Alty_traits = typename _Alloc_types::_Alty_traits;
; 1880 : 	using _Alproxy = _Rebind_alloc_t<_Alty, _Container_proxy>;
; 1881 : 	using _Alproxy_traits = allocator_traits<_Alproxy>;
; 1882 : 	using _Val_types = typename _Alloc_types::_Val_types;
; 1883 : 	using _Mydata_t = _String_val<_Val_types>;
; 1884 : 	using _Bxty = typename _Mydata_t::_Bxty;
; 1885 : 
; 1886 : 	using value_type = typename _Val_types::value_type;
; 1887 : 	using size_type = typename _Val_types::size_type;
; 1888 : 	using difference_type = typename _Val_types::difference_type;
; 1889 : 	using pointer = typename _Val_types::pointer;
; 1890 : 	using const_pointer = typename _Val_types::const_pointer;
; 1891 : 	using reference = value_type&;
; 1892 : 	using const_reference = const value_type&;
; 1893 : 
; 1894 : 	using iterator = _String_iterator<_Mydata_t>;
; 1895 : 	using const_iterator = _String_const_iterator<_Mydata_t>;
; 1896 : 
; 1897 : 	enum
; 1898 : 		{	// length of internal buffer, [1, 16]
; 1899 : 		_BUF_SIZE = _Mydata_t::_BUF_SIZE
; 1900 : 		};
; 1901 : 
; 1902 : 	enum
; 1903 : 		{	// roundup mask for allocated buffers, [0, 15]
; 1904 : 		_ALLOC_MASK = _Mydata_t::_ALLOC_MASK
; 1905 : 		};
; 1906 : 
; 1907 : #if _ITERATOR_DEBUG_LEVEL == 0
; 1908 : 	_String_alloc()
; 1909 : 		: _Mypair(_Zero_then_variadic_args_t())
; 1910 : 		{	// default construct allocator
; 1911 : 		}
; 1912 : 
; 1913 : 	template<class _Any_alloc,
; 1914 : 		class = enable_if_t<!is_same_v<remove_cv_t<remove_reference_t<_Any_alloc>>, _String_alloc>>>
; 1915 : 		_String_alloc(_Any_alloc&& _Al)
; 1916 : 		: _Mypair(_One_then_variadic_args_t(),
; 1917 : 			_STD forward<_Any_alloc>(_Al))
; 1918 : 		{	// construct allocator from _Al
; 1919 : 		}
; 1920 : 
; 1921 : 	void _Copy_alloc(const _Alty& _Al)
; 1922 : 		{	// replace old allocator
; 1923 : 		_Pocca(_Getal(), _Al);
; 1924 : 		}
; 1925 : 
; 1926 : 	void _Move_alloc(_Alty& _Al)
; 1927 : 		{	// replace old allocator
; 1928 : 		_Pocma(_Getal(), _Al);
; 1929 : 		}
; 1930 : 
; 1931 : #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 1932 : 	_String_alloc()
; 1933 : 		: _Mypair(_Zero_then_variadic_args_t())

  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1935 : 		_Alloc_proxy();

  00058	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy

; 1936 : 		}

  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1861 : 			{	// user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1862 : 			}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1856 : 		_Bxty()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T3 = -4						; size = 4
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 1850 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000f	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00015	8b 55 fc	 mov	 edx, DWORD PTR $T3[ebp]
  00018	3b 55 0c	 cmp	 edx, DWORD PTR __Size$[ebp]
  0001b	73 08		 jae	 SHORT $LN5@Clamp_suff
  0001d	8d 45 fc	 lea	 eax, DWORD PTR $T3[ebp]
  00020	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00023	eb 06		 jmp	 SHORT $LN6@Clamp_suff
$LN5@Clamp_suff:
  00025	8d 4d 0c	 lea	 ecx, DWORD PTR __Size$[ebp]
  00028	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
$LN6@Clamp_suff:
  0002b	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  0002e	89 55 f0	 mov	 DWORD PTR $T2[ebp], edx
  00031	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00034	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1851 : 		return (_Min_value(_Size, _Mysize - _Off));

  00037	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0003a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1852 : 		}

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1845 : 		{	// report an out_of_range error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1846 : 		_Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 1847 : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 1829 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1830 : 		if (_Mysize < _Off)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0000d	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00010	73 05		 jae	 SHORT $LN3@Check_offs

; 1831 : 			{
; 1832 : 			_Xran();

  00012	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN3@Check_offs:

; 1833 : 			}
; 1834 : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1824 : 		{	// returns whether the large string mode (allocated memory) is engaged

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN3@Large_stri
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
  00022	8a 45 fc	 mov	 al, BYTE PTR tv66[ebp]

; 1826 : 		}

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1813 : 		{	// determine current pointer to buffer for immutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00019	72 09		 jb	 SHORT $LN6@Myptr
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@Myptr
$LN6@Myptr:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Myptr:

; 1815 : 		if (_Large_string_engaged())

  0002b	0f b6 55 f8	 movzx	 edx, BYTE PTR tv76[ebp]
  0002f	85 d2		 test	 edx, edx
  00031	74 09		 je	 SHORT $LN2@Myptr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx
$LN2@Myptr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1820 : 		return (_Result);

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 1821 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1802 : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1803 : 		value_type * _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00019	72 09		 jb	 SHORT $LN6@Myptr
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@Myptr
$LN6@Myptr:
  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Myptr:

; 1804 : 		if (_Large_string_engaged())

  0002b	0f b6 55 f8	 movzx	 edx, BYTE PTR tv76[ebp]
  0002f	85 d2		 test	 edx, edx
  00031	74 09		 je	 SHORT $LN2@Myptr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00039	89 4d f4	 mov	 DWORD PTR __Result$[ebp], ecx
$LN2@Myptr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1809 : 		return (_Result);

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 1810 : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1786 : 		{	// initialize values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 1787 : 		}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 896  : 		{	// get allocator to use

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 897  : 		return (_Al);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 898  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 891  : 		{	// get maximum size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00003	83 c8 ff	 or	 eax, -1

; 893  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00009	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Count$[ebp], 4096 ; 00001000H
  00010	72 11		 jb	 SHORT $LN6@allocate

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00021	eb 1e		 jmp	 SHORT $LN5@allocate
$LN6@allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00023	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00027	74 11		 je	 SHORT $LN7@allocate

; 52   : 		return (::operator new(_Bytes));

  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  00035	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00038	eb 07		 jmp	 SHORT $LN5@allocate
$LN7@allocate:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
$LN5@allocate:

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00041	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 998  : 		}

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
__Bytes$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __Bytes$[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00015	81 7d fc 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0001c	72 10		 jb	 SHORT $LN4@deallocate

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0001e	8d 55 fc	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00021	52		 push	 edx
  00022	8d 45 f8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0002b	83 c4 08	 add	 esp, 8
$LN4@deallocate:

; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8

; 993  : 		}

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 979  : 	constexpr allocator() noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 1203 : 	{	// convert size_t to size_t, unchanged

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1204 : 	return (_Len);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1205 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_container$ = -12					; size = 4
__Back_shift$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 114  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 115  : 	_Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	83 c1 27	 add	 ecx, 39			; 00000027H
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00011	89 0a		 mov	 DWORD PTR [edx], ecx

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001b	ba 04 00 00 00	 mov	 edx, 4
  00020	6b c2 ff	 imul	 eax, edx, -1
  00023	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00026	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00029	89 55 f4	 mov	 DWORD PTR __Ptr_container$[ebp], edx
$LN4@Adjust_man:

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0002c	b8 04 00 00 00	 mov	 eax, 4
  00031	6b c8 fe	 imul	 ecx, eax, -2
  00034	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00037	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0003e	75 02		 jne	 SHORT $LN7@Adjust_man
  00040	eb 44		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0004c	6a 00		 push	 0
  0004e	6a 7a		 push	 122			; 0000007aH
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00055	6a 02		 push	 2
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005d	83 c4 18	 add	 esp, 24			; 00000018H
  00060	83 f8 01	 cmp	 eax, 1
  00063	75 01		 jne	 SHORT $LN19@Adjust_man
  00065	cc		 int	 3
$LN19@Adjust_man:
  00066	6a 00		 push	 0
  00068	6a 7a		 push	 122			; 0000007aH
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
  00082	33 c9		 xor	 ecx, ecx
  00084	75 bc		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00086	33 d2		 xor	 edx, edx
  00088	75 a2		 jne	 SHORT $LN4@Adjust_man

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);

  0008a	c7 45 f0 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00091	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00094	8b 08		 mov	 ecx, DWORD PTR [eax]
  00096	2b 4d f4	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  00099	89 4d f8	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009c	83 7d f8 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000a0	72 08		 jb	 SHORT $LN13@Adjust_man
  000a2	83 7d f8 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000a6	77 02		 ja	 SHORT $LN13@Adjust_man
  000a8	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000b4	6a 00		 push	 0
  000b6	68 84 00 00 00	 push	 132			; 00000084H
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000c0	6a 02		 push	 2
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000c8	83 c4 18	 add	 esp, 24			; 00000018H
  000cb	83 f8 01	 cmp	 eax, 1
  000ce	75 01		 jne	 SHORT $LN20@Adjust_man
  000d0	cc		 int	 3
$LN20@Adjust_man:
  000d1	6a 00		 push	 0
  000d3	68 84 00 00 00	 push	 132			; 00000084H
  000d8	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ed	83 c4 14	 add	 esp, 20			; 00000014H
  000f0	33 c0		 xor	 eax, eax
  000f2	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  000f4	33 c9		 xor	 ecx, ecx
  000f6	75 a4		 jne	 SHORT $LN10@Adjust_man

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000f8	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000fb	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000fe	89 02		 mov	 DWORD PTR [edx], eax

; 134  : 	}

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 52   : 		return (::operator new(_Bytes));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4

; 53   : 		}

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   : 	{	// gets the size of _Count copies of a type with size 1

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	return (_Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 39   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnext$1 = -4						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 191  : 		{	// cut ties with parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 193  : 		if (_Myproxy != nullptr)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	0f 84 96 00 00
	00		 je	 $LN13@Orphan_me

; 194  : 			{	// adopted, remove self from list
; 195  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	83 c2 04	 add	 edx, 4
  0001d	89 55 fc	 mov	 DWORD PTR __Pnext$1[ebp], edx
$LN2@Orphan_me:

; 196  : 			while (*_Pnext != nullptr && *_Pnext != this)

  00020	8b 45 fc	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00023	83 38 00	 cmp	 DWORD PTR [eax], 0
  00026	74 17		 je	 SHORT $LN6@Orphan_me
  00028	8b 4d fc	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	3b 55 f8	 cmp	 edx, DWORD PTR _this$[ebp]
  00030	74 0d		 je	 SHORT $LN6@Orphan_me

; 197  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  00032	8b 45 fc	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	83 c1 04	 add	 ecx, 4
  0003a	89 4d fc	 mov	 DWORD PTR __Pnext$1[ebp], ecx
  0003d	eb e1		 jmp	 SHORT $LN2@Orphan_me
$LN6@Orphan_me:

; 198  : 
; 199  : 			_STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  0003f	8b 55 fc	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  00042	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00045	74 02		 je	 SHORT $LN9@Orphan_me
  00047	eb 4a		 jmp	 SHORT $LN4@Orphan_me
$LN9@Orphan_me:
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00053	6a 00		 push	 0
  00055	68 c7 00 00 00	 push	 199			; 000000c7H
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@EJIMBHLG@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0005f	6a 02		 push	 2
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00067	83 c4 18	 add	 esp, 24			; 00000018H
  0006a	83 f8 01	 cmp	 eax, 1
  0006d	75 01		 jne	 SHORT $LN14@Orphan_me
  0006f	cc		 int	 3
$LN14@Orphan_me:
  00070	6a 00		 push	 0
  00072	68 c7 00 00 00	 push	 199			; 000000c7H
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@FANNPLN@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@KLDMFDFL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0008c	83 c4 14	 add	 esp, 20			; 00000014H
  0008f	33 c9		 xor	 ecx, ecx
  00091	75 b6		 jne	 SHORT $LN9@Orphan_me
$LN4@Orphan_me:
  00093	33 d2		 xor	 edx, edx
  00095	75 a8		 jne	 SHORT $LN6@Orphan_me

; 200  : 			*_Pnext = _Mynextiter;

  00097	8b 45 fc	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a0	89 10		 mov	 DWORD PTR [eax], edx

; 201  : 			_Myproxy = nullptr;

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN13@Orphan_me:

; 202  : 			}
; 203  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 204  : 		}

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 186  : 		{	// get address of remaining iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 		return (&_Mynextiter);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 188  : 		}

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 181  : 		{	// get owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  : 		return (_Myproxy == nullptr ? nullptr : _Myproxy->_Mycont);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN3@Getcont
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00018	eb 0a		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
$LN4@Getcont:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 183  : 		}

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 176  : 		{	// disown owning container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 177  : 		_Myproxy = nullptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 178  : 		}

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -28						; size = 4
__Lock$3 = -24						; size = 4
__Parent_proxy$4 = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 147  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 148  : 		if (_Parent == nullptr)

  00028	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  0002c	75 1e		 jne	 SHORT $LN2@Adopt

; 149  : 			{	// no future parent, just disown current parent
; 150  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 151  : 			_Lockit _Lock(_LOCK_DEBUG);

  0002e	6a 03		 push	 3
  00030	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 152  : 			_Orphan_me();

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 153  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 154  : 			}

  00041	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 155  : 		else

  0004a	eb 4b		 jmp	 SHORT $LN5@Adopt
$LN2@Adopt:

; 156  : 			{	// have a parent, do adoption
; 157  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	89 4d ec	 mov	 DWORD PTR __Parent_proxy$4[ebp], ecx

; 158  : 
; 159  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 160  : 			if (_Myproxy != _Parent_proxy)

  00054	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	3b 45 ec	 cmp	 eax, DWORD PTR __Parent_proxy$4[ebp]
  0005c	74 39		 je	 SHORT $LN5@Adopt

; 161  : 				{	// change parentage
; 162  : 				_Lockit _Lock(_LOCK_DEBUG);

  0005e	6a 03		 push	 3
  00060	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 163  : 				_Orphan_me();

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 164  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

  00071	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	8b 55 ec	 mov	 edx, DWORD PTR __Parent_proxy$4[ebp]
  00077	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 165  : 				_Parent_proxy->_Myfirstiter = this;

  0007d	8b 4d ec	 mov	 ecx, DWORD PTR __Parent_proxy$4[ebp]
  00080	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00083	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 166  : 				_Myproxy = _Parent_proxy;

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 4d ec	 mov	 ecx, DWORD PTR __Parent_proxy$4[ebp]
  0008c	89 08		 mov	 DWORD PTR [eax], ecx

; 167  : 				}

  0008e	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN5@Adopt:

; 168  : 
; 169  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 170  : 			_Myproxy = _Parent_proxy;
; 171  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			}
; 173  : 		}

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 139  : 		{	// destroy the iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Iterator_base12@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 141  : 		_Lockit _Lock(_LOCK_DEBUG);

  00028	6a 03		 push	 3
  0002a	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 142  : 		_Orphan_me();

  00033	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 143  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 144  : 		}

  0003b	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Iterator_base12@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 119  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 		if (_Myproxy != _Right._Myproxy)

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002e	8b 10		 mov	 edx, DWORD PTR [eax]
  00030	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00032	74 36		 je	 SHORT $LN2@operator

; 121  : 			{
; 122  : 			if (_Right._Myproxy == nullptr)

  00034	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00037	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003a	75 1e		 jne	 SHORT $LN3@operator

; 123  : 				{	// becoming invalid, disown current parent
; 124  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 125  : 				_Lockit _Lock(_LOCK_DEBUG);

  0003c	6a 03		 push	 3
  0003e	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 126  : 				_Orphan_me();

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 127  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 128  : 				}

  0004f	8d 4d ec	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ

; 129  : 			else

  00058	eb 10		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 130  : 				{
; 131  : 				_Adopt(_Right._Myproxy->_Mycont);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	50		 push	 eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
$LN2@operator:

; 132  : 				}
; 133  : 			}
; 134  : 
; 135  : 		return (*this);

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 136  : 		}

  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 115  : 		*this = _Right;

  0001a	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0001d	52		 push	 edx
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 116  : 		}

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 109  : 		{	// construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 108  : 		: _Myproxy(nullptr), _Mynextiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 110  : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
__Temp$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 229  : 	{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  00028	6a 03		 push	 3
  0002a	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;

  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 4d ec	 mov	 DWORD PTR __Temp$[ebp], ecx

; 235  : 	_Myproxy = _Right._Myproxy;

  0003b	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	89 0a		 mov	 DWORD PTR [edx], ecx

; 236  : 	_Right._Myproxy = _Temp;

  00045	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00048	8b 45 ec	 mov	 eax, DWORD PTR __Temp$[ebp]
  0004b	89 02		 mov	 DWORD PTR [edx], eax

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00053	74 0a		 je	 SHORT $LN2@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  00055	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

  0005f	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00062	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00065	74 0a		 je	 SHORT $LN3@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0006f	89 11		 mov	 DWORD PTR [ecx], edx
$LN3@Swap_all:

; 242  : 	}

  00071	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$2 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	74 4f		 je	 SHORT $LN6@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00030	6a 03		 push	 3
  00032	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	83 c2 04	 add	 edx, 4
  00043	89 55 f0	 mov	 DWORD PTR __Pnext$3[ebp], edx
  00046	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$3[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$3[ebp]
  00050	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00053	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  00055	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$3[ebp]
  00058	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0005b	74 0d		 je	 SHORT $LN3@Orphan_all

; 222  : 			(*_Pnext)->_Myproxy = nullptr;

  0005d	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$3[ebp]
  00060	8b 02		 mov	 eax, DWORD PTR [edx]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00068	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = nullptr;

  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 224  : 		}

  00076	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN6@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Container_base12::_Getpfirst, COMDAT
; _this$ = ecx

; 95   : 		{	// get address of iterator chain

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   : 		return (_Myproxy == nullptr ? nullptr : &_Myproxy->_Myfirstiter);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 09		 jne	 SHORT $LN3@Getpfirst
  00011	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00018	eb 0b		 jmp	 SHORT $LN4@Getpfirst
$LN3@Getpfirst:
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001f	83 c2 04	 add	 edx, 4
  00022	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
$LN4@Getpfirst:
  00025	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 97   : 		}

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Container_base12::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 81   : 		{	// construct childless container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 		: _Myproxy(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 82   : 		}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 69   : 		{	// construct from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 70   : 		}

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 505  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 		_Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 507  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 494  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 496  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 470  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memcpy
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 472  : 		}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv71 = -12						; size = 4
tv68 = -8						; size = 4
tv74 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 460  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 461  : #if _HAS_CXX17
; 462  : 		return (__builtin_strlen(_First));
; 463  : #else /* _HAS_CXX17 */
; 464  : 		return (_CSTD strlen(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0000f	83 c1 01	 add	 ecx, 1
  00012	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
$LL3@length:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	88 45 ff	 mov	 BYTE PTR tv74[ebp], al
  0001d	83 45 f8 01	 add	 DWORD PTR tv68[ebp], 1
  00021	80 7d ff 00	 cmp	 BYTE PTR tv74[ebp], 0
  00025	75 ee		 jne	 SHORT $LL3@length
  00027	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0002a	2b 4d f4	 sub	 ecx, DWORD PTR tv71[ebp]
  0002d	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 465  : #endif /* _HAS_CXX17 */
; 466  : 		}

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 616  : 		{	// return maximum value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return (INT_MAX);

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 618  : 		}

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 230  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  :         #pragma warning(push)
; 232  :         #pragma warning(disable : 4995 4996 6386)
; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	d1 e0		 shl	 eax, 1
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _memcpy
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  :         #pragma warning(pop)
; 235  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z
_TEXT	SEGMENT
_buffer$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 329  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 330  : 		if (pszCategory == nullptr)

  00013	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  00017	75 05		 jne	 SHORT $LN2@RegisterCa

; 331  : 		{
; 332  : 			return;

  00019	e9 a9 00 00 00	 jmp	 $LN1@RegisterCa
$LN2@RegisterCa:

; 333  : 		}
; 334  : 
; 335  : 		if (m_nLastCategory >= MaxCategoryArray) 

  0001e	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00025	72 2d		 jb	 SHORT $LN3@RegisterCa

; 336  : 		{
; 337  : 			ATLASSERT(false && "Too many categories defined");

  00027	33 c0		 xor	 eax, eax
  00029	75 27		 jne	 SHORT $LN5@RegisterCa
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm@
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs@
  00035	6a 00		 push	 0
  00037	68 51 01 00 00	 push	 337			; 00000151H
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_1OE@PDFAMNPL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00041	6a 02		 push	 2
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00049	83 c4 18	 add	 esp, 24			; 00000018H
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 01		 jne	 SHORT $LN5@RegisterCa
  00051	cc		 int	 3
$LN5@RegisterCa:

; 338  : 			return;

  00052	eb 73		 jmp	 SHORT $LN1@RegisterCa
$LN3@RegisterCa:

; 339  : 		}
; 340  : 
; 341  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00054	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  0005e	8b 45 0c	 mov	 eax, DWORD PTR _nCategory$[ebp]
  00061	89 82 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[edx], eax

; 342  : #ifdef _UNICODE
; 343  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);
; 344  : #else
; 345  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	

  00067	68 00 01 00 00	 push	 256			; 00000100H
  0006c	6a 00		 push	 0
  0006e	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _memset
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 346  : #if _MSC_VER < 1900
; 347  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 348  : #else
; 349  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%hs", pszCategory);

  0007d	8b 55 08	 mov	 edx, DWORD PTR _pszCategory$[ebp]
  00080	52		 push	 edx
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs@
  00086	6a 7f		 push	 127			; 0000007fH
  00088	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 _swprintf_s
  00094	83 c4 10	 add	 esp, 16			; 00000010H

; 350  : #endif
; 351  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);

  00097	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _buffer$[ebp]
  0009d	51		 push	 ecx
  0009e	6a 7f		 push	 127			; 0000007fH
  000a0	69 15 00 00 00
	00 04 01 00 00	 imul	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  000aa	81 c2 04 00 00
	00		 add	 edx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  000b0	52		 push	 edx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 352  : #endif
; 353  : 	
; 354  : 		m_nLastCategory++;

  000ba	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000bf	83 c0 01	 add	 eax, 1
  000c2	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN1@RegisterCa:

; 355  : 	}

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00003	68 00 20 00 00	 push	 8192			; 00002000H
  00008	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PGMFNIFA@atlTraceException@
  0000d	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  00012	83 c4 08	 add	 esp, 8

; 110  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 480  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 481  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00007	68 00 20 00 00	 push	 8192			; 00002000H
  0000c	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPBDI@Z ; ATL::CTrace::RegisterCategory
  00015	83 c4 08	 add	 esp, 8

; 482  : }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PBD@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_msg$ = -36						; size = 28
_bResult$ = -8						; size = 4
_bQuit$ = -4						; size = 4
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00006	6a 01		 push	 1
  00008	6a 12		 push	 18			; 00000012H
  0000a	6a 12		 push	 18			; 00000012H
  0000c	6a 00		 push	 0
  0000e	8d 45 dc	 lea	 eax, DWORD PTR _msg$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00018	89 45 fc	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00026	52		 push	 edx
  00027	6a 02		 push	 2
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	89 45 f8	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00035	83 7d fc 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  00039	74 0a		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0003b	8b 45 e4	 mov	 eax, DWORD PTR _msg$[ebp+8]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC						; COMDAT

; 535  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 536  :             return _time64(_Time);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Time$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  0000d	83 c4 04	 add	 esp, 4

; 537  :         }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR __Format$[ebp], ecx

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	8b 55 f4	 mov	 edx, DWORD PTR __ArgList$[ebp]
  00015	52		 push	 edx
  00016	6a 00		 push	 0
  00018	8b 45 f0	 mov	 eax, DWORD PTR __Format$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR __BufferCount$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	83 c9 01	 or	 ecx, 1
  0002e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00031	52		 push	 edx
  00032	51		 push	 ecx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00039	83 c4 1c	 add	 esp, 28			; 0000001cH
  0003c	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003f	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  00043	7d 09		 jge	 SHORT $LN7@snprintf
  00045	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv86[ebp], -1
  0004c	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00051	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00054	8b 4d f8	 mov	 ecx, DWORD PTR tv86[ebp]
  00057	89 4d ec	 mov	 DWORD PTR __Result$[ebp], ecx

; 1975 :         __crt_va_end(_ArgList);

  0005a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00061	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
tv80 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1409 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00006	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	6a 00		 push	 0
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  00013	52		 push	 edx
  00014	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	83 c9 01	 or	 ecx, 1
  00022	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00025	52		 push	 edx
  00026	51		 push	 ecx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0002d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00030	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00033	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  00037	7d 09		 jge	 SHORT $LN5@vsnprintf
  00039	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv80[ebp], -1
  00040	eb 06		 jmp	 SHORT $LN3@vsnprintf
$LN5@vsnprintf:
  00042	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00045	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
$LN3@vsnprintf:

; 1410 :         #pragma warning(push)
; 1411 :         #pragma warning(disable: 4996) // Deprecation
; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00048	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]

; 1413 :         #pragma warning(pop)
; 1414 :     }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1389 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00006	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	83 ca 01	 or	 edx, 1
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	50		 push	 eax
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0002f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00032	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00035	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00039	7d 09		 jge	 SHORT $LN3@vsnprintf_
  0003b	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00042	eb 06		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00044	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  00047	89 4d f8	 mov	 DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
  0004a	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1395 :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv80 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1538 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1539 :             int _Result;
; 1540 :             va_list _ArgList;
; 1541 :             __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1542 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR __Format$[ebp], ecx

; 1265 :         int const _Result = __stdio_common_vswprintf_s(

  00012	8b 55 f4	 mov	 edx, DWORD PTR __ArgList$[ebp]
  00015	52		 push	 edx
  00016	6a 00		 push	 0
  00018	8b 45 f0	 mov	 eax, DWORD PTR __Format$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR __BufferCount$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	51		 push	 ecx
  0002d	8b 10		 mov	 edx, DWORD PTR [eax]
  0002f	52		 push	 edx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s
  00036	83 c4 1c	 add	 esp, 28			; 0000001cH
  00039	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1266 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1267 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1268 : 
; 1269 :         return _Result < 0 ? -1 : _Result;

  0003c	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  00040	7d 09		 jge	 SHORT $LN5@swprintf_s
  00042	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv80[ebp], -1
  00049	eb 06		 jmp	 SHORT $LN3@swprintf_s
$LN5@swprintf_s:
  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  0004e	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
$LN3@swprintf_s:

; 1542 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00051	8b 4d f8	 mov	 ecx, DWORD PTR tv80[ebp]
  00054	89 4d ec	 mov	 DWORD PTR __Result$[ebp], ecx

; 1543 :             __crt_va_end(_ArgList);

  00057	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1544 :             return _Result;

  0005e	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1545 :         }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1264 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1265 :         int const _Result = __stdio_common_vswprintf_s(

  00006	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	52		 push	 edx
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s
  0002c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002f	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1266 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1267 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1268 : 
; 1269 :         return _Result < 0 ? -1 : _Result;

  00032	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00036	7d 09		 jge	 SHORT $LN3@vswprintf_
  00038	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  0003f	eb 06		 jmp	 SHORT $LN4@vswprintf_
$LN3@vswprintf_:
  00041	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  00044	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN4@vswprintf_:
  00047	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]

; 1270 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv68 = -8						; size = 4
tv76 = -4						; size = 4
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  0001b	83 7d f4 00	 cmp	 DWORD PTR tv74[ebp], 0
  0001f	75 09		 jne	 SHORT $LN7@
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN5@
$LN7@:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00031	83 7d fc 00	 cmp	 DWORD PTR tv76[ebp], 0
  00035	74 09		 je	 SHORT $LN3@
  00037	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0003e	eb 07		 jmp	 SHORT $LN4@
$LN3@:
  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@:
  00047	8a 45 f8	 mov	 al, BYTE PTR tv68[ebp]

; 195  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
tv68 = -8						; size = 4
tv70 = -4						; size = 4
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001b	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001f	75 09		 jne	 SHORT $LN3@IsEqualGUI
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@IsEqualGUI
$LN3@IsEqualGUI:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@IsEqualGUI:
  00031	8b 45 fc	 mov	 eax, DWORD PTR tv70[ebp]

; 162  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 188  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\tcpnetworkengine.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00013	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00017	76 11		 jbe	 SHORT $LN1@vector
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00022	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00025	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00028	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
