; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\SHA1.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0SHA1@util@zl@@QAE@XZ				; zl::util::SHA1::SHA1
PUBLIC	??1SHA1@util@zl@@QAE@XZ				; zl::util::SHA1::~SHA1
PUBLIC	?hexDigest@SHA1@util@zl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ; zl::util::SHA1::hexDigest
PUBLIC	?reset@SHA1@util@zl@@QAEXXZ			; zl::util::SHA1::reset
PUBLIC	?update@SHA1@util@zl@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; zl::util::SHA1::update
PUBLIC	?final@SHA1@util@zl@@QAEXPAX@Z			; zl::util::SHA1::final
PUBLIC	?hexFinal@SHA1@util@zl@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; zl::util::SHA1::hexFinal
PUBLIC	?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z	; zl::util::SHA1::sha1Transform
PUBLIC	?update@SHA1@util@zl@@AAEXPBEI@Z		; zl::util::SHA1::update
PUBLIC	?finalInternal@SHA1@util@zl@@AAEXXZ		; zl::util::SHA1::finalInternal
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_01IFKFHFEL@?$IA@				; `string'
PUBLIC	??_C@_01LOCGONAA@?$AA@				; `string'
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF@		; `string'
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef@		; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF@ DB '0123456789ABCDEF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA@ DB 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IFKFHFEL@?$IA@
CONST	SEGMENT
??_C@_01IFKFHFEL@?$IA@ DB 080H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xmemory0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z$0
	DD	00H
	DD	FLAT:___std_terminate
__ehfuncinfo$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 92   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]

; 94   : 	if (_Block_size <= _Bytes)

  00006	83 ca ff	 or	 edx, -1
  00009	56		 push	 esi
  0000a	8d 48 27	 lea	 ecx, DWORD PTR [eax+39]
  0000d	3b c8		 cmp	 ecx, eax
  0000f	0f 46 ca	 cmovbe	 ecx, edx

; 52   : 		return (::operator new(_Bytes));

  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00018	8b f0		 mov	 esi, eax

; 52   : 		return (::operator new(_Bytes));

  0001a	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0001d	85 f6		 test	 esi, esi
  0001f	75 3f		 jne	 SHORT $LN6@Allocate_m
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0002b	50		 push	 eax
  0002c	6a 65		 push	 101			; 00000065H
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0003b	83 c4 18	 add	 esp, 24			; 00000018H
  0003e	83 f8 01	 cmp	 eax, 1
  00041	75 01		 jne	 SHORT $LN12@Allocate_m
  00043	cc		 int	 3
$LN12@Allocate_m:
  00044	6a 00		 push	 0
  00046	6a 65		 push	 101			; 00000065H
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@Allocate_m:

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00060	8d 46 27	 lea	 eax, DWORD PTR [esi+39]
  00063	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00066	89 70 fc	 mov	 DWORD PTR [eax-4], esi

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

  00069	c7 40 f8 fa fa
	fa fa		 mov	 DWORD PTR [eax-8], -84215046 ; fafafafaH

; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);

  00070	5e		 pop	 esi

; 110  : 	}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 26   : 	if (_Max_possible < _Count)

  00006	83 ca ff	 or	 edx, -1
  00009	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  0000f	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00016	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 987  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>, COMDAT

; 1212 : 	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	6a 08		 push	 8
  00005	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000d	83 c4 08	 add	 esp, 8

; 1213 : 	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 1214 : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00000	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 871  : 		{	// deallocate _Count elements at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 872  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	83 c4 08	 add	 esp, 8

; 874  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 26   : 	if (_Max_possible < _Count)

  00006	83 ca ff	 or	 edx, -1
  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00015	0f 47 ca	 cmova	 ecx, edx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 998  : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 199  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Bytes$[ebp]
  00008	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0000e	0f 82 b8 00 00
	00		 jb	 $LN24@Deallocate

; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0001a	83 c6 27	 add	 esi, 39			; 00000027H
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00021	81 7f f8 fa fa
	fa fa		 cmp	 DWORD PTR [edi-8], -84215046 ; fafafafaH
  00028	8b 5f fc	 mov	 ebx, DWORD PTR [edi-4]
  0002b	74 42		 je	 SHORT $LN9@Deallocate
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00037	6a 00		 push	 0
  00039	6a 7a		 push	 122			; 0000007aH
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00040	6a 02		 push	 2
  00042	ff d1		 call	 ecx
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN22@Deallocate
  0004c	cc		 int	 3
$LN22@Deallocate:
  0004d	6a 00		 push	 0
  0004f	6a 7a		 push	 122			; 0000007aH
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@Deallocate:

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006f	2b fb		 sub	 edi, ebx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00071	83 ff 08	 cmp	 edi, 8
  00074	72 05		 jb	 SHORT $LN16@Deallocate
  00076	83 ff 27	 cmp	 edi, 39			; 00000027H
  00079	76 42		 jbe	 SHORT $LN15@Deallocate
$LN16@Deallocate:
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00085	6a 00		 push	 0
  00087	68 84 00 00 00	 push	 132			; 00000084H
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00091	6a 02		 push	 2
  00093	ff d1		 call	 ecx
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	83 f8 01	 cmp	 eax, 1
  0009b	75 01		 jne	 SHORT $LN23@Deallocate
  0009d	cc		 int	 3
$LN23@Deallocate:
  0009e	6a 00		 push	 0
  000a0	68 84 00 00 00	 push	 132			; 00000084H
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@Deallocate:
  000bd	5f		 pop	 edi

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  000be	56		 push	 esi
  000bf	53		 push	 ebx
  000c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c5	83 c4 08	 add	 esp, 8
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx

; 208  : 	}

  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN24@Deallocate:

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000cc	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  000cf	56		 push	 esi
  000d0	53		 push	 ebx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d6	83 c4 08	 add	 esp, 8
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx

; 208  : 	}

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 180  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 6d		 jb	 SHORT $LN2@Allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0000e	8d 41 27	 lea	 eax, DWORD PTR [ecx+39]

; 94   : 	if (_Block_size <= _Bytes)

  00011	83 ca ff	 or	 edx, -1
  00014	3b c1		 cmp	 eax, ecx
  00016	56		 push	 esi
  00017	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00020	8b f0		 mov	 esi, eax

; 52   : 		return (::operator new(_Bytes));

  00022	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00025	85 f6		 test	 esi, esi
  00027	75 3f		 jne	 SHORT $LN10@Allocate
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	50		 push	 eax
  00034	6a 65		 push	 101			; 00000065H
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003b	6a 02		 push	 2
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00043	83 c4 18	 add	 esp, 24			; 00000018H
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 01		 jne	 SHORT $LN16@Allocate
  0004b	cc		 int	 3
$LN16@Allocate:
  0004c	6a 00		 push	 0
  0004e	6a 65		 push	 101			; 00000065H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00065	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Allocate:

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00068	8d 46 27	 lea	 eax, DWORD PTR [esi+39]
  0006b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0006e	89 70 fc	 mov	 DWORD PTR [eax-4], esi

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

  00071	c7 40 f8 fa fa
	fa fa		 mov	 DWORD PTR [eax-8], -84215046 ; fafafafaH

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00078	5e		 pop	 esi

; 194  : 	}

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN2@Allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  0007b	85 c9		 test	 ecx, ecx
  0007d	74 09		 je	 SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

  0007f	89 4d 08	 mov	 DWORD PTR __Bytes$[ebp], ecx

; 194  : 	}

  00082	5d		 pop	 ebp

; 52   : 		return (::operator new(_Bytes));

  00083	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00088	33 c0		 xor	 eax, eax

; 194  : 	}

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000d	0f 42 c1	 cmovb	 eax, ecx

; 34   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1943 : 		{	// construct allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0000b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00012	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0001e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00020	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00029	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	89 30		 mov	 DWORD PTR [eax], esi

; 1944 : 		_Alloc_proxy();
; 1945 : 		}

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
tv422 = -8						; size = 4
__New_size$1$ = -8					; size = 4
__Old$1$ = -4						; size = 4
__New_ptr$1$ = 8					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();
; 3922 : 		const size_type _Old_size = _My_data._Mysize;
; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00013	8b c1		 mov	 eax, ecx
  00015	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00018	2b c3		 sub	 eax, ebx
  0001a	3b c2		 cmp	 eax, edx
  0001c	0f 82 bc 00 00
	00		 jb	 $LN88@Reallocate

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

  00022	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00025	03 d3		 add	 edx, ebx

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00027	8b f2		 mov	 esi, edx

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  00029	89 55 f8	 mov	 DWORD PTR __New_size$1$[ebp], edx

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002c	83 ce 0f	 or	 esi, 15			; 0000000fH

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

  0002f	89 45 fc	 mov	 DWORD PTR __Old$1$[ebp], eax

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00032	3b f1		 cmp	 esi, ecx

; 3870 : 		if (_Masked > _Max)

  00034	76 04		 jbe	 SHORT $LN25@Reallocate

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00036	8b f1		 mov	 esi, ecx
  00038	eb 18		 jmp	 SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  0003a	8b d0		 mov	 edx, eax
  0003c	d1 ea		 shr	 edx, 1
  0003e	2b ca		 sub	 ecx, edx
  00040	3b c1		 cmp	 eax, ecx
  00042	76 07		 jbe	 SHORT $LN26@Reallocate

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00044	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00049	eb 07		 jmp	 SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004b	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  0004d	3b f0		 cmp	 esi, eax
  0004f	0f 42 f0	 cmovb	 esi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00052	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005e	89 45 08	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;
; 3935 : 		_My_data._Myres = _New_capacity;
; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);
; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00068	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  0006c	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  0006f	89 47 14	 mov	 DWORD PTR [edi+20], eax
  00072	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00075	89 77 18	 mov	 DWORD PTR [edi+24], esi
  00078	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0007b	53		 push	 ebx
  0007c	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0007f	89 4d f8	 mov	 DWORD PTR tv422[ebp], ecx
  00082	72 34		 jb	 SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  00084	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00086	56		 push	 esi
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0008d	8b 4d f8	 mov	 ecx, DWORD PTR tv422[ebp]
  00090	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  00093	88 01		 mov	 BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00095	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
  00098	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00099	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009d	50		 push	 eax
  0009e	56		 push	 esi
  0009f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000a4	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a7	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000aa	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 3950 : 		return (*this);

  000ad	8b c7		 mov	 eax, edi
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx

; 3951 : 		}

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000b8	56		 push	 esi
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000bf	8b 4d f8	 mov	 ecx, DWORD PTR tv422[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  000c5	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000c8	88 01		 mov	 BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000ca	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000cd	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000d1	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3950 : 		return (*this);

  000d3	8b c7		 mov	 eax, edi
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx

; 3951 : 		}

  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c2 0c 00	 ret	 12			; 0000000cH
$LN88@Reallocate:

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

  000de	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN86@Reallocate:
  000e3	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$ = ecx

; 3241 : 				const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3241 : 				const _Elem _Ch) {

  00007	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  00015	8a 45 14	 mov	 al, BYTE PTR __Ch$[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  0001b	88 04 3e	 mov	 BYTE PTR [esi+edi], al
  0001e	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3245 : 			}, _Ch);

  00025	5d		 pop	 ebp
  00026	c2 10 00	 ret	 16			; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBEXQADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z
_TEXT	SEGMENT
$T2 = -32						; size = 4
_end$1$ = -28						; size = 4
_hex_digits$1$ = -24					; size = 4
__Old$1$ = -20						; size = 4
tv1137 = -20						; size = 4
__Old$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_data$ = 12						; size = 4
__New_ptr$1$ = 16					; size = 4
__New_ptr$1$ = 16					; size = 4
_size$ = 16						; size = 4
_uppercase$ = 20					; size = 1
__Ch$1$ = 23						; size = 1
__Ch$1$ = 23						; size = 1
?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z PROC ; zl::util::encodeAsString, COMDAT

; 240  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 241  :             const char* hex_digits = uppercase ? "0123456789ABCDEF" : "0123456789abcdef";

  00028	80 7d 14 00	 cmp	 BYTE PTR _uppercase$[ebp], 0
  0002c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@JGGOGLEG@0123456789ABCDEF@

; 242  :             const unsigned char* p = static_cast<const unsigned char*>(data);
; 243  :             const unsigned char *first = p;
; 244  :             const unsigned char *end = p + size;

  00031	8b 7d 0c	 mov	 edi, DWORD PTR _data$[ebp]
  00034	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0BB@JCEFLFJE@0123456789abcdef@
  00039	0f 44 c1	 cmove	 eax, ecx
  0003c	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  00043	89 45 e8	 mov	 DWORD PTR _hex_digits$1$[ebp], eax
  00046	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00049	03 c7		 add	 eax, edi
  0004b	89 45 e4	 mov	 DWORD PTR _end$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  0004e	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00051	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2142 : 		{	// construct empty string

  00053	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  0005a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00060	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00067	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0006e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00073	89 06		 mov	 DWORD PTR [esi], eax

; 3980 : 		_Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00075	8d 5e 04	 lea	 ebx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00078	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0007b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00081	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	89 30		 mov	 DWORD PTR [eax], esi

; 3976 : 		_My_data._Mysize = 0;

  0008c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00093	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0009a	c6 03 00	 mov	 BYTE PTR [ebx], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 255  :             return str;

  0009d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a4	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  000ab	3b 7d e4	 cmp	 edi, DWORD PTR _end$1$[ebp]
  000ae	0f 84 fa 01 00
	00		 je	 $LN3@encodeAsSt
$LL2@encodeAsSt:

; 250  :                 str.push_back(hex_digits[ch >> 4]);

  000b4	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR _hex_digits$1$[ebp]
  000ba	8b c2		 mov	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3229 : 		const size_type _Old_size = _My_data._Mysize;

  000bc	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 250  :                 str.push_back(hex_digits[ch >> 4]);

  000bf	c1 e8 04	 shr	 eax, 4
  000c2	89 55 ec	 mov	 DWORD PTR tv1137[ebp], edx
  000c5	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3230 : 		if (_Old_size < _My_data._Myres)

  000c8	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 250  :                 str.push_back(hex_digits[ch >> 4]);

  000cb	88 45 17	 mov	 BYTE PTR __Ch$1$[ebp], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3230 : 		if (_Old_size < _My_data._Myres)

  000ce	89 4d f0	 mov	 DWORD PTR __Old$1$[ebp], ecx
  000d1	3b f9		 cmp	 edi, ecx
  000d3	73 1f		 jae	 SHORT $LN76@encodeAsSt

; 3231 : 			{
; 3232 : 			_My_data._Mysize = _Old_size + 1;

  000d5	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  000d8	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  000db	8b c3		 mov	 eax, ebx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  000dd	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  000e0	72 02		 jb	 SHORT $LN293@encodeAsSt
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  000e2	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN293@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000e4	8a 4d 17	 mov	 cl, BYTE PTR __Ch$1$[ebp]
  000e7	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  000ea	c6 44 38 01 00	 mov	 BYTE PTR [eax+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3236 : 			return;

  000ef	e9 bc 00 00 00	 jmp	 $LN96@encodeAsSt
$LN76@encodeAsSt:

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  000f4	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000f9	2b c7		 sub	 eax, edi
  000fb	83 f8 01	 cmp	 eax, 1
  000fe	0f 82 be 01 00
	00		 jb	 $LN286@encodeAsSt

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long
; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  00104	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00107	83 ce 0f	 or	 esi, 15			; 0000000fH
  0010a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 3870 : 		if (_Masked > _Max)

  00110	76 07		 jbe	 SHORT $LN117@encodeAsSt

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00112	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00117	eb 1e		 jmp	 SHORT $LN116@encodeAsSt
$LN117@encodeAsSt:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  00119	8b d1		 mov	 edx, ecx
  0011b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00120	d1 ea		 shr	 edx, 1
  00122	2b c2		 sub	 eax, edx
  00124	3b c8		 cmp	 ecx, eax
  00126	76 07		 jbe	 SHORT $LN118@encodeAsSt

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00128	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0012d	eb 08		 jmp	 SHORT $LN116@encodeAsSt
$LN118@encodeAsSt:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0012f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00132	3b f0		 cmp	 esi, eax
  00134	0f 42 f0	 cmovb	 esi, eax
$LN116@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00137	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0013a	50		 push	 eax
  0013b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3933 : 		_My_data._Orphan_all();

  00140	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00143	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00146	89 45 10	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  00149	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;
; 3935 : 		_My_data._Myres = _New_capacity;
; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);
; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  0014e	83 7d f0 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  00152	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00155	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00158	57		 push	 edi
  00159	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0015c	89 70 18	 mov	 DWORD PTR [eax+24], esi
  0015f	72 2f		 jb	 SHORT $LN95@encodeAsSt

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  00161	8b 33		 mov	 esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00163	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00166	56		 push	 esi
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0016d	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00170	8a 4d 17	 mov	 cl, BYTE PTR __Ch$1$[ebp]
  00173	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  00176	c6 44 38 01 00	 mov	 BYTE PTR [eax+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0017b	8b 45 f0	 mov	 eax, DWORD PTR __Old$1$[ebp]
  0017e	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0017f	50		 push	 eax
  00180	56		 push	 esi
  00181	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  00186	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00189	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  0018c	89 03		 mov	 DWORD PTR [ebx], eax

; 3943 : 			}
; 3944 : 		else

  0018e	eb 1a		 jmp	 SHORT $LN296@encodeAsSt
$LN95@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00190	8b 75 10	 mov	 esi, DWORD PTR __New_ptr$1$[ebp]
  00193	53		 push	 ebx
  00194	56		 push	 esi
  00195	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0019a	8a 4d 17	 mov	 cl, BYTE PTR __Ch$1$[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0019d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  001a0	88 0c 3e	 mov	 BYTE PTR [esi+edi], cl
  001a3	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  001a8	89 33		 mov	 DWORD PTR [ebx], esi
$LN296@encodeAsSt:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 251  :                 str.push_back(hex_digits[ch & 0x0F]);

  001aa	8b 55 ec	 mov	 edx, DWORD PTR tv1137[ebp]
  001ad	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
$LN96@encodeAsSt:
  001b0	8b 45 e8	 mov	 eax, DWORD PTR _hex_digits$1$[ebp]
  001b3	83 e2 0f	 and	 edx, 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3230 : 		if (_Old_size < _My_data._Myres)

  001b6	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  001b9	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  001bc	89 4d ec	 mov	 DWORD PTR __Old$1$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 251  :                 str.push_back(hex_digits[ch & 0x0F]);

  001bf	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  001c2	88 55 17	 mov	 BYTE PTR __Ch$1$[ebp], dl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3230 : 		if (_Old_size < _My_data._Myres)

  001c5	3b f9		 cmp	 edi, ecx
  001c7	73 1c		 jae	 SHORT $LN181@encodeAsSt

; 3231 : 			{
; 3232 : 			_My_data._Mysize = _Old_size + 1;

  001c9	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  001cc	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  001cf	8b c3		 mov	 eax, ebx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  001d1	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  001d4	72 02		 jb	 SHORT $LN292@encodeAsSt
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  001d6	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN292@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  001d8	88 14 38	 mov	 BYTE PTR [eax+edi], dl
  001db	c6 44 38 01 00	 mov	 BYTE PTR [eax+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3236 : 			return;

  001e0	e9 b9 00 00 00	 jmp	 $LN201@encodeAsSt
$LN181@encodeAsSt:

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  001e5	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  001ea	2b c7		 sub	 eax, edi
  001ec	83 f8 01	 cmp	 eax, 1
  001ef	0f 82 cd 00 00
	00		 jb	 $LN286@encodeAsSt

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long
; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  001f5	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  001f8	83 ce 0f	 or	 esi, 15			; 0000000fH
  001fb	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 3870 : 		if (_Masked > _Max)

  00201	76 07		 jbe	 SHORT $LN222@encodeAsSt

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00203	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00208	eb 1e		 jmp	 SHORT $LN221@encodeAsSt
$LN222@encodeAsSt:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  0020a	8b d1		 mov	 edx, ecx
  0020c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00211	d1 ea		 shr	 edx, 1
  00213	2b c2		 sub	 eax, edx
  00215	3b c8		 cmp	 ecx, eax
  00217	76 07		 jbe	 SHORT $LN223@encodeAsSt

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00219	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0021e	eb 08		 jmp	 SHORT $LN221@encodeAsSt
$LN223@encodeAsSt:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00220	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00223	3b f0		 cmp	 esi, eax
  00225	0f 42 f0	 cmovb	 esi, eax
$LN221@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00228	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0022b	50		 push	 eax
  0022c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3933 : 		_My_data._Orphan_all();

  00231	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00234	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00237	89 45 10	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  0023a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;
; 3935 : 		_My_data._Myres = _New_capacity;
; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);
; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  0023f	83 7d ec 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  00243	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00246	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00249	57		 push	 edi
  0024a	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0024d	89 70 18	 mov	 DWORD PTR [eax+24], esi
  00250	72 2f		 jb	 SHORT $LN200@encodeAsSt

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  00252	8b 33		 mov	 esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00254	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00257	56		 push	 esi
  00258	50		 push	 eax
  00259	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0025e	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00261	8a 4d 17	 mov	 cl, BYTE PTR __Ch$1$[ebp]
  00264	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
  00267	c6 44 38 01 00	 mov	 BYTE PTR [eax+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0026c	8b 45 ec	 mov	 eax, DWORD PTR __Old$1$[ebp]
  0026f	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00270	50		 push	 eax
  00271	56		 push	 esi
  00272	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  00277	8b 45 10	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0027a	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  0027d	89 03		 mov	 DWORD PTR [ebx], eax

; 3943 : 			}
; 3944 : 		else

  0027f	eb 1a		 jmp	 SHORT $LN297@encodeAsSt
$LN200@encodeAsSt:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00281	8b 75 10	 mov	 esi, DWORD PTR __New_ptr$1$[ebp]
  00284	53		 push	 ebx
  00285	56		 push	 esi
  00286	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0028b	8a 4d 17	 mov	 cl, BYTE PTR __Ch$1$[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0028e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  00291	88 0c 3e	 mov	 BYTE PTR [esi+edi], cl
  00294	c6 44 3e 01 00	 mov	 BYTE PTR [esi+edi+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00299	89 33		 mov	 DWORD PTR [ebx], esi
$LN297@encodeAsSt:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 252  :                 ++first;

  0029b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
$LN201@encodeAsSt:
  0029e	8b 7d 0c	 mov	 edi, DWORD PTR _data$[ebp]
  002a1	47		 inc	 edi
  002a2	89 7d 0c	 mov	 DWORD PTR _data$[ebp], edi
  002a5	3b 7d e4	 cmp	 edi, DWORD PTR _end$1$[ebp]
  002a8	0f 85 06 fe ff
	ff		 jne	 $LL2@encodeAsSt
$LN3@encodeAsSt:

; 255  :             return str;

  002ae	8b c6		 mov	 eax, esi

; 256  :         }

  002b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ba	59		 pop	 ecx
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx
  002be	8b e5		 mov	 esp, ebp
  002c0	5d		 pop	 ebp
  002c1	c3		 ret	 0
$LN286@encodeAsSt:
  002c2	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN295@encodeAsSt:
  002c7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z$0:
  00000	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN6@encodeAsSt
  0000c	83 65 e0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@encodeAsSt:
  00018	c3		 ret	 0
__ehhandler$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z ENDP ; zl::util::encodeAsString
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?finalInternal@SHA1@util@zl@@AAEXXZ
_TEXT	SEGMENT
_finalcount$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
?finalInternal@SHA1@util@zl@@AAEXXZ PROC		; zl::util::SHA1::finalInternal, COMDAT
; _this$ = ecx

; 210  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b f1		 mov	 esi, ecx

; 178  :             size_t i = 0;

  00014	33 db		 xor	 ebx, ebx

; 211  :             uint8_t finalcount[8];
; 212  :             for (int i = 0; i < 8; ++i)
; 213  :             {
; 214  :                 // Endian independent
; 215  :                 finalcount[i] = static_cast<uint8_t>((context_.count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);

  00016	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00019	8b c1		 mov	 eax, ecx
  0001b	c1 e8 18	 shr	 eax, 24			; 00000018H
  0001e	88 45 f4	 mov	 BYTE PTR _finalcount$[ebp], al
  00021	8b c1		 mov	 eax, ecx
  00023	c1 e8 10	 shr	 eax, 16			; 00000010H
  00026	88 45 f5	 mov	 BYTE PTR _finalcount$[ebp+1], al
  00029	8b c1		 mov	 eax, ecx
  0002b	c1 e8 08	 shr	 eax, 8
  0002e	88 45 f6	 mov	 BYTE PTR _finalcount$[ebp+2], al
  00031	88 4d f7	 mov	 BYTE PTR _finalcount$[ebp+3], cl
  00034	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00037	8b c1		 mov	 eax, ecx
  00039	c1 e8 18	 shr	 eax, 24			; 00000018H

; 181  :             size_t index = (context_.count[0] >> 3) & 63;

  0003c	8b d1		 mov	 edx, ecx

; 211  :             uint8_t finalcount[8];
; 212  :             for (int i = 0; i < 8; ++i)
; 213  :             {
; 214  :                 // Endian independent
; 215  :                 finalcount[i] = static_cast<uint8_t>((context_.count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);

  0003e	88 45 f8	 mov	 BYTE PTR _finalcount$[ebp+4], al
  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 10	 shr	 eax, 16			; 00000010H
  00046	88 45 f9	 mov	 BYTE PTR _finalcount$[ebp+5], al
  00049	8b c1		 mov	 eax, ecx
  0004b	c1 e8 08	 shr	 eax, 8
  0004e	88 45 fa	 mov	 BYTE PTR _finalcount$[ebp+6], al

; 188  :             context_.count[0] += static_cast<uint32_t>(input_len << 3);

  00051	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00054	c1 ea 03	 shr	 edx, 3
  00057	83 e2 3f	 and	 edx, 63			; 0000003fH
  0005a	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 189  :             if (context_.count[0] < static_cast<uint32_t>(input_len << 3))

  0005d	83 f8 08	 cmp	 eax, 8

; 211  :             uint8_t finalcount[8];
; 212  :             for (int i = 0; i < 8; ++i)
; 213  :             {
; 214  :                 // Endian independent
; 215  :                 finalcount[i] = static_cast<uint8_t>((context_.count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);

  00060	88 4d fb	 mov	 BYTE PTR _finalcount$[ebp+7], cl

; 189  :             if (context_.count[0] < static_cast<uint32_t>(input_len << 3))

  00063	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00066	73 01		 jae	 SHORT $LN12@finalInter

; 190  :             {
; 191  :                 ++context_.count[1];  // if overlow (carry), add one to high word

  00068	40		 inc	 eax
$LN12@finalInter:

; 192  :             }
; 193  :             context_.count[1] += static_cast<uint32_t>(input_len >> 29);

  00069	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 194  :             if ((index + input_len) > 63)

  0006c	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0006f	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00072	76 4d		 jbe	 SHORT $LN13@finalInter

; 195  :             {
; 196  :                 i = 64 - index;

  00074	57		 push	 edi
  00075	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H

; 197  :                 memcpy(&context_.buffer[index], data, i);

  0007a	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  0007d	2b da		 sub	 ebx, edx
  0007f	03 c2		 add	 eax, edx
  00081	53		 push	 ebx
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_01IFKFHFEL@?$IA@
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :                 sha1Transform(context_.state, context_.buffer);

  00090	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00093	8b ce		 mov	 ecx, esi
  00095	50		 push	 eax
  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 ?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z ; zl::util::SHA1::sha1Transform

; 199  :                 for (; i + 63 < input_len; i += 64)

  0009c	8d 7b 3f	 lea	 edi, DWORD PTR [ebx+63]
  0009f	83 ff 01	 cmp	 edi, 1
  000a2	73 1a		 jae	 SHORT $LN10@finalInter
$LL11@finalInter:

; 200  :                 {
; 201  :                     sha1Transform(context_.state, data + i);

  000a4	8d 87 c1 ff ff
	ff		 lea	 eax, DWORD PTR ??_C@_01IFKFHFEL@?$IA@[edi-63]
  000aa	8b ce		 mov	 ecx, esi
  000ac	50		 push	 eax
  000ad	56		 push	 esi
  000ae	e8 00 00 00 00	 call	 ?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z ; zl::util::SHA1::sha1Transform
  000b3	83 c7 40	 add	 edi, 64			; 00000040H
  000b6	83 c3 40	 add	 ebx, 64			; 00000040H
  000b9	83 ff 01	 cmp	 edi, 1
  000bc	72 e6		 jb	 SHORT $LL11@finalInter
$LN10@finalInter:

; 202  :                 }
; 203  :                 index = 0;

  000be	33 d2		 xor	 edx, edx
  000c0	5f		 pop	 edi
$LN13@finalInter:

; 204  :             }
; 205  :             memcpy(&context_.buffer[index], &data[i], input_len - i);

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	2b c3		 sub	 eax, ebx
  000c8	50		 push	 eax
  000c9	8d 83 00 00 00
	00		 lea	 eax, DWORD PTR ??_C@_01IFKFHFEL@?$IA@[ebx]
  000cf	50		 push	 eax
  000d0	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  000d3	03 c2		 add	 eax, edx
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _memcpy

; 216  :             }
; 217  :             update(reinterpret_cast<const uint8_t*>("\200"), 1);
; 218  :             while ((context_.count[0] & 504) != 448)

  000db	8b 46 14	 mov	 eax, DWORD PTR [esi+20]

; 205  :             memcpy(&context_.buffer[index], &data[i], input_len - i);

  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 216  :             }
; 217  :             update(reinterpret_cast<const uint8_t*>("\200"), 1);
; 218  :             while ((context_.count[0] & 504) != 448)

  000e1	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  000e6	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  000eb	74 20		 je	 SHORT $LN6@finalInter
  000ed	0f 1f 00	 npad	 3
$LL5@finalInter:

; 219  :             {
; 220  :                 update(reinterpret_cast<const uint8_t*>("\0"), 1);

  000f0	6a 01		 push	 1
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_01LOCGONAA@?$AA@
  000f7	8b ce		 mov	 ecx, esi
  000f9	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  000fe	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00101	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  00106	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0010b	75 e3		 jne	 SHORT $LL5@finalInter
$LN6@finalInter:

; 221  :             }
; 222  :             // Should cause a SHA1Transform().
; 223  :             update(finalcount, 8);

  0010d	6a 08		 push	 8
  0010f	8d 45 f4	 lea	 eax, DWORD PTR _finalcount$[ebp]
  00112	8b ce		 mov	 ecx, esi
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 224  :             // Wipe variables.
; 225  :             memset(finalcount, 0, 8);   // SWR
; 226  :         }

  0011a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011d	5e		 pop	 esi
  0011e	33 cd		 xor	 ecx, ebp
  00120	5b		 pop	 ebx
  00121	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c3		 ret	 0
?finalInternal@SHA1@util@zl@@AAEXXZ ENDP		; zl::util::SHA1::finalInternal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?update@SHA1@util@zl@@AAEXPBEI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_data$ = 8						; size = 4
_input_len$ = 12					; size = 4
?update@SHA1@util@zl@@AAEXPBEI@Z PROC			; zl::util::SHA1::update, COMDAT
; _this$ = ecx

; 177  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 178  :             size_t i = 0;
; 179  : 
; 180  :             // Compute number of bytes mod 64.
; 181  :             size_t index = (context_.count[0] >> 3) & 63;
; 182  : 
; 183  :             // Update number of bits.
; 184  :             // TODO(xxx): Use uint64 instead of 2 uint32_t for count.
; 185  :             // count[0] has low 29 bits for byte count + 3 pad 0's making 32 bits for
; 186  :             // bit count.
; 187  :             // Add bit count to low uint32_t
; 188  :             context_.count[0] += static_cast<uint32_t>(input_len << 3);

  00004	8b 55 0c	 mov	 edx, DWORD PTR _input_len$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	33 db		 xor	 ebx, ebx
  0000e	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00011	8b f0		 mov	 esi, eax
  00013	c1 ee 03	 shr	 esi, 3
  00016	83 e6 3f	 and	 esi, 63			; 0000003fH
  00019	8d 0c d0	 lea	 ecx, DWORD PTR [eax+edx*8]

; 189  :             if (context_.count[0] < static_cast<uint32_t>(input_len << 3))

  0001c	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8d 04 d5 00 00
	00 00		 lea	 eax, DWORD PTR [edx*8]
  00029	89 4f 14	 mov	 DWORD PTR [edi+20], ecx
  0002c	3b c8		 cmp	 ecx, eax
  0002e	73 07		 jae	 SHORT $LN11@update

; 190  :             {
; 191  :                 ++context_.count[1];  // if overlow (carry), add one to high word

  00030	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00033	40		 inc	 eax
  00034	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
$LN11@update:

; 192  :             }
; 193  :             context_.count[1] += static_cast<uint32_t>(input_len >> 29);

  00037	8b c2		 mov	 eax, edx
  00039	c1 e8 1d	 shr	 eax, 29			; 0000001dH
  0003c	03 45 fc	 add	 eax, DWORD PTR $T1[ebp]
  0003f	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 194  :             if ((index + input_len) > 63)

  00042	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
  00045	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00048	76 56		 jbe	 SHORT $LN6@update

; 195  :             {
; 196  :                 i = 64 - index;

  0004a	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H

; 197  :                 memcpy(&context_.buffer[index], data, i);

  0004f	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00052	2b de		 sub	 ebx, esi
  00054	03 c6		 add	 eax, esi
  00056	53		 push	 ebx
  00057	ff 75 08	 push	 DWORD PTR _data$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 _memcpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 198  :                 sha1Transform(context_.state, context_.buffer);

  00063	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  00066	8b cf		 mov	 ecx, edi
  00068	50		 push	 eax
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 ?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z ; zl::util::SHA1::sha1Transform

; 199  :                 for (; i + 63 < input_len; i += 64)

  0006f	8b 55 0c	 mov	 edx, DWORD PTR _input_len$[ebp]
  00072	8d 73 3f	 lea	 esi, DWORD PTR [ebx+63]
  00075	3b f2		 cmp	 esi, edx
  00077	73 25		 jae	 SHORT $LN3@update
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@update:

; 200  :                 {
; 201  :                     sha1Transform(context_.state, data + i);

  00080	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00083	8b cf		 mov	 ecx, edi
  00085	83 c0 c1	 add	 eax, -63		; ffffffc1H
  00088	03 c6		 add	 eax, esi
  0008a	50		 push	 eax
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 ?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z ; zl::util::SHA1::sha1Transform
  00091	8b 55 0c	 mov	 edx, DWORD PTR _input_len$[ebp]
  00094	83 c6 40	 add	 esi, 64			; 00000040H
  00097	83 c3 40	 add	 ebx, 64			; 00000040H
  0009a	3b f2		 cmp	 esi, edx
  0009c	72 e2		 jb	 SHORT $LL4@update
$LN3@update:

; 202  :                 }
; 203  :                 index = 0;

  0009e	33 f6		 xor	 esi, esi
$LN6@update:

; 204  :             }
; 205  :             memcpy(&context_.buffer[index], &data[i], input_len - i);

  000a0	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  000a3	2b d3		 sub	 edx, ebx
  000a5	03 c3		 add	 eax, ebx
  000a7	52		 push	 edx
  000a8	50		 push	 eax
  000a9	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  000ac	03 c6		 add	 eax, esi
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 _memcpy
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	5f		 pop	 edi
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 206  :         }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?update@SHA1@util@zl@@AAEXPBEI@Z ENDP			; zl::util::SHA1::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z
_TEXT	SEGMENT
_d$7$ = -76						; size = 4
_c$32$ = -76						; size = 4
_c$11$ = -76						; size = 4
tv6423 = -76						; size = 4
_a$10$ = -76						; size = 4
_e$31$ = -72						; size = 4
_e$29$ = -72						; size = 4
_e$19$ = -72						; size = 4
_e$15$ = -72						; size = 4
_e$13$ = -72						; size = 4
_e$11$ = -72						; size = 4
_c$25$ = -72						; size = 4
_b$32$ = -72						; size = 4
tv6494 = -72						; size = 4
_d$19$ = -68						; size = 4
_d$5$ = -68						; size = 4
_c$29$ = -68						; size = 4
_c$27$ = -68						; size = 4
tv6516 = -68						; size = 4
tv6344 = -68						; size = 4
_a$14$ = -68						; size = 4
_a$4$ = -68						; size = 4
_d$31$ = -64						; size = 4
_d$15$ = -64						; size = 4
_b$28$ = -64						; size = 4
_b$26$ = -64						; size = 4
_a$32$ = -64						; size = 4
tv6450 = -64						; size = 4
tv6399 = -64						; size = 4
_c$31$ = -60						; size = 4
_a$28$ = -60						; size = 4
tv6472 = -60						; size = 4
tv6398 = -60						; size = 4
tv6479 = -56						; size = 4
tv6396 = -56						; size = 4
tv6370 = -56						; size = 4
tv6487 = -52						; size = 4
tv6413 = -52						; size = 4
tv6395 = -52						; size = 4
_e$25$ = -48						; size = 4
_e$5$ = -48						; size = 4
_c$15$ = -48						; size = 4
_c$5$ = -48						; size = 4
_b$30$ = -48						; size = 4
tv6515 = -48						; size = 4
_a$6$ = -48						; size = 4
_d$25$ = -44						; size = 4
_d$13$ = -44						; size = 4
tv6517 = -44						; size = 4
tv6502 = -44						; size = 4
_b$12$ = -40						; size = 4
tv6518 = -40						; size = 4
tv6519 = -36						; size = 4
_d$11$ = -32						; size = 4
_c$9$ = -32						; size = 4
_c$7$ = -32						; size = 4
_b$6$ = -32						; size = 4
tv6373 = -32						; size = 4
tv6371 = -32						; size = 4
_e$23$ = -28						; size = 4
_d$29$ = -28						; size = 4
_d$21$ = -28						; size = 4
_c$19$ = -28						; size = 4
tv6512 = -28						; size = 4
_a$16$ = -28						; size = 4
_e$17$ = -24						; size = 4
_d$23$ = -24						; size = 4
_c$21$ = -24						; size = 4
_b$20$ = -24						; size = 4
_a$30$ = -24						; size = 4
tv6513 = -24						; size = 4
_e$21$ = -20						; size = 4
_c$23$ = -20						; size = 4
_c$17$ = -20						; size = 4
tv6514 = -20						; size = 4
_e$7$ = -16						; size = 4
_c$13$ = -16						; size = 4
_b$24$ = -16						; size = 4
_b$18$ = -16						; size = 4
_b$16$ = -16						; size = 4
_b$10$ = -16						; size = 4
_b$8$ = -16						; size = 4
_a$22$ = -16						; size = 4
_a$20$ = -16						; size = 4
_d$17$ = -12						; size = 4
_b$22$ = -12						; size = 4
_a$24$ = -12						; size = 4
tv6400 = -12						; size = 4
_b$14$ = -8						; size = 4
tv6501 = -8						; size = 4
_a$18$ = -8						; size = 4
_a$8$ = -8						; size = 4
tv6401 = -4						; size = 4
tv6374 = -4						; size = 4
_a$2$ = -4						; size = 4
_state$ = 8						; size = 4
_buffer$ = 12						; size = 4
?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z PROC		; zl::util::SHA1::sha1Transform, COMDAT
; _this$ = ecx

; 59   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 60   :             union CHAR64LONG16
; 61   :             {
; 62   :                 uint8_t c[64];
; 63   :                 uint32_t l[16];
; 64   :             };
; 65   : 
; 66   :             // Note(fbarchard): This option does modify the user's data buffer.
; 67   :             CHAR64LONG16* block = const_cast<CHAR64LONG16*>(reinterpret_cast<const CHAR64LONG16*>(buffer));
; 68   : 
; 69   :             // Copy context_.state[] to working vars.
; 70   :             uint32_t a = state[0];
; 71   :             uint32_t b = state[1];
; 72   :             uint32_t c = state[2];
; 73   :             uint32_t d = state[3];
; 74   :             uint32_t e = state[4];
; 75   : 
; 76   :             // 4 rounds of 20 operations each. Loop unrolled.
; 77   :             // Note(fbarchard): The following has lint warnings for multiple ; on
; 78   :             // a line and no space after , but is left as-is to be similar to the
; 79   :             // original code.
; 80   :             R0(a, b, c, d, e, 0);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00013	89 45 f8	 mov	 DWORD PTR tv6501[ebp], eax
  00016	c1 4d f8 08	 ror	 DWORD PTR tv6501[ebp], 8
  0001a	81 65 f8 00 ff
	00 ff		 and	 DWORD PTR tv6501[ebp], -16711936 ; ff00ff00H
  00021	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00023	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00026	c1 c0 08	 rol	 eax, 8
  00029	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0002e	89 4d fc	 mov	 DWORD PTR _a$2$[ebp], ecx
  00031	09 45 f8	 or	 DWORD PTR tv6501[ebp], eax
  00034	8b c6		 mov	 eax, esi
  00036	c1 c1 05	 rol	 ecx, 5
  00039	03 4d f8	 add	 ecx, DWORD PTR tv6501[ebp]
  0003c	57		 push	 edi
  0003d	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  00040	33 c7		 xor	 eax, edi
  00042	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00045	23 c3		 and	 eax, ebx
  00047	33 c6		 xor	 eax, esi
  00049	c1 cb 02	 ror	 ebx, 2
  0004c	03 c1		 add	 eax, ecx
  0004e	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  00054	03 d0		 add	 edx, eax

; 81   :             R0(e, a, b, c, d, 1);

  00056	81 c6 99 79 82
	5a		 add	 esi, 1518500249		; 5a827999H
  0005c	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	8b c8		 mov	 ecx, eax
  00064	c1 c0 08	 rol	 eax, 8
  00067	c1 c9 08	 ror	 ecx, 8
  0006a	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0006f	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00075	0b c8		 or	 ecx, eax
  00077	8b c7		 mov	 eax, edi
  00079	33 c3		 xor	 eax, ebx
  0007b	89 4d b8	 mov	 DWORD PTR tv6494[ebp], ecx
  0007e	23 45 fc	 and	 eax, DWORD PTR _a$2$[ebp]
  00081	8b ca		 mov	 ecx, edx
  00083	33 c7		 xor	 eax, edi
  00085	c1 c1 05	 rol	 ecx, 5
  00088	03 4d b8	 add	 ecx, DWORD PTR tv6494[ebp]

; 82   :             R0(d, e, a, b, c, 2);

  0008b	81 c7 99 79 82
	5a		 add	 edi, 1518500249		; 5a827999H
  00091	03 c1		 add	 eax, ecx
  00093	c1 4d fc 02	 ror	 DWORD PTR _a$2$[ebp], 2
  00097	03 f0		 add	 esi, eax
  00099	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0009c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0009f	8b c8		 mov	 ecx, eax
  000a1	c1 c9 08	 ror	 ecx, 8
  000a4	c1 c0 08	 rol	 eax, 8
  000a7	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  000ad	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  000b2	0b c8		 or	 ecx, eax
  000b4	8b c3		 mov	 eax, ebx
  000b6	33 45 fc	 xor	 eax, DWORD PTR _a$2$[ebp]
  000b9	89 4d cc	 mov	 DWORD PTR tv6487[ebp], ecx
  000bc	23 c2		 and	 eax, edx
  000be	33 c3		 xor	 eax, ebx
  000c0	c1 ca 02	 ror	 edx, 2
  000c3	8b ce		 mov	 ecx, esi
  000c5	c1 c1 05	 rol	 ecx, 5
  000c8	03 4d cc	 add	 ecx, DWORD PTR tv6487[ebp]
  000cb	03 c1		 add	 eax, ecx
  000cd	03 f8		 add	 edi, eax

; 83   :             R0(c, d, e, a, b, 3);

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  000d2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000d5	8b c8		 mov	 ecx, eax
  000d7	c1 c9 08	 ror	 ecx, 8
  000da	c1 c0 08	 rol	 eax, 8
  000dd	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  000e3	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  000e8	0b c8		 or	 ecx, eax
  000ea	8b c2		 mov	 eax, edx
  000ec	89 4d c8	 mov	 DWORD PTR tv6479[ebp], ecx
  000ef	8b cf		 mov	 ecx, edi
  000f1	c1 c1 05	 rol	 ecx, 5
  000f4	33 45 fc	 xor	 eax, DWORD PTR _a$2$[ebp]
  000f7	03 4d c8	 add	 ecx, DWORD PTR tv6479[ebp]
  000fa	23 c6		 and	 eax, esi
  000fc	33 45 fc	 xor	 eax, DWORD PTR _a$2$[ebp]
  000ff	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  00105	03 c1		 add	 eax, ecx
  00107	c1 ce 02	 ror	 esi, 2
  0010a	03 d8		 add	 ebx, eax

; 84   :             R0(b, c, d, e, a, 4);

  0010c	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0010f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00112	8b c8		 mov	 ecx, eax
  00114	c1 c0 08	 rol	 eax, 8
  00117	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0011c	c1 c9 08	 ror	 ecx, 8
  0011f	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00125	0b c8		 or	 ecx, eax
  00127	8b c2		 mov	 eax, edx
  00129	33 c6		 xor	 eax, esi
  0012b	89 4d c4	 mov	 DWORD PTR tv6472[ebp], ecx
  0012e	23 c7		 and	 eax, edi
  00130	8b cb		 mov	 ecx, ebx
  00132	33 c2		 xor	 eax, edx
  00134	c1 c1 05	 rol	 ecx, 5
  00137	03 4d c4	 add	 ecx, DWORD PTR tv6472[ebp]

; 85   :             R0(a, b, c, d, e, 5);

  0013a	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  00140	03 c1		 add	 eax, ecx
  00142	c1 cf 02	 ror	 edi, 2
  00145	8b 4d fc	 mov	 ecx, DWORD PTR _a$2$[ebp]
  00148	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  0014e	03 c8		 add	 ecx, eax
  00150	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00153	89 4d bc	 mov	 DWORD PTR _a$4$[ebp], ecx
  00156	c1 c1 05	 rol	 ecx, 5
  00159	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0015c	89 45 fc	 mov	 DWORD PTR tv6401[ebp], eax
  0015f	c1 4d fc 08	 ror	 DWORD PTR tv6401[ebp], 8
  00163	81 65 fc 00 ff
	00 ff		 and	 DWORD PTR tv6401[ebp], -16711936 ; ff00ff00H
  0016a	c1 c0 08	 rol	 eax, 8
  0016d	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00172	09 45 fc	 or	 DWORD PTR tv6401[ebp], eax
  00175	8b c6		 mov	 eax, esi
  00177	03 4d fc	 add	 ecx, DWORD PTR tv6401[ebp]
  0017a	33 c7		 xor	 eax, edi
  0017c	23 c3		 and	 eax, ebx
  0017e	c1 cb 02	 ror	 ebx, 2
  00181	33 c6		 xor	 eax, esi

; 86   :             R0(e, a, b, c, d, 6);

  00183	81 c6 99 79 82
	5a		 add	 esi, 1518500249		; 5a827999H
  00189	03 c8		 add	 ecx, eax
  0018b	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0018e	03 ca		 add	 ecx, edx
  00190	89 4d d0	 mov	 DWORD PTR _e$5$[ebp], ecx
  00193	c1 c1 05	 rol	 ecx, 5
  00196	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00199	8b d0		 mov	 edx, eax
  0019b	c1 c0 08	 rol	 eax, 8
  0019e	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  001a3	c1 ca 08	 ror	 edx, 8
  001a6	81 e2 00 ff 00
	ff		 and	 edx, -16711936		; ff00ff00H
  001ac	0b d0		 or	 edx, eax
  001ae	8b c7		 mov	 eax, edi
  001b0	33 c3		 xor	 eax, ebx
  001b2	89 55 f4	 mov	 DWORD PTR tv6400[ebp], edx
  001b5	8b 55 bc	 mov	 edx, DWORD PTR _a$4$[ebp]
  001b8	23 c2		 and	 eax, edx
  001ba	03 4d f4	 add	 ecx, DWORD PTR tv6400[ebp]
  001bd	33 c7		 xor	 eax, edi
  001bf	03 c8		 add	 ecx, eax
  001c1	c1 ca 02	 ror	 edx, 2

; 87   :             R0(d, e, a, b, c, 7);

  001c4	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  001c7	03 ce		 add	 ecx, esi
  001c9	89 4d bc	 mov	 DWORD PTR _d$5$[ebp], ecx
  001cc	c1 c1 05	 rol	 ecx, 5
  001cf	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001d2	8b f0		 mov	 esi, eax
  001d4	c1 ce 08	 ror	 esi, 8
  001d7	c1 c0 08	 rol	 eax, 8
  001da	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  001e0	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  001e5	0b f0		 or	 esi, eax
  001e7	8b c3		 mov	 eax, ebx
  001e9	89 75 c0	 mov	 DWORD PTR tv6450[ebp], esi
  001ec	33 c2		 xor	 eax, edx
  001ee	03 4d c0	 add	 ecx, DWORD PTR tv6450[ebp]
  001f1	81 c7 99 79 82
	5a		 add	 edi, 1518500249		; 5a827999H
  001f7	8b 75 d0	 mov	 esi, DWORD PTR _e$5$[ebp]
  001fa	23 c6		 and	 eax, esi
  001fc	33 c3		 xor	 eax, ebx
  001fe	c1 ce 02	 ror	 esi, 2
  00201	03 c8		 add	 ecx, eax

; 88   :             R0(c, d, e, a, b, 8);

  00203	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  00209	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0020c	03 cf		 add	 ecx, edi
  0020e	89 4d d0	 mov	 DWORD PTR _c$5$[ebp], ecx
  00211	c1 c1 05	 rol	 ecx, 5
  00214	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00217	8b f8		 mov	 edi, eax
  00219	c1 c0 08	 rol	 eax, 8
  0021c	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00221	c1 cf 08	 ror	 edi, 8
  00224	81 e7 00 ff 00
	ff		 and	 edi, -16711936		; ff00ff00H
  0022a	0b f8		 or	 edi, eax
  0022c	8b c6		 mov	 eax, esi
  0022e	33 c2		 xor	 eax, edx
  00230	89 7d dc	 mov	 DWORD PTR tv6519[ebp], edi
  00233	03 4d dc	 add	 ecx, DWORD PTR tv6519[ebp]
  00236	8b 7d bc	 mov	 edi, DWORD PTR _d$5$[ebp]
  00239	23 c7		 and	 eax, edi
  0023b	33 c2		 xor	 eax, edx
  0023d	c1 cf 02	 ror	 edi, 2
  00240	03 c8		 add	 ecx, eax

; 89   :             R0(b, c, d, e, a, 9);

  00242	81 c2 99 79 82
	5a		 add	 edx, 1518500249		; 5a827999H
  00248	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0024b	03 cb		 add	 ecx, ebx
  0024d	89 4d e0	 mov	 DWORD PTR _b$6$[ebp], ecx
  00250	c1 c1 05	 rol	 ecx, 5
  00253	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00256	8b d8		 mov	 ebx, eax
  00258	c1 c0 08	 rol	 eax, 8
  0025b	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00260	c1 cb 08	 ror	 ebx, 8
  00263	81 e3 00 ff 00
	ff		 and	 ebx, -16711936		; ff00ff00H
  00269	0b d8		 or	 ebx, eax
  0026b	8b c6		 mov	 eax, esi
  0026d	33 c7		 xor	 eax, edi
  0026f	89 5d d8	 mov	 DWORD PTR tv6518[ebp], ebx
  00272	03 4d d8	 add	 ecx, DWORD PTR tv6518[ebp]
  00275	8b 5d d0	 mov	 ebx, DWORD PTR _c$5$[ebp]
  00278	23 c3		 and	 eax, ebx
  0027a	33 c6		 xor	 eax, esi
  0027c	c1 cb 02	 ror	 ebx, 2
  0027f	03 c8		 add	 ecx, eax

; 90   :             R0(a, b, c, d, e, 10);

  00281	81 c6 99 79 82
	5a		 add	 esi, 1518500249		; 5a827999H
  00287	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0028a	03 ca		 add	 ecx, edx
  0028c	89 4d d0	 mov	 DWORD PTR _a$6$[ebp], ecx
  0028f	c1 c1 05	 rol	 ecx, 5
  00292	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00295	8b d0		 mov	 edx, eax
  00297	c1 c0 08	 rol	 eax, 8
  0029a	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0029f	c1 ca 08	 ror	 edx, 8
  002a2	81 e2 00 ff 00
	ff		 and	 edx, -16711936		; ff00ff00H
  002a8	0b d0		 or	 edx, eax
  002aa	8b c7		 mov	 eax, edi
  002ac	33 c3		 xor	 eax, ebx
  002ae	89 55 d4	 mov	 DWORD PTR tv6517[ebp], edx
  002b1	8b 55 e0	 mov	 edx, DWORD PTR _b$6$[ebp]
  002b4	23 c2		 and	 eax, edx
  002b6	03 4d d4	 add	 ecx, DWORD PTR tv6517[ebp]
  002b9	33 c7		 xor	 eax, edi
  002bb	03 c8		 add	 ecx, eax
  002bd	c1 ca 02	 ror	 edx, 2

; 91   :             R0(e, a, b, c, d, 11);

  002c0	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  002c3	03 ce		 add	 ecx, esi
  002c5	89 4d f0	 mov	 DWORD PTR _e$7$[ebp], ecx
  002c8	89 55 e0	 mov	 DWORD PTR _b$6$[ebp], edx
  002cb	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  002ce	8b f0		 mov	 esi, eax
  002d0	c1 ce 08	 ror	 esi, 8
  002d3	c1 c0 08	 rol	 eax, 8
  002d6	81 e6 00 ff 00
	ff		 and	 esi, -16711936		; ff00ff00H
  002dc	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  002e1	0b f0		 or	 esi, eax
  002e3	c1 c1 05	 rol	 ecx, 5
  002e6	8b c3		 mov	 eax, ebx
  002e8	33 c2		 xor	 eax, edx
  002ea	89 75 bc	 mov	 DWORD PTR tv6516[ebp], esi
  002ed	23 45 d0	 and	 eax, DWORD PTR _a$6$[ebp]
  002f0	03 f1		 add	 esi, ecx
  002f2	33 c3		 xor	 eax, ebx
  002f4	81 c7 99 79 82
	5a		 add	 edi, 1518500249		; 5a827999H
  002fa	03 f0		 add	 esi, eax

; 92   :             R0(d, e, a, b, c, 12);

  002fc	81 c3 99 79 82
	5a		 add	 ebx, 1518500249		; 5a827999H
  00302	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00305	03 f7		 add	 esi, edi
  00307	8b 7d d0	 mov	 edi, DWORD PTR _a$6$[ebp]
  0030a	c1 cf 02	 ror	 edi, 2
  0030d	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00310	8b c8		 mov	 ecx, eax
  00312	c1 c9 08	 ror	 ecx, 8
  00315	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  0031b	c1 c0 08	 rol	 eax, 8
  0031e	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00323	0b c8		 or	 ecx, eax
  00325	8b c2		 mov	 eax, edx
  00327	89 4d d0	 mov	 DWORD PTR tv6515[ebp], ecx
  0032a	33 c7		 xor	 eax, edi
  0032c	23 45 f0	 and	 eax, DWORD PTR _e$7$[ebp]
  0032f	8b ce		 mov	 ecx, esi
  00331	33 d0		 xor	 edx, eax
  00333	c1 c1 05	 rol	 ecx, 5
  00336	03 4d d0	 add	 ecx, DWORD PTR tv6515[ebp]

; 93   :             R0(c, d, e, a, b, 13);

  00339	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0033c	03 d1		 add	 edx, ecx
  0033e	03 d3		 add	 edx, ebx
  00340	8b 5d f0	 mov	 ebx, DWORD PTR _e$7$[ebp]
  00343	c1 cb 02	 ror	 ebx, 2
  00346	89 5d f0	 mov	 DWORD PTR _e$7$[ebp], ebx
  00349	33 df		 xor	 ebx, edi
  0034b	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0034e	23 de		 and	 ebx, esi
  00350	8b c8		 mov	 ecx, eax
  00352	c1 ce 02	 ror	 esi, 2
  00355	c1 c9 08	 ror	 ecx, 8
  00358	33 df		 xor	 ebx, edi
  0035a	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  00360	c1 c0 08	 rol	 eax, 8
  00363	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  00368	89 75 b4	 mov	 DWORD PTR _d$7$[ebp], esi
  0036b	0b c8		 or	 ecx, eax

; 94   :             R0(b, c, d, e, a, 14);

  0036d	81 c7 99 79 82
	5a		 add	 edi, 1518500249		; 5a827999H
  00373	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00376	89 4d ec	 mov	 DWORD PTR tv6514[ebp], ecx
  00379	8b ca		 mov	 ecx, edx
  0037b	c1 c1 05	 rol	 ecx, 5
  0037e	03 4d ec	 add	 ecx, DWORD PTR tv6514[ebp]
  00381	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00384	03 d9		 add	 ebx, ecx
  00386	8b 4d e0	 mov	 ecx, DWORD PTR _b$6$[ebp]
  00389	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  0038f	03 d9		 add	 ebx, ecx
  00391	8b c8		 mov	 ecx, eax
  00393	c1 c0 08	 rol	 eax, 8
  00396	c1 c9 08	 ror	 ecx, 8
  00399	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  0039e	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  003a4	0b c8		 or	 ecx, eax
  003a6	8b 45 f0	 mov	 eax, DWORD PTR _e$7$[ebp]
  003a9	89 4d e8	 mov	 DWORD PTR tv6513[ebp], ecx
  003ac	33 c6		 xor	 eax, esi
  003ae	23 c2		 and	 eax, edx
  003b0	8b cb		 mov	 ecx, ebx
  003b2	33 45 f0	 xor	 eax, DWORD PTR _e$7$[ebp]
  003b5	c1 c1 05	 rol	 ecx, 5
  003b8	03 4d e8	 add	 ecx, DWORD PTR tv6513[ebp]
  003bb	03 c1		 add	 eax, ecx
  003bd	c1 ca 02	 ror	 edx, 2
  003c0	03 f8		 add	 edi, eax
  003c2	89 55 e0	 mov	 DWORD PTR _c$7$[ebp], edx

; 95   :             R0(a, b, c, d, e, 15);

  003c5	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  003c8	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  003cb	8b c8		 mov	 ecx, eax
  003cd	c1 c9 08	 ror	 ecx, 8
  003d0	81 e1 00 ff 00
	ff		 and	 ecx, -16711936		; ff00ff00H
  003d6	c1 c0 08	 rol	 eax, 8
  003d9	25 ff 00 ff 00	 and	 eax, 16711935		; 00ff00ffH
  003de	0b c8		 or	 ecx, eax
  003e0	8b c6		 mov	 eax, esi
  003e2	33 c2		 xor	 eax, edx
  003e4	89 4d e4	 mov	 DWORD PTR tv6512[ebp], ecx

; 96   :             R1(e, a, b, c, d, 16);

  003e7	8b 55 cc	 mov	 edx, DWORD PTR tv6487[ebp]
  003ea	23 c3		 and	 eax, ebx
  003ec	33 55 f8	 xor	 edx, DWORD PTR tv6501[ebp]
  003ef	8b cf		 mov	 ecx, edi
  003f1	33 55 ec	 xor	 edx, DWORD PTR tv6514[ebp]
  003f4	33 f0		 xor	 esi, eax
  003f6	33 55 dc	 xor	 edx, DWORD PTR tv6519[ebp]
  003f9	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  003fc	c1 c1 05	 rol	 ecx, 5
  003ff	03 4d e4	 add	 ecx, DWORD PTR tv6512[ebp]
  00402	03 f1		 add	 esi, ecx
  00404	d1 c2		 rol	 edx, 1
  00406	8b 4d f0	 mov	 ecx, DWORD PTR _e$7$[ebp]
  00409	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  0040f	89 10		 mov	 DWORD PTR [eax], edx
  00411	03 f1		 add	 esi, ecx
  00413	c1 cb 02	 ror	 ebx, 2
  00416	89 5d f0	 mov	 DWORD PTR _b$8$[ebp], ebx
  00419	8b ce		 mov	 ecx, esi
  0041b	33 5d e0	 xor	 ebx, DWORD PTR _c$7$[ebp]
  0041e	c1 c1 05	 rol	 ecx, 5
  00421	23 df		 and	 ebx, edi
  00423	33 5d e0	 xor	 ebx, DWORD PTR _c$7$[ebp]
  00426	03 ca		 add	 ecx, edx

; 97   :             R1(d, e, a, b, c, 17);

  00428	8b 55 c8	 mov	 edx, DWORD PTR tv6479[ebp]
  0042b	03 d9		 add	 ebx, ecx
  0042d	33 55 b8	 xor	 edx, DWORD PTR tv6494[ebp]
  00430	33 55 e8	 xor	 edx, DWORD PTR tv6513[ebp]
  00433	33 55 d8	 xor	 edx, DWORD PTR tv6518[ebp]
  00436	8b 4d b4	 mov	 ecx, DWORD PTR _d$7$[ebp]
  00439	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  0043f	d1 c2		 rol	 edx, 1
  00441	03 d9		 add	 ebx, ecx
  00443	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00446	c1 cf 02	 ror	 edi, 2
  00449	8b cb		 mov	 ecx, ebx
  0044b	c1 c1 05	 rol	 ecx, 5
  0044e	03 ca		 add	 ecx, edx
  00450	89 7d f8	 mov	 DWORD PTR _a$8$[ebp], edi
  00453	33 7d f0	 xor	 edi, DWORD PTR _b$8$[ebp]

; 98   :             R1(c, d, e, a, b, 18);

  00456	8b 55 c4	 mov	 edx, DWORD PTR tv6472[ebp]
  00459	23 fe		 and	 edi, esi
  0045b	33 55 cc	 xor	 edx, DWORD PTR tv6487[ebp]
  0045e	33 55 e4	 xor	 edx, DWORD PTR tv6512[ebp]
  00461	33 7d f0	 xor	 edi, DWORD PTR _b$8$[ebp]
  00464	33 55 d4	 xor	 edx, DWORD PTR tv6517[ebp]
  00467	03 f9		 add	 edi, ecx
  00469	8b 4d e0	 mov	 ecx, DWORD PTR _c$7$[ebp]
  0046c	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  00472	d1 c2		 rol	 edx, 1
  00474	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00477	03 f9		 add	 edi, ecx
  00479	c1 ce 02	 ror	 esi, 2
  0047c	8b cf		 mov	 ecx, edi
  0047e	c1 c1 05	 rol	 ecx, 5
  00481	8b c6		 mov	 eax, esi
  00483	33 45 f8	 xor	 eax, DWORD PTR _a$8$[ebp]
  00486	03 ca		 add	 ecx, edx

; 99   :             R1(b, c, d, e, a, 19);

  00488	8b 55 fc	 mov	 edx, DWORD PTR tv6401[ebp]
  0048b	23 c3		 and	 eax, ebx
  0048d	33 45 f8	 xor	 eax, DWORD PTR _a$8$[ebp]
  00490	33 55 c8	 xor	 edx, DWORD PTR tv6479[ebp]
  00493	03 c1		 add	 eax, ecx
  00495	8b 4d f0	 mov	 ecx, DWORD PTR _b$8$[ebp]
  00498	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  0049e	c1 cb 02	 ror	 ebx, 2
  004a1	03 c1		 add	 eax, ecx
  004a3	89 7d e0	 mov	 DWORD PTR _c$9$[ebp], edi
  004a6	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  004a9	89 45 f0	 mov	 DWORD PTR _b$10$[ebp], eax
  004ac	33 11		 xor	 edx, DWORD PTR [ecx]
  004ae	33 55 bc	 xor	 edx, DWORD PTR tv6516[ebp]
  004b1	d1 c2		 rol	 edx, 1
  004b3	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  004b6	8b c8		 mov	 ecx, eax
  004b8	c1 4d e0 02	 ror	 DWORD PTR _c$9$[ebp], 2
  004bc	8b c6		 mov	 eax, esi
  004be	33 c3		 xor	 eax, ebx
  004c0	c1 c1 05	 rol	 ecx, 5
  004c3	23 f8		 and	 edi, eax
  004c5	03 ca		 add	 ecx, edx

; 100  :             R2(a, b, c, d, e, 20);

  004c7	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  004ca	33 fe		 xor	 edi, esi
  004cc	8b 55 f4	 mov	 edx, DWORD PTR tv6400[ebp]
  004cf	03 f9		 add	 edi, ecx
  004d1	33 55 c4	 xor	 edx, DWORD PTR tv6472[ebp]
  004d4	81 c6 a1 eb d9
	6e		 add	 esi, 1859775393		; 6ed9eba1H
  004da	8b 4d f8	 mov	 ecx, DWORD PTR _a$8$[ebp]
  004dd	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  004e0	81 c1 99 79 82
	5a		 add	 ecx, 1518500249		; 5a827999H
  004e6	33 55 d0	 xor	 edx, DWORD PTR tv6515[ebp]
  004e9	03 f9		 add	 edi, ecx
  004eb	d1 c2		 rol	 edx, 1
  004ed	8b cf		 mov	 ecx, edi
  004ef	89 50 10	 mov	 DWORD PTR [eax+16], edx
  004f2	8b c3		 mov	 eax, ebx
  004f4	33 45 e0	 xor	 eax, DWORD PTR _c$9$[ebp]
  004f7	33 45 f0	 xor	 eax, DWORD PTR _b$10$[ebp]
  004fa	c1 4d f0 02	 ror	 DWORD PTR _b$10$[ebp], 2
  004fe	c1 c1 05	 rol	 ecx, 5
  00501	03 d1		 add	 edx, ecx

; 101  :             R2(e, a, b, c, d, 21);

  00503	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00506	03 d0		 add	 edx, eax
  00508	8b 45 fc	 mov	 eax, DWORD PTR tv6401[ebp]
  0050b	03 d6		 add	 edx, esi
  0050d	8b 75 e0	 mov	 esi, DWORD PTR _c$9$[ebp]
  00510	33 41 08	 xor	 eax, DWORD PTR [ecx+8]
  00513	33 45 ec	 xor	 eax, DWORD PTR tv6514[ebp]
  00516	33 45 c0	 xor	 eax, DWORD PTR tv6450[ebp]
  00519	d1 c0		 rol	 eax, 1
  0051b	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0051e	8b ca		 mov	 ecx, edx
  00520	89 45 fc	 mov	 DWORD PTR tv6401[ebp], eax
  00523	8b c6		 mov	 eax, esi
  00525	33 45 f0	 xor	 eax, DWORD PTR _b$10$[ebp]

; 102  :             R2(d, e, a, b, c, 22);

  00528	81 c6 a1 eb d9
	6e		 add	 esi, 1859775393		; 6ed9eba1H
  0052e	33 c7		 xor	 eax, edi
  00530	c1 c1 05	 rol	 ecx, 5
  00533	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  00539	c1 cf 02	 ror	 edi, 2
  0053c	03 4d fc	 add	 ecx, DWORD PTR tv6401[ebp]
  0053f	03 c1		 add	 eax, ecx
  00541	89 7d b4	 mov	 DWORD PTR _a$10$[ebp], edi
  00544	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00547	03 d8		 add	 ebx, eax
  00549	8b 45 f4	 mov	 eax, DWORD PTR tv6400[ebp]
  0054c	33 41 0c	 xor	 eax, DWORD PTR [ecx+12]
  0054f	33 45 e8	 xor	 eax, DWORD PTR tv6513[ebp]
  00552	33 45 dc	 xor	 eax, DWORD PTR tv6519[ebp]
  00555	d1 c0		 rol	 eax, 1
  00557	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0055a	8b cb		 mov	 ecx, ebx
  0055c	89 45 f4	 mov	 DWORD PTR tv6400[ebp], eax
  0055f	8b c2		 mov	 eax, edx
  00561	33 45 f0	 xor	 eax, DWORD PTR _b$10$[ebp]
  00564	33 c7		 xor	 eax, edi
  00566	c1 c1 05	 rol	 ecx, 5
  00569	03 4d f4	 add	 ecx, DWORD PTR tv6400[ebp]
  0056c	03 c1		 add	 eax, ecx
  0056e	c1 ca 02	 ror	 edx, 2

; 103  :             R2(c, d, e, a, b, 23);

  00571	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00574	03 f0		 add	 esi, eax
  00576	89 55 b8	 mov	 DWORD PTR _e$11$[ebp], edx
  00579	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0057c	33 45 e4	 xor	 eax, DWORD PTR tv6512[ebp]
  0057f	33 45 d8	 xor	 eax, DWORD PTR tv6518[ebp]
  00582	33 45 c0	 xor	 eax, DWORD PTR tv6450[ebp]
  00585	d1 c0		 rol	 eax, 1
  00587	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0058a	8b ce		 mov	 ecx, esi
  0058c	89 45 c0	 mov	 DWORD PTR tv6399[ebp], eax
  0058f	8b c2		 mov	 eax, edx
  00591	33 c3		 xor	 eax, ebx
  00593	c1 c1 05	 rol	 ecx, 5
  00596	33 f8		 xor	 edi, eax
  00598	03 4d c0	 add	 ecx, DWORD PTR tv6399[ebp]
  0059b	03 f9		 add	 edi, ecx
  0059d	c1 cb 02	 ror	 ebx, 2
  005a0	8b 4d f0	 mov	 ecx, DWORD PTR _b$10$[ebp]

; 104  :             R2(b, c, d, e, a, 24);

  005a3	33 d3		 xor	 edx, ebx
  005a5	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  005ab	89 5d e0	 mov	 DWORD PTR _d$11$[ebp], ebx
  005ae	03 f9		 add	 edi, ecx
  005b0	33 d6		 xor	 edx, esi
  005b2	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  005b5	c1 ce 02	 ror	 esi, 2

; 105  :             R2(a, b, c, d, e, 25);

  005b8	33 de		 xor	 ebx, esi
  005ba	33 df		 xor	 ebx, edi
  005bc	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  005bf	33 01		 xor	 eax, DWORD PTR [ecx]
  005c1	33 45 d4	 xor	 eax, DWORD PTR tv6517[ebp]
  005c4	33 45 dc	 xor	 eax, DWORD PTR tv6519[ebp]
  005c7	d1 c0		 rol	 eax, 1
  005c9	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  005cc	8b cf		 mov	 ecx, edi
  005ce	c1 c1 05	 rol	 ecx, 5
  005d1	03 c8		 add	 ecx, eax
  005d3	89 45 c4	 mov	 DWORD PTR tv6398[ebp], eax
  005d6	03 d1		 add	 edx, ecx
  005d8	c1 cf 02	 ror	 edi, 2
  005db	8b 4d b4	 mov	 ecx, DWORD PTR _a$10$[ebp]
  005de	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  005e4	89 75 b4	 mov	 DWORD PTR _c$11$[ebp], esi
  005e7	03 d1		 add	 edx, ecx
  005e9	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  005ec	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  005ef	33 45 bc	 xor	 eax, DWORD PTR tv6516[ebp]
  005f2	33 45 d8	 xor	 eax, DWORD PTR tv6518[ebp]
  005f5	33 45 f4	 xor	 eax, DWORD PTR tv6400[ebp]
  005f8	d1 c0		 rol	 eax, 1
  005fa	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  005fd	8b ca		 mov	 ecx, edx
  005ff	c1 c1 05	 rol	 ecx, 5
  00602	03 c8		 add	 ecx, eax
  00604	89 45 c8	 mov	 DWORD PTR tv6396[ebp], eax
  00607	03 d9		 add	 ebx, ecx
  00609	89 7d d8	 mov	 DWORD PTR _b$12$[ebp], edi
  0060c	8b 4d b8	 mov	 ecx, DWORD PTR _e$11$[ebp]
  0060f	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  00615	03 d9		 add	 ebx, ecx

; 106  :             R2(e, a, b, c, d, 26);

  00617	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0061a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0061d	33 45 d0	 xor	 eax, DWORD PTR tv6515[ebp]
  00620	33 45 d4	 xor	 eax, DWORD PTR tv6517[ebp]
  00623	33 45 c0	 xor	 eax, DWORD PTR tv6399[ebp]
  00626	d1 c0		 rol	 eax, 1
  00628	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  0062b	8b cb		 mov	 ecx, ebx
  0062d	89 45 cc	 mov	 DWORD PTR tv6395[ebp], eax
  00630	8b c6		 mov	 eax, esi
  00632	c1 c1 05	 rol	 ecx, 5
  00635	33 c7		 xor	 eax, edi
  00637	03 4d cc	 add	 ecx, DWORD PTR tv6395[ebp]
  0063a	33 c2		 xor	 eax, edx
  0063c	03 c1		 add	 eax, ecx
  0063e	c1 ca 02	 ror	 edx, 2
  00641	8b 4d e0	 mov	 ecx, DWORD PTR _d$11$[ebp]
  00644	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  0064a	03 c1		 add	 eax, ecx

; 107  :             R2(d, e, a, b, c, 27);

  0064c	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0064f	89 45 d4	 mov	 DWORD PTR _d$13$[ebp], eax
  00652	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00655	33 75 ec	 xor	 esi, DWORD PTR tv6514[ebp]
  00658	33 75 bc	 xor	 esi, DWORD PTR tv6516[ebp]
  0065b	33 75 c4	 xor	 esi, DWORD PTR tv6398[ebp]
  0065e	d1 c6		 rol	 esi, 1
  00660	89 71 2c	 mov	 DWORD PTR [ecx+44], esi
  00663	8b c8		 mov	 ecx, eax
  00665	c1 c1 05	 rol	 ecx, 5
  00668	8b c3		 mov	 eax, ebx
  0066a	33 c7		 xor	 eax, edi
  0066c	03 ce		 add	 ecx, esi
  0066e	33 c2		 xor	 eax, edx
  00670	03 c1		 add	 eax, ecx
  00672	8b 4d b4	 mov	 ecx, DWORD PTR _c$11$[ebp]
  00675	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  0067b	03 c1		 add	 eax, ecx

; 108  :             R2(c, d, e, a, b, 28);

  0067d	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00680	89 45 f0	 mov	 DWORD PTR _c$13$[ebp], eax
  00683	c1 cb 02	 ror	 ebx, 2
  00686	89 5d b8	 mov	 DWORD PTR _e$13$[ebp], ebx
  00689	8b 79 10	 mov	 edi, DWORD PTR [ecx+16]
  0068c	33 7d e8	 xor	 edi, DWORD PTR tv6513[ebp]
  0068f	33 7d d0	 xor	 edi, DWORD PTR tv6515[ebp]
  00692	33 7d c8	 xor	 edi, DWORD PTR tv6396[ebp]
  00695	d1 c7		 rol	 edi, 1
  00697	89 79 30	 mov	 DWORD PTR [ecx+48], edi
  0069a	8b c8		 mov	 ecx, eax
  0069c	c1 c1 05	 rol	 ecx, 5
  0069f	8b c3		 mov	 eax, ebx
  006a1	8b 5d d4	 mov	 ebx, DWORD PTR _d$13$[ebp]
  006a4	03 cf		 add	 ecx, edi
  006a6	33 c3		 xor	 eax, ebx
  006a8	c1 cb 02	 ror	 ebx, 2
  006ab	33 c2		 xor	 eax, edx
  006ad	89 5d d4	 mov	 DWORD PTR _d$13$[ebp], ebx
  006b0	03 c1		 add	 eax, ecx

; 109  :             R2(b, c, d, e, a, 29);

  006b2	81 c2 a1 eb d9
	6e		 add	 edx, 1859775393		; 6ed9eba1H
  006b8	8b 4d d8	 mov	 ecx, DWORD PTR _b$12$[ebp]
  006bb	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  006c1	03 c1		 add	 eax, ecx
  006c3	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  006c6	89 45 f8	 mov	 DWORD PTR _b$14$[ebp], eax
  006c9	8b 59 14	 mov	 ebx, DWORD PTR [ecx+20]
  006cc	33 5d e4	 xor	 ebx, DWORD PTR tv6512[ebp]
  006cf	33 5d ec	 xor	 ebx, DWORD PTR tv6514[ebp]
  006d2	33 5d cc	 xor	 ebx, DWORD PTR tv6395[ebp]
  006d5	d1 c3		 rol	 ebx, 1
  006d7	89 59 34	 mov	 DWORD PTR [ecx+52], ebx
  006da	8b c8		 mov	 ecx, eax
  006dc	8b 45 b8	 mov	 eax, DWORD PTR _e$13$[ebp]
  006df	33 45 d4	 xor	 eax, DWORD PTR _d$13$[ebp]
  006e2	33 45 f0	 xor	 eax, DWORD PTR _c$13$[ebp]
  006e5	c1 4d f0 02	 ror	 DWORD PTR _c$13$[ebp], 2
  006e9	c1 c1 05	 rol	 ecx, 5
  006ec	03 cb		 add	 ecx, ebx
  006ee	03 c1		 add	 eax, ecx

; 110  :             R2(a, b, c, d, e, 30);

  006f0	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  006f3	03 c2		 add	 eax, edx
  006f5	89 45 bc	 mov	 DWORD PTR _a$14$[ebp], eax
  006f8	8b 11		 mov	 edx, DWORD PTR [ecx]
  006fa	33 55 e8	 xor	 edx, DWORD PTR tv6513[ebp]
  006fd	33 d6		 xor	 edx, esi
  006ff	8b 75 d4	 mov	 esi, DWORD PTR _d$13$[ebp]
  00702	33 55 f4	 xor	 edx, DWORD PTR tv6400[ebp]
  00705	d1 c2		 rol	 edx, 1
  00707	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  0070a	8b c8		 mov	 ecx, eax
  0070c	c1 c1 05	 rol	 ecx, 5
  0070f	8b c6		 mov	 eax, esi
  00711	33 45 f0	 xor	 eax, DWORD PTR _c$13$[ebp]
  00714	03 ca		 add	 ecx, edx
  00716	33 45 f8	 xor	 eax, DWORD PTR _b$14$[ebp]

; 111  :             R2(e, a, b, c, d, 31);

  00719	81 c6 a1 eb d9
	6e		 add	 esi, 1859775393		; 6ed9eba1H
  0071f	03 c1		 add	 eax, ecx
  00721	c1 4d f8 02	 ror	 DWORD PTR _b$14$[ebp], 2
  00725	8b 4d b8	 mov	 ecx, DWORD PTR _e$13$[ebp]
  00728	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  0072e	03 c1		 add	 eax, ecx
  00730	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00733	89 45 b8	 mov	 DWORD PTR _e$15$[ebp], eax
  00736	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00739	33 55 e4	 xor	 edx, DWORD PTR tv6512[ebp]
  0073c	33 d7		 xor	 edx, edi
  0073e	8b 7d f0	 mov	 edi, DWORD PTR _c$13$[ebp]
  00741	33 55 c0	 xor	 edx, DWORD PTR tv6399[ebp]
  00744	d1 c2		 rol	 edx, 1
  00746	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00749	8b c8		 mov	 ecx, eax
  0074b	8b c7		 mov	 eax, edi
  0074d	c1 c1 05	 rol	 ecx, 5
  00750	33 45 f8	 xor	 eax, DWORD PTR _b$14$[ebp]
  00753	03 ca		 add	 ecx, edx
  00755	33 45 bc	 xor	 eax, DWORD PTR _a$14$[ebp]
  00758	03 c1		 add	 eax, ecx
  0075a	03 c6		 add	 eax, esi
  0075c	8b 75 bc	 mov	 esi, DWORD PTR _a$14$[ebp]
  0075f	89 45 c0	 mov	 DWORD PTR _d$15$[ebp], eax

; 112  :             R2(d, e, a, b, c, 32);

  00762	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00765	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  0076b	c1 ce 02	 ror	 esi, 2
  0076e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00771	33 11		 xor	 edx, DWORD PTR [ecx]
  00773	33 d3		 xor	 edx, ebx
  00775	8b 5d f8	 mov	 ebx, DWORD PTR _b$14$[ebp]
  00778	33 55 c4	 xor	 edx, DWORD PTR tv6398[ebp]
  0077b	d1 c2		 rol	 edx, 1
  0077d	89 11		 mov	 DWORD PTR [ecx], edx
  0077f	8b c8		 mov	 ecx, eax
  00781	8b 45 b8	 mov	 eax, DWORD PTR _e$15$[ebp]
  00784	33 c3		 xor	 eax, ebx
  00786	c1 c1 05	 rol	 ecx, 5
  00789	03 ca		 add	 ecx, edx
  0078b	33 c6		 xor	 eax, esi
  0078d	03 c1		 add	 eax, ecx

; 113  :             R2(c, d, e, a, b, 33);

  0078f	81 c3 a1 eb d9
	6e		 add	 ebx, 1859775393		; 6ed9eba1H
  00795	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00798	03 c7		 add	 eax, edi
  0079a	8b 7d b8	 mov	 edi, DWORD PTR _e$15$[ebp]
  0079d	89 45 d0	 mov	 DWORD PTR _c$15$[ebp], eax
  007a0	c1 cf 02	 ror	 edi, 2
  007a3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  007a6	33 51 04	 xor	 edx, DWORD PTR [ecx+4]
  007a9	33 55 c8	 xor	 edx, DWORD PTR tv6396[ebp]
  007ac	33 51 38	 xor	 edx, DWORD PTR [ecx+56]
  007af	d1 c2		 rol	 edx, 1
  007b1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  007b4	8b c8		 mov	 ecx, eax
  007b6	c1 c1 05	 rol	 ecx, 5
  007b9	8b c7		 mov	 eax, edi
  007bb	33 45 c0	 xor	 eax, DWORD PTR _d$15$[ebp]
  007be	03 ca		 add	 ecx, edx
  007c0	33 c6		 xor	 eax, esi

; 114  :             R2(b, c, d, e, a, 34);

  007c2	81 c6 a1 eb d9
	6e		 add	 esi, 1859775393		; 6ed9eba1H
  007c8	03 c1		 add	 eax, ecx
  007ca	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  007cd	03 c3		 add	 eax, ebx
  007cf	8b 5d c0	 mov	 ebx, DWORD PTR _d$15$[ebp]
  007d2	89 45 f0	 mov	 DWORD PTR _b$16$[ebp], eax
  007d5	c1 cb 02	 ror	 ebx, 2
  007d8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  007db	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  007de	33 55 cc	 xor	 edx, DWORD PTR tv6395[ebp]
  007e1	33 51 3c	 xor	 edx, DWORD PTR [ecx+60]
  007e4	d1 c2		 rol	 edx, 1
  007e6	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  007e9	8b c8		 mov	 ecx, eax
  007eb	c1 c1 05	 rol	 ecx, 5
  007ee	8b c7		 mov	 eax, edi
  007f0	03 ca		 add	 ecx, edx
  007f2	33 c3		 xor	 eax, ebx
  007f4	33 45 d0	 xor	 eax, DWORD PTR _c$15$[ebp]

; 115  :             R2(a, b, c, d, e, 35);

  007f7	81 c7 a1 eb d9
	6e		 add	 edi, 1859775393		; 6ed9eba1H
  007fd	03 c1		 add	 eax, ecx
  007ff	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00802	03 c6		 add	 eax, esi
  00804	8b 75 d0	 mov	 esi, DWORD PTR _c$15$[ebp]
  00807	89 45 e4	 mov	 DWORD PTR _a$16$[ebp], eax
  0080a	c1 ce 02	 ror	 esi, 2
  0080d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00810	33 51 0c	 xor	 edx, DWORD PTR [ecx+12]
  00813	33 11		 xor	 edx, DWORD PTR [ecx]
  00815	33 51 2c	 xor	 edx, DWORD PTR [ecx+44]
  00818	d1 c2		 rol	 edx, 1
  0081a	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0081d	8b c8		 mov	 ecx, eax
  0081f	c1 c1 05	 rol	 ecx, 5
  00822	8b c3		 mov	 eax, ebx
  00824	33 c6		 xor	 eax, esi
  00826	89 75 d0	 mov	 DWORD PTR _c$15$[ebp], esi
  00829	33 45 f0	 xor	 eax, DWORD PTR _b$16$[ebp]
  0082c	03 ca		 add	 ecx, edx
  0082e	03 c1		 add	 eax, ecx

; 116  :             R2(e, a, b, c, d, 36);

  00830	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00833	03 c7		 add	 eax, edi
  00835	c1 4d f0 02	 ror	 DWORD PTR _b$16$[ebp], 2
  00839	89 45 e8	 mov	 DWORD PTR _e$17$[ebp], eax
  0083c	8b 79 18	 mov	 edi, DWORD PTR [ecx+24]
  0083f	8b d7		 mov	 edx, edi
  00841	33 51 10	 xor	 edx, DWORD PTR [ecx+16]
  00844	81 c3 a1 eb d9
	6e		 add	 ebx, 1859775393		; 6ed9eba1H
  0084a	33 51 04	 xor	 edx, DWORD PTR [ecx+4]
  0084d	33 51 30	 xor	 edx, DWORD PTR [ecx+48]
  00850	d1 c2		 rol	 edx, 1
  00852	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00855	8b c8		 mov	 ecx, eax
  00857	c1 c1 05	 rol	 ecx, 5
  0085a	8b c6		 mov	 eax, esi
  0085c	33 45 f0	 xor	 eax, DWORD PTR _b$16$[ebp]
  0085f	03 ca		 add	 ecx, edx
  00861	8b 75 e4	 mov	 esi, DWORD PTR _a$16$[ebp]
  00864	33 c6		 xor	 eax, esi
  00866	03 c1		 add	 eax, ecx
  00868	c1 ce 02	 ror	 esi, 2

; 117  :             R2(d, e, a, b, c, 37);

  0086b	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0086e	03 c3		 add	 eax, ebx

; 118  :             R2(c, d, e, a, b, 38);

  00870	8b 5d 0c	 mov	 ebx, DWORD PTR _buffer$[ebp]
  00873	89 75 e4	 mov	 DWORD PTR _a$16$[ebp], esi
  00876	89 45 f4	 mov	 DWORD PTR _d$17$[ebp], eax
  00879	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]
  0087c	8b d6		 mov	 edx, esi
  0087e	33 51 14	 xor	 edx, DWORD PTR [ecx+20]
  00881	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  00884	33 51 34	 xor	 edx, DWORD PTR [ecx+52]
  00887	33 7b 0c	 xor	 edi, DWORD PTR [ebx+12]
  0088a	33 7b 38	 xor	 edi, DWORD PTR [ebx+56]
  0088d	d1 c2		 rol	 edx, 1
  0088f	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  00892	8b c8		 mov	 ecx, eax
  00894	8b 45 e8	 mov	 eax, DWORD PTR _e$17$[ebp]
  00897	33 45 f0	 xor	 eax, DWORD PTR _b$16$[ebp]
  0089a	33 45 e4	 xor	 eax, DWORD PTR _a$16$[ebp]
  0089d	c1 c1 05	 rol	 ecx, 5
  008a0	03 ca		 add	 ecx, edx
  008a2	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  008a5	03 c1		 add	 eax, ecx
  008a7	8b 4d d0	 mov	 ecx, DWORD PTR _c$15$[ebp]
  008aa	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  008b0	03 c8		 add	 ecx, eax
  008b2	8b 45 e8	 mov	 eax, DWORD PTR _e$17$[ebp]
  008b5	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  008b8	33 fa		 xor	 edi, edx
  008ba	c1 c8 02	 ror	 eax, 2
  008bd	89 4d ec	 mov	 DWORD PTR _c$17$[ebp], ecx
  008c0	89 45 e8	 mov	 DWORD PTR _e$17$[ebp], eax
  008c3	33 45 f4	 xor	 eax, DWORD PTR _d$17$[ebp]
  008c6	33 45 e4	 xor	 eax, DWORD PTR _a$16$[ebp]
  008c9	c1 c1 05	 rol	 ecx, 5
  008cc	d1 c7		 rol	 edi, 1
  008ce	03 cf		 add	 ecx, edi
  008d0	89 7b 18	 mov	 DWORD PTR [ebx+24], edi
  008d3	8b 5d f0	 mov	 ebx, DWORD PTR _b$16$[ebp]
  008d6	03 c1		 add	 eax, ecx

; 119  :             R2(b, c, d, e, a, 39);

  008d8	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  008db	81 c3 a1 eb d9
	6e		 add	 ebx, 1859775393		; 6ed9eba1H
  008e1	03 c3		 add	 eax, ebx
  008e3	8b 5d f4	 mov	 ebx, DWORD PTR _d$17$[ebp]
  008e6	89 45 f0	 mov	 DWORD PTR _b$18$[ebp], eax
  008e9	c1 cb 02	 ror	 ebx, 2
  008ec	33 71 10	 xor	 esi, DWORD PTR [ecx+16]
  008ef	33 71 3c	 xor	 esi, DWORD PTR [ecx+60]
  008f2	8b 79 24	 mov	 edi, DWORD PTR [ecx+36]
  008f5	33 f7		 xor	 esi, edi
  008f7	d1 c6		 rol	 esi, 1
  008f9	89 71 1c	 mov	 DWORD PTR [ecx+28], esi
  008fc	8b c8		 mov	 ecx, eax
  008fe	8b 45 e8	 mov	 eax, DWORD PTR _e$17$[ebp]
  00901	c1 c1 05	 rol	 ecx, 5
  00904	33 c3		 xor	 eax, ebx
  00906	33 45 ec	 xor	 eax, DWORD PTR _c$17$[ebp]
  00909	03 ce		 add	 ecx, esi
  0090b	03 c1		 add	 eax, ecx
  0090d	89 5d f4	 mov	 DWORD PTR _d$17$[ebp], ebx
  00910	8b 4d e4	 mov	 ecx, DWORD PTR _a$16$[ebp]
  00913	81 c1 a1 eb d9
	6e		 add	 ecx, 1859775393		; 6ed9eba1H
  00919	03 c8		 add	 ecx, eax
  0091b	8b 45 ec	 mov	 eax, DWORD PTR _c$17$[ebp]
  0091e	c1 c8 02	 ror	 eax, 2
  00921	89 4d f8	 mov	 DWORD PTR _a$18$[ebp], ecx
  00924	89 45 ec	 mov	 DWORD PTR _c$17$[ebp], eax

; 120  :             R3(a, b, c, d, e, 40);

  00927	8b 75 0c	 mov	 esi, DWORD PTR _buffer$[ebp]
  0092a	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0092d	8b 5e 28	 mov	 ebx, DWORD PTR [esi+40]
  00930	8b 76 14	 mov	 esi, DWORD PTR [esi+20]
  00933	33 30		 xor	 esi, DWORD PTR [eax]
  00935	33 f3		 xor	 esi, ebx
  00937	33 f2		 xor	 esi, edx
  00939	8b d0		 mov	 edx, eax
  0093b	8b 45 ec	 mov	 eax, DWORD PTR _c$17$[ebp]
  0093e	d1 c6		 rol	 esi, 1
  00940	89 72 20	 mov	 DWORD PTR [edx+32], esi
  00943	8b d1		 mov	 edx, ecx
  00945	8b c8		 mov	 ecx, eax
  00947	c1 c2 05	 rol	 edx, 5
  0094a	0b 4d f0	 or	 ecx, DWORD PTR _b$18$[ebp]
  0094d	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00953	23 4d f4	 and	 ecx, DWORD PTR _d$17$[ebp]
  00956	23 45 f0	 and	 eax, DWORD PTR _b$18$[ebp]
  00959	0b c8		 or	 ecx, eax
  0095b	8b 45 f0	 mov	 eax, DWORD PTR _b$18$[ebp]
  0095e	03 ce		 add	 ecx, esi
  00960	c1 c8 02	 ror	 eax, 2
  00963	03 4d e8	 add	 ecx, DWORD PTR _e$17$[ebp]
  00966	03 ca		 add	 ecx, edx
  00968	89 45 f0	 mov	 DWORD PTR _b$18$[ebp], eax

; 121  :             R3(e, a, b, c, d, 41);

  0096b	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0096e	89 4d b8	 mov	 DWORD PTR _e$19$[ebp], ecx
  00971	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00974	8b f2		 mov	 esi, edx
  00976	89 55 fc	 mov	 DWORD PTR tv6374[ebp], edx
  00979	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0097c	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  0097f	33 72 2c	 xor	 esi, DWORD PTR [edx+44]
  00982	33 f7		 xor	 esi, edi

; 122  :             R3(d, e, a, b, c, 42);

  00984	8b 7d b8	 mov	 edi, DWORD PTR _e$19$[ebp]
  00987	d1 c6		 rol	 esi, 1
  00989	89 72 24	 mov	 DWORD PTR [edx+36], esi
  0098c	8b d1		 mov	 edx, ecx
  0098e	8b c8		 mov	 ecx, eax
  00990	c1 c2 05	 rol	 edx, 5
  00993	0b 4d f8	 or	 ecx, DWORD PTR _a$18$[ebp]
  00996	23 4d ec	 and	 ecx, DWORD PTR _c$17$[ebp]
  00999	23 45 f8	 and	 eax, DWORD PTR _a$18$[ebp]
  0099c	0b c8		 or	 ecx, eax
  0099e	c1 4d f8 02	 ror	 DWORD PTR _a$18$[ebp], 2
  009a2	03 ce		 add	 ecx, esi
  009a4	c1 cf 02	 ror	 edi, 2
  009a7	03 4d f4	 add	 ecx, DWORD PTR _d$17$[ebp]
  009aa	8d 82 dc bc 1b
	8f		 lea	 eax, DWORD PTR [edx-1894007588]
  009b0	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  009b3	03 c1		 add	 eax, ecx
  009b5	89 45 bc	 mov	 DWORD PTR _d$19$[ebp], eax
  009b8	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  009bb	8b f1		 mov	 esi, ecx
  009bd	33 72 08	 xor	 esi, DWORD PTR [edx+8]
  009c0	33 72 30	 xor	 esi, DWORD PTR [edx+48]
  009c3	33 f3		 xor	 esi, ebx
  009c5	89 4d e0	 mov	 DWORD PTR tv6371[ebp], ecx
  009c8	d1 c6		 rol	 esi, 1
  009ca	89 72 28	 mov	 DWORD PTR [edx+40], esi
  009cd	8b d0		 mov	 edx, eax
  009cf	8b 45 b8	 mov	 eax, DWORD PTR _e$19$[ebp]
  009d2	8b c8		 mov	 ecx, eax
  009d4	0b 4d f8	 or	 ecx, DWORD PTR _a$18$[ebp]
  009d7	23 4d f0	 and	 ecx, DWORD PTR _b$18$[ebp]
  009da	23 45 f8	 and	 eax, DWORD PTR _a$18$[ebp]
  009dd	0b c8		 or	 ecx, eax
  009df	c1 c2 05	 rol	 edx, 5
  009e2	03 ce		 add	 ecx, esi
  009e4	03 4d ec	 add	 ecx, DWORD PTR _c$17$[ebp]
  009e7	8d 82 dc bc 1b
	8f		 lea	 eax, DWORD PTR [edx-1894007588]
  009ed	03 c1		 add	 eax, ecx

; 123  :             R3(c, d, e, a, b, 43);

  009ef	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  009f2	89 45 e4	 mov	 DWORD PTR _c$19$[ebp], eax
  009f5	8b d0		 mov	 edx, eax
  009f7	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  009fa	33 71 34	 xor	 esi, DWORD PTR [ecx+52]
  009fd	33 71 2c	 xor	 esi, DWORD PTR [ecx+44]
  00a00	33 71 20	 xor	 esi, DWORD PTR [ecx+32]
  00a03	d1 c6		 rol	 esi, 1
  00a05	89 71 2c	 mov	 DWORD PTR [ecx+44], esi
  00a08	c1 c2 05	 rol	 edx, 5
  00a0b	8b cf		 mov	 ecx, edi
  00a0d	0b 4d bc	 or	 ecx, DWORD PTR _d$19$[ebp]
  00a10	8b c7		 mov	 eax, edi
  00a12	23 4d f8	 and	 ecx, DWORD PTR _a$18$[ebp]
  00a15	23 45 bc	 and	 eax, DWORD PTR _d$19$[ebp]
  00a18	0b c8		 or	 ecx, eax
  00a1a	8b 5d bc	 mov	 ebx, DWORD PTR _d$19$[ebp]
  00a1d	03 ce		 add	 ecx, esi
  00a1f	c1 cb 02	 ror	 ebx, 2
  00a22	03 4d f0	 add	 ecx, DWORD PTR _b$18$[ebp]
  00a25	8d 82 dc bc 1b
	8f		 lea	 eax, DWORD PTR [edx-1894007588]
  00a2b	03 c1		 add	 eax, ecx

; 124  :             R3(b, c, d, e, a, 44);

  00a2d	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00a30	89 45 e8	 mov	 DWORD PTR _b$20$[ebp], eax
  00a33	8b d0		 mov	 edx, eax
  00a35	c1 c2 05	 rol	 edx, 5
  00a38	8b c3		 mov	 eax, ebx
  00a3a	23 45 e4	 and	 eax, DWORD PTR _c$19$[ebp]
  00a3d	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00a43	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00a46	33 71 38	 xor	 esi, DWORD PTR [ecx+56]
  00a49	33 71 30	 xor	 esi, DWORD PTR [ecx+48]
  00a4c	33 71 24	 xor	 esi, DWORD PTR [ecx+36]
  00a4f	d1 c6		 rol	 esi, 1
  00a51	89 71 30	 mov	 DWORD PTR [ecx+48], esi
  00a54	8b cb		 mov	 ecx, ebx
  00a56	0b 4d e4	 or	 ecx, DWORD PTR _c$19$[ebp]
  00a59	23 cf		 and	 ecx, edi
  00a5b	0b c8		 or	 ecx, eax
  00a5d	8b 45 e4	 mov	 eax, DWORD PTR _c$19$[ebp]
  00a60	03 ce		 add	 ecx, esi
  00a62	c1 c8 02	 ror	 eax, 2
  00a65	03 4d f8	 add	 ecx, DWORD PTR _a$18$[ebp]
  00a68	03 ca		 add	 ecx, edx
  00a6a	89 45 e4	 mov	 DWORD PTR _c$19$[ebp], eax

; 125  :             R3(a, b, c, d, e, 45);

  00a6d	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00a70	89 4d f0	 mov	 DWORD PTR _a$20$[ebp], ecx
  00a73	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00a76	33 72 3c	 xor	 esi, DWORD PTR [edx+60]
  00a79	33 72 34	 xor	 esi, DWORD PTR [edx+52]
  00a7c	33 72 28	 xor	 esi, DWORD PTR [edx+40]
  00a7f	d1 c6		 rol	 esi, 1
  00a81	89 72 34	 mov	 DWORD PTR [edx+52], esi
  00a84	8b d1		 mov	 edx, ecx
  00a86	8b c8		 mov	 ecx, eax
  00a88	c1 c2 05	 rol	 edx, 5
  00a8b	0b 4d e8	 or	 ecx, DWORD PTR _b$20$[ebp]
  00a8e	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00a94	23 45 e8	 and	 eax, DWORD PTR _b$20$[ebp]
  00a97	23 cb		 and	 ecx, ebx
  00a99	0b c8		 or	 ecx, eax
  00a9b	8b 45 e8	 mov	 eax, DWORD PTR _b$20$[ebp]
  00a9e	03 ce		 add	 ecx, esi
  00aa0	c1 c8 02	 ror	 eax, 2

; 126  :             R3(e, a, b, c, d, 46);

  00aa3	8b 75 fc	 mov	 esi, DWORD PTR tv6374[ebp]
  00aa6	03 cf		 add	 ecx, edi
  00aa8	8b 7d e4	 mov	 edi, DWORD PTR _c$19$[ebp]
  00aab	03 ca		 add	 ecx, edx
  00aad	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00ab0	89 4d ec	 mov	 DWORD PTR _e$21$[ebp], ecx
  00ab3	89 45 e8	 mov	 DWORD PTR _b$20$[ebp], eax
  00ab6	33 32		 xor	 esi, DWORD PTR [edx]
  00ab8	33 72 38	 xor	 esi, DWORD PTR [edx+56]
  00abb	33 72 2c	 xor	 esi, DWORD PTR [edx+44]
  00abe	d1 c6		 rol	 esi, 1
  00ac0	89 72 38	 mov	 DWORD PTR [edx+56], esi
  00ac3	8b d1		 mov	 edx, ecx
  00ac5	8b c8		 mov	 ecx, eax
  00ac7	c1 c2 05	 rol	 edx, 5
  00aca	0b 4d f0	 or	 ecx, DWORD PTR _a$20$[ebp]
  00acd	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00ad3	23 45 f0	 and	 eax, DWORD PTR _a$20$[ebp]
  00ad6	23 cf		 and	 ecx, edi
  00ad8	0b c8		 or	 ecx, eax
  00ada	8b 45 f0	 mov	 eax, DWORD PTR _a$20$[ebp]
  00add	03 ce		 add	 ecx, esi
  00adf	03 cb		 add	 ecx, ebx
  00ae1	03 ca		 add	 ecx, edx
  00ae3	c1 c8 02	 ror	 eax, 2
  00ae6	89 4d e4	 mov	 DWORD PTR _d$21$[ebp], ecx

; 127  :             R3(d, e, a, b, c, 47);

  00ae9	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00aec	8b 75 e0	 mov	 esi, DWORD PTR tv6371[ebp]
  00aef	8b 5d e8	 mov	 ebx, DWORD PTR _b$20$[ebp]
  00af2	89 45 f0	 mov	 DWORD PTR _a$20$[ebp], eax
  00af5	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  00af8	33 72 3c	 xor	 esi, DWORD PTR [edx+60]
  00afb	33 72 30	 xor	 esi, DWORD PTR [edx+48]
  00afe	d1 c6		 rol	 esi, 1
  00b00	89 72 3c	 mov	 DWORD PTR [edx+60], esi
  00b03	8b d1		 mov	 edx, ecx
  00b05	8b 4d ec	 mov	 ecx, DWORD PTR _e$21$[ebp]
  00b08	81 c6 dc bc 1b
	8f		 add	 esi, -1894007588	; 8f1bbcdcH
  00b0e	0b c8		 or	 ecx, eax
  00b10	c1 c2 05	 rol	 edx, 5
  00b13	8b 45 ec	 mov	 eax, DWORD PTR _e$21$[ebp]
  00b16	23 cb		 and	 ecx, ebx
  00b18	23 45 f0	 and	 eax, DWORD PTR _a$20$[ebp]
  00b1b	0b c8		 or	 ecx, eax
  00b1d	8b 45 ec	 mov	 eax, DWORD PTR _e$21$[ebp]
  00b20	03 ce		 add	 ecx, esi
  00b22	c1 c8 02	 ror	 eax, 2
  00b25	03 cf		 add	 ecx, edi
  00b27	89 45 ec	 mov	 DWORD PTR _e$21$[ebp], eax
  00b2a	03 ca		 add	 ecx, edx

; 128  :             R3(c, d, e, a, b, 48);

  00b2c	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00b2f	89 4d e8	 mov	 DWORD PTR _c$21$[ebp], ecx
  00b32	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00b35	33 32		 xor	 esi, DWORD PTR [edx]
  00b37	33 72 34	 xor	 esi, DWORD PTR [edx+52]
  00b3a	33 72 20	 xor	 esi, DWORD PTR [edx+32]
  00b3d	d1 c6		 rol	 esi, 1
  00b3f	89 32		 mov	 DWORD PTR [edx], esi
  00b41	8b d1		 mov	 edx, ecx
  00b43	8b c8		 mov	 ecx, eax
  00b45	c1 c2 05	 rol	 edx, 5
  00b48	0b 4d e4	 or	 ecx, DWORD PTR _d$21$[ebp]
  00b4b	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00b51	23 4d f0	 and	 ecx, DWORD PTR _a$20$[ebp]
  00b54	23 45 e4	 and	 eax, DWORD PTR _d$21$[ebp]
  00b57	0b c8		 or	 ecx, eax
  00b59	8b 45 e4	 mov	 eax, DWORD PTR _d$21$[ebp]
  00b5c	03 ce		 add	 ecx, esi
  00b5e	c1 c8 02	 ror	 eax, 2
  00b61	03 cb		 add	 ecx, ebx
  00b63	89 45 e4	 mov	 DWORD PTR _d$21$[ebp], eax
  00b66	03 ca		 add	 ecx, edx

; 129  :             R3(b, c, d, e, a, 49);
; 130  :             R3(a, b, c, d, e, 50);

  00b68	8b 7d e4	 mov	 edi, DWORD PTR _d$21$[ebp]
  00b6b	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00b6e	89 4d f4	 mov	 DWORD PTR _b$22$[ebp], ecx
  00b71	8b 72 0c	 mov	 esi, DWORD PTR [edx+12]
  00b74	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  00b77	33 72 38	 xor	 esi, DWORD PTR [edx+56]
  00b7a	33 72 24	 xor	 esi, DWORD PTR [edx+36]
  00b7d	d1 c6		 rol	 esi, 1
  00b7f	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00b82	8b d1		 mov	 edx, ecx
  00b84	8b c8		 mov	 ecx, eax
  00b86	c1 c2 05	 rol	 edx, 5
  00b89	0b 4d e8	 or	 ecx, DWORD PTR _c$21$[ebp]
  00b8c	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00b92	23 4d ec	 and	 ecx, DWORD PTR _e$21$[ebp]
  00b95	23 45 e8	 and	 eax, DWORD PTR _c$21$[ebp]
  00b98	0b c8		 or	 ecx, eax
  00b9a	8b 45 e8	 mov	 eax, DWORD PTR _c$21$[ebp]
  00b9d	03 ce		 add	 ecx, esi
  00b9f	c1 c8 02	 ror	 eax, 2
  00ba2	03 4d f0	 add	 ecx, DWORD PTR _a$20$[ebp]
  00ba5	03 ca		 add	 ecx, edx
  00ba7	89 45 e8	 mov	 DWORD PTR _c$21$[ebp], eax
  00baa	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00bad	89 4d f0	 mov	 DWORD PTR _a$22$[ebp], ecx
  00bb0	8b 72 10	 mov	 esi, DWORD PTR [edx+16]
  00bb3	33 72 08	 xor	 esi, DWORD PTR [edx+8]
  00bb6	33 72 3c	 xor	 esi, DWORD PTR [edx+60]
  00bb9	33 72 28	 xor	 esi, DWORD PTR [edx+40]
  00bbc	d1 c6		 rol	 esi, 1
  00bbe	89 72 08	 mov	 DWORD PTR [edx+8], esi
  00bc1	8b d1		 mov	 edx, ecx
  00bc3	8b c8		 mov	 ecx, eax
  00bc5	c1 c2 05	 rol	 edx, 5
  00bc8	0b 4d f4	 or	 ecx, DWORD PTR _b$22$[ebp]
  00bcb	23 45 f4	 and	 eax, DWORD PTR _b$22$[ebp]
  00bce	23 cf		 and	 ecx, edi
  00bd0	0b c8		 or	 ecx, eax

; 131  :             R3(e, a, b, c, d, 51);

  00bd2	8b 5d e8	 mov	 ebx, DWORD PTR _c$21$[ebp]
  00bd5	03 ce		 add	 ecx, esi
  00bd7	8b 45 f4	 mov	 eax, DWORD PTR _b$22$[ebp]
  00bda	03 4d ec	 add	 ecx, DWORD PTR _e$21$[ebp]
  00bdd	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00be3	03 ca		 add	 ecx, edx
  00be5	c1 c8 02	 ror	 eax, 2
  00be8	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00beb	89 4d e4	 mov	 DWORD PTR _e$23$[ebp], ecx
  00bee	89 45 f4	 mov	 DWORD PTR _b$22$[ebp], eax
  00bf1	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00bf4	33 72 0c	 xor	 esi, DWORD PTR [edx+12]
  00bf7	33 32		 xor	 esi, DWORD PTR [edx]
  00bf9	33 72 2c	 xor	 esi, DWORD PTR [edx+44]
  00bfc	d1 c6		 rol	 esi, 1
  00bfe	89 72 0c	 mov	 DWORD PTR [edx+12], esi
  00c01	8b d1		 mov	 edx, ecx
  00c03	8b c8		 mov	 ecx, eax
  00c05	c1 c2 05	 rol	 edx, 5
  00c08	0b 4d f0	 or	 ecx, DWORD PTR _a$22$[ebp]
  00c0b	81 c2 dc bc 1b
	8f		 add	 edx, -1894007588	; 8f1bbcdcH
  00c11	23 45 f0	 and	 eax, DWORD PTR _a$22$[ebp]
  00c14	23 cb		 and	 ecx, ebx
  00c16	0b c8		 or	 ecx, eax

; 132  :             R3(d, e, a, b, c, 52);

  00c18	81 c3 dc bc 1b
	8f		 add	 ebx, -1894007588	; 8f1bbcdcH
  00c1e	03 ce		 add	 ecx, esi
  00c20	8b 45 f0	 mov	 eax, DWORD PTR _a$22$[ebp]
  00c23	8b 75 fc	 mov	 esi, DWORD PTR tv6374[ebp]
  00c26	03 cf		 add	 ecx, edi
  00c28	03 ca		 add	 ecx, edx
  00c2a	c1 c8 02	 ror	 eax, 2
  00c2d	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00c30	89 4d e8	 mov	 DWORD PTR _d$23$[ebp], ecx
  00c33	89 45 f0	 mov	 DWORD PTR _a$22$[ebp], eax

; 133  :             R3(c, d, e, a, b, 53);

  00c36	8b 7d e8	 mov	 edi, DWORD PTR _d$23$[ebp]
  00c39	33 72 10	 xor	 esi, DWORD PTR [edx+16]
  00c3c	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  00c3f	33 72 30	 xor	 esi, DWORD PTR [edx+48]
  00c42	d1 c6		 rol	 esi, 1
  00c44	89 72 10	 mov	 DWORD PTR [edx+16], esi
  00c47	8b d1		 mov	 edx, ecx
  00c49	8b 4d e4	 mov	 ecx, DWORD PTR _e$23$[ebp]
  00c4c	0b c8		 or	 ecx, eax
  00c4e	c1 c2 05	 rol	 edx, 5
  00c51	23 4d f4	 and	 ecx, DWORD PTR _b$22$[ebp]
  00c54	8b 45 e4	 mov	 eax, DWORD PTR _e$23$[ebp]
  00c57	23 45 f0	 and	 eax, DWORD PTR _a$22$[ebp]
  00c5a	0b c8		 or	 ecx, eax
  00c5c	8b 45 e4	 mov	 eax, DWORD PTR _e$23$[ebp]
  00c5f	03 ce		 add	 ecx, esi
  00c61	c1 c8 02	 ror	 eax, 2
  00c64	8b 75 e0	 mov	 esi, DWORD PTR tv6371[ebp]
  00c67	03 cb		 add	 ecx, ebx
  00c69	8b 5d f0	 mov	 ebx, DWORD PTR _a$22$[ebp]
  00c6c	03 ca		 add	 ecx, edx
  00c6e	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00c71	89 4d ec	 mov	 DWORD PTR _c$23$[ebp], ecx
  00c74	89 45 e4	 mov	 DWORD PTR _e$23$[ebp], eax
  00c77	33 72 14	 xor	 esi, DWORD PTR [edx+20]
  00c7a	33 72 08	 xor	 esi, DWORD PTR [edx+8]
  00c7d	33 72 34	 xor	 esi, DWORD PTR [edx+52]
  00c80	d1 c6		 rol	 esi, 1
  00c82	89 72 14	 mov	 DWORD PTR [edx+20], esi
  00c85	8b d1		 mov	 edx, ecx
  00c87	8b c8		 mov	 ecx, eax
  00c89	c1 c2 05	 rol	 edx, 5
  00c8c	0b 4d e8	 or	 ecx, DWORD PTR _d$23$[ebp]
  00c8f	23 45 e8	 and	 eax, DWORD PTR _d$23$[ebp]
  00c92	23 cb		 and	 ecx, ebx
  00c94	0b c8		 or	 ecx, eax
  00c96	03 ce		 add	 ecx, esi
  00c98	8d 82 dc bc 1b
	8f		 lea	 eax, DWORD PTR [edx-1894007588]
  00c9e	03 4d f4	 add	 ecx, DWORD PTR _b$22$[ebp]
  00ca1	03 c1		 add	 eax, ecx

; 134  :             R3(b, c, d, e, a, 54);

  00ca3	8b 4d fc	 mov	 ecx, DWORD PTR tv6374[ebp]
  00ca6	c1 cf 02	 ror	 edi, 2
  00ca9	89 45 f0	 mov	 DWORD PTR _b$24$[ebp], eax
  00cac	89 7d e8	 mov	 DWORD PTR _d$23$[ebp], edi
  00caf	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00cb2	33 4a 0c	 xor	 ecx, DWORD PTR [edx+12]
  00cb5	33 4a 38	 xor	 ecx, DWORD PTR [edx+56]
  00cb8	33 4a 20	 xor	 ecx, DWORD PTR [edx+32]
  00cbb	d1 c1		 rol	 ecx, 1
  00cbd	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  00cc0	8b d0		 mov	 edx, eax
  00cc2	89 4d fc	 mov	 DWORD PTR tv6374[ebp], ecx
  00cc5	8b c7		 mov	 eax, edi
  00cc7	23 45 ec	 and	 eax, DWORD PTR _c$23$[ebp]
  00cca	8b cf		 mov	 ecx, edi
  00ccc	0b 4d ec	 or	 ecx, DWORD PTR _c$23$[ebp]
  00ccf	23 4d e4	 and	 ecx, DWORD PTR _e$23$[ebp]
  00cd2	0b c8		 or	 ecx, eax
  00cd4	c1 c2 05	 rol	 edx, 5
  00cd7	03 4d fc	 add	 ecx, DWORD PTR tv6374[ebp]
  00cda	03 cb		 add	 ecx, ebx
  00cdc	8b 5d ec	 mov	 ebx, DWORD PTR _c$23$[ebp]
  00cdf	c1 cb 02	 ror	 ebx, 2
  00ce2	8d 82 dc bc 1b
	8f		 lea	 eax, DWORD PTR [edx-1894007588]
  00ce8	89 5d ec	 mov	 DWORD PTR _c$23$[ebp], ebx

; 135  :             R3(a, b, c, d, e, 55);

  00ceb	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00cee	03 c1		 add	 eax, ecx
  00cf0	8b 4d e0	 mov	 ecx, DWORD PTR tv6371[ebp]
  00cf3	89 45 f4	 mov	 DWORD PTR _a$24$[ebp], eax
  00cf6	33 4a 10	 xor	 ecx, DWORD PTR [edx+16]
  00cf9	33 4a 3c	 xor	 ecx, DWORD PTR [edx+60]
  00cfc	33 4a 24	 xor	 ecx, DWORD PTR [edx+36]
  00cff	d1 c1		 rol	 ecx, 1
  00d01	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx
  00d04	8b d0		 mov	 edx, eax
  00d06	89 4d e0	 mov	 DWORD PTR tv6371[ebp], ecx
  00d09	8b c3		 mov	 eax, ebx
  00d0b	23 45 f0	 and	 eax, DWORD PTR _b$24$[ebp]
  00d0e	8b cb		 mov	 ecx, ebx
  00d10	0b 4d f0	 or	 ecx, DWORD PTR _b$24$[ebp]
  00d13	23 cf		 and	 ecx, edi
  00d15	c1 c2 05	 rol	 edx, 5
  00d18	0b c8		 or	 ecx, eax
  00d1a	8b 45 f0	 mov	 eax, DWORD PTR _b$24$[ebp]
  00d1d	03 4d e0	 add	 ecx, DWORD PTR tv6371[ebp]
  00d20	03 4d e4	 add	 ecx, DWORD PTR _e$23$[ebp]
  00d23	8d ba dc bc 1b
	8f		 lea	 edi, DWORD PTR [edx-1894007588]
  00d29	c1 c8 02	 ror	 eax, 2

; 136  :             R3(e, a, b, c, d, 56);

  00d2c	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00d2f	03 f9		 add	 edi, ecx
  00d31	8b c8		 mov	 ecx, eax
  00d33	89 45 f0	 mov	 DWORD PTR _b$24$[ebp], eax
  00d36	0b 4d f4	 or	 ecx, DWORD PTR _a$24$[ebp]
  00d39	23 45 f4	 and	 eax, DWORD PTR _a$24$[ebp]
  00d3c	23 cb		 and	 ecx, ebx
  00d3e	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00d41	0b c8		 or	 ecx, eax
  00d43	33 32		 xor	 esi, DWORD PTR [edx]
  00d45	33 72 28	 xor	 esi, DWORD PTR [edx+40]
  00d48	33 72 20	 xor	 esi, DWORD PTR [edx+32]
  00d4b	d1 c6		 rol	 esi, 1
  00d4d	89 72 20	 mov	 DWORD PTR [edx+32], esi
  00d50	03 ce		 add	 ecx, esi
  00d52	03 4d e8	 add	 ecx, DWORD PTR _d$23$[ebp]
  00d55	8b d7		 mov	 edx, edi
  00d57	8b 45 f4	 mov	 eax, DWORD PTR _a$24$[ebp]
  00d5a	c1 c2 05	 rol	 edx, 5
  00d5d	c1 c8 02	 ror	 eax, 2
  00d60	89 7d d0	 mov	 DWORD PTR _e$25$[ebp], edi
  00d63	89 45 f4	 mov	 DWORD PTR _a$24$[ebp], eax
  00d66	8d 9a dc bc 1b
	8f		 lea	 ebx, DWORD PTR [edx-1894007588]

; 137  :             R3(d, e, a, b, c, 57);

  00d6c	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00d6f	03 d9		 add	 ebx, ecx
  00d71	89 5d d4	 mov	 DWORD PTR _d$25$[ebp], ebx
  00d74	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00d77	8b f1		 mov	 esi, ecx
  00d79	33 72 04	 xor	 esi, DWORD PTR [edx+4]
  00d7c	33 72 2c	 xor	 esi, DWORD PTR [edx+44]
  00d7f	33 72 24	 xor	 esi, DWORD PTR [edx+36]
  00d82	d1 c6		 rol	 esi, 1
  00d84	89 72 24	 mov	 DWORD PTR [edx+36], esi
  00d87	8b d3		 mov	 edx, ebx
  00d89	89 4d e0	 mov	 DWORD PTR tv6373[ebp], ecx
  00d8c	8b cf		 mov	 ecx, edi
  00d8e	c1 c2 05	 rol	 edx, 5
  00d91	0b c8		 or	 ecx, eax
  00d93	8b c7		 mov	 eax, edi
  00d95	23 4d f0	 and	 ecx, DWORD PTR _b$24$[ebp]
  00d98	8d ba dc bc 1b
	8f		 lea	 edi, DWORD PTR [edx-1894007588]
  00d9e	23 45 f4	 and	 eax, DWORD PTR _a$24$[ebp]

; 138  :             R3(c, d, e, a, b, 58);

  00da1	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00da4	0b c8		 or	 ecx, eax
  00da6	03 ce		 add	 ecx, esi
  00da8	8b 45 d0	 mov	 eax, DWORD PTR _e$25$[ebp]
  00dab	03 4d ec	 add	 ecx, DWORD PTR _c$23$[ebp]
  00dae	03 f9		 add	 edi, ecx
  00db0	c1 c8 02	 ror	 eax, 2
  00db3	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00db6	8b f1		 mov	 esi, ecx
  00db8	33 72 08	 xor	 esi, DWORD PTR [edx+8]
  00dbb	33 72 30	 xor	 esi, DWORD PTR [edx+48]
  00dbe	33 72 28	 xor	 esi, DWORD PTR [edx+40]
  00dc1	89 4d c8	 mov	 DWORD PTR tv6370[ebp], ecx
  00dc4	8b c8		 mov	 ecx, eax
  00dc6	0b cb		 or	 ecx, ebx
  00dc8	d1 c6		 rol	 esi, 1
  00dca	23 4d f4	 and	 ecx, DWORD PTR _a$24$[ebp]
  00dcd	89 72 28	 mov	 DWORD PTR [edx+40], esi
  00dd0	8b d7		 mov	 edx, edi
  00dd2	89 45 d0	 mov	 DWORD PTR _e$25$[ebp], eax
  00dd5	23 c3		 and	 eax, ebx
  00dd7	0b c8		 or	 ecx, eax
  00dd9	c1 c2 05	 rol	 edx, 5
  00ddc	03 ce		 add	 ecx, esi
  00dde	8b 45 d4	 mov	 eax, DWORD PTR _d$25$[ebp]
  00de1	03 4d f0	 add	 ecx, DWORD PTR _b$24$[ebp]
  00de4	c1 c8 02	 ror	 eax, 2
  00de7	8d 9a dc bc 1b
	8f		 lea	 ebx, DWORD PTR [edx-1894007588]
  00ded	89 45 d4	 mov	 DWORD PTR _d$25$[ebp], eax
  00df0	03 d9		 add	 ebx, ecx

; 139  :             R3(b, c, d, e, a, 59);

  00df2	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00df5	8b d3		 mov	 edx, ebx
  00df7	c1 c2 05	 rol	 edx, 5
  00dfa	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00dfd	33 71 34	 xor	 esi, DWORD PTR [ecx+52]
  00e00	33 71 2c	 xor	 esi, DWORD PTR [ecx+44]
  00e03	33 71 20	 xor	 esi, DWORD PTR [ecx+32]
  00e06	d1 c6		 rol	 esi, 1
  00e08	89 71 2c	 mov	 DWORD PTR [ecx+44], esi
  00e0b	8b c8		 mov	 ecx, eax
  00e0d	0b cf		 or	 ecx, edi
  00e0f	23 c7		 and	 eax, edi
  00e11	23 4d d0	 and	 ecx, DWORD PTR _e$25$[ebp]
  00e14	0b c8		 or	 ecx, eax
  00e16	c1 cf 02	 ror	 edi, 2

; 140  :             R4(a, b, c, d, e, 60);

  00e19	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00e1c	03 ce		 add	 ecx, esi
  00e1e	03 4d f4	 add	 ecx, DWORD PTR _a$24$[ebp]
  00e21	8d b2 dc bc 1b
	8f		 lea	 esi, DWORD PTR [edx-1894007588]
  00e27	03 f1		 add	 esi, ecx
  00e29	89 7d b8	 mov	 DWORD PTR _c$25$[ebp], edi
  00e2c	8b ce		 mov	 ecx, esi
  00e2e	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00e31	33 50 38	 xor	 edx, DWORD PTR [eax+56]
  00e34	33 50 30	 xor	 edx, DWORD PTR [eax+48]
  00e37	33 50 24	 xor	 edx, DWORD PTR [eax+36]
  00e3a	d1 c2		 rol	 edx, 1
  00e3c	89 50 30	 mov	 DWORD PTR [eax+48], edx
  00e3f	8b 45 d4	 mov	 eax, DWORD PTR _d$25$[ebp]
  00e42	33 c7		 xor	 eax, edi
  00e44	c1 c1 05	 rol	 ecx, 5
  00e47	33 c3		 xor	 eax, ebx
  00e49	c1 cb 02	 ror	 ebx, 2
  00e4c	03 c2		 add	 eax, edx
  00e4e	89 5d c0	 mov	 DWORD PTR _b$26$[ebp], ebx
  00e51	03 45 d0	 add	 eax, DWORD PTR _e$25$[ebp]
  00e54	8d b9 d6 c1 62
	ca		 lea	 edi, DWORD PTR [ecx-899497514]
  00e5a	03 f8		 add	 edi, eax

; 141  :             R4(e, a, b, c, d, 61);

  00e5c	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00e5f	8b cf		 mov	 ecx, edi
  00e61	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00e64	33 50 3c	 xor	 edx, DWORD PTR [eax+60]
  00e67	33 50 34	 xor	 edx, DWORD PTR [eax+52]
  00e6a	33 50 28	 xor	 edx, DWORD PTR [eax+40]
  00e6d	d1 c2		 rol	 edx, 1
  00e6f	89 50 34	 mov	 DWORD PTR [eax+52], edx
  00e72	8b 45 b8	 mov	 eax, DWORD PTR _c$25$[ebp]
  00e75	33 c3		 xor	 eax, ebx
  00e77	c1 c1 05	 rol	 ecx, 5
  00e7a	33 c6		 xor	 eax, esi
  00e7c	c1 ce 02	 ror	 esi, 2
  00e7f	03 c2		 add	 eax, edx

; 142  :             R4(d, e, a, b, c, 62);

  00e81	8b 55 e0	 mov	 edx, DWORD PTR tv6373[ebp]
  00e84	03 45 d4	 add	 eax, DWORD PTR _d$25$[ebp]
  00e87	8d 99 d6 c1 62
	ca		 lea	 ebx, DWORD PTR [ecx-899497514]
  00e8d	03 d8		 add	 ebx, eax
  00e8f	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00e92	8b cb		 mov	 ecx, ebx
  00e94	c1 c1 05	 rol	 ecx, 5
  00e97	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00e9d	33 10		 xor	 edx, DWORD PTR [eax]
  00e9f	33 50 38	 xor	 edx, DWORD PTR [eax+56]
  00ea2	33 50 2c	 xor	 edx, DWORD PTR [eax+44]
  00ea5	d1 c2		 rol	 edx, 1
  00ea7	89 50 38	 mov	 DWORD PTR [eax+56], edx
  00eaa	8b c7		 mov	 eax, edi
  00eac	33 45 c0	 xor	 eax, DWORD PTR _b$26$[ebp]
  00eaf	33 c6		 xor	 eax, esi
  00eb1	c1 cf 02	 ror	 edi, 2
  00eb4	03 c2		 add	 eax, edx

; 143  :             R4(c, d, e, a, b, 63);

  00eb6	8b 55 c8	 mov	 edx, DWORD PTR tv6370[ebp]
  00eb9	03 45 b8	 add	 eax, DWORD PTR _c$25$[ebp]
  00ebc	03 c1		 add	 eax, ecx
  00ebe	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00ec1	89 45 bc	 mov	 DWORD PTR _c$27$[ebp], eax
  00ec4	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00ec7	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00eca	89 4d b4	 mov	 DWORD PTR tv6423[ebp], ecx
  00ecd	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00ed0	33 50 3c	 xor	 edx, DWORD PTR [eax+60]
  00ed3	33 d1		 xor	 edx, ecx
  00ed5	8b c8		 mov	 ecx, eax
  00ed7	d1 c2		 rol	 edx, 1
  00ed9	8b c7		 mov	 eax, edi
  00edb	33 c3		 xor	 eax, ebx
  00edd	c1 cb 02	 ror	 ebx, 2
  00ee0	33 c6		 xor	 eax, esi
  00ee2	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00ee5	03 c2		 add	 eax, edx
  00ee7	03 45 c0	 add	 eax, DWORD PTR _b$26$[ebp]
  00eea	8b 4d bc	 mov	 ecx, DWORD PTR _c$27$[ebp]
  00eed	c1 c1 05	 rol	 ecx, 5
  00ef0	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00ef6	03 c1		 add	 eax, ecx

; 144  :             R4(b, c, d, e, a, 64);

  00ef8	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00efb	89 45 c0	 mov	 DWORD PTR _b$28$[ebp], eax
  00efe	8b c1		 mov	 eax, ecx
  00f00	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00f03	33 10		 xor	 edx, DWORD PTR [eax]
  00f05	8b c7		 mov	 eax, edi
  00f07	33 51 34	 xor	 edx, DWORD PTR [ecx+52]
  00f0a	33 c3		 xor	 eax, ebx
  00f0c	33 51 20	 xor	 edx, DWORD PTR [ecx+32]
  00f0f	33 45 bc	 xor	 eax, DWORD PTR _c$27$[ebp]
  00f12	d1 c2		 rol	 edx, 1
  00f14	89 11		 mov	 DWORD PTR [ecx], edx
  00f16	03 c2		 add	 eax, edx
  00f18	8b 4d c0	 mov	 ecx, DWORD PTR _b$28$[ebp]
  00f1b	03 c6		 add	 eax, esi

; 145  :             R4(a, b, c, d, e, 65);

  00f1d	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00f20	8b 75 bc	 mov	 esi, DWORD PTR _c$27$[ebp]
  00f23	c1 c1 05	 rol	 ecx, 5
  00f26	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00f2c	c1 ce 02	 ror	 esi, 2
  00f2f	03 c1		 add	 eax, ecx
  00f31	8b 4a 38	 mov	 ecx, DWORD PTR [edx+56]
  00f34	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00f37	89 45 c4	 mov	 DWORD PTR _a$28$[ebp], eax
  00f3a	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00f3d	89 4d cc	 mov	 DWORD PTR tv6413[ebp], ecx
  00f40	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  00f43	33 d1		 xor	 edx, ecx
  00f45	8b c8		 mov	 ecx, eax
  00f47	33 51 24	 xor	 edx, DWORD PTR [ecx+36]
  00f4a	d1 c2		 rol	 edx, 1
  00f4c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00f4f	8b 4d c4	 mov	 ecx, DWORD PTR _a$28$[ebp]
  00f52	c1 c1 05	 rol	 ecx, 5
  00f55	8b c3		 mov	 eax, ebx
  00f57	33 c6		 xor	 eax, esi
  00f59	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00f5f	33 45 c0	 xor	 eax, DWORD PTR _b$28$[ebp]
  00f62	03 c2		 add	 eax, edx
  00f64	03 c7		 add	 eax, edi
  00f66	8b 7d c0	 mov	 edi, DWORD PTR _b$28$[ebp]
  00f69	03 c1		 add	 eax, ecx
  00f6b	c1 cf 02	 ror	 edi, 2

; 146  :             R4(e, a, b, c, d, 66);

  00f6e	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00f71	89 45 b8	 mov	 DWORD PTR _e$29$[ebp], eax
  00f74	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00f77	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  00f7a	33 51 3c	 xor	 edx, DWORD PTR [ecx+60]
  00f7d	33 51 28	 xor	 edx, DWORD PTR [ecx+40]
  00f80	d1 c2		 rol	 edx, 1
  00f82	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00f85	8b c8		 mov	 ecx, eax
  00f87	c1 c1 05	 rol	 ecx, 5
  00f8a	8b c6		 mov	 eax, esi
  00f8c	33 c7		 xor	 eax, edi
  00f8e	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00f94	33 45 c4	 xor	 eax, DWORD PTR _a$28$[ebp]
  00f97	03 c2		 add	 eax, edx

; 147  :             R4(d, e, a, b, c, 67);

  00f99	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  00f9c	03 c3		 add	 eax, ebx
  00f9e	8b 5d c4	 mov	 ebx, DWORD PTR _a$28$[ebp]
  00fa1	03 c1		 add	 eax, ecx
  00fa3	c1 cb 02	 ror	 ebx, 2
  00fa6	89 45 e4	 mov	 DWORD PTR _d$29$[ebp], eax
  00fa9	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00fab	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  00fae	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  00fb1	89 4d d4	 mov	 DWORD PTR tv6502[ebp], ecx
  00fb4	33 50 0c	 xor	 edx, DWORD PTR [eax+12]
  00fb7	33 d1		 xor	 edx, ecx
  00fb9	8b c8		 mov	 ecx, eax
  00fbb	8b 45 b8	 mov	 eax, DWORD PTR _e$29$[ebp]
  00fbe	33 c7		 xor	 eax, edi

; 148  :             R4(c, d, e, a, b, 68);

  00fc0	81 c7 d6 c1 62
	ca		 add	 edi, -899497514		; ca62c1d6H
  00fc6	33 c3		 xor	 eax, ebx
  00fc8	33 51 2c	 xor	 edx, DWORD PTR [ecx+44]
  00fcb	d1 c2		 rol	 edx, 1
  00fcd	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00fd0	03 c2		 add	 eax, edx
  00fd2	8b 4d e4	 mov	 ecx, DWORD PTR _d$29$[ebp]
  00fd5	03 c6		 add	 eax, esi
  00fd7	8b 55 e0	 mov	 edx, DWORD PTR tv6373[ebp]
  00fda	8b 75 b8	 mov	 esi, DWORD PTR _e$29$[ebp]
  00fdd	c1 c1 05	 rol	 ecx, 5
  00fe0	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H
  00fe6	c1 ce 02	 ror	 esi, 2
  00fe9	03 c1		 add	 eax, ecx
  00feb	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00fee	89 45 bc	 mov	 DWORD PTR _c$29$[ebp], eax
  00ff1	33 51 10	 xor	 edx, DWORD PTR [ecx+16]
  00ff4	33 51 04	 xor	 edx, DWORD PTR [ecx+4]
  00ff7	33 51 30	 xor	 edx, DWORD PTR [ecx+48]
  00ffa	d1 c2		 rol	 edx, 1
  00ffc	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00fff	8b c8		 mov	 ecx, eax
  01001	8b c6		 mov	 eax, esi
  01003	c1 c1 05	 rol	 ecx, 5
  01006	33 45 e4	 xor	 eax, DWORD PTR _d$29$[ebp]
  01009	33 c3		 xor	 eax, ebx
  0100b	03 c2		 add	 eax, edx

; 149  :             R4(b, c, d, e, a, 69);

  0100d	8b 55 c8	 mov	 edx, DWORD PTR tv6370[ebp]
  01010	03 c7		 add	 eax, edi
  01012	8b 7d e4	 mov	 edi, DWORD PTR _d$29$[ebp]
  01015	03 c1		 add	 eax, ecx
  01017	c1 cf 02	 ror	 edi, 2
  0101a	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0101d	89 45 d0	 mov	 DWORD PTR _b$30$[ebp], eax
  01020	89 7d e4	 mov	 DWORD PTR _d$29$[ebp], edi
  01023	33 51 14	 xor	 edx, DWORD PTR [ecx+20]
  01026	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  01029	33 51 34	 xor	 edx, DWORD PTR [ecx+52]
  0102c	d1 c2		 rol	 edx, 1
  0102e	89 51 14	 mov	 DWORD PTR [ecx+20], edx
  01031	8b c8		 mov	 ecx, eax
  01033	8b c6		 mov	 eax, esi
  01035	c1 c1 05	 rol	 ecx, 5
  01038	33 c7		 xor	 eax, edi
  0103a	81 c3 d6 c1 62
	ca		 add	 ebx, -899497514		; ca62c1d6H
  01040	33 45 bc	 xor	 eax, DWORD PTR _c$29$[ebp]

; 150  :             R4(a, b, c, d, e, 70);

  01043	81 c6 d6 c1 62
	ca		 add	 esi, -899497514		; ca62c1d6H
  01049	03 c2		 add	 eax, edx
  0104b	8b 55 0c	 mov	 edx, DWORD PTR _buffer$[ebp]
  0104e	03 c3		 add	 eax, ebx
  01050	8b 5d bc	 mov	 ebx, DWORD PTR _c$29$[ebp]
  01053	03 c1		 add	 eax, ecx
  01055	c1 cb 02	 ror	 ebx, 2
  01058	8b 4d e0	 mov	 ecx, DWORD PTR tv6373[ebp]
  0105b	33 fb		 xor	 edi, ebx
  0105d	33 4a 0c	 xor	 ecx, DWORD PTR [edx+12]
  01060	33 4a 38	 xor	 ecx, DWORD PTR [edx+56]
  01063	33 4a 20	 xor	 ecx, DWORD PTR [edx+32]
  01066	89 45 e8	 mov	 DWORD PTR _a$30$[ebp], eax
  01069	d1 c1		 rol	 ecx, 1
  0106b	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  0106e	8b 55 d0	 mov	 edx, DWORD PTR _b$30$[ebp]
  01071	33 fa		 xor	 edi, edx
  01073	89 4d e0	 mov	 DWORD PTR tv6373[ebp], ecx
  01076	8b c8		 mov	 ecx, eax

; 151  :             R4(e, a, b, c, d, 71);

  01078	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0107b	03 7d e0	 add	 edi, DWORD PTR tv6373[ebp]
  0107e	03 fe		 add	 edi, esi
  01080	c1 ca 02	 ror	 edx, 2
  01083	8b 75 c8	 mov	 esi, DWORD PTR tv6370[ebp]
  01086	33 70 10	 xor	 esi, DWORD PTR [eax+16]
  01089	33 70 3c	 xor	 esi, DWORD PTR [eax+60]
  0108c	33 70 24	 xor	 esi, DWORD PTR [eax+36]
  0108f	89 55 d0	 mov	 DWORD PTR _b$30$[ebp], edx
  01092	d1 c6		 rol	 esi, 1
  01094	89 70 1c	 mov	 DWORD PTR [eax+28], esi
  01097	8b c3		 mov	 eax, ebx
  01099	33 c2		 xor	 eax, edx
  0109b	c1 c1 05	 rol	 ecx, 5
  0109e	8b 55 e8	 mov	 edx, DWORD PTR _a$30$[ebp]
  010a1	03 f9		 add	 edi, ecx
  010a3	33 c2		 xor	 eax, edx
  010a5	8b cf		 mov	 ecx, edi
  010a7	05 d6 c1 62 ca	 add	 eax, -899497514		; ca62c1d6H
  010ac	c1 ca 02	 ror	 edx, 2
  010af	03 f0		 add	 esi, eax
  010b1	89 55 e8	 mov	 DWORD PTR _a$30$[ebp], edx

; 152  :             R4(d, e, a, b, c, 72);

  010b4	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  010b7	03 75 e4	 add	 esi, DWORD PTR _d$29$[ebp]
  010ba	c1 c1 05	 rol	 ecx, 5
  010bd	03 f1		 add	 esi, ecx
  010bf	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  010c2	8b ce		 mov	 ecx, esi
  010c4	33 10		 xor	 edx, DWORD PTR [eax]
  010c6	33 50 28	 xor	 edx, DWORD PTR [eax+40]
  010c9	33 50 20	 xor	 edx, DWORD PTR [eax+32]
  010cc	d1 c2		 rol	 edx, 1
  010ce	89 50 20	 mov	 DWORD PTR [eax+32], edx
  010d1	8b c7		 mov	 eax, edi
  010d3	33 45 d0	 xor	 eax, DWORD PTR _b$30$[ebp]
  010d6	33 45 e8	 xor	 eax, DWORD PTR _a$30$[ebp]
  010d9	03 c2		 add	 eax, edx
  010db	c1 c1 05	 rol	 ecx, 5
  010de	03 c3		 add	 eax, ebx
  010e0	c1 cf 02	 ror	 edi, 2
  010e3	89 7d b8	 mov	 DWORD PTR _e$31$[ebp], edi
  010e6	8d 99 d6 c1 62
	ca		 lea	 ebx, DWORD PTR [ecx-899497514]
  010ec	03 d8		 add	 ebx, eax

; 153  :             R4(c, d, e, a, b, 73);

  010ee	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  010f1	8b cb		 mov	 ecx, ebx
  010f3	c1 c1 05	 rol	 ecx, 5
  010f6	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  010f9	33 50 04	 xor	 edx, DWORD PTR [eax+4]
  010fc	33 50 2c	 xor	 edx, DWORD PTR [eax+44]
  010ff	33 50 24	 xor	 edx, DWORD PTR [eax+36]
  01102	d1 c2		 rol	 edx, 1
  01104	89 50 24	 mov	 DWORD PTR [eax+36], edx
  01107	8b c7		 mov	 eax, edi
  01109	33 c6		 xor	 eax, esi
  0110b	33 45 e8	 xor	 eax, DWORD PTR _a$30$[ebp]
  0110e	03 c2		 add	 eax, edx
  01110	03 45 d0	 add	 eax, DWORD PTR _b$30$[ebp]
  01113	8d b9 d6 c1 62
	ca		 lea	 edi, DWORD PTR [ecx-899497514]
  01119	c1 ce 02	 ror	 esi, 2

; 154  :             R4(b, c, d, e, a, 74);

  0111c	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0111f	03 f8		 add	 edi, eax
  01121	89 75 c0	 mov	 DWORD PTR _d$31$[ebp], esi
  01124	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  01127	8b d0		 mov	 edx, eax
  01129	33 51 08	 xor	 edx, DWORD PTR [ecx+8]
  0112c	33 51 30	 xor	 edx, DWORD PTR [ecx+48]
  0112f	33 51 28	 xor	 edx, DWORD PTR [ecx+40]
  01132	89 45 bc	 mov	 DWORD PTR tv6344[ebp], eax
  01135	8b 45 b8	 mov	 eax, DWORD PTR _e$31$[ebp]
  01138	33 c6		 xor	 eax, esi
  0113a	d1 c2		 rol	 edx, 1
  0113c	89 51 28	 mov	 DWORD PTR [ecx+40], edx
  0113f	33 c3		 xor	 eax, ebx
  01141	03 c2		 add	 eax, edx
  01143	c1 cb 02	 ror	 ebx, 2
  01146	03 45 e8	 add	 eax, DWORD PTR _a$30$[ebp]
  01149	8b cf		 mov	 ecx, edi
  0114b	c1 c1 05	 rol	 ecx, 5
  0114e	89 5d c4	 mov	 DWORD PTR _c$31$[ebp], ebx
  01151	8d b1 d6 c1 62
	ca		 lea	 esi, DWORD PTR [ecx-899497514]
  01157	03 f0		 add	 esi, eax

; 155  :             R4(a, b, c, d, e, 75);

  01159	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0115c	8b ce		 mov	 ecx, esi
  0115e	c1 c1 05	 rol	 ecx, 5
  01161	8b 50 20	 mov	 edx, DWORD PTR [eax+32]
  01164	33 50 0c	 xor	 edx, DWORD PTR [eax+12]
  01167	33 50 34	 xor	 edx, DWORD PTR [eax+52]
  0116a	33 50 2c	 xor	 edx, DWORD PTR [eax+44]
  0116d	d1 c2		 rol	 edx, 1
  0116f	89 50 2c	 mov	 DWORD PTR [eax+44], edx
  01172	8b 45 c0	 mov	 eax, DWORD PTR _d$31$[ebp]
  01175	33 c3		 xor	 eax, ebx
  01177	8d 99 d6 c1 62
	ca		 lea	 ebx, DWORD PTR [ecx-899497514]
  0117d	33 c7		 xor	 eax, edi
  0117f	c1 cf 02	 ror	 edi, 2
  01182	03 c2		 add	 eax, edx
  01184	03 45 b8	 add	 eax, DWORD PTR _e$31$[ebp]
  01187	03 d8		 add	 ebx, eax
  01189	89 7d b8	 mov	 DWORD PTR _b$32$[ebp], edi

; 156  :             R4(e, a, b, c, d, 76);

  0118c	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  0118f	8b cb		 mov	 ecx, ebx
  01191	c1 c1 05	 rol	 ecx, 5
  01194	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  01197	33 55 cc	 xor	 edx, DWORD PTR tv6413[ebp]
  0119a	33 55 b4	 xor	 edx, DWORD PTR tv6423[ebp]
  0119d	33 50 24	 xor	 edx, DWORD PTR [eax+36]
  011a0	d1 c2		 rol	 edx, 1
  011a2	89 50 30	 mov	 DWORD PTR [eax+48], edx
  011a5	8b 45 c4	 mov	 eax, DWORD PTR _c$31$[ebp]
  011a8	33 c7		 xor	 eax, edi
  011aa	8d b9 d6 c1 62
	ca		 lea	 edi, DWORD PTR [ecx-899497514]
  011b0	33 c6		 xor	 eax, esi
  011b2	c1 ce 02	 ror	 esi, 2
  011b5	03 c2		 add	 eax, edx
  011b7	03 45 c0	 add	 eax, DWORD PTR _d$31$[ebp]
  011ba	03 f8		 add	 edi, eax
  011bc	89 75 c0	 mov	 DWORD PTR _a$32$[ebp], esi

; 157  :             R4(d, e, a, b, c, 77);

  011bf	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  011c2	8b cf		 mov	 ecx, edi
  011c4	c1 c1 05	 rol	 ecx, 5
  011c7	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  011ca	33 50 14	 xor	 edx, DWORD PTR [eax+20]
  011cd	33 50 3c	 xor	 edx, DWORD PTR [eax+60]
  011d0	33 50 34	 xor	 edx, DWORD PTR [eax+52]
  011d3	d1 c2		 rol	 edx, 1
  011d5	89 50 34	 mov	 DWORD PTR [eax+52], edx
  011d8	8b c3		 mov	 eax, ebx
  011da	33 45 b8	 xor	 eax, DWORD PTR _b$32$[ebp]
  011dd	33 c6		 xor	 eax, esi
  011df	c1 cb 02	 ror	 ebx, 2
  011e2	03 c2		 add	 eax, edx
  011e4	8d b1 d6 c1 62
	ca		 lea	 esi, DWORD PTR [ecx-899497514]
  011ea	03 45 c4	 add	 eax, DWORD PTR _c$31$[ebp]
  011ed	03 f0		 add	 esi, eax

; 158  :             R4(c, d, e, a, b, 78);

  011ef	8b 45 0c	 mov	 eax, DWORD PTR _buffer$[ebp]
  011f2	89 75 b4	 mov	 DWORD PTR _c$32$[ebp], esi
  011f5	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  011f8	33 55 d4	 xor	 edx, DWORD PTR tv6502[ebp]
  011fb	33 55 cc	 xor	 edx, DWORD PTR tv6413[ebp]
  011fe	8b ce		 mov	 ecx, esi
  01200	33 50 2c	 xor	 edx, DWORD PTR [eax+44]
  01203	d1 c2		 rol	 edx, 1
  01205	89 50 38	 mov	 DWORD PTR [eax+56], edx
  01208	8b c3		 mov	 eax, ebx
  0120a	33 c7		 xor	 eax, edi
  0120c	c1 c1 05	 rol	 ecx, 5
  0120f	33 45 c0	 xor	 eax, DWORD PTR _a$32$[ebp]
  01212	03 c2		 add	 eax, edx
  01214	c1 cf 02	 ror	 edi, 2
  01217	03 45 b8	 add	 eax, DWORD PTR _b$32$[ebp]
  0121a	8d 91 d6 c1 62
	ca		 lea	 edx, DWORD PTR [ecx-899497514]

; 159  :             R4(b, c, d, e, a, 79);

  01220	8b 4d 0c	 mov	 ecx, DWORD PTR _buffer$[ebp]
  01223	03 d0		 add	 edx, eax
  01225	8b f1		 mov	 esi, ecx
  01227	8b 45 bc	 mov	 eax, DWORD PTR tv6344[ebp]
  0122a	33 41 04	 xor	 eax, DWORD PTR [ecx+4]
  0122d	33 41 30	 xor	 eax, DWORD PTR [ecx+48]
  01230	33 46 3c	 xor	 eax, DWORD PTR [esi+60]
  01233	8b 75 b4	 mov	 esi, DWORD PTR _c$32$[ebp]
  01236	d1 c0		 rol	 eax, 1
  01238	89 41 3c	 mov	 DWORD PTR [ecx+60], eax
  0123b	8b ca		 mov	 ecx, edx
  0123d	89 45 bc	 mov	 DWORD PTR tv6344[ebp], eax
  01240	8b c3		 mov	 eax, ebx
  01242	33 c7		 xor	 eax, edi
  01244	c1 c1 05	 rol	 ecx, 5
  01247	33 c6		 xor	 eax, esi
  01249	81 c1 d6 c1 62
	ca		 add	 ecx, -899497514		; ca62c1d6H

; 160  : 
; 161  :             // Add the working vars back into context.state[].
; 162  :             state[0] += a;

  0124f	03 4d c0	 add	 ecx, DWORD PTR _a$32$[ebp]
  01252	03 45 bc	 add	 eax, DWORD PTR tv6344[ebp]
  01255	03 c1		 add	 eax, ecx
  01257	c1 ce 02	 ror	 esi, 2
  0125a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]

; 163  :             state[1] += b;
; 164  :             state[2] += c;
; 165  :             state[3] += d;

  0125d	01 79 0c	 add	 DWORD PTR [ecx+12], edi
  01260	01 71 08	 add	 DWORD PTR [ecx+8], esi
  01263	01 01		 add	 DWORD PTR [ecx], eax
  01265	01 51 04	 add	 DWORD PTR [ecx+4], edx

; 166  :             state[4] += e;

  01268	01 59 10	 add	 DWORD PTR [ecx+16], ebx
  0126b	5f		 pop	 edi
  0126c	5e		 pop	 esi
  0126d	5b		 pop	 ebx

; 167  :         }

  0126e	8b e5		 mov	 esp, ebp
  01270	5d		 pop	 ebp
  01271	c2 08 00	 ret	 8
?sha1Transform@SHA1@util@zl@@AAEXQAIQBE@Z ENDP		; zl::util::SHA1::sha1Transform
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?hexFinal@SHA1@util@zl@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_digest$ = -32						; size = 20
_finalcount$1 = -12					; size = 8
___$ReturnUdt$GSCopy$ = -8				; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?hexFinal@SHA1@util@zl@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; zl::util::SHA1::hexFinal, COMDAT
; _this$ = ecx

; 259  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00017	89 7d f8	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], edi

; 215  :                 finalcount[i] = static_cast<uint8_t>((context_.count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);

  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	8b c2		 mov	 eax, edx
  0001f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00022	c1 e8 18	 shr	 eax, 24			; 00000018H
  00025	88 45 f4	 mov	 BYTE PTR _finalcount$1[ebp], al
  00028	8b c2		 mov	 eax, edx
  0002a	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002d	88 45 f5	 mov	 BYTE PTR _finalcount$1[ebp+1], al
  00030	8b c2		 mov	 eax, edx
  00032	c1 e8 08	 shr	 eax, 8
  00035	88 45 f6	 mov	 BYTE PTR _finalcount$1[ebp+2], al
  00038	8b c1		 mov	 eax, ecx
  0003a	c1 e8 18	 shr	 eax, 24			; 00000018H
  0003d	88 45 f8	 mov	 BYTE PTR _finalcount$1[ebp+4], al
  00040	8b c1		 mov	 eax, ecx
  00042	c1 e8 10	 shr	 eax, 16			; 00000010H
  00045	88 45 f9	 mov	 BYTE PTR _finalcount$1[ebp+5], al
  00048	8b c1		 mov	 eax, ecx

; 216  :             }
; 217  :             update(reinterpret_cast<const uint8_t*>("\200"), 1);

  0004a	6a 01		 push	 1
  0004c	c1 e8 08	 shr	 eax, 8
  0004f	88 4d fb	 mov	 BYTE PTR _finalcount$1[ebp+7], cl
  00052	8b ce		 mov	 ecx, esi
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_01IFKFHFEL@?$IA@
  00059	88 55 f7	 mov	 BYTE PTR _finalcount$1[ebp+3], dl
  0005c	88 45 fa	 mov	 BYTE PTR _finalcount$1[ebp+6], al
  0005f	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 218  :             while ((context_.count[0] & 504) != 448)

  00064	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00067	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  0006c	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  00071	74 1d		 je	 SHORT $LN15@hexFinal
$LL14@hexFinal:

; 219  :             {
; 220  :                 update(reinterpret_cast<const uint8_t*>("\0"), 1);

  00073	6a 01		 push	 1
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_01LOCGONAA@?$AA@
  0007a	8b ce		 mov	 ecx, esi
  0007c	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  00081	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00084	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  00089	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0008e	75 e3		 jne	 SHORT $LL14@hexFinal
$LN15@hexFinal:

; 221  :             }
; 222  :             // Should cause a SHA1Transform().
; 223  :             update(finalcount, 8);

  00090	6a 08		 push	 8
  00092	8d 45 f4	 lea	 eax, DWORD PTR _finalcount$1[ebp]
  00095	8b ce		 mov	 ecx, esi
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  0009d	33 c0		 xor	 eax, eax
  0009f	90		 npad	 1
$LL8@hexFinal:

; 234  :                 data[i] = static_cast<uint8_t>((context_.state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);

  000a0	8b d0		 mov	 edx, eax
  000a2	b9 03 00 00 00	 mov	 ecx, 3
  000a7	83 e2 03	 and	 edx, 3
  000aa	2b ca		 sub	 ecx, edx
  000ac	8b d0		 mov	 edx, eax
  000ae	c1 fa 02	 sar	 edx, 2
  000b1	c1 e1 03	 shl	 ecx, 3
  000b4	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  000b7	d3 ea		 shr	 edx, cl
  000b9	88 54 05 e0	 mov	 BYTE PTR _digest$[ebp+eax], dl
  000bd	40		 inc	 eax
  000be	83 f8 14	 cmp	 eax, 20			; 00000014H
  000c1	7c dd		 jl	 SHORT $LL8@hexFinal

; 260  :             uint8_t digest[20];
; 261  :             final(&digest);
; 262  :             return encodeAsString(digest, 20);

  000c3	6a 00		 push	 0
  000c5	6a 14		 push	 20			; 00000014H
  000c7	8d 45 e0	 lea	 eax, DWORD PTR _digest$[ebp]
  000ca	50		 push	 eax
  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 ?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z ; zl::util::encodeAsString

; 263  :         }

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d4	83 c4 10	 add	 esp, 16			; 00000010H
  000d7	8b c7		 mov	 eax, edi
  000d9	33 cd		 xor	 ecx, ebp
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 04 00	 ret	 4
?hexFinal@SHA1@util@zl@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; zl::util::SHA1::hexFinal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?final@SHA1@util@zl@@QAEXPAX@Z
_TEXT	SEGMENT
_finalcount$1 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_digest$ = 8						; size = 4
?final@SHA1@util@zl@@QAEXPAX@Z PROC			; zl::util::SHA1::final, COMDAT
; _this$ = ecx

; 229  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _digest$[ebp]

; 217  :             update(reinterpret_cast<const uint8_t*>("\200"), 1);

  00017	6a 01		 push	 1
  00019	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001c	8b c2		 mov	 eax, edx
  0001e	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00021	c1 e8 18	 shr	 eax, 24			; 00000018H
  00024	88 45 f4	 mov	 BYTE PTR _finalcount$1[ebp], al
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 10	 shr	 eax, 16			; 00000010H
  0002c	88 45 f5	 mov	 BYTE PTR _finalcount$1[ebp+1], al
  0002f	8b c2		 mov	 eax, edx
  00031	c1 e8 08	 shr	 eax, 8
  00034	88 45 f6	 mov	 BYTE PTR _finalcount$1[ebp+2], al
  00037	8b c1		 mov	 eax, ecx
  00039	c1 e8 18	 shr	 eax, 24			; 00000018H
  0003c	88 45 f8	 mov	 BYTE PTR _finalcount$1[ebp+4], al
  0003f	8b c1		 mov	 eax, ecx
  00041	c1 e8 10	 shr	 eax, 16			; 00000010H
  00044	88 45 f9	 mov	 BYTE PTR _finalcount$1[ebp+5], al
  00047	8b c1		 mov	 eax, ecx
  00049	c1 e8 08	 shr	 eax, 8
  0004c	88 4d fb	 mov	 BYTE PTR _finalcount$1[ebp+7], cl
  0004f	8b ce		 mov	 ecx, esi
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_01IFKFHFEL@?$IA@
  00056	88 55 f7	 mov	 BYTE PTR _finalcount$1[ebp+3], dl
  00059	88 45 fa	 mov	 BYTE PTR _finalcount$1[ebp+6], al
  0005c	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 218  :             while ((context_.count[0] & 504) != 448)

  00061	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00064	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  00069	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0006e	74 1d		 je	 SHORT $LN11@final
$LL10@final:

; 219  :             {
; 220  :                 update(reinterpret_cast<const uint8_t*>("\0"), 1);

  00070	6a 01		 push	 1
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_01LOCGONAA@?$AA@
  00077	8b ce		 mov	 ecx, esi
  00079	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  0007e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00081	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  00086	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  0008b	75 e3		 jne	 SHORT $LL10@final
$LN11@final:

; 221  :             }
; 222  :             // Should cause a SHA1Transform().
; 223  :             update(finalcount, 8);

  0008d	6a 08		 push	 8
  0008f	8d 45 f4	 lea	 eax, DWORD PTR _finalcount$1[ebp]
  00092	8b ce		 mov	 ecx, esi
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  0009a	33 c0		 xor	 eax, eax
  0009c	0f 1f 40 00	 npad	 4
$LL4@final:

; 230  :             char* data = static_cast<char*>(digest);
; 231  :             finalInternal();
; 232  :             for (int i = 0; i < kSHA1DigestSize; ++i)
; 233  :             {
; 234  :                 data[i] = static_cast<uint8_t>((context_.state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);

  000a0	8b d0		 mov	 edx, eax
  000a2	b9 03 00 00 00	 mov	 ecx, 3
  000a7	83 e2 03	 and	 edx, 3
  000aa	2b ca		 sub	 ecx, edx
  000ac	8b d0		 mov	 edx, eax
  000ae	c1 fa 02	 sar	 edx, 2
  000b1	c1 e1 03	 shl	 ecx, 3
  000b4	8b 14 96	 mov	 edx, DWORD PTR [esi+edx*4]
  000b7	d3 ea		 shr	 edx, cl
  000b9	88 14 07	 mov	 BYTE PTR [edi+eax], dl
  000bc	40		 inc	 eax
  000bd	83 f8 14	 cmp	 eax, 20			; 00000014H
  000c0	7c de		 jl	 SHORT $LL4@final

; 235  :             }
; 236  :         }

  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	5f		 pop	 edi
  000c6	33 cd		 xor	 ecx, ebp
  000c8	5e		 pop	 esi
  000c9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ce	8b e5		 mov	 esp, ebp
  000d0	5d		 pop	 ebp
  000d1	c2 04 00	 ret	 4
?final@SHA1@util@zl@@QAEXPAX@Z ENDP			; zl::util::SHA1::final
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?update@SHA1@util@zl@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
?update@SHA1@util@zl@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; zl::util::SHA1::update, COMDAT
; _this$ = ecx

; 170  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00003	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00006	83 7a 18 10	 cmp	 DWORD PTR [edx+24], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  0000a	8d 42 04	 lea	 eax, DWORD PTR [edx+4]

; 1815 : 		if (_Large_string_engaged())

  0000d	72 02		 jb	 SHORT $LN10@update
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN10@update:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 172  :             update(buff, src.size());

  00011	ff 72 14	 push	 DWORD PTR [edx+20]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 173  :         }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?update@SHA1@util@zl@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; zl::util::SHA1::update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?reset@SHA1@util@zl@@QAEXXZ
_TEXT	SEGMENT
?reset@SHA1@util@zl@@QAEXXZ PROC			; zl::util::SHA1::reset, COMDAT
; _this$ = ecx

; 22   :             // SHA1 initialization constants.
; 23   :             context_.state[0] = 0x67452301;

  00000	c7 01 01 23 45
	67		 mov	 DWORD PTR [ecx], 1732584193 ; 67452301H

; 24   :             context_.state[1] = 0xEFCDAB89;

  00006	c7 41 04 89 ab
	cd ef		 mov	 DWORD PTR [ecx+4], -271733879 ; efcdab89H

; 25   :             context_.state[2] = 0x98BADCFE;

  0000d	c7 41 08 fe dc
	ba 98		 mov	 DWORD PTR [ecx+8], -1732584194 ; 98badcfeH

; 26   :             context_.state[3] = 0x10325476;

  00014	c7 41 0c 76 54
	32 10		 mov	 DWORD PTR [ecx+12], 271733878 ; 10325476H

; 27   :             context_.state[4] = 0xC3D2E1F0;

  0001b	c7 41 10 f0 e1
	d2 c3		 mov	 DWORD PTR [ecx+16], -1009589776 ; c3d2e1f0H

; 28   :             context_.count[0] = context_.count[1] = 0;

  00022	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00029	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 29   :         }

  00030	c3		 ret	 0
?reset@SHA1@util@zl@@QAEXXZ ENDP			; zl::util::SHA1::reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?hexDigest@SHA1@util@zl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z
_TEXT	SEGMENT
_sha1$ = -144						; size = 112
_digest$1 = -32						; size = 20
_finalcount$2 = -12					; size = 8
___$ReturnUdt$GSCopy$ = -8				; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_src$ = 12						; size = 4
?hexDigest@SHA1@util@zl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z PROC ; zl::util::SHA1::hexDigest, COMDAT

; 266  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00016	56		 push	 esi
  00017	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	89 75 f8	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0001d	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00021	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 23   :             context_.state[0] = 0x67452301;

  00024	c7 85 70 ff ff
	ff 01 23 45 67	 mov	 DWORD PTR _sha1$[ebp], 1732584193 ; 67452301H

; 24   :             context_.state[1] = 0xEFCDAB89;

  0002e	c7 85 74 ff ff
	ff 89 ab cd ef	 mov	 DWORD PTR _sha1$[ebp+4], -271733879 ; efcdab89H

; 25   :             context_.state[2] = 0x98BADCFE;

  00038	c7 85 78 ff ff
	ff fe dc ba 98	 mov	 DWORD PTR _sha1$[ebp+8], -1732584194 ; 98badcfeH

; 26   :             context_.state[3] = 0x10325476;

  00042	c7 85 7c ff ff
	ff 76 54 32 10	 mov	 DWORD PTR _sha1$[ebp+12], 271733878 ; 10325476H

; 27   :             context_.state[4] = 0xC3D2E1F0;

  0004c	c7 45 80 f0 e1
	d2 c3		 mov	 DWORD PTR _sha1$[ebp+16], -1009589776 ; c3d2e1f0H

; 28   :             context_.count[0] = context_.count[1] = 0;

  00053	c7 45 88 00 00
	00 00		 mov	 DWORD PTR _sha1$[ebp+24], 0
  0005a	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _sha1$[ebp+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1815 : 		if (_Large_string_engaged())

  00061	72 02		 jb	 SHORT $LN18@hexDigest
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00063	8b 00		 mov	 eax, DWORD PTR [eax]
$LN18@hexDigest:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp

; 172  :             update(buff, src.size());

  00065	ff 71 14	 push	 DWORD PTR [ecx+20]
  00068	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _sha1$[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 215  :                 finalcount[i] = static_cast<uint8_t>((context_.count[(i >= 4 ? 0 : 1)] >> ((3 - (i & 3)) * 8)) & 255);

  00074	8b 4d 88	 mov	 ecx, DWORD PTR _sha1$[ebp+24]
  00077	8b c1		 mov	 eax, ecx
  00079	c1 e8 18	 shr	 eax, 24			; 00000018H
  0007c	88 45 f4	 mov	 BYTE PTR _finalcount$2[ebp], al
  0007f	8b c1		 mov	 eax, ecx
  00081	c1 e8 10	 shr	 eax, 16			; 00000010H
  00084	88 45 f5	 mov	 BYTE PTR _finalcount$2[ebp+1], al
  00087	8b c1		 mov	 eax, ecx
  00089	c1 e8 08	 shr	 eax, 8
  0008c	88 45 f6	 mov	 BYTE PTR _finalcount$2[ebp+2], al
  0008f	88 4d f7	 mov	 BYTE PTR _finalcount$2[ebp+3], cl
  00092	8b 4d 84	 mov	 ecx, DWORD PTR _sha1$[ebp+20]
  00095	8b c1		 mov	 eax, ecx
  00097	c1 e8 18	 shr	 eax, 24			; 00000018H
  0009a	88 45 f8	 mov	 BYTE PTR _finalcount$2[ebp+4], al
  0009d	8b c1		 mov	 eax, ecx
  0009f	c1 e8 10	 shr	 eax, 16			; 00000010H
  000a2	88 45 f9	 mov	 BYTE PTR _finalcount$2[ebp+5], al
  000a5	8b c1		 mov	 eax, ecx

; 216  :             }
; 217  :             update(reinterpret_cast<const uint8_t*>("\200"), 1);

  000a7	6a 01		 push	 1
  000a9	c1 e8 08	 shr	 eax, 8
  000ac	88 4d fb	 mov	 BYTE PTR _finalcount$2[ebp+7], cl
  000af	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _sha1$[ebp]
  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_01IFKFHFEL@?$IA@
  000ba	88 45 fa	 mov	 BYTE PTR _finalcount$2[ebp+6], al
  000bd	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update

; 218  :             while ((context_.count[0] & 504) != 448)

  000c2	8b 45 84	 mov	 eax, DWORD PTR _sha1$[ebp+20]
  000c5	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  000ca	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  000cf	74 21		 je	 SHORT $LN44@hexDigest
$LL43@hexDigest:

; 219  :             {
; 220  :                 update(reinterpret_cast<const uint8_t*>("\0"), 1);

  000d1	6a 01		 push	 1
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_01LOCGONAA@?$AA@
  000d8	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _sha1$[ebp]
  000de	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  000e3	8b 45 84	 mov	 eax, DWORD PTR _sha1$[ebp+20]
  000e6	25 f8 01 00 00	 and	 eax, 504		; 000001f8H
  000eb	3d c0 01 00 00	 cmp	 eax, 448		; 000001c0H
  000f0	75 df		 jne	 SHORT $LL43@hexDigest
$LN44@hexDigest:

; 221  :             }
; 222  :             // Should cause a SHA1Transform().
; 223  :             update(finalcount, 8);

  000f2	6a 08		 push	 8
  000f4	8d 45 f4	 lea	 eax, DWORD PTR _finalcount$2[ebp]
  000f7	50		 push	 eax
  000f8	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _sha1$[ebp]
  000fe	e8 00 00 00 00	 call	 ?update@SHA1@util@zl@@AAEXPBEI@Z ; zl::util::SHA1::update
  00103	33 c0		 xor	 eax, eax
$LL37@hexDigest:

; 234  :                 data[i] = static_cast<uint8_t>((context_.state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);

  00105	8b d0		 mov	 edx, eax
  00107	b9 03 00 00 00	 mov	 ecx, 3
  0010c	83 e2 03	 and	 edx, 3
  0010f	2b ca		 sub	 ecx, edx
  00111	8b d0		 mov	 edx, eax
  00113	c1 fa 02	 sar	 edx, 2
  00116	c1 e1 03	 shl	 ecx, 3
  00119	8b 94 95 70 ff
	ff ff		 mov	 edx, DWORD PTR _sha1$[ebp+edx*4]
  00120	d3 ea		 shr	 edx, cl
  00122	88 54 05 e0	 mov	 BYTE PTR _digest$1[ebp+eax], dl
  00126	40		 inc	 eax
  00127	83 f8 14	 cmp	 eax, 20			; 00000014H
  0012a	7c d9		 jl	 SHORT $LL37@hexDigest

; 262  :             return encodeAsString(digest, 20);

  0012c	6a 00		 push	 0
  0012e	6a 14		 push	 20			; 00000014H
  00130	8d 45 e0	 lea	 eax, DWORD PTR _digest$1[ebp]
  00133	50		 push	 eax
  00134	56		 push	 esi
  00135	e8 00 00 00 00	 call	 ?encodeAsString@util@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBXI_N@Z ; zl::util::encodeAsString

; 270  :         }

  0013a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]

; 262  :             return encodeAsString(digest, 20);

  0013d	83 c4 10	 add	 esp, 16			; 00000010H

; 267  :             SHA1 sha1;
; 268  :             sha1.update(src);
; 269  :             return sha1.hexFinal();

  00140	8b c6		 mov	 eax, esi

; 270  :         }

  00142	33 cd		 xor	 ecx, ebp
  00144	5e		 pop	 esi
  00145	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014a	8b e5		 mov	 esp, ebp
  0014c	5d		 pop	 ebp
  0014d	c3		 ret	 0
?hexDigest@SHA1@util@zl@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV45@@Z ENDP ; zl::util::SHA1::hexDigest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ??1SHA1@util@zl@@QAE@XZ
_TEXT	SEGMENT
??1SHA1@util@zl@@QAE@XZ PROC				; zl::util::SHA1::~SHA1, COMDAT
; _this$ = ecx

; 17   :         }

  00000	c3		 ret	 0
??1SHA1@util@zl@@QAE@XZ ENDP				; zl::util::SHA1::~SHA1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ??0SHA1@util@zl@@QAE@XZ
_TEXT	SEGMENT
??0SHA1@util@zl@@QAE@XZ PROC				; zl::util::SHA1::SHA1, COMDAT
; _this$ = ecx

; 23   :             context_.state[0] = 0x67452301;

  00000	c7 01 01 23 45
	67		 mov	 DWORD PTR [ecx], 1732584193 ; 67452301H

; 12   :             reset();
; 13   :         }

  00006	8b c1		 mov	 eax, ecx

; 24   :             context_.state[1] = 0xEFCDAB89;

  00008	c7 41 04 89 ab
	cd ef		 mov	 DWORD PTR [ecx+4], -271733879 ; efcdab89H

; 25   :             context_.state[2] = 0x98BADCFE;

  0000f	c7 41 08 fe dc
	ba 98		 mov	 DWORD PTR [ecx+8], -1732584194 ; 98badcfeH

; 26   :             context_.state[3] = 0x10325476;

  00016	c7 41 0c 76 54
	32 10		 mov	 DWORD PTR [ecx+12], 271733878 ; 10325476H

; 27   :             context_.state[4] = 0xC3D2E1F0;

  0001d	c7 41 10 f0 e1
	d2 c3		 mov	 DWORD PTR [ecx+16], -1009589776 ; c3d2e1f0H

; 28   :             context_.count[0] = context_.count[1] = 0;

  00024	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0002b	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 12   :             reset();
; 13   :         }

  00032	c3		 ret	 0
??0SHA1@util@zl@@QAE@XZ ENDP				; zl::util::SHA1::SHA1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 23   : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 42 c2	 cmovb	 eax, edx

; 25   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4004 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3984 : 		{	// initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00008	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3985 : 		this->_Orphan_all();
; 3986 : 		auto& _My_data = this->_Get_data();
; 3987 : 		if (_My_data._Large_string_engaged())

  0000e	72 0d		 jb	 SHORT $LN2@Tidy_deall

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	50		 push	 eax
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0001d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00024	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0002b	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 4000 : 		}

  00030	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3975 : 		auto& _My_data = this->_Get_data();
; 3976 : 		_My_data._Mysize = 0;

  00000	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00007	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0000e	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3981 : 		}

  00012	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3866 : 		{	// determines the next array size to allocate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3867 : 		const size_type _Max = max_size();
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  00006	83 ca 0f	 or	 edx, 15			; 0000000fH
  00009	56		 push	 esi
  0000a	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH

; 3870 : 		if (_Masked > _Max)

  00010	77 21		 ja	 SHORT $LN25@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

  00012	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]

; 3876 : 		if (_Old > _Max - _Old / 2)

  00015	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001a	8b ce		 mov	 ecx, esi
  0001c	d1 e9		 shr	 ecx, 1
  0001e	2b c1		 sub	 eax, ecx
  00020	3b f0		 cmp	 esi, eax
  00022	77 0f		 ja	 SHORT $LN25@Calculate_

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00024	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00027	3b d0		 cmp	 edx, eax
  00029	5e		 pop	 esi
  0002a	0f 42 d0	 cmovb	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002d	8b c2		 mov	 eax, edx

; 3882 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN25@Calculate_:

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00033	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00038	5e		 pop	 esi

; 3882 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3307 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3308 : 		const size_type _Storage_max = // can always store small string
; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3310 : 		return (_Min_value(

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3302 : 		return (this->_Get_data()._Mysize);

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 3303 : 		}

  00003	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00004	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1815 : 		if (_Large_string_engaged())

  00007	72 02		 jb	 SHORT $LN8@data

; 3285 : 		return (this->_Get_data()._Myptr());

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN8@data:

; 3286 : 		}

  0000b	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
tv550 = -16						; size = 4
__Old$1$ = -12						; size = 4
tv547 = -8						; size = 4
__New_ptr$1$ = -4					; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3227 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	57		 push	 edi

; 3228 : 		auto& _My_data = this->_Get_data();
; 3229 : 		const size_type _Old_size = _My_data._Mysize;
; 3230 : 		if (_Old_size < _My_data._Myres)

  0000a	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  0000d	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]
  00010	89 4d f4	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00013	3b f9		 cmp	 edi, ecx
  00015	73 23		 jae	 SHORT $LN2@push_back

; 3231 : 			{
; 3232 : 			_My_data._Mysize = _Old_size + 1;

  00017	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0001a	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  0001d	83 c3 04	 add	 ebx, 4

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00020	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  00023	72 02		 jb	 SHORT $LN9@push_back
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00025	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN9@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00027	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  0002a	88 04 3b	 mov	 BYTE PTR [ebx+edi], al
  0002d	c6 44 3b 01 00	 mov	 BYTE PTR [ebx+edi+1], 0
  00032	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3246 : 		}

  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
$LN2@push_back:

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  0003a	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0003f	8b c2		 mov	 eax, edx
  00041	2b c7		 sub	 eax, edi
  00043	83 f8 01	 cmp	 eax, 1
  00046	0f 82 b5 00 00
	00		 jb	 $LN108@push_back
  0004c	56		 push	 esi

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  0004d	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00050	83 ce 0f	 or	 esi, 15			; 0000000fH
  00053	3b f2		 cmp	 esi, edx

; 3870 : 		if (_Masked > _Max)

  00055	76 04		 jbe	 SHORT $LN43@push_back

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00057	8b f2		 mov	 esi, edx
  00059	eb 18		 jmp	 SHORT $LN42@push_back
$LN43@push_back:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  0005b	8b c1		 mov	 eax, ecx
  0005d	d1 e8		 shr	 eax, 1
  0005f	2b d0		 sub	 edx, eax
  00061	3b ca		 cmp	 ecx, edx
  00063	76 07		 jbe	 SHORT $LN44@push_back

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00065	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0006a	eb 07		 jmp	 SHORT $LN42@push_back
$LN44@push_back:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0006c	03 c1		 add	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  0006e	3b f0		 cmp	 esi, eax
  00070	0f 42 f0	 cmovb	 esi, eax
$LN42@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00073	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0007c	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0007f	89 45 fc	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

  00089	8d 47 01	 lea	 eax, DWORD PTR [edi+1]

; 3935 : 		_My_data._Myres = _New_capacity;

  0008c	89 73 18	 mov	 DWORD PTR [ebx+24], esi
  0008f	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

  00092	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00095	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00098	8b 5d f4	 mov	 ebx, DWORD PTR __Old$1$[ebp]
  0009b	89 75 f0	 mov	 DWORD PTR tv550[ebp], esi
  0009e	57		 push	 edi
  0009f	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
  000a2	89 4d f8	 mov	 DWORD PTR tv547[ebp], ecx
  000a5	83 fb 10	 cmp	 ebx, 16			; 00000010H
  000a8	72 33		 jb	 SHORT $LN21@push_back

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000aa	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000ac	56		 push	 esi
  000ad	50		 push	 eax
  000ae	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000b3	8b 4d f8	 mov	 ecx, DWORD PTR tv547[ebp]
  000b6	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  000b9	88 01		 mov	 BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bb	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000be	50		 push	 eax
  000bf	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000c0	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000c9	8b 4d f0	 mov	 ecx, DWORD PTR tv550[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000cc	83 c4 14	 add	 esp, 20			; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000cf	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000d2	5e		 pop	 esi
  000d3	5f		 pop	 edi
  000d4	89 01		 mov	 DWORD PTR [ecx], eax

; 3246 : 		}

  000d6	5b		 pop	 ebx
  000d7	8b e5		 mov	 esp, ebp
  000d9	5d		 pop	 ebp
  000da	c2 04 00	 ret	 4
$LN21@push_back:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000dd	56		 push	 esi
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000e4	8b 4d f8	 mov	 ecx, DWORD PTR tv547[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  000ea	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  000ed	88 01		 mov	 BYTE PTR [ecx], al
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000ef	8b 45 fc	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  000f2	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000f6	89 06		 mov	 DWORD PTR [esi], eax
  000f8	5e		 pop	 esi
  000f9	5f		 pop	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3246 : 		}

  000fa	5b		 pop	 ebx
  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 04 00	 ret	 4
$LN108@push_back:

; 3925 : 			_Xlen();	// result too long

  00101	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN106@push_back:
  00106	cc		 int	 3
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2459 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00008	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0000e	72 0d		 jb	 SHORT $LN4@basic_stri

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	50		 push	 eax
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0001d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2023 : 		_Get_data()._Orphan_all();

  00024	8b ce		 mov	 ecx, esi

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00026	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0002d	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2023 : 		_Get_data()._Orphan_all();

  00031	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00036	6a 08		 push	 8
  00038	ff 36		 push	 DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003f	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00048	5e		 pop	 esi

; 2460 : 		_Tidy_deallocate();
; 2461 : 		}

  00049	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Lock$2 = 8						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2344 : 		{	// assign by stealing _Right's buffer, memcpy optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00026	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00029	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H

; 2345 : 			// pre: this != &_Right
; 2346 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2347 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2348 : 		auto& _Right_data = _Right._Get_data();
; 2349 : 
; 2350 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2351 : 		if (_Right_data._Large_string_engaged())

  0002d	72 35		 jb	 SHORT $LN2@Assign_rv_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00045	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  00047	89 0e		 mov	 DWORD PTR [esi], ecx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  00049	8b 07		 mov	 eax, DWORD PTR [edi]
  0004b	85 c0		 test	 eax, eax
  0004d	74 04		 je	 SHORT $LN22@Assign_rv_

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN22@Assign_rv_:

; 240  : 	if (_Right._Myproxy != nullptr)

  00053	85 c9		 test	 ecx, ecx
  00055	74 02		 je	 SHORT $LN23@Assign_rv_

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00057	89 31		 mov	 DWORD PTR [ecx], esi
$LN23@Assign_rv_:

; 242  : 	}

  00059	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2355 : 		else

  00062	eb 07		 jmp	 SHORT $LN3@Assign_rv_
$LN2@Assign_rv_:

; 2023 : 		_Get_data()._Orphan_all();

  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Assign_rv_:

; 2356 : 			{
; 2357 : 			_Right._Orphan_all();
; 2358 : 			}
; 2359 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2360 : 
; 2361 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2362 : 			+ _Memcpy_move_offset;
; 2363 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2364 : 			+ _Memcpy_move_offset;
; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0006b	0f 10 46 04	 movups	 xmm0, XMMWORD PTR [esi+4]
  0006f	0f 11 47 04	 movups	 XMMWORD PTR [edi+4], xmm0
  00073	f3 0f 7e 46 14	 movq	 xmm0, QWORD PTR [esi+20]
  00078	66 0f d6 47 14	 movq	 QWORD PTR [edi+20], xmm0

; 3976 : 		_My_data._Mysize = 0;

  0007d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00084	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0008b	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2367 : 		}

  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2268 : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00026	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0002e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0003c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00041	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00044	89 06		 mov	 DWORD PTR [esi], eax

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00046	c6 45 f0 00	 mov	 BYTE PTR $T2[ebp], 0
  0004a	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0004c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00052	ff 75 f0	 push	 DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00055	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  0005c	8b 06		 mov	 eax, DWORD PTR [esi]

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  0005e	ff 75 08	 push	 DWORD PTR __Right$[ebp]

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00061	89 30		 mov	 DWORD PTR [eax], esi

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00063	e8 00 00 00 00	 call	 ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2270 : 		}

  00068	8b c6		 mov	 eax, esi
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2142 : 		{	// construct empty string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00025	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0002d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0003b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00040	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00042	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00045	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	89 30		 mov	 DWORD PTR [eax], esi

; 2144 : 		}

  00056	8b c6		 mov	 eax, esi

; 3976 : 		_My_data._Mysize = 0;

  00058	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0005f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00066	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2144 : 		}

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 2049 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2043 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 2044 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2038 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 2039 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2033 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 2034 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Lock$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all, COMDAT
; _this$ = ecx

; 2027 : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  00027	6a 03		 push	 3
  00029	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00039	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  0003c	8b 17		 mov	 edx, DWORD PTR [edi]
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  00042	89 16		 mov	 DWORD PTR [esi], edx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN12@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  0004a	89 38		 mov	 DWORD PTR [eax], edi
  0004c	8b 16		 mov	 edx, DWORD PTR [esi]
$LN12@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

  0004e	85 d2		 test	 edx, edx
  00050	74 02		 je	 SHORT $LN13@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00052	89 32		 mov	 DWORD PTR [edx], esi
$LN13@Swap_all:

; 242  : 	}

  00054	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2029 : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 2023 : 		_Get_data()._Orphan_all();

  00000	e9 00 00 00 00	 jmp	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 2012 : 		return (_Get_data()._Myproxy);

  00000	8b c1		 mov	 eax, ecx

; 2013 : 		}

  00002	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 1997 : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00008	6a 08		 push	 8
  0000a	ff 36		 push	 DWORD PTR [esi]
  0000c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00011	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001a	5e		 pop	 esi

; 2003 : 		}

  0001b	c3		 ret	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1989 : 		{	// construct proxy

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00001	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1989 : 		{	// construct proxy

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00005	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0000a	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0000c	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 1994 : 		}

  00021	c3		 ret	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1948 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00008	6a 08		 push	 8
  0000a	ff 36		 push	 DWORD PTR [esi]
  0000c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00011	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001a	5e		 pop	 esi

; 1949 : 		_Free_proxy();
; 1950 : 		}

  0001b	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1934 : 		{	// default construct allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0000b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00012	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0001e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00020	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00029	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	89 30		 mov	 DWORD PTR [eax], esi

; 1935 : 		_Alloc_proxy();
; 1936 : 		}

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1862 : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	0f 93 c0	 setae	 al

; 1826 : 		}

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 1814 : 		const value_type * _Result = _Bx._Buf;

  00004	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1815 : 		if (_Large_string_engaged())

  00007	72 02		 jb	 SHORT $LN2@Myptr

; 1816 : 			{
; 1817 : 			_Result = _Unfancy(_Bx._Ptr);
; 1818 : 			}
; 1819 : 
; 1820 : 		return (_Result);

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2@Myptr:

; 1821 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;

  00004	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1804 : 		if (_Large_string_engaged())

  00007	72 02		 jb	 SHORT $LN2@Myptr

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2@Myptr:

; 1810 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1787 : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00016	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	83 c8 ff	 or	 eax, -1

; 893  : 		}

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0000b	83 c4 04	 add	 esp, 4

; 998  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000e	83 c4 08	 add	 esp, 8

; 993  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 114  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  : 	_Bytes += _Non_user_size;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];
; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00010	83 00 27	 add	 DWORD PTR [eax], 39	; 00000027H
  00013	57		 push	 edi
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	81 78 f8 fa fa
	fa fa		 cmp	 DWORD PTR [eax-8], -84215046 ; fafafafaH
  0001d	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00020	74 44		 je	 SHORT $LN6@Adjust_man
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0002c	6a 00		 push	 0
  0002e	6a 7a		 push	 122			; 0000007aH
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00035	6a 02		 push	 2
  00037	ff d1		 call	 ecx
  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 01		 jne	 SHORT $LN19@Adjust_man
  00041	cc		 int	 3
$LN19@Adjust_man:
  00042	6a 00		 push	 0
  00044	6a 7a		 push	 122			; 0000007aH
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0005b	8b 06		 mov	 eax, DWORD PTR [esi]
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
$LN6@Adjust_man:

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00066	2b c7		 sub	 eax, edi

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00068	83 f8 08	 cmp	 eax, 8
  0006b	72 05		 jb	 SHORT $LN13@Adjust_man
  0006d	83 f8 27	 cmp	 eax, 39			; 00000027H
  00070	76 42		 jbe	 SHORT $LN22@Adjust_man
$LN13@Adjust_man:
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0007c	6a 00		 push	 0
  0007e	68 84 00 00 00	 push	 132			; 00000084H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00088	6a 02		 push	 2
  0008a	ff d1		 call	 ecx
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 01		 jne	 SHORT $LN20@Adjust_man
  00094	cc		 int	 3
$LN20@Adjust_man:
  00095	6a 00		 push	 0
  00097	68 84 00 00 00	 push	 132			; 00000084H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
$LN22@Adjust_man:

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 134  : 	}

  000b4	89 3e		 mov	 DWORD PTR [esi], edi
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 		}

  00003	5d		 pop	 ebp

; 52   : 		return (::operator new(_Bytes));

  00004	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   : 	{	// gets the size of _Count copies of a type with size 1

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	return (_Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 39   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 229  : 	{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  00027	6a 03		 push	 3
  00029	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00032	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00035	8b 17		 mov	 edx, DWORD PTR [edi]
  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  0003b	89 16		 mov	 DWORD PTR [esi], edx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  0003d	8b 07		 mov	 eax, DWORD PTR [edi]
  0003f	85 c0		 test	 eax, eax
  00041	74 04		 je	 SHORT $LN2@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  00043	89 38		 mov	 DWORD PTR [eax], edi
  00045	8b 16		 mov	 edx, DWORD PTR [esi]
$LN2@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

  00047	85 d2		 test	 edx, edx
  00049	74 02		 je	 SHORT $LN3@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  0004b	89 32		 mov	 DWORD PTR [edx], esi
$LN3@Swap_all:

; 242  : 	}

  0004d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)

  00026	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00029	74 3d		 je	 SHORT $LN5@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002b	6a 03		 push	 3
  0002d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00036	8b 06		 mov	 eax, DWORD PTR [esi]

; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)

  00038	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003c	74 1a		 je	 SHORT $LN3@Orphan_all
  0003e	66 90		 npad	 2
$LL4@Orphan_all:

; 222  : 			(*_Pnext)->_Myproxy = nullptr;

  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00052	85 c9		 test	 ecx, ecx
  00054	75 ea		 jne	 SHORT $LL4@Orphan_all
  00056	8b 06		 mov	 eax, DWORD PTR [esi]
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}

  00058	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0005b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN5@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	5e		 pop	 esi
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 82   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 70   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 505  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 507  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 470  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 		}

  00003	5d		 pop	 ebp

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 617  : 		return (INT_MAX);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 618  : 		}

  00005	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 188  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\utility\sha1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
