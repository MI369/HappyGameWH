; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\StringUtil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?stringFormatAppend@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; zl::base::stringFormatAppend
PUBLIC	?stringFormat@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; zl::base::stringFormat
PUBLIC	?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ; zl::base::stringFormat
PUBLIC	?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; zl::base::stringFormatAppendImpl
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
CONST	SEGMENT
??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '7', 00H, '\', 00H, 'c'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 't'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'm', 00H
	DB	's', 00H, 'v', 00H, 'c', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '1', 00H, '6', 00H, '.', 00H, '2', 00H, '7', 00H, '0', 00H
	DB	'2', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xmemory0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ$0
	DD	00H
	DD	FLAT:___std_terminate
__ehfuncinfo$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 92   : 	{	// allocate _Bytes manually aligned to at least _Big_allocation_alignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]

; 94   : 	if (_Block_size <= _Bytes)

  00006	83 ca ff	 or	 edx, -1
  00009	56		 push	 esi
  0000a	8d 48 27	 lea	 ecx, DWORD PTR [eax+39]
  0000d	3b c8		 cmp	 ecx, eax
  0000f	0f 46 ca	 cmovbe	 ecx, edx

; 52   : 		return (::operator new(_Bytes));

  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00018	8b f0		 mov	 esi, eax

; 52   : 		return (::operator new(_Bytes));

  0001a	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0001d	85 f6		 test	 esi, esi
  0001f	75 3f		 jne	 SHORT $LN6@Allocate_m
  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0002b	50		 push	 eax
  0002c	6a 65		 push	 101			; 00000065H
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00033	6a 02		 push	 2
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0003b	83 c4 18	 add	 esp, 24			; 00000018H
  0003e	83 f8 01	 cmp	 eax, 1
  00041	75 01		 jne	 SHORT $LN12@Allocate_m
  00043	cc		 int	 3
$LN12@Allocate_m:
  00044	6a 00		 push	 0
  00046	6a 65		 push	 101			; 00000065H
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@Allocate_m:

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00060	8d 46 27	 lea	 eax, DWORD PTR [esi+39]
  00063	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00066	89 70 fc	 mov	 DWORD PTR [eax-4], esi

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

  00069	c7 40 f8 fa fa
	fa fa		 mov	 DWORD PTR [eax-8], -84215046 ; fafafafaH

; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);

  00070	5e		 pop	 esi

; 110  : 	}

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 288  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 288  : 		}

  00016	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1573 : 	{	// forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1574 : 	return (static_cast<_Ty&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1575 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 23   : 	{	// gets the size of _Count copies of a type sized _Ty_size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]

; 26   : 	if (_Max_possible < _Count)

  00006	83 ca ff	 or	 edx, -1
  00009	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  0000f	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00016	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 987  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	89 01		 mov	 DWORD PTR [ecx], eax
  0000d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00010	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>, COMDAT

; 1212 : 	{	// deallocate a plain pointer using an allocator, non-fancy pointers special case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	6a 08		 push	 8
  00005	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00008	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000d	83 c4 08	 add	 esp, 8

; 1213 : 	allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
; 1214 : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@$0A@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00000	c3		 ret	 0
??$destroy@U_Container_proxy@std@@@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@QAU_Container_proxy@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 871  : 		{	// deallocate _Count elements at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 872  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	83 c4 08	 add	 esp, 8

; 874  : 		}

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 25   : 	size_t _Result = _Count * _Ty_size;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 26   : 	if (_Max_possible < _Count)

  00006	83 ca ff	 or	 edx, -1
  00009	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0000e	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00015	0f 47 ca	 cmova	 ecx, edx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0001e	83 c4 04	 add	 esp, 4

; 998  : 		}

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 199  : 	{	// deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Bytes$[ebp]
  00008	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  0000e	0f 82 b8 00 00
	00		 jb	 $LN24@Deallocate

; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0001a	83 c6 27	 add	 esi, 39			; 00000027H
  0001d	57		 push	 edi
  0001e	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  00021	81 7f f8 fa fa
	fa fa		 cmp	 DWORD PTR [edi-8], -84215046 ; fafafafaH
  00028	8b 5f fc	 mov	 ebx, DWORD PTR [edi-4]
  0002b	74 42		 je	 SHORT $LN9@Deallocate
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00037	6a 00		 push	 0
  00039	6a 7a		 push	 122			; 0000007aH
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00040	6a 02		 push	 2
  00042	ff d1		 call	 ecx
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN22@Deallocate
  0004c	cc		 int	 3
$LN22@Deallocate:
  0004d	6a 00		 push	 0
  0004f	6a 7a		 push	 122			; 0000007aH
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
$LN9@Deallocate:

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006f	2b fb		 sub	 edi, ebx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00071	83 ff 08	 cmp	 edi, 8
  00074	72 05		 jb	 SHORT $LN16@Deallocate
  00076	83 ff 27	 cmp	 edi, 39			; 00000027H
  00079	76 42		 jbe	 SHORT $LN15@Deallocate
$LN16@Deallocate:
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00085	6a 00		 push	 0
  00087	68 84 00 00 00	 push	 132			; 00000084H
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00091	6a 02		 push	 2
  00093	ff d1		 call	 ecx
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	83 f8 01	 cmp	 eax, 1
  0009b	75 01		 jne	 SHORT $LN23@Deallocate
  0009d	cc		 int	 3
$LN23@Deallocate:
  0009e	6a 00		 push	 0
  000a0	68 84 00 00 00	 push	 132			; 00000084H
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ba	83 c4 14	 add	 esp, 20			; 00000014H
$LN15@Deallocate:
  000bd	5f		 pop	 edi

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  000be	56		 push	 esi
  000bf	53		 push	 ebx
  000c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000c5	83 c4 08	 add	 esp, 8
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx

; 208  : 	}

  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN24@Deallocate:

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000cc	8b 5d 08	 mov	 ebx, DWORD PTR __Ptr$[ebp]

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  000cf	56		 push	 esi
  000d0	53		 push	 ebx
  000d1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000d6	83 c4 08	 add	 esp, 8
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx

; 208  : 	}

  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 180  : 	{	// allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 6d		 jb	 SHORT $LN2@Allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0000e	8d 41 27	 lea	 eax, DWORD PTR [ecx+39]

; 94   : 	if (_Block_size <= _Bytes)

  00011	83 ca ff	 or	 edx, -1
  00014	3b c1		 cmp	 eax, ecx
  00016	56		 push	 esi
  00017	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00020	8b f0		 mov	 esi, eax

; 52   : 		return (::operator new(_Bytes));

  00022	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00025	85 f6		 test	 esi, esi
  00027	75 3f		 jne	 SHORT $LN10@Allocate
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00033	50		 push	 eax
  00034	6a 65		 push	 101			; 00000065H
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  0003b	6a 02		 push	 2
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00043	83 c4 18	 add	 esp, 24			; 00000018H
  00046	83 f8 01	 cmp	 eax, 1
  00049	75 01		 jne	 SHORT $LN16@Allocate
  0004b	cc		 int	 3
$LN16@Allocate:
  0004c	6a 00		 push	 0
  0004e	6a 65		 push	 101			; 00000065H
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@GFNCMDLA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA_@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00065	83 c4 14	 add	 esp, 20			; 00000014H
$LN10@Allocate:

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00068	8d 46 27	 lea	 eax, DWORD PTR [esi+39]
  0006b	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0006e	89 70 fc	 mov	 DWORD PTR [eax-4], esi

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;

  00071	c7 40 f8 fa fa
	fa fa		 mov	 DWORD PTR [eax-8], -84215046 ; fafafafaH

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00078	5e		 pop	 esi

; 194  : 	}

  00079	5d		 pop	 ebp
  0007a	c3		 ret	 0
$LN2@Allocate:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  0007b	85 c9		 test	 ecx, ecx
  0007d	74 09		 je	 SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

  0007f	89 4d 08	 mov	 DWORD PTR __Bytes$[ebp], ecx

; 194  : 	}

  00082	5d		 pop	 ebp

; 52   : 		return (::operator new(_Bytes));

  00083	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00088	33 c0		 xor	 eax, eax

; 194  : 	}

  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>, COMDAT

; 879  : 		{	// construct _Objty(_Types...) at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00003	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 881  : 			_Objty(_STD forward<_Types>(_Args)...);
; 882  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$construct@PADABQAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPADABQAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Max_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Max_value@I@std@@YAABIABI0@Z PROC			; std::_Max_value<unsigned int>, COMDAT

; 32   : 	{	// return larger of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8b 10		 mov	 edx, DWORD PTR [eax]
  0000b	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0000d	0f 42 c1	 cmovb	 eax, ecx

; 34   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Max_value@I@std@@YAABIABI0@Z ENDP			; std::_Max_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 887  : 		_Ptr->~_Uty();
; 888  : 		}

  00000	c3		 ret	 0
??$destroy@PAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@QAPAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1785 : 		_Myres(0)

  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT
; _this$ = ecx

; 1943 : 		{	// construct allocator from _Al

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0000b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00012	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0001e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00020	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00029	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	89 30		 mov	 DWORD PTR [eax], esi

; 1944 : 		_Alloc_proxy();
; 1945 : 		}

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c2 04 00	 ret	 4
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1588 : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1589 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1590 : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
tv418 = -12						; size = 4
__New_size$1$ = -12					; size = 4
tv419 = -8						; size = 4
__Old$1$ = -4						; size = 4
__New_ptr$1$ = 8					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 3919 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3920 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3921 : 		auto& _My_data = this->_Get_data();
; 3922 : 		const size_type _Old_size = _My_data._Mysize;
; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  00003	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00013	8b c1		 mov	 eax, ecx
  00015	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  00018	2b c3		 sub	 eax, ebx
  0001a	3b c2		 cmp	 eax, edx
  0001c	0f 82 d2 00 00
	00		 jb	 $LN88@Reallocate

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

  00022	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00025	03 d3		 add	 edx, ebx

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00027	8b f2		 mov	 esi, edx

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  00029	89 55 f4	 mov	 DWORD PTR __New_size$1$[ebp], edx

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0002c	83 ce 0f	 or	 esi, 15			; 0000000fH

; 3929 : 		const size_type _Old_capacity = _My_data._Myres;

  0002f	89 45 fc	 mov	 DWORD PTR __Old$1$[ebp], eax

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00032	3b f1		 cmp	 esi, ecx

; 3870 : 		if (_Masked > _Max)

  00034	76 04		 jbe	 SHORT $LN25@Reallocate

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00036	8b f1		 mov	 esi, ecx
  00038	eb 18		 jmp	 SHORT $LN24@Reallocate
$LN25@Reallocate:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  0003a	8b d0		 mov	 edx, eax
  0003c	d1 ea		 shr	 edx, 1
  0003e	2b ca		 sub	 ecx, edx
  00040	3b c1		 cmp	 eax, ecx
  00042	76 07		 jbe	 SHORT $LN26@Reallocate

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00044	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00049	eb 07		 jmp	 SHORT $LN24@Reallocate
$LN26@Reallocate:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004b	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  0004d	3b f0		 cmp	 esi, eax
  0004f	0f 42 f0	 cmovb	 esi, eax
$LN24@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00052	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005b	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005e	89 45 08	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  00061	8b cf		 mov	 ecx, edi
  00063	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  0006b	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 3935 : 		_My_data._Myres = _New_capacity;
; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

  0006e	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  00071	89 77 18	 mov	 DWORD PTR [edi+24], esi
  00074	8d 77 04	 lea	 esi, DWORD PTR [edi+4]

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  00077	53		 push	 ebx
  00078	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]
  0007b	89 4d f8	 mov	 DWORD PTR tv419[ebp], ecx
  0007e	03 4d 14	 add	 ecx, DWORD PTR _<_Args_1>$[ebp]
  00081	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  00085	89 4d f4	 mov	 DWORD PTR tv418[ebp], ecx
  00088	72 3c		 jb	 SHORT $LN3@Reallocate

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  0008a	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0008c	56		 push	 esi
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _memcpy
  00093	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00096	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00099	ff 75 f8	 push	 DWORD PTR tv419[ebp]
  0009c	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000a1	8b 45 f4	 mov	 eax, DWORD PTR tv418[ebp]
  000a4	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000a7	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000aa	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000b2	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b5	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000b8	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 3950 : 		return (*this);

  000bb	8b c7		 mov	 eax, edi
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	5b		 pop	 ebx

; 3951 : 		}

  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 10 00	 ret	 16			; 00000010H
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000c6	56		 push	 esi
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _memcpy
  000cd	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000d0	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000d3	ff 75 f8	 push	 DWORD PTR tv419[ebp]
  000d6	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000db	8b 45 f4	 mov	 eax, DWORD PTR tv418[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000de	83 c4 18	 add	 esp, 24			; 00000018H

; 506  : 		_Left = _Right;

  000e1	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000e4	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000e7	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3950 : 		return (*this);

  000e9	8b c7		 mov	 eax, edi
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx

; 3951 : 		}

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c2 10 00	 ret	 16			; 00000010H
$LN88@Reallocate:

; 3924 : 			{
; 3925 : 			_Xlen();	// result too long

  000f4	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN86@Reallocate:
  000f9	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z
_TEXT	SEGMENT
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 2583 : 				const _Elem * const _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	8b 75 08	 mov	 esi, DWORD PTR __New_ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2583 : 				const _Elem * const _Ptr, const size_type _Count) {

  00007	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00008	8b 7d 10	 mov	 edi, DWORD PTR __Old_size$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 0c	 push	 DWORD PTR __Old_ptr$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2585 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00015	03 fe		 add	 edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00017	8b 75 18	 mov	 esi, DWORD PTR __Count$[ebp]
  0001a	56		 push	 esi
  0001b	ff 75 14	 push	 DWORD PTR __Ptr$[ebp]
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 18	 add	 esp, 24			; 00000018H

; 506  : 		_Left = _Right;

  00027	c6 04 37 00	 mov	 BYTE PTR [edi+esi], 0
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2587 : 			}, _Ptr, _Count));

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBEXQADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 329  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 330  : 	return (__builtin_addressof(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 331  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 345  : 	{	// do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 346  : 	return (_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 347  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_dst$GSCopy$1$ = -1044					; size = 4
tv87 = -1040						; size = 4
_format$GSCopy$1$ = -1036				; size = 4
_ap$GSCopy$1$ = -1032					; size = 4
_space$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_dst$ = 8						; size = 4
_format$ = 12						; size = 4
_ap$ = 16						; size = 4
?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; zl::base::stringFormatAppendImpl, COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _dst$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _format$[ebp]
  0001b	57		 push	 edi
  0001c	8b 7d 10	 mov	 edi, DWORD PTR _ap$[ebp]
  0001f	89 9d ec fb ff
	ff		 mov	 DWORD PTR _dst$GSCopy$1$[ebp], ebx
  00025	89 b5 f4 fb ff
	ff		 mov	 DWORD PTR _format$GSCopy$1$[ebp], esi
  0002b	89 bd f8 fb ff
	ff		 mov	 DWORD PTR _ap$GSCopy$1$[ebp], edi
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

  00031	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00036	57		 push	 edi
  00037	6a 00		 push	 0
  00039	56		 push	 esi
  0003a	68 00 04 00 00	 push	 1024			; 00000400H
  0003f	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _space$[ebp]
  00045	89 85 f0 fb ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  0004b	51		 push	 ecx
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	ff 70 04	 push	 DWORD PTR [eax+4]
  00051	83 c9 02	 or	 ecx, 2
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  0005b	8b f0		 mov	 esi, eax
  0005d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

  00060	83 c8 ff	 or	 eax, -1
  00063	85 f6		 test	 esi, esi
  00065	0f 48 f0	 cmovs	 esi, eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp

; 24   :     if ((result >= 0) && (result < static_cast<int>(sizeof(space))))

  00068	81 fe ff 03 00
	00		 cmp	 esi, 1023		; 000003ffH
  0006e	77 22		 ja	 SHORT $LN4@stringForm

; 25   :     {
; 26   :         dst->append(space, result);

  00070	56		 push	 esi
  00071	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _space$[ebp]
  00077	8b cb		 mov	 ecx, ebx
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0007f	5f		 pop	 edi

; 54   : 
; 55   :     return result;
; 56   : }

  00080	8b c6		 mov	 eax, esi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00087	33 cd		 xor	 ecx, ebp
  00089	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
$LN4@stringForm:

; 27   :         return result;
; 28   :     }
; 29   :     
; 30   :     int length = sizeof(space);

  00092	bf 00 04 00 00	 mov	 edi, 1024		; 00000400H
$LL2@stringForm:

; 42   :         char* buf = new char[length];

  00097	03 ff		 add	 edi, edi
  00099	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0009c	85 f6		 test	 esi, esi
  0009e	0f 49 f8	 cmovns	 edi, eax
  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

  000a7	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _ap$GSCopy$1$[ebp]
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp

; 42   :         char* buf = new char[length];

  000ad	8b d8		 mov	 ebx, eax
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h

; 1440 :         int const _Result = __stdio_common_vsprintf(

  000af	8b 85 f0 fb ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  000b5	6a 00		 push	 0
  000b7	ff b5 f4 fb ff
	ff		 push	 DWORD PTR _format$GSCopy$1$[ebp]
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	57		 push	 edi
  000c0	53		 push	 ebx
  000c1	ff 70 04	 push	 DWORD PTR [eax+4]
  000c4	83 c9 02	 or	 ecx, 2
  000c7	51		 push	 ecx
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  000ce	8b f0		 mov	 esi, eax
  000d0	83 c4 20	 add	 esp, 32			; 00000020H

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

  000d3	85 f6		 test	 esi, esi
  000d5	b8 ff ff ff ff	 mov	 eax, -1
  000da	0f 48 f0	 cmovs	 esi, eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp

; 46   :         if ((result >= 0) && (result < length))

  000dd	85 f6		 test	 esi, esi
  000df	78 04		 js	 SHORT $LN7@stringForm
  000e1	3b f7		 cmp	 esi, edi
  000e3	7c 0b		 jl	 SHORT $LN15@stringForm
$LN7@stringForm:

; 50   :             break;
; 51   :         }
; 52   :         delete[] buf;

  000e5	53		 push	 ebx
  000e6	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000eb	83 c4 04	 add	 esp, 4

; 53   :     }

  000ee	eb a7		 jmp	 SHORT $LL2@stringForm
$LN15@stringForm:

; 47   :         {
; 48   :             dst->append(buf, result);

  000f0	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR _dst$GSCopy$1$[ebp]
  000f6	56		 push	 esi
  000f7	53		 push	 ebx
  000f8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 49   :             delete[] buf;

  000fd	53		 push	 ebx
  000fe	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 54   : 
; 55   :     return result;
; 56   : }

  00103	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	83 c4 04	 add	 esp, 4
  00109	8b c6		 mov	 eax, esi
  0010b	33 cd		 xor	 ecx, ebp
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
  0010f	5b		 pop	 ebx
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; zl::base::stringFormatAppendImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_format$ = 12						; size = 4
?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC ; zl::base::stringFormat, COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  0002b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0002e	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2142 : 		{	// construct empty string

  00030	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00037	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0003d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00044	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0004b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00050	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00058	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	89 30		 mov	 DWORD PTR [eax], esi

; 3976 : 		_My_data._Mysize = 0;

  00063	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006a	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00071	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp

; 84   :     return result;

  00075	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007f	50		 push	 eax
  00080	ff 75 0c	 push	 DWORD PTR _format$[ebp]
  00083	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T2[ebp], 1
  0008a	56		 push	 esi
  0008b	e8 00 00 00 00	 call	 ?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; zl::base::stringFormatAppendImpl
  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	8b c6		 mov	 eax, esi

; 85   : }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5e		 pop	 esi
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN4@stringForm
  0000c	83 65 f0 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@stringForm:
  00018	c3		 ret	 0
__ehhandler$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ:
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?stringFormat@base@zl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; zl::base::stringFormat
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?stringFormat@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_format$ = 12						; size = 4
?stringFormat@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC ; zl::base::stringFormat, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00003	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00006	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;

  0000a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]

; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  0000d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 1804 : 		if (_Large_string_engaged())

  00014	72 02		 jb	 SHORT $LN12@stringForm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00016	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN12@stringForm:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00018	c6 01 00	 mov	 BYTE PTR [ecx], 0
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp

; 72   :     size_t result = stringFormatAppendImpl(dst, format, ap);

  0001b	8d 4d 10	 lea	 ecx, DWORD PTR _format$[ebp+4]
  0001e	51		 push	 ecx
  0001f	ff 75 0c	 push	 DWORD PTR _format$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; zl::base::stringFormatAppendImpl
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   :     va_end(ap);
; 74   :     return result;
; 75   : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?stringFormat@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; zl::base::stringFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?stringFormatAppend@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_format$ = 12						; size = 4
?stringFormatAppend@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ PROC ; zl::base::stringFormatAppend, COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 60   :     va_list ap;
; 61   :     va_start(ap, format);
; 62   :     size_t result = stringFormatAppendImpl(dst, format, ap);

  00003	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR _format$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dst$[ebp]
  0000d	e8 00 00 00 00	 call	 ?stringFormatAppendImpl@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; zl::base::stringFormatAppendImpl
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   :     va_end(ap);
; 64   :     return result;
; 65   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?stringFormatAppend@base@zl@@YAIPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDZZ ENDP ; zl::base::stringFormatAppend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 23   : 	{	// return smaller of _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000d	0f 42 c2	 cmovb	 eax, edx

; 25   : 	}

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 4004 : 		_Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3984 : 		{	// initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00008	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3985 : 		this->_Orphan_all();
; 3986 : 		auto& _My_data = this->_Get_data();
; 3987 : 		if (_My_data._Large_string_engaged())

  0000e	72 0d		 jb	 SHORT $LN2@Tidy_deall

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	50		 push	 eax
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0001d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00024	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0002b	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
  0002f	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 4000 : 		}

  00030	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3975 : 		auto& _My_data = this->_Get_data();
; 3976 : 		_My_data._Mysize = 0;

  00000	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00007	c7 41 18 0f 00
	00 00		 mov	 DWORD PTR [ecx+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0000e	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3981 : 		}

  00012	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3968 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00003	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 3969 : 		auto& _My_data = this->_Get_data();
; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00007	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0000a	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 1804 : 		if (_Large_string_engaged())

  0000d	72 0b		 jb	 SHORT $LN16@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00012	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3971 : 		}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN16@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0001a	c6 44 11 04 00	 mov	 BYTE PTR [ecx+edx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3971 : 		}

  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z
_TEXT	SEGMENT
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 3866 : 		{	// determines the next array size to allocate

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3867 : 		const size_type _Max = max_size();
; 3868 : 		auto& _My_data = this->_Get_data();
; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00003	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  00006	83 ca 0f	 or	 edx, 15			; 0000000fH
  00009	56		 push	 esi
  0000a	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH

; 3870 : 		if (_Masked > _Max)

  00010	77 21		 ja	 SHORT $LN25@Calculate_

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);
; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;

  00012	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]

; 3876 : 		if (_Old > _Max - _Old / 2)

  00015	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001a	8b ce		 mov	 ecx, esi
  0001c	d1 e9		 shr	 ecx, 1
  0001e	2b c1		 sub	 eax, ecx
  00020	3b f0		 cmp	 esi, eax
  00022	77 0f		 ja	 SHORT $LN25@Calculate_

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00024	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00027	3b d0		 cmp	 edx, eax
  00029	5e		 pop	 esi
  0002a	0f 42 d0	 cmovb	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002d	8b c2		 mov	 eax, edx

; 3882 : 		}

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN25@Calculate_:

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00033	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00038	5e		 pop	 esi

; 3882 : 		}

  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3307 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3308 : 		const size_type _Storage_max = // can always store small string
; 3309 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3310 : 		return (_Min_value(

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 3311 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3312 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3313 : 			));
; 3314 : 
; 3315 : 		}

  00005	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 3970 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00004	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1804 : 		if (_Large_string_engaged())

  0000b	72 07		 jb	 SHORT $LN18@clear
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00010	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2872 : 		}

  00013	c3		 ret	 0
$LN18@clear:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00014	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2872 : 		}

  00018	c3		 ret	 0
?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv536 = -12						; size = 4
__New_size$1$ = -12					; size = 4
tv537 = -8						; size = 4
__Old_size$1$ = -8					; size = 4
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__New_ptr$1$ = 12					; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2569 : 		{	// append [_Ptr, _Ptr + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 2570 : 		auto& _My_data = this->_Get_data();
; 2571 : 		const size_type _Old_size = _My_data._Mysize;
; 2572 : 		if (_Count <= _My_data._Myres - _Old_size)

  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  0000e	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4b 14	 mov	 ecx, DWORD PTR [ebx+20]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d f8	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 fc	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b f8		 cmp	 edi, eax
  00020	77 2f		 ja	 SHORT $LN2@append

; 2573 : 			{
; 2574 : 			_My_data._Mysize = _Old_size + _Count;

  00022	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00025	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 1803 : 		value_type * _Result = _Bx._Buf;

  00028	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]

; 1825 : 		return (_BUF_SIZE <= _Myres);

  0002b	83 fa 10	 cmp	 edx, 16			; 00000010H

; 1804 : 		if (_Large_string_engaged())

  0002e	72 02		 jb	 SHORT $LN9@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstddef

; 346  : 	return (_Ptr);

  00030	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00032	57		 push	 edi
  00033	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2576 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00036	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 _memmove
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 		_Left = _Right;

  00042	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2588 : 		}

  00046	8b c3		 mov	 eax, ebx
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
$LN2@append:

; 3923 : 		if (max_size() - _Old_size < _Size_increase)

  00051	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00056	2b c1		 sub	 eax, ecx
  00058	3b c7		 cmp	 eax, edi
  0005a	0f 82 d8 00 00
	00		 jb	 $LN107@append

; 3926 : 			}
; 3927 : 
; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  00060	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00063	8b f0		 mov	 esi, eax

; 3928 : 		const size_type _New_size = _Old_size + _Size_increase;

  00065	89 45 f4	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 3869 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00068	83 ce 0f	 or	 esi, 15			; 0000000fH
  0006b	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 3870 : 		if (_Masked > _Max)

  00071	76 07		 jbe	 SHORT $LN43@append

; 3871 : 			{	// the mask overflows, settle for max_size()
; 3872 : 			return (_Max);

  00073	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00078	eb 1e		 jmp	 SHORT $LN42@append
$LN43@append:

; 3873 : 			}
; 3874 : 
; 3875 : 		const size_type _Old = _My_data._Myres;
; 3876 : 		if (_Old > _Max - _Old / 2)

  0007a	8b ca		 mov	 ecx, edx
  0007c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00081	d1 e9		 shr	 ecx, 1
  00083	2b c1		 sub	 eax, ecx
  00085	3b d0		 cmp	 edx, eax
  00087	76 07		 jbe	 SHORT $LN44@append

; 3877 : 			{	// similarly, geometric overflows
; 3878 : 			return (_Max);

  00089	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0008e	eb 08		 jmp	 SHORT $LN42@append
$LN44@append:

; 3879 : 			}
; 3880 : 
; 3881 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00090	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\utility

; 33   : 	return (_Left < _Right ? _Right : _Left);

  00093	3b f0		 cmp	 esi, eax
  00095	0f 42 f0	 cmovb	 esi, eax
$LN42@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00098	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000a1	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3932 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  000a4	89 45 0c	 mov	 DWORD PTR __New_ptr$1$[ebp], eax

; 3933 : 		_My_data._Orphan_all();

  000a7	8b cb		 mov	 ecx, ebx
  000a9	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 3934 : 		_My_data._Mysize = _New_size;

  000ae	8b 45 f4	 mov	 eax, DWORD PTR __New_size$1$[ebp]

; 3935 : 		_My_data._Myres = _New_capacity;
; 3936 : 		_Elem * const _Raw_new = _Unfancy(_New_ptr);

  000b1	8b 4d f8	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000b4	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  000b7	8b 45 0c	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  000ba	89 73 18	 mov	 DWORD PTR [ebx+24], esi
  000bd	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]

; 3937 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000c0	51		 push	 ecx
  000c1	8d 14 08	 lea	 edx, DWORD PTR [eax+ecx]
  000c4	89 55 f8	 mov	 DWORD PTR tv537[ebp], edx
  000c7	03 d7		 add	 edx, edi
  000c9	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000cd	89 55 f4	 mov	 DWORD PTR tv536[ebp], edx
  000d0	72 3a		 jb	 SHORT $LN21@append

; 3938 : 			{
; 3939 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000d2	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  000d4	56		 push	 esi
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 _memcpy
  000db	57		 push	 edi
  000dc	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  000df	ff 75 f8	 push	 DWORD PTR tv537[ebp]
  000e2	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  000e7	8b 45 f4	 mov	 eax, DWORD PTR tv536[ebp]
  000ea	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3941 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ed	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000f0	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f1	50		 push	 eax
  000f2	56		 push	 esi
  000f3	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000f8	8b 45 0c	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000fb	83 c4 20	 add	 esp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3942 : 			_My_data._Bx._Ptr = _New_ptr;

  000fe	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2588 : 		}

  00101	8b c3		 mov	 eax, ebx
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 08 00	 ret	 8
$LN21@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  0010c	56		 push	 esi
  0010d	50		 push	 eax
  0010e	e8 00 00 00 00	 call	 _memcpy
  00113	57		 push	 edi
  00114	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00117	ff 75 f8	 push	 DWORD PTR tv537[ebp]
  0011a	e8 00 00 00 00	 call	 _memcpy

; 506  : 		_Left = _Right;

  0011f	8b 45 f4	 mov	 eax, DWORD PTR tv536[ebp]

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00122	83 c4 18	 add	 esp, 24			; 00000018H

; 506  : 		_Left = _Right;

  00125	c6 00 00	 mov	 BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00128	8b 45 0c	 mov	 eax, DWORD PTR __New_ptr$1$[ebp]
  0012b	5f		 pop	 edi
  0012c	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2588 : 		}

  0012e	8b c3		 mov	 eax, ebx
  00130	5e		 pop	 esi
  00131	5b		 pop	 ebx
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 08 00	 ret	 8
$LN107@append:

; 3925 : 			_Xlen();	// result too long

  00138	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN105@append:
  0013d	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2459 : 		{	// destroy the string

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00008	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0000b	83 f8 10	 cmp	 eax, 16			; 00000010H

; 3987 : 		if (_My_data._Large_string_engaged())

  0000e	72 0d		 jb	 SHORT $LN4@basic_stri

; 3988 : 			{
; 3989 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3990 : 			auto& _Al = this->_Getal();
; 3991 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3992 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00010	40		 inc	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	50		 push	 eax
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 3995 : 		_My_data._Mysize = 0;

  0001d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2023 : 		_Get_data()._Orphan_all();

  00024	8b ce		 mov	 ecx, esi

; 3996 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00026	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0002d	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2023 : 		_Get_data()._Orphan_all();

  00031	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00036	6a 08		 push	 8
  00038	ff 36		 push	 DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003f	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00042	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00048	5e		 pop	 esi

; 2460 : 		_Tidy_deallocate();
; 2461 : 		}

  00049	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Lock$2 = 8						; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2344 : 		{	// assign by stealing _Right's buffer, memcpy optimization

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00026	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00029	83 7e 18 10	 cmp	 DWORD PTR [esi+24], 16	; 00000010H

; 2345 : 			// pre: this != &_Right
; 2346 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2347 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2348 : 		auto& _Right_data = _Right._Get_data();
; 2349 : 
; 2350 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2351 : 		if (_Right_data._Large_string_engaged())

  0002d	72 35		 jb	 SHORT $LN2@Assign_rv_
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  0002f	6a 03		 push	 3
  00031	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]
  00043	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00045	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  00047	89 0e		 mov	 DWORD PTR [esi], ecx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  00049	8b 07		 mov	 eax, DWORD PTR [edi]
  0004b	85 c0		 test	 eax, eax
  0004d	74 04		 je	 SHORT $LN22@Assign_rv_

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  0004f	89 38		 mov	 DWORD PTR [eax], edi
  00051	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN22@Assign_rv_:

; 240  : 	if (_Right._Myproxy != nullptr)

  00053	85 c9		 test	 ecx, ecx
  00055	74 02		 je	 SHORT $LN23@Assign_rv_

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00057	89 31		 mov	 DWORD PTR [ecx], esi
$LN23@Assign_rv_:

; 242  : 	}

  00059	8d 4d 08	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2355 : 		else

  00062	eb 07		 jmp	 SHORT $LN3@Assign_rv_
$LN2@Assign_rv_:

; 2023 : 		_Get_data()._Orphan_all();

  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
$LN3@Assign_rv_:

; 2356 : 			{
; 2357 : 			_Right._Orphan_all();
; 2358 : 			}
; 2359 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2360 : 
; 2361 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2362 : 			+ _Memcpy_move_offset;
; 2363 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2364 : 			+ _Memcpy_move_offset;
; 2365 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0006b	0f 10 46 04	 movups	 xmm0, XMMWORD PTR [esi+4]
  0006f	0f 11 47 04	 movups	 XMMWORD PTR [edi+4], xmm0
  00073	f3 0f 7e 46 14	 movq	 xmm0, QWORD PTR [esi+20]
  00078	66 0f d6 47 14	 movq	 QWORD PTR [edi+20], xmm0

; 3976 : 		_My_data._Mysize = 0;

  0007d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00084	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  0008b	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2367 : 		}

  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2268 : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00026	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00028	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0002e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0003c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00041	83 c4 04	 add	 esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00044	89 06		 mov	 DWORD PTR [esi], eax

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00046	c6 45 f0 00	 mov	 BYTE PTR $T2[ebp], 0
  0004a	8b ce		 mov	 ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0004c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00052	ff 75 f0	 push	 DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00055	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  0005c	8b 06		 mov	 eax, DWORD PTR [esi]

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  0005e	ff 75 08	 push	 DWORD PTR __Right$[ebp]

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00061	89 30		 mov	 DWORD PTR [eax], esi

; 2269 : 		_Assign_rv_contents_with_alloc_always_equal(_STD move(_Right), _Use_memcpy_move{});

  00063	e8 00 00 00 00	 call	 ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal

; 2270 : 		}

  00068	8b c6		 mov	 eax, esi
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2142 : 		{	// construct empty string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00025	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00027	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0002d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0003b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  00040	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00042	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00045	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0004b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	89 30		 mov	 DWORD PTR [eax], esi

; 2144 : 		}

  00056	8b c6		 mov	 eax, esi

; 3976 : 		_My_data._Mysize = 0;

  00058	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3977 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0005f	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd

; 506  : 		_Left = _Right;

  00066	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2144 : 		}

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2048 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 2049 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 2043 : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 2044 : 		}

  00002	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2038 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 2039 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 2033 : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 2034 : 		}

  00002	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Lock$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all, COMDAT
; _this$ = ecx

; 2027 : 		{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  00027	6a 03		 push	 3
  00029	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0002c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00039	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  0003c	8b 17		 mov	 edx, DWORD PTR [edi]
  0003e	8b 06		 mov	 eax, DWORD PTR [esi]
  00040	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  00042	89 16		 mov	 DWORD PTR [esi], edx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  00044	8b 07		 mov	 eax, DWORD PTR [edi]
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN12@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  0004a	89 38		 mov	 DWORD PTR [eax], edi
  0004c	8b 16		 mov	 edx, DWORD PTR [esi]
$LN12@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

  0004e	85 d2		 test	 edx, edx
  00050	74 02		 je	 SHORT $LN13@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  00052	89 32		 mov	 DWORD PTR [edx], esi
$LN13@Swap_all:

; 242  : 	}

  00054	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2029 : 		}

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Swap_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 2023 : 		_Get_data()._Orphan_all();

  00000	e9 00 00 00 00	 jmp	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT
; _this$ = ecx

; 2012 : 		return (_Get_data()._Myproxy);

  00000	8b c1		 mov	 eax, ecx

; 2013 : 		}

  00002	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 1997 : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00008	6a 08		 push	 8
  0000a	ff 36		 push	 DWORD PTR [esi]
  0000c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00011	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001a	5e		 pop	 esi

; 2003 : 		}

  0001b	c3		 ret	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1989 : 		{	// construct proxy

  00000	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00001	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1989 : 		{	// construct proxy

  00003	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00005	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0000a	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  0000c	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00015	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	5e		 pop	 esi

; 1994 : 		}

  00021	c3		 ret	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1948 : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2023 : 		_Get_data()._Orphan_all();

  00003	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 873  : 		_Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00008	6a 08		 push	 8
  0000a	ff 36		 push	 DWORD PTR [esi]
  0000c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00011	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 2002 : 		_Myproxy() = nullptr;

  00014	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0001a	5e		 pop	 esi

; 1949 : 		_Free_proxy();
; 1950 : 		}

  0001b	c3		 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1934 : 		{	// default construct allocator

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	6a 08		 push	 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1784 : 		_Mysize(0),

  0000b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 1785 : 		_Myres(0)

  00012	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00019	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1991 : 		_Myproxy() = _Unfancy(_Proxy_allocator.allocate(1));

  0001e	89 06		 mov	 DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00020	83 c4 04	 add	 esp, 4

; 880  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00023	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00029	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1993 : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

  00030	8b 06		 mov	 eax, DWORD PTR [esi]
  00032	89 30		 mov	 DWORD PTR [eax], esi

; 1935 : 		_Alloc_proxy();
; 1936 : 		}

  00034	8b c6		 mov	 eax, esi
  00036	5e		 pop	 esi
  00037	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1862 : 			}

  00000	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1857 : 			{	// user-provided, for fancy pointers
; 1858 : 			}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00004	0f 93 c0	 setae	 al

; 1826 : 		}

  00007	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1825 : 		return (_BUF_SIZE <= _Myres);

  00000	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H

; 1803 : 		value_type * _Result = _Bx._Buf;

  00004	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 1804 : 		if (_Large_string_engaged())

  00007	72 02		 jb	 SHORT $LN2@Myptr

; 1805 : 			{
; 1806 : 			_Result = _Unfancy(_Bx._Ptr);
; 1807 : 			}
; 1808 : 
; 1809 : 		return (_Result);

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN2@Myptr:

; 1810 : 		}

  0000b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xstring

; 1787 : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0000f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  00016	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	83 c8 ff	 or	 eax, -1

; 893  : 		}

  00003	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 996  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));

  00003	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0000b	83 c4 04	 add	 esp, 4

; 998  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 990  : 		{	// deallocate object at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00003	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000e	83 c4 08	 add	 esp, 8

; 993  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 114  : 	{	// adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  : 	_Bytes += _Non_user_size;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];
; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00010	83 00 27	 add	 DWORD PTR [eax], 39	; 00000027H
  00013	57		 push	 edi
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	81 78 f8 fa fa
	fa fa		 cmp	 DWORD PTR [eax-8], -84215046 ; fafafafaH
  0001d	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00020	74 44		 je	 SHORT $LN6@Adjust_man
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0002c	6a 00		 push	 0
  0002e	6a 7a		 push	 122			; 0000007aH
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00035	6a 02		 push	 2
  00037	ff d1		 call	 ecx
  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	83 f8 01	 cmp	 eax, 1
  0003f	75 01		 jne	 SHORT $LN19@Adjust_man
  00041	cc		 int	 3
$LN19@Adjust_man:
  00042	6a 00		 push	 0
  00044	6a 7a		 push	 122			; 0000007aH
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0005b	8b 06		 mov	 eax, DWORD PTR [esi]
  0005d	83 c4 14	 add	 esp, 20			; 00000014H
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp___CrtDbgReport
$LN6@Adjust_man:

; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00066	2b c7		 sub	 eax, edi

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00068	83 f8 08	 cmp	 eax, 8
  0006b	72 05		 jb	 SHORT $LN13@Adjust_man
  0006d	83 f8 27	 cmp	 eax, 39			; 00000027H
  00070	76 42		 jbe	 SHORT $LN22@Adjust_man
$LN13@Adjust_man:
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0007c	6a 00		 push	 0
  0007e	68 84 00 00 00	 push	 132			; 00000084H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0GJ@FFDBCFBF@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00088	6a 02		 push	 2
  0008a	ff d1		 call	 ecx
  0008c	83 c4 18	 add	 esp, 24			; 00000018H
  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 01		 jne	 SHORT $LN20@Adjust_man
  00094	cc		 int	 3
$LN20@Adjust_man:
  00095	6a 00		 push	 0
  00097	68 84 00 00 00	 push	 132			; 00000084H
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1NC@PIOGAKBO@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b1	83 c4 14	 add	 esp, 20			; 00000014H
$LN22@Adjust_man:

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);
; 134  : 	}

  000b4	89 3e		 mov	 DWORD PTR [esi], edi
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 51   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 53   : 		}

  00003	5d		 pop	 ebp

; 52   : 		return (::operator new(_Bytes));

  00004	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 37   : 	{	// gets the size of _Count copies of a type with size 1

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 38   : 	return (_Count);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 39   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 229  : 	{	// swap all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx

; 230  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 231  : 	_Lockit _Lock(_LOCK_DEBUG);

  00027	6a 03		 push	 3
  00029	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 232  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 233  : 
; 234  : 	_Container_proxy *_Temp = _Myproxy;
; 235  : 	_Myproxy = _Right._Myproxy;

  00032	8b 75 08	 mov	 esi, DWORD PTR __Right$[ebp]
  00035	8b 17		 mov	 edx, DWORD PTR [edi]
  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	89 07		 mov	 DWORD PTR [edi], eax

; 236  : 	_Right._Myproxy = _Temp;

  0003b	89 16		 mov	 DWORD PTR [esi], edx

; 237  : 
; 238  : 	if (_Myproxy != nullptr)

  0003d	8b 07		 mov	 eax, DWORD PTR [edi]
  0003f	85 c0		 test	 eax, eax
  00041	74 04		 je	 SHORT $LN2@Swap_all

; 239  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

  00043	89 38		 mov	 DWORD PTR [eax], edi
  00045	8b 16		 mov	 edx, DWORD PTR [esi]
$LN2@Swap_all:

; 240  : 	if (_Right._Myproxy != nullptr)

  00047	85 d2		 test	 edx, edx
  00049	74 02		 je	 SHORT $LN3@Swap_all

; 241  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

  0004b	89 32		 mov	 DWORD PTR [edx], esi
$LN3@Swap_all:

; 242  : 	}

  0004d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 214  : 	{	// orphan all iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != nullptr)

  00026	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00029	74 3d		 je	 SHORT $LN5@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  0002b	6a 03		 push	 3
  0002d	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00036	8b 06		 mov	 eax, DWORD PTR [esi]

; 221  : 			*_Pnext != nullptr; *_Pnext = (*_Pnext)->_Mynextiter)

  00038	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0003c	74 1a		 je	 SHORT $LN3@Orphan_all
  0003e	66 90		 npad	 2
$LL4@Orphan_all:

; 222  : 			(*_Pnext)->_Myproxy = nullptr;

  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00049	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00052	85 c9		 test	 ecx, ecx
  00054	75 ea		 jne	 SHORT $LL4@Orphan_all
  00056	8b 06		 mov	 eax, DWORD PTR [esi]
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = nullptr;
; 224  : 		}

  00058	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0005b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
$LN5@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	5e		 pop	 esi
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		: _Myproxy(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 82   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		: _Mycont(nullptr), _Myfirstiter(nullptr)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 70   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 505  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 506  : 		_Left = _Right;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000b	88 08		 mov	 BYTE PTR [eax], cl

; 507  : 		}

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 494  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 496  : 		}

  00003	5d		 pop	 ebp

; 495  : 		return (static_cast<char *>(_CSTD memmove(_First1, _First2, _Count)));

  00004	e9 00 00 00 00	 jmp	 _memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 470  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  : 		}

  00003	5d		 pop	 ebp

; 471  : 		return (static_cast<char *>(_CSTD memcpy(_First1, _First2, _Count)));

  00004	e9 00 00 00 00	 jmp	 _memcpy
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 617  : 		return (INT_MAX);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 618  : 		}

  00005	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1439 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1440 :         int const _Result = __stdio_common_vsprintf(

  00003	ff 75 14	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 02	 or	 ecx, 2
  0001e	51		 push	 ecx
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1441 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1442 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1443 : 
; 1444 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1445 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 188  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\zlreactor\base\stringutil.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
