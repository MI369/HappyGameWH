; Listing generated by Microsoft (R) Optimizing Compiler Version 19.16.27032.1 

	TITLE	G:\网狐\HappyGameWH\服务端\系统模块\服务器组件\内核引擎\TimerEngine.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?IID_ITraceServiceManager@@3U_GUID@@B DD 08bfc36dbH	; IID_ITraceServiceManager
	DW	05ba2H
	DW	042baH
	DB	081H
	DB	0b0H
	DB	087H
	DB	0b0H
	DB	01cH
	DB	09eH
	DB	0afH
	DB	0feH
?IID_IServiceModule@@3U_GUID@@B DD 05980504H		; IID_IServiceModule
	DW	0a2f2H
	DW	04b0fH
	DB	09bH
	DB	054H
	DB	051H
	DB	054H
	DB	01eH
	DB	05H
	DB	05cH
	DB	0ffH
?IID_IAsynchronismEngine@@3U_GUID@@B DD 0c7a13074H	; IID_IAsynchronismEngine
	DW	075c5H
	DW	04b8eH
	DB	0b5H
	DB	04bH
	DB	0eeH
	DB	0eH
	DB	0ecH
	DB	0feH
	DB	0b9H
	DB	0ebH
?IID_IDataBase@@3U_GUID@@B DD 0a2e38a78H		; IID_IDataBase
	DW	01e4fH
	DW	04de4H
	DB	0a5H
	DB	0d1H
	DB	0b9H
	DB	019H
	DB	09bH
	DB	0ceH
	DB	041H
	DB	0aeH
?IID_IDataBaseEngine@@3U_GUID@@B DD 047b5a119H		; IID_IDataBaseEngine
	DW	01676H
	DW	049a3H
	DB	0beH
	DB	0aeH
	DB	0caH
	DB	027H
	DB	0ebH
	DB	059H
	DB	097H
	DB	022H
?IID_IUDPNetworkEngine@@3U_GUID@@B DD 08d138a9bH	; IID_IUDPNetworkEngine
	DW	0a97dH
	DW	04d51H
	DB	09dH
	DB	06cH
	DB	0d8H
	DB	06eH
	DB	0a1H
	DB	084H
	DB	045H
	DB	02eH
?IID_ITCPNetworkEngine@@3U_GUID@@B DD 07747f683H	; IID_ITCPNetworkEngine
	DW	0c0daH
	DW	04588H
	DB	089H
	DB	0ccH
	DB	015H
	DB	093H
	DB	0acH
	DB	0c0H
	DB	044H
	DB	0c8H
?IID_ITCPSocketService@@3U_GUID@@B DD 0709a4449H	; IID_ITCPSocketService
	DW	0ad77H
	DW	04b3dH
	DB	0b4H
	DB	0d6H
	DB	08dH
	DB	0bH
	DB	028H
	DB	065H
	DB	0ecH
	DB	0aeH
?IID_IWEBSocketService@@3U_GUID@@B DD 091052ff2H	; IID_IWEBSocketService
	DW	0eb29H
	DW	040b9H
	DB	0b2H
	DB	0a2H
	DB	08aH
	DB	0a2H
	DB	098H
	DB	036H
	DB	02cH
	DB	084H
?IID_ITimerEngine@@3U_GUID@@B DD 0496401aeH		; IID_ITimerEngine
	DW	06fb0H
	DW	04e9fH
	DB	090H
	DB	098H
	DB	044H
	DB	09dH
	DB	09cH
	DB	0b2H
	DB	0bdH
	DB	097H
?IID_ITimerEngineEvent@@3U_GUID@@B DD 0eb78a125H	; IID_ITimerEngineEvent
	DW	062fcH
	DW	04811H
	DB	0b6H
	DB	0f2H
	DB	059H
	DB	026H
	DB	088H
	DB	04H
	DB	0c3H
	DB	02H
?IID_IAttemperEngine@@3U_GUID@@B DD 0b070b2cH		; IID_IAttemperEngine
	DW	09d72H
	DW	042d2H
	DB	0a5H
	DB	070H
	DB	0baH
	DB	02cH
	DB	0bfH
	DB	06fH
	DB	0bbH
	DB	01cH
?IID_IUnknownEx@@3U_GUID@@B DD 05feec21eH		; IID_IUnknownEx
	DW	0dbf3H
	DW	046f0H
	DB	09fH
	DB	057H
	DB	0d1H
	DB	0cdH
	DB	071H
	DB	01cH
	DB	046H
	DB	0deH
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?AfxAssertFailedLine@@YGHPBDH@Z			; AfxAssertFailedLine
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	?InterfaceVersionCompare@@YA_NKK@Z		; InterfaceVersionCompare
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0CTimerThread@@QAE@XZ				; CTimerThread::CTimerThread
PUBLIC	??1CTimerThread@@UAE@XZ				; CTimerThread::~CTimerThread
PUBLIC	?InitThread@CTimerThread@@QAE_NPAVCTimerEngine@@K@Z ; CTimerThread::InitThread
PUBLIC	?OnEventThreadRun@CTimerThread@@EAE_NXZ		; CTimerThread::OnEventThreadRun
PUBLIC	??_GCTimerThread@@UAEPAXI@Z			; CTimerThread::`scalar deleting destructor'
PUBLIC	??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ	; CWHArray<tagTimerItem *,tagTimerItem * const &>::CWHArray<tagTimerItem *,tagTimerItem * const &>
PUBLIC	??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ	; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
PUBLIC	?Append@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABV1@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Append
PUBLIC	?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
PUBLIC	?SetSize@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetSize
PUBLIC	?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow
PUBLIC	?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt
PUBLIC	?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll
PUBLIC	?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::AllocMemory
PUBLIC	??_G?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`scalar deleting destructor'
PUBLIC	??0CTimerEngine@@QAE@XZ				; CTimerEngine::CTimerEngine
PUBLIC	??1CTimerEngine@@UAE@XZ				; CTimerEngine::~CTimerEngine
PUBLIC	?Release@CTimerEngine@@UAEXXZ			; CTimerEngine::Release
PUBLIC	?QueryInterface@CTimerEngine@@UAEPAXABU_GUID@@K@Z ; CTimerEngine::QueryInterface
PUBLIC	?StartService@CTimerEngine@@UAE_NXZ		; CTimerEngine::StartService
PUBLIC	?ConcludeService@CTimerEngine@@UAE_NXZ		; CTimerEngine::ConcludeService
PUBLIC	?SetTimerEngineEvent@CTimerEngine@@UAE_NPAUIUnknownEx@@@Z ; CTimerEngine::SetTimerEngineEvent
PUBLIC	?SetTimer@CTimerEngine@@UAE_NKKKI@Z		; CTimerEngine::SetTimer
PUBLIC	?SetTimeCell@CTimerEngine@@UAE_NK@Z		; CTimerEngine::SetTimeCell
PUBLIC	?KillTimer@CTimerEngine@@UAE_NK@Z		; CTimerEngine::KillTimer
PUBLIC	?KillAllTimer@CTimerEngine@@UAE_NXZ		; CTimerEngine::KillAllTimer
PUBLIC	?OnTimerThreadSink@CTimerEngine@@AAEXXZ		; CTimerEngine::OnTimerThreadSink
PUBLIC	??_GCTimerEngine@@UAEPAXI@Z			; CTimerEngine::`scalar deleting destructor'
PUBLIC	_CreateTimerEngine
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ ; `string'
PUBLIC	??_7IUnknownEx@@6B@				; IUnknownEx::`vftable'
PUBLIC	??_7IServiceModule@@6B@				; IServiceModule::`vftable'
PUBLIC	??_7ITimerEngine@@6B@				; ITimerEngine::`vftable'
PUBLIC	??_7CTimerThread@@6B@				; CTimerThread::`vftable'
PUBLIC	??_7?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`vftable'
PUBLIC	??_7CTimerEngine@@6B@				; CTimerEngine::`vftable'
PUBLIC	??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	__TI2PAD
PUBLIC	__CTA2PAD
PUBLIC	??_R0PAD@8					; char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAD@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@ ; `string'
PUBLIC	??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ ; `string'
PUBLIC	??_R4IUnknownEx@@6B@				; IUnknownEx::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIUnknownEx@@@8				; IUnknownEx `RTTI Type Descriptor'
PUBLIC	??_R3IUnknownEx@@8				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknownEx@@8				; IUnknownEx::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknownEx@@8			; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IServiceModule@@6B@			; IServiceModule::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUIServiceModule@@@8			; IServiceModule `RTTI Type Descriptor'
PUBLIC	??_R3IServiceModule@@8				; IServiceModule::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IServiceModule@@8				; IServiceModule::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IServiceModule@@8			; IServiceModule::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ITimerEngine@@6B@				; ITimerEngine::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUITimerEngine@@@8			; ITimerEngine `RTTI Type Descriptor'
PUBLIC	??_R3ITimerEngine@@8				; ITimerEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITimerEngine@@8				; ITimerEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITimerEngine@@8			; ITimerEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTimerEngine@@6B@				; CTimerEngine::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTimerEngine@@@8			; CTimerEngine `RTTI Type Descriptor'
PUBLIC	??_R3CTimerEngine@@8				; CTimerEngine::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTimerEngine@@8				; CTimerEngine::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTimerEngine@@8			; CTimerEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTimerThread@@6B@				; CTimerThread::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTimerThread@@@8			; CTimerThread `RTTI Type Descriptor'
PUBLIC	??_R3CTimerThread@@8				; CTimerThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTimerThread@@8				; CTimerThread::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTimerThread@@8			; CTimerThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CWHThread@@8			; CWHThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWHThread@@@8				; CWHThread `RTTI Type Descriptor'
PUBLIC	??_R3CWHThread@@8				; CWHThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWHThread@@8				; CWHThread::`RTTI Base Class Array'
PUBLIC	??_R4?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@@8	; CWHArray<tagTimerItem *,tagTimerItem * const &> `RTTI Type Descriptor'
PUBLIC	??_R3?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8 ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:PROC	; AfxThrowInvalidArgException
EXTRN	??0CCriticalSection@@QAE@XZ:PROC		; CCriticalSection::CCriticalSection
EXTRN	??1CCriticalSection@@UAE@XZ:PROC		; CCriticalSection::~CCriticalSection
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_??0CWHThread@@IAE@XZ:PROC
EXTRN	__imp_??1CWHThread@@MAE@XZ:PROC
EXTRN	__imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z:PROC
EXTRN	__imp_??1CWHDataLocker@@UAE@XZ:PROC
EXTRN	??_ECTimerThread@@UAEPAXI@Z:PROC		; CTimerThread::`vector deleting destructor'
EXTRN	??_E?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z:PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`vector deleting destructor'
EXTRN	??_ECTimerEngine@@UAEPAXI@Z:PROC		; CTimerEngine::`vector deleting destructor'
EXTRN	?ConcludeThread@CWHThread@@UAE_NK@Z:PROC	; CWHThread::ConcludeThread
EXTRN	?IsRuning@CWHThread@@UAE_NXZ:PROC		; CWHThread::IsRuning
EXTRN	?OnEventThreadConclude@CWHThread@@MAE_NXZ:PROC	; CWHThread::OnEventThreadConclude
EXTRN	?OnEventThreadStrat@CWHThread@@MAE_NXZ:PROC	; CWHThread::OnEventThreadStrat
EXTRN	?StartThread@CWHThread@@UAE_NXZ:PROC		; CWHThread::StartThread
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8 DD FLAT:??_R0?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@@8 ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	SEGMENT
??_R2?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8 DD FLAT:??_R1A@?0A@EA@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8 ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	SEGMENT
??_R3?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8 DD 00H	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@@8
data$r	SEGMENT
??_R0?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@@8 DD FLAT:??_7type_info@@6B@ ; CWHArray<tagTimerItem *,tagTimerItem * const &> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@
rdata$r	SEGMENT
??_R4?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@ DD 00H	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CWHArray@PAUtagTimerItem@@ABQAU1@@@@8
	DD	FLAT:??_R3?$CWHArray@PAUtagTimerItem@@ABQAU1@@@8
rdata$r	ENDS
;	COMDAT ??_R2CWHThread@@8
rdata$r	SEGMENT
??_R2CWHThread@@8 DD FLAT:??_R1A@?0A@EA@CWHThread@@8	; CWHThread::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWHThread@@8
rdata$r	SEGMENT
??_R3CWHThread@@8 DD 00H				; CWHThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWHThread@@@8
data$r	SEGMENT
??_R0?AVCWHThread@@@8 DD FLAT:??_7type_info@@6B@	; CWHThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWHThread@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWHThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWHThread@@8 DD FLAT:??_R0?AVCWHThread@@@8 ; CWHThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTimerThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTimerThread@@8 DD FLAT:??_R0?AVCTimerThread@@@8 ; CTimerThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTimerThread@@8
rdata$r	ENDS
;	COMDAT ??_R2CTimerThread@@8
rdata$r	SEGMENT
??_R2CTimerThread@@8 DD FLAT:??_R1A@?0A@EA@CTimerThread@@8 ; CTimerThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWHThread@@8
rdata$r	ENDS
;	COMDAT ??_R3CTimerThread@@8
rdata$r	SEGMENT
??_R3CTimerThread@@8 DD 00H				; CTimerThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTimerThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTimerThread@@@8
data$r	SEGMENT
??_R0?AVCTimerThread@@@8 DD FLAT:??_7type_info@@6B@	; CTimerThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTimerThread@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTimerThread@@6B@
rdata$r	SEGMENT
??_R4CTimerThread@@6B@ DD 00H				; CTimerThread::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTimerThread@@@8
	DD	FLAT:??_R3CTimerThread@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTimerEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTimerEngine@@8 DD FLAT:??_R0?AVCTimerEngine@@@8 ; CTimerEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2CTimerEngine@@8
rdata$r	SEGMENT
??_R2CTimerEngine@@8 DD FLAT:??_R1A@?0A@EA@CTimerEngine@@8 ; CTimerEngine::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITimerEngine@@8
	DD	FLAT:??_R1A@?0A@EA@IServiceModule@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3CTimerEngine@@8
rdata$r	SEGMENT
??_R3CTimerEngine@@8 DD 00H				; CTimerEngine::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CTimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTimerEngine@@@8
data$r	SEGMENT
??_R0?AVCTimerEngine@@@8 DD FLAT:??_7type_info@@6B@	; CTimerEngine `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTimerEngine@@', 00H
data$r	ENDS
;	COMDAT ??_R4CTimerEngine@@6B@
rdata$r	SEGMENT
??_R4CTimerEngine@@6B@ DD 00H				; CTimerEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTimerEngine@@@8
	DD	FLAT:??_R3CTimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITimerEngine@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITimerEngine@@8 DD FLAT:??_R0?AUITimerEngine@@@8 ; ITimerEngine::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R2ITimerEngine@@8
rdata$r	SEGMENT
??_R2ITimerEngine@@8 DD FLAT:??_R1A@?0A@EA@ITimerEngine@@8 ; ITimerEngine::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IServiceModule@@8
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3ITimerEngine@@8
rdata$r	SEGMENT
??_R3ITimerEngine@@8 DD 00H				; ITimerEngine::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ITimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITimerEngine@@@8
data$r	SEGMENT
??_R0?AUITimerEngine@@@8 DD FLAT:??_7type_info@@6B@	; ITimerEngine `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITimerEngine@@', 00H
data$r	ENDS
;	COMDAT ??_R4ITimerEngine@@6B@
rdata$r	SEGMENT
??_R4ITimerEngine@@6B@ DD 00H				; ITimerEngine::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUITimerEngine@@@8
	DD	FLAT:??_R3ITimerEngine@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IServiceModule@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IServiceModule@@8 DD FLAT:??_R0?AUIServiceModule@@@8 ; IServiceModule::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R2IServiceModule@@8
rdata$r	SEGMENT
??_R2IServiceModule@@8 DD FLAT:??_R1A@?0A@EA@IServiceModule@@8 ; IServiceModule::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R3IServiceModule@@8
rdata$r	SEGMENT
??_R3IServiceModule@@8 DD 00H				; IServiceModule::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIServiceModule@@@8
data$r	SEGMENT
??_R0?AUIServiceModule@@@8 DD FLAT:??_7type_info@@6B@	; IServiceModule `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIServiceModule@@', 00H
data$r	ENDS
;	COMDAT ??_R4IServiceModule@@6B@
rdata$r	SEGMENT
??_R4IServiceModule@@6B@ DD 00H				; IServiceModule::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIServiceModule@@@8
	DD	FLAT:??_R3IServiceModule@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknownEx@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknownEx@@8 DD FLAT:??_R0?AUIUnknownEx@@@8 ; IUnknownEx::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknownEx@@8
rdata$r	SEGMENT
??_R2IUnknownEx@@8 DD FLAT:??_R1A@?0A@EA@IUnknownEx@@8	; IUnknownEx::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknownEx@@8
rdata$r	SEGMENT
??_R3IUnknownEx@@8 DD 00H				; IUnknownEx::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknownEx@@@8
data$r	SEGMENT
??_R0?AUIUnknownEx@@@8 DD FLAT:??_7type_info@@6B@	; IUnknownEx `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknownEx@@', 00H
data$r	ENDS
;	COMDAT ??_R4IUnknownEx@@6B@
rdata$r	SEGMENT
??_R4IUnknownEx@@6B@ DD 00H				; IUnknownEx::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUIUnknownEx@@@8
	DD	FLAT:??_R3IUnknownEx@@8
rdata$r	ENDS
;	COMDAT ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0c8H, 0abH, 0beH, 0d6H, 0b6H, 0a8H, 0d2H, 0e5H, '\a'
	DB	'rray.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@ DB 0bdH, 0d3H, 0bfH
	DB	0daH, 0b2H, 0e9H, 0d1H, 0afH, 0caH, 0a7H, 0b0H, 0dcH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@
CONST	SEGMENT
??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@ DB 0b4H, 0b4H, 0bdH, 0a8H
	DB	0caH, 0a7H, 0b0H, 0dcH, 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAD@84
xdata$x	SEGMENT
__CT??_R0PAD@84 DD 01H
	DD	FLAT:??_R0PAD@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAD@8
data$r	SEGMENT
??_R0PAD@8 DD	FLAT:??_7type_info@@6B@			; char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAD', 00H
data$r	ENDS
;	COMDAT __CTA2PAD
xdata$x	SEGMENT
__CTA2PAD DD	02H
	DD	FLAT:__CT??_R0PAD@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAD
xdata$x	SEGMENT
__TI2PAD DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAD
xdata$x	ENDS
;	COMDAT ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
CONST	SEGMENT
??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@ DB 'g'
	DB	':\', 0cdH, 0f8H, 0baH, 0fcH, '\happygamewh\', 0b7H, 0feH, 0ceH
	DB	0f1H, 0b6H, 0cbH, '\', 0cfH, 0b5H, 0cdH, 0b3H, 0c4H, 0a3H, 0bfH
	DB	0e9H, '\', 0b7H, 0feH, 0ceH, 0f1H, 0c6H, 0f7H, 0d7H, 0e9H, 0bcH
	DB	0feH, '\', 0c4H, 0daH, 0baH, 0cbH, 0d2H, 0fdH, 0c7H, 0e6H, '\t'
	DB	'imerengine.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CTimerEngine@@6B@
CONST	SEGMENT
??_7CTimerEngine@@6B@ DD FLAT:??_R4CTimerEngine@@6B@	; CTimerEngine::`vftable'
	DD	FLAT:?Release@CTimerEngine@@UAEXXZ
	DD	FLAT:?QueryInterface@CTimerEngine@@UAEPAXABU_GUID@@K@Z
	DD	FLAT:?StartService@CTimerEngine@@UAE_NXZ
	DD	FLAT:?ConcludeService@CTimerEngine@@UAE_NXZ
	DD	FLAT:?SetTimeCell@CTimerEngine@@UAE_NK@Z
	DD	FLAT:?SetTimerEngineEvent@CTimerEngine@@UAE_NPAUIUnknownEx@@@Z
	DD	FLAT:?SetTimer@CTimerEngine@@UAE_NKKKI@Z
	DD	FLAT:?KillTimer@CTimerEngine@@UAE_NK@Z
	DD	FLAT:?KillAllTimer@CTimerEngine@@UAE_NXZ
	DD	FLAT:??_ECTimerEngine@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@
CONST	SEGMENT
??_7?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@ DD FLAT:??_R4?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::`vftable'
	DD	FLAT:??_E?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CTimerThread@@6B@
CONST	SEGMENT
??_7CTimerThread@@6B@ DD FLAT:??_R4CTimerThread@@6B@	; CTimerThread::`vftable'
	DD	FLAT:??_ECTimerThread@@UAEPAXI@Z
	DD	FLAT:?IsRuning@CWHThread@@UAE_NXZ
	DD	FLAT:?StartThread@CWHThread@@UAE_NXZ
	DD	FLAT:?ConcludeThread@CWHThread@@UAE_NK@Z
	DD	FLAT:?OnEventThreadRun@CTimerThread@@EAE_NXZ
	DD	FLAT:?OnEventThreadStrat@CWHThread@@MAE_NXZ
	DD	FLAT:?OnEventThreadConclude@CWHThread@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7ITimerEngine@@6B@
CONST	SEGMENT
??_7ITimerEngine@@6B@ DD FLAT:??_R4ITimerEngine@@6B@	; ITimerEngine::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IServiceModule@@6B@
CONST	SEGMENT
??_7IServiceModule@@6B@ DD FLAT:??_R4IServiceModule@@6B@ ; IServiceModule::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7IUnknownEx@@6B@
CONST	SEGMENT
??_7IUnknownEx@@6B@ DD FLAT:??_R4IUnknownEx@@6B@	; IUnknownEx::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xlocnum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
CONST	SEGMENT
??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@ DB 'c:\pro'
	DB	'gram files (x86)\microsoft visual studio\2017\community\vc\to'
	DB	'ols\msvc\14.16.27023\include\xlocale', 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$_CreateTimerEngine$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_CreateTimerEngine$2
__catchsym$_CreateTimerEngine$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$_CreateTimerEngine$0
__ehfuncinfo$_CreateTimerEngine DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$_CreateTimerEngine
	DD	02H
	DD	FLAT:__tryblocktable$_CreateTimerEngine
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$_CreateTimerEngine DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$_CreateTimerEngine$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$_CreateTimerEngine$6
__unwindtable$_CreateTimerEngine DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$_CreateTimerEngine$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnTimerThreadSink@CTimerEngine@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnTimerThreadSink@CTimerEngine@@AAEXXZ$0
__ehfuncinfo$?OnTimerThreadSink@CTimerEngine@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnTimerThreadSink@CTimerEngine@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?KillAllTimer@CTimerEngine@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?KillAllTimer@CTimerEngine@@UAE_NXZ$0
__ehfuncinfo$?KillAllTimer@CTimerEngine@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?KillAllTimer@CTimerEngine@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?KillTimer@CTimerEngine@@UAE_NK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?KillTimer@CTimerEngine@@UAE_NK@Z$0
__ehfuncinfo$?KillTimer@CTimerEngine@@UAE_NK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?KillTimer@CTimerEngine@@UAE_NK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SetTimeCell@CTimerEngine@@UAE_NK@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetTimeCell@CTimerEngine@@UAE_NK@Z$0
__tryblocktable$?SetTimeCell@CTimerEngine@@UAE_NK@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?SetTimeCell@CTimerEngine@@UAE_NK@Z$3
__unwindtable$?SetTimeCell@CTimerEngine@@UAE_NK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTimeCell@CTimerEngine@@UAE_NK@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?SetTimeCell@CTimerEngine@@UAE_NK@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetTimeCell@CTimerEngine@@UAE_NK@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetTimeCell@CTimerEngine@@UAE_NK@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$0
__tryblocktable$?SetTimer@CTimerEngine@@UAE_NKKKI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$3
__unwindtable$?SetTimer@CTimerEngine@@UAE_NKKKI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?SetTimer@CTimerEngine@@UAE_NKKKI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SetTimer@CTimerEngine@@UAE_NKKKI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?SetTimer@CTimerEngine@@UAE_NKKKI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??1CTimerEngine@@UAE@XZ$9 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??1CTimerEngine@@UAE@XZ$2
__catchsym$??1CTimerEngine@@UAE@XZ$8 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??1CTimerEngine@@UAE@XZ$0
__ehfuncinfo$??1CTimerEngine@@UAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CTimerEngine@@UAE@XZ
	DD	02H
	DD	FLAT:__tryblocktable$??1CTimerEngine@@UAE@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__tryblocktable$??1CTimerEngine@@UAE@XZ DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??1CTimerEngine@@UAE@XZ$8
	DD	06H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:__catchsym$??1CTimerEngine@@UAE@XZ$9
__unwindtable$??1CTimerEngine@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CTimerEngine@@UAE@XZ$4
	DD	00H
	DD	FLAT:__unwindfunclet$??1CTimerEngine@@UAE@XZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$??1CTimerEngine@@UAE@XZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$??1CTimerEngine@@UAE@XZ$7
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
	DD	03H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTimerEngine@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTimerEngine@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTimerEngine@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTimerEngine@@QAE@XZ$2
__ehfuncinfo$??0CTimerEngine@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CTimerEngine@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv66 = -28						; size = 4
tv86 = -24						; size = 4
__Ptrdest$ = -20					; size = 4
__Ptrnext$1 = -16					; size = 4
__Count$ = -12						; size = 4
tv83 = -8						; size = 4
tv89 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 664  : 	{	// convert C string to _Elem sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 665  : 	size_t _Count = _CSTD strlen(_Ptr) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0000f	83 c1 01	 add	 ecx, 1
  00012	89 4d e8	 mov	 DWORD PTR tv86[ebp], ecx
$LL7@Maklocstr:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0001d	83 45 f8 01	 add	 DWORD PTR tv83[ebp], 1
  00021	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00025	75 ee		 jne	 SHORT $LL7@Maklocstr
  00027	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0002a	2b 4d e8	 sub	 ecx, DWORD PTR tv86[ebp]
  0002d	89 4d e4	 mov	 DWORD PTR tv66[ebp], ecx
  00030	8b 55 e4	 mov	 edx, DWORD PTR tv66[ebp]
  00033	83 c2 01	 add	 edx, 1
  00036	89 55 f4	 mov	 DWORD PTR __Count$[ebp], edx

; 666  : 
; 667  : 	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),

  00039	68 9c 02 00 00	 push	 668			; 0000029cH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00043	6a 02		 push	 2
  00045	6a 01		 push	 1
  00047	8b 45 f4	 mov	 eax, DWORD PTR __Count$[ebp]
  0004a	50		 push	 eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00051	83 c4 14	 add	 esp, 20			; 00000014H
  00054	89 45 ec	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 668  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 669  : 
; 670  : 	if (!_Ptrdest)

  00057	83 7d ec 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  0005b	75 05		 jne	 SHORT $LN5@Maklocstr

; 671  : 		_Xbad_alloc();

  0005d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 672  : 
; 673  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

  00062	8b 4d ec	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00065	89 4d f0	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00068	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  0006a	8b 55 f4	 mov	 edx, DWORD PTR __Count$[ebp]
  0006d	83 ea 01	 sub	 edx, 1
  00070	89 55 f4	 mov	 DWORD PTR __Count$[ebp], edx
  00073	8b 45 f0	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  00076	83 c0 01	 add	 eax, 1
  00079	89 45 f0	 mov	 DWORD PTR __Ptrnext$1[ebp], eax
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
$LN4@Maklocstr:
  00085	83 7d f4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00089	76 0c		 jbe	 SHORT $LN3@Maklocstr

; 674  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

  0008b	8b 55 f0	 mov	 edx, DWORD PTR __Ptrnext$1[ebp]
  0008e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00091	8a 08		 mov	 cl, BYTE PTR [eax]
  00093	88 0a		 mov	 BYTE PTR [edx], cl
  00095	eb d3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 675  : 
; 676  : 	return (_Ptrdest);

  00097	8b 45 ec	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 677  : 	}

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT _CreateTimerEngine
_TEXT	SEGMENT
tv129 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
tv150 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
tv151 = -44						; size = 4
tv153 = -40						; size = 4
_pObject$6 = -36					; size = 4
tv75 = -32						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
_pTimerEngine$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_Guid$ = 8						; size = 4
_dwInterfaceVer$ = 12					; size = 4
_CreateTimerEngine PROC					; COMDAT

; 438  : DECLARE_CREATE_MODULE(TimerEngine);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_CreateTimerEngine
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 34	 sub	 esp, 52			; 00000034H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pTimerEngine$[ebp], 0
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0003a	68 80 00 00 00	 push	 128			; 00000080H
  0003f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 d8	 mov	 DWORD PTR tv153[ebp], eax
  0004a	8b 45 d8	 mov	 eax, DWORD PTR tv153[ebp]
  0004d	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax
  00050	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00054	83 7d e4 00	 cmp	 DWORD PTR $T7[ebp], 0
  00058	74 13		 je	 SHORT $LN7@CreateTime
  0005a	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  0005d	e8 00 00 00 00	 call	 ??0CTimerEngine@@QAE@XZ	; CTimerEngine::CTimerEngine
  00062	89 45 d4	 mov	 DWORD PTR tv151[ebp], eax
  00065	8b 4d d4	 mov	 ecx, DWORD PTR tv151[ebp]
  00068	89 4d e0	 mov	 DWORD PTR tv75[ebp], ecx
  0006b	eb 07		 jmp	 SHORT $LN8@CreateTime
$LN7@CreateTime:
  0006d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN8@CreateTime:
  00074	8b 55 e0	 mov	 edx, DWORD PTR tv75[ebp]
  00077	89 55 d0	 mov	 DWORD PTR $T5[ebp], edx
  0007a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0007e	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  00081	89 45 ec	 mov	 DWORD PTR _pTimerEngine$[ebp], eax
  00084	83 7d ec 00	 cmp	 DWORD PTR _pTimerEngine$[ebp], 0
  00088	75 15		 jne	 SHORT $LN3@CreateTime
  0008a	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ??_C@_08HBOFLKLL@?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM@
  00091	68 00 00 00 00	 push	 OFFSET __TI2PAD
  00096	8d 4d cc	 lea	 ecx, DWORD PTR $T4[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@CreateTime:
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d ec	 mov	 ecx, DWORD PTR _pTimerEngine$[ebp]
  000aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ac	8b 4d ec	 mov	 ecx, DWORD PTR _pTimerEngine$[ebp]
  000af	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b2	ff d0		 call	 eax
  000b4	89 45 c8	 mov	 DWORD PTR tv150[ebp], eax
  000b7	8b 4d c8	 mov	 ecx, DWORD PTR tv150[ebp]
  000ba	89 4d dc	 mov	 DWORD PTR _pObject$6[ebp], ecx
  000bd	83 7d dc 00	 cmp	 DWORD PTR _pObject$6[ebp], 0
  000c1	75 15		 jne	 SHORT $LN4@CreateTime
  000c3	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0N@DLOPLLLM@?$LN?S?$LP?Z?$LC?i?Q?$KP?J?$KH?$LA?$NM@
  000ca	68 00 00 00 00	 push	 OFFSET __TI2PAD
  000cf	8d 55 c4	 lea	 edx, DWORD PTR $T3[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN4@CreateTime:
  000d8	8b 45 dc	 mov	 eax, DWORD PTR _pObject$6[ebp]
  000db	e9 83 00 00 00	 jmp	 $LN6@CreateTime
__catch$_CreateTimerEngine$0:
  000e0	b8 00 00 00 00	 mov	 eax, $LN18@CreateTime
  000e5	c3		 ret	 0
  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000ed	eb 07		 jmp	 SHORT __tryend$_CreateTimerEngine$1
$LN18@CreateTime:
  000ef	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$_CreateTimerEngine$1:
  000f6	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _pTimerEngine$[ebp]
  00100	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  00103	8b 4d c0	 mov	 ecx, DWORD PTR $T2[ebp]
  00106	89 4d e8	 mov	 DWORD PTR $T8[ebp], ecx
  00109	83 7d e8 00	 cmp	 DWORD PTR $T8[ebp], 0
  0010d	74 14		 je	 SHORT $LN9@CreateTime
  0010f	6a 01		 push	 1
  00111	8b 55 e8	 mov	 edx, DWORD PTR $T8[ebp]
  00114	8b 02		 mov	 eax, DWORD PTR [edx]
  00116	8b 4d e8	 mov	 ecx, DWORD PTR $T8[ebp]
  00119	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  0011c	ff d2		 call	 edx
  0011e	89 45 bc	 mov	 DWORD PTR tv129[ebp], eax
  00121	eb 07		 jmp	 SHORT $LN10@CreateTime
$LN9@CreateTime:
  00123	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv129[ebp], 0
$LN10@CreateTime:
  0012a	eb 1e		 jmp	 SHORT $LN14@CreateTime
__catch$_CreateTimerEngine$2:
  0012c	33 c0		 xor	 eax, eax
  0012e	75 14		 jne	 SHORT $LN11@CreateTime
  00130	68 b6 01 00 00	 push	 438			; 000001b6H
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0013a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0013f	85 c0		 test	 eax, eax
  00141	74 01		 je	 SHORT $LN11@CreateTime
  00143	cc		 int	 3
$LN11@CreateTime:
  00144	b8 00 00 00 00	 mov	 eax, $LN20@CreateTime
  00149	c3		 ret	 0
$LN14@CreateTime:
  0014a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00151	eb 07		 jmp	 SHORT __tryend$_CreateTimerEngine$3
$LN20@CreateTime:
  00153	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$_CreateTimerEngine$3:
  0015a	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pTimerEngine$[ebp], 0
  00161	33 c0		 xor	 eax, eax
$LN6@CreateTime:
  00163	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00166	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016d	59		 pop	 ecx
  0016e	5f		 pop	 edi
  0016f	5e		 pop	 esi
  00170	5b		 pop	 ebx
  00171	8b e5		 mov	 esp, ebp
  00173	5d		 pop	 ebp
  00174	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_CreateTimerEngine$4:
  00000	68 80 00 00 00	 push	 128			; 00000080H
  00005	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__ehhandler$_CreateTimerEngine:
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_CreateTimerEngine
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_CreateTimerEngine ENDP
; Function compile flags: /Odtp
;	COMDAT ??_GCTimerEngine@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTimerEngine@@UAEPAXI@Z PROC			; CTimerEngine::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTimerEngine@@UAE@XZ	; CTimerEngine::~CTimerEngine
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 11		 je	 SHORT $LN2@scalar
  00017	68 80 00 00 00	 push	 128			; 00000080H
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00025	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_GCTimerEngine@@UAEPAXI@Z ENDP			; CTimerEngine::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?OnTimerThreadSink@CTimerEngine@@AAEXXZ
_TEXT	SEGMENT
_ThreadLock$ = -64					; size = 12
_nIndex$2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
tv188 = -40						; size = 4
_this$ = -36						; size = 4
_dwTimeLeave$5 = -32					; size = 4
_i$6 = -28						; size = 4
_pTimerItem$7 = -24					; size = 4
_this$ = -20						; size = 4
_bKillTimer$8 = -13					; size = 1
__$EHRec$ = -12						; size = 12
?OnTimerThreadSink@CTimerEngine@@AAEXXZ PROC		; CTimerEngine::OnTimerThreadSink, COMDAT
; _this$ = ecx

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnTimerThreadSink@CTimerEngine@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 363  :     // 锁定资源
; 364  :     CWHDataLocker ThreadLock(m_CriticalSection);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 5c	 add	 eax, 92			; 0000005cH
  00030	50		 push	 eax
  00031	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 365  : 
; 366  :     // 倒计时间
; 367  :     if (m_dwTimeLeave == NO_TIME_LEAVE)

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 79 0c ff	 cmp	 DWORD PTR [ecx+12], -1
  00048	75 38		 jne	 SHORT $LN5@OnTimerThr
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  0004a	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0004d	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00050	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 369  :         ASSERT(m_TimerItemActive.GetCount() == 0);

  00053	83 7d d4 00	 cmp	 DWORD PTR $T4[ebp], 0
  00057	74 14		 je	 SHORT $LN14@OnTimerThr
  00059	68 71 01 00 00	 push	 369			; 00000171H
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00063	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00068	85 c0		 test	 eax, eax
  0006a	74 01		 je	 SHORT $LN14@OnTimerThr
  0006c	cc		 int	 3
$LN14@OnTimerThr:

; 370  :         return;

  0006d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00074	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0007d	e9 da 01 00 00	 jmp	 $LN1@OnTimerThr
$LN5@OnTimerThr:

; 371  :     }
; 372  : 
; 373  :     // 减少时间
; 374  :     m_dwTimePass += m_dwTimerSpace;

  00082	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00085	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00088	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0008e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00091	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 375  :     m_dwTimeLeave -= m_dwTimerSpace;

  00094	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0009d	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  000a0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 376  : 
; 377  :     // 查询定时器
; 378  :     if (m_dwTimeLeave == 0)

  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  000ad	0f 85 99 01 00
	00		 jne	 $LN6@OnTimerThr

; 379  :     {
; 380  :         // 变量定义
; 381  :         bool bKillTimer = false;

  000b3	c6 45 f3 00	 mov	 BYTE PTR _bKillTimer$8[ebp], 0

; 382  :         DWORD dwTimeLeave = NO_TIME_LEAVE;

  000b7	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _dwTimeLeave$5[ebp], -1

; 385  :         for (INT_PTR i = 0; i < m_TimerItemActive.GetCount();)

  000be	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
$LN4@OnTimerThr:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000c5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000c8	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  000cb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 385  :         for (INT_PTR i = 0; i < m_TimerItemActive.GetCount();)

  000ce	8b 4d e4	 mov	 ecx, DWORD PTR _i$6[ebp]
  000d1	3b 4d d0	 cmp	 ecx, DWORD PTR $T3[ebp]
  000d4	0f 8d 5f 01 00
	00		 jge	 $LN3@OnTimerThr
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000da	8b 55 e4	 mov	 edx, DWORD PTR _i$6[ebp]
  000dd	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 388  :             tagTimerItem * pTimerItem = m_TimerItemActive[i];

  000de	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	83 c1 48	 add	 ecx, 72			; 00000048H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000e4	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 388  :             tagTimerItem * pTimerItem = m_TimerItemActive[i];

  000e9	8b 00		 mov	 eax, DWORD PTR [eax]
  000eb	89 45 e8	 mov	 DWORD PTR _pTimerItem$7[ebp], eax

; 389  :             ASSERT(pTimerItem->dwTimeLeave >= m_dwTimePass);

  000ee	8b 4d e8	 mov	 ecx, DWORD PTR _pTimerItem$7[ebp]
  000f1	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000f7	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000fa	73 14		 jae	 SHORT $LN15@OnTimerThr
  000fc	68 85 01 00 00	 push	 389			; 00000185H
  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00106	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0010b	85 c0		 test	 eax, eax
  0010d	74 01		 je	 SHORT $LN15@OnTimerThr
  0010f	cc		 int	 3
$LN15@OnTimerThr:

; 390  : 
; 391  :             // 设置变量
; 392  :             bKillTimer = false;

  00110	c6 45 f3 00	 mov	 BYTE PTR _bKillTimer$8[ebp], 0

; 393  :             pTimerItem->dwTimeLeave -= m_dwTimePass;

  00114	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  00117	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0011a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0011d	2b 48 08	 sub	 ecx, DWORD PTR [eax+8]
  00120	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  00123	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 394  : 
; 395  :             // 通知判断
; 396  :             if (pTimerItem->dwTimeLeave == 0L)

  00126	8b 45 e8	 mov	 eax, DWORD PTR _pTimerItem$7[ebp]
  00129	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0012d	0f 85 ab 00 00
	00		 jne	 $LN7@OnTimerThr

; 397  :             {
; 398  :                 // 发送通知
; 399  :                 ASSERT(m_pITimerEngineEvent != NULL);

  00133	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0013a	75 14		 jne	 SHORT $LN16@OnTimerThr
  0013c	68 8f 01 00 00	 push	 399			; 0000018fH
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00146	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0014b	85 c0		 test	 eax, eax
  0014d	74 01		 je	 SHORT $LN16@OnTimerThr
  0014f	cc		 int	 3
$LN16@OnTimerThr:

; 400  :                 m_pITimerEngineEvent->OnEventTimer(pTimerItem->dwTimerID, pTimerItem->dwBindParameter);

  00150	8b 45 e8	 mov	 eax, DWORD PTR _pTimerItem$7[ebp]
  00153	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00156	51		 push	 ecx
  00157	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  0015a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0015d	50		 push	 eax
  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00164	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 12		 mov	 edx, DWORD PTR [edx]
  00169	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0016c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0016f	ff d0		 call	 eax

; 401  : 
; 402  :                 // 设置次数
; 403  :                 if (pTimerItem->dwRepeatTimes != TIMES_INFINITY)

  00171	8b 4d e8	 mov	 ecx, DWORD PTR _pTimerItem$7[ebp]
  00174	83 79 0c ff	 cmp	 DWORD PTR [ecx+12], -1
  00178	74 51		 je	 SHORT $LN8@OnTimerThr

; 404  :                 {
; 405  :                     if (pTimerItem->dwRepeatTimes == 1L)

  0017a	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  0017d	83 7a 0c 01	 cmp	 DWORD PTR [edx+12], 1
  00181	75 39		 jne	 SHORT $LN9@OnTimerThr

; 406  :                     {
; 407  :                         bKillTimer = true;

  00183	c6 45 f3 01	 mov	 BYTE PTR _bKillTimer$8[ebp], 1

; 408  :                         m_TimerItemActive.RemoveAt(i);

  00187	6a 01		 push	 1
  00189	8b 45 e4	 mov	 eax, DWORD PTR _i$6[ebp]
  0018c	50		 push	 eax
  0018d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	83 c1 48	 add	 ecx, 72			; 00000048H
  00193	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt

; 409  :                         m_TimerItemFree.Add(pTimerItem);

  00198	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019b	83 c1 34	 add	 ecx, 52			; 00000034H
  0019e	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  001a1	8b 55 dc	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  001a7	89 45 cc	 mov	 DWORD PTR _nIndex$2[ebp], eax

; 107  : 	SetAtGrow(nIndex,newElement);

  001aa	8d 4d e8	 lea	 ecx, DWORD PTR _pTimerItem$7[ebp]
  001ad	51		 push	 ecx
  001ae	8b 55 cc	 mov	 edx, DWORD PTR _nIndex$2[ebp]
  001b1	52		 push	 edx
  001b2	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 411  :                     else pTimerItem->dwRepeatTimes--;

  001ba	eb 0f		 jmp	 SHORT $LN8@OnTimerThr
$LN9@OnTimerThr:
  001bc	8b 45 e8	 mov	 eax, DWORD PTR _pTimerItem$7[ebp]
  001bf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001c2	83 e9 01	 sub	 ecx, 1
  001c5	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  001c8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN8@OnTimerThr:

; 412  :                 }
; 413  : 
; 414  :                 // 设置时间
; 415  :                 if (bKillTimer == false) pTimerItem->dwTimeLeave = pTimerItem->dwElapse;

  001cb	0f b6 45 f3	 movzx	 eax, BYTE PTR _bKillTimer$8[ebp]
  001cf	85 c0		 test	 eax, eax
  001d1	75 0b		 jne	 SHORT $LN7@OnTimerThr
  001d3	8b 4d e8	 mov	 ecx, DWORD PTR _pTimerItem$7[ebp]
  001d6	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$7[ebp]
  001d9	8b 02		 mov	 eax, DWORD PTR [edx]
  001db	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN7@OnTimerThr:

; 416  :             }
; 417  : 
; 418  :             // 增加索引
; 419  :             if (bKillTimer == false)

  001de	0f b6 4d f3	 movzx	 ecx, BYTE PTR _bKillTimer$8[ebp]
  001e2	85 c9		 test	 ecx, ecx
  001e4	75 4e		 jne	 SHORT $LN12@OnTimerThr

; 420  :             {
; 421  :                 i++;

  001e6	8b 55 e4	 mov	 edx, DWORD PTR _i$6[ebp]
  001e9	83 c2 01	 add	 edx, 1
  001ec	89 55 e4	 mov	 DWORD PTR _i$6[ebp], edx

; 422  :                 dwTimeLeave = __min(dwTimeLeave, pTimerItem->dwTimeLeave);

  001ef	8b 45 e8	 mov	 eax, DWORD PTR _pTimerItem$7[ebp]
  001f2	8b 4d e0	 mov	 ecx, DWORD PTR _dwTimeLeave$5[ebp]
  001f5	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  001f8	73 08		 jae	 SHORT $LN17@OnTimerThr
  001fa	8b 55 e0	 mov	 edx, DWORD PTR _dwTimeLeave$5[ebp]
  001fd	89 55 d8	 mov	 DWORD PTR tv188[ebp], edx
  00200	eb 09		 jmp	 SHORT $LN18@OnTimerThr
$LN17@OnTimerThr:
  00202	8b 45 e8	 mov	 eax, DWORD PTR _pTimerItem$7[ebp]
  00205	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00208	89 4d d8	 mov	 DWORD PTR tv188[ebp], ecx
$LN18@OnTimerThr:
  0020b	8b 55 d8	 mov	 edx, DWORD PTR tv188[ebp]
  0020e	89 55 e0	 mov	 DWORD PTR _dwTimeLeave$5[ebp], edx

; 423  :                 ASSERT(dwTimeLeave%m_dwTimerSpace == 0);

  00211	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00214	8b 45 e0	 mov	 eax, DWORD PTR _dwTimeLeave$5[ebp]
  00217	33 d2		 xor	 edx, edx
  00219	f7 71 10	 div	 DWORD PTR [ecx+16]
  0021c	85 d2		 test	 edx, edx
  0021e	74 14		 je	 SHORT $LN12@OnTimerThr
  00220	68 a7 01 00 00	 push	 423			; 000001a7H
  00225	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0022a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0022f	85 c0		 test	 eax, eax
  00231	74 01		 je	 SHORT $LN12@OnTimerThr
  00233	cc		 int	 3
$LN12@OnTimerThr:

; 424  :             }
; 425  :         }

  00234	e9 8c fe ff ff	 jmp	 $LN4@OnTimerThr
$LN3@OnTimerThr:

; 426  : 
; 427  :         // 设置响应
; 428  :         m_dwTimePass = 0L;

  00239	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0023c	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 429  :         m_dwTimeLeave = dwTimeLeave;

  00243	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	8b 55 e0	 mov	 edx, DWORD PTR _dwTimeLeave$5[ebp]
  00249	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN6@OnTimerThr:

; 430  :     }
; 431  : 
; 432  :     return;

  0024c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00253	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00256	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
$LN1@OnTimerThr:

; 433  : }

  0025c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0025f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00266	59		 pop	 ecx
  00267	8b e5		 mov	 esp, ebp
  00269	5d		 pop	 ebp
  0026a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnTimerThreadSink@CTimerEngine@@AAEXXZ$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?OnTimerThreadSink@CTimerEngine@@AAEXXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnTimerThreadSink@CTimerEngine@@AAEXXZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnTimerThreadSink@CTimerEngine@@AAEXXZ ENDP		; CTimerEngine::OnTimerThreadSink
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?KillAllTimer@CTimerEngine@@UAE_NXZ
_TEXT	SEGMENT
_ThreadLock$ = -32					; size = 12
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?KillAllTimer@CTimerEngine@@UAE_NXZ PROC		; CTimerEngine::KillAllTimer, COMDAT
; _this$ = ecx

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?KillAllTimer@CTimerEngine@@UAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 283  :     // 锁定资源
; 284  :     CWHDataLocker ThreadLock(m_CriticalSection);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 5c	 add	 eax, 92			; 0000005cH
  00030	50		 push	 eax
  00031	8d 4d e0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 285  : 
; 286  :     // 删除定时器
; 287  :     m_TimerItemFree.Append(m_TimerItemActive);

  00041	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	83 c1 48	 add	 ecx, 72			; 00000048H
  00047	51		 push	 ecx
  00048	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 34	 add	 ecx, 52			; 00000034H
  0004e	e8 00 00 00 00	 call	 ?Append@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABV1@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Append

; 288  :     m_TimerItemActive.RemoveAll();

  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 48	 add	 ecx, 72			; 00000048H
  00059	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll

; 289  : 
; 290  :     // 设置变量
; 291  :     m_dwTimePass = 0L;

  0005e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00061	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 292  :     m_dwTimeLeave = NO_TIME_LEAVE;

  00068	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 293  : 
; 294  :     return true;

  00072	c6 45 f3 01	 mov	 BYTE PTR $T2[ebp], 1
  00076	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8d 4d e0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00086	8a 45 f3	 mov	 al, BYTE PTR $T2[ebp]

; 295  : }

  00089	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00093	59		 pop	 ecx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?KillAllTimer@CTimerEngine@@UAE_NXZ$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?KillAllTimer@CTimerEngine@@UAE_NXZ:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?KillAllTimer@CTimerEngine@@UAE_NXZ
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?KillAllTimer@CTimerEngine@@UAE_NXZ ENDP		; CTimerEngine::KillAllTimer
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?KillTimer@CTimerEngine@@UAE_NK@Z
_TEXT	SEGMENT
_ThreadLock$ = -56					; size = 12
$T2 = -44						; size = 4
_nIndex$3 = -40						; size = 4
$T4 = -36						; size = 4
_this$ = -32						; size = 4
_pTimerItem$5 = -28					; size = 4
_i$6 = -24						; size = 4
_this$ = -20						; size = 4
$T7 = -14						; size = 1
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dwTimerID$ = 8						; size = 4
?KillTimer@CTimerEngine@@UAE_NK@Z PROC			; CTimerEngine::KillTimer, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?KillTimer@CTimerEngine@@UAE_NK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 253  :     // 锁定资源
; 254  :     CWHDataLocker ThreadLock(m_CriticalSection);

  00028	6a 01		 push	 1
  0002a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 5c	 add	 eax, 92			; 0000005cH
  00030	50		 push	 eax
  00031	8d 4d c8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 257  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  00048	eb 09		 jmp	 SHORT $LN4@KillTimer
$LN2@KillTimer:
  0004a	8b 4d e8	 mov	 ecx, DWORD PTR _i$6[ebp]
  0004d	83 c1 01	 add	 ecx, 1
  00050	89 4d e8	 mov	 DWORD PTR _i$6[ebp], ecx
$LN4@KillTimer:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00053	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8b 42 58	 mov	 eax, DWORD PTR [edx+88]
  00059	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 257  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  0005c	8b 4d e8	 mov	 ecx, DWORD PTR _i$6[ebp]
  0005f	3b 4d dc	 cmp	 ecx, DWORD PTR $T4[ebp]
  00062	0f 8d 95 00 00
	00		 jge	 $LN3@KillTimer
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00068	8b 55 e8	 mov	 edx, DWORD PTR _i$6[ebp]
  0006b	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 260  :         tagTimerItem * pTimerItem = m_TimerItemActive[i];

  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	83 c1 48	 add	 ecx, 72			; 00000048H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00072	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 260  :         tagTimerItem * pTimerItem = m_TimerItemActive[i];

  00077	8b 00		 mov	 eax, DWORD PTR [eax]
  00079	89 45 e4	 mov	 DWORD PTR _pTimerItem$5[ebp], eax

; 261  :         if (pTimerItem->dwTimerID != dwTimerID) continue;

  0007c	8b 4d e4	 mov	 ecx, DWORD PTR _pTimerItem$5[ebp]
  0007f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00082	3b 55 08	 cmp	 edx, DWORD PTR _dwTimerID$[ebp]
  00085	74 02		 je	 SHORT $LN5@KillTimer
  00087	eb c1		 jmp	 SHORT $LN2@KillTimer
$LN5@KillTimer:

; 262  : 
; 263  :         // 设置对象
; 264  :         m_TimerItemActive.RemoveAt(i);

  00089	6a 01		 push	 1
  0008b	8b 45 e8	 mov	 eax, DWORD PTR _i$6[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	83 c1 48	 add	 ecx, 72			; 00000048H
  00095	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt

; 265  :         m_TimerItemFree.Add(pTimerItem);

  0009a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 34	 add	 ecx, 52			; 00000034H
  000a0	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  000a3	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000a9	89 45 d8	 mov	 DWORD PTR _nIndex$3[ebp], eax

; 107  : 	SetAtGrow(nIndex,newElement);

  000ac	8d 4d e4	 lea	 ecx, DWORD PTR _pTimerItem$5[ebp]
  000af	51		 push	 ecx
  000b0	8b 55 d8	 mov	 edx, DWORD PTR _nIndex$3[ebp]
  000b3	52		 push	 edx
  000b4	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow

; 99   : 	return m_nElementCount;

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  000c2	89 4d d4	 mov	 DWORD PTR $T2[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 268  :         if (m_TimerItemActive.GetCount() == 0)

  000c5	83 7d d4 00	 cmp	 DWORD PTR $T2[ebp], 0
  000c9	75 14		 jne	 SHORT $LN6@KillTimer

; 269  :         {
; 270  :             m_dwTimePass = 0L;

  000cb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 271  :             m_dwTimeLeave = NO_TIME_LEAVE;

  000d5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1
$LN6@KillTimer:

; 272  :         }
; 273  : 
; 274  :         return true;

  000df	c6 45 f3 01	 mov	 BYTE PTR $T8[ebp], 1
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 4d c8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  000f3	8a 45 f3	 mov	 al, BYTE PTR $T8[ebp]
  000f6	eb 1c		 jmp	 SHORT $LN1@KillTimer

; 275  :     }

  000f8	e9 4d ff ff ff	 jmp	 $LN2@KillTimer
$LN3@KillTimer:

; 276  : 
; 277  :     return false;

  000fd	c6 45 f2 00	 mov	 BYTE PTR $T7[ebp], 0
  00101	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00108	8d 4d c8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00111	8a 45 f2	 mov	 al, BYTE PTR $T7[ebp]
$LN1@KillTimer:

; 278  : }

  00114	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00117	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011e	59		 pop	 ecx
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?KillTimer@CTimerEngine@@UAE_NK@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?KillTimer@CTimerEngine@@UAE_NK@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?KillTimer@CTimerEngine@@UAE_NK@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?KillTimer@CTimerEngine@@UAE_NK@Z ENDP			; CTimerEngine::KillTimer
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?SetTimeCell@CTimerEngine@@UAE_NK@Z
_TEXT	SEGMENT
_ThreadLock$ = -88					; size = 12
_nIndex$2 = -76						; size = 4
_dwBindParameter$ = -72					; size = 4
_dwRepeat$ = -68					; size = 4
tv177 = -64						; size = 4
$T3 = -60						; size = 4
tv65 = -56						; size = 4
$T4 = -52						; size = 4
_this$ = -48						; size = 4
tv171 = -44						; size = 4
_nFreeCount$5 = -40					; size = 4
_i$6 = -36						; size = 4
_dwElapse$ = -32					; size = 4
_pTimerItem$ = -28					; size = 4
_this$ = -24						; size = 4
$T7 = -20						; size = 1
$T8 = -19						; size = 1
$T9 = -18						; size = 1
_bTimerExist$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
_dwTimerID$ = 8						; size = 4
?SetTimeCell@CTimerEngine@@UAE_NK@Z PROC		; CTimerEngine::SetTimeCell, COMDAT
; _this$ = ecx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetTimeCell@CTimerEngine@@UAE_NK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 192  :     // 锁定资源
; 193  :     CWHDataLocker ThreadLock(m_CriticalSection);

  0002f	6a 01		 push	 1
  00031	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 5c	 add	 eax, 92			; 0000005cH
  00037	50		 push	 eax
  00038	8d 4d a8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 194  : 
; 195  :     DWORD dwElapse = 1; DWORD dwRepeat = 1; WPARAM dwBindParameter = 0;

  00048	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _dwElapse$[ebp], 1
  0004f	c7 45 bc 01 00
	00 00		 mov	 DWORD PTR _dwRepeat$[ebp], 1
  00056	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _dwBindParameter$[ebp], 0

; 196  :     // 效验参数
; 197  :     dwElapse = (dwElapse + m_dwTimerSpace - 1) / m_dwTimerSpace*m_dwTimerSpace;

  0005d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00063	8b 45 e0	 mov	 eax, DWORD PTR _dwElapse$[ebp]
  00066	8d 44 10 ff	 lea	 eax, DWORD PTR [eax+edx-1]
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 71 10	 div	 DWORD PTR [ecx+16]
  00072	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00075	0f af 42 10	 imul	 eax, DWORD PTR [edx+16]
  00079	89 45 e0	 mov	 DWORD PTR _dwElapse$[ebp], eax

; 198  : 
; 199  :     // 查找定时器
; 200  :     bool bTimerExist = false;

  0007c	c6 45 ef 00	 mov	 BYTE PTR _bTimerExist$[ebp], 0

; 201  :     tagTimerItem * pTimerItem = NULL;

  00080	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pTimerItem$[ebp], 0

; 202  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  00087	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  0008e	eb 09		 jmp	 SHORT $LN4@SetTimeCel
$LN2@SetTimeCel:
  00090	8b 45 dc	 mov	 eax, DWORD PTR _i$6[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 dc	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@SetTimeCel:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00099	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  0009f	89 55 cc	 mov	 DWORD PTR $T4[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 202  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  000a2	8b 45 dc	 mov	 eax, DWORD PTR _i$6[ebp]
  000a5	3b 45 cc	 cmp	 eax, DWORD PTR $T4[ebp]
  000a8	7d 27		 jge	 SHORT $LN3@SetTimeCel
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000aa	8b 4d dc	 mov	 ecx, DWORD PTR _i$6[ebp]
  000ad	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 204  :         pTimerItem = m_TimerItemActive[i];

  000ae	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	83 c1 48	 add	 ecx, 72			; 00000048H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000b4	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 204  :         pTimerItem = m_TimerItemActive[i];

  000b9	8b 10		 mov	 edx, DWORD PTR [eax]
  000bb	89 55 e4	 mov	 DWORD PTR _pTimerItem$[ebp], edx

; 205  :         if (pTimerItem->dwTimerID == dwTimerID)

  000be	8b 45 e4	 mov	 eax, DWORD PTR _pTimerItem$[ebp]
  000c1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c4	3b 4d 08	 cmp	 ecx, DWORD PTR _dwTimerID$[ebp]
  000c7	75 06		 jne	 SHORT $LN5@SetTimeCel

; 206  :         {
; 207  :             bTimerExist = true;

  000c9	c6 45 ef 01	 mov	 BYTE PTR _bTimerExist$[ebp], 1

; 208  :             break;

  000cd	eb 02		 jmp	 SHORT $LN3@SetTimeCel
$LN5@SetTimeCel:

; 209  :         }
; 210  :     }

  000cf	eb bf		 jmp	 SHORT $LN2@SetTimeCel
$LN3@SetTimeCel:

; 211  : 
; 212  :     // 创建定时器
; 213  :     if (bTimerExist == false)

  000d1	0f b6 55 ef	 movzx	 edx, BYTE PTR _bTimerExist$[ebp]
  000d5	85 d2		 test	 edx, edx
  000d7	0f 85 c6 00 00
	00		 jne	 $LN18@SetTimeCel
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000dd	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000e3	89 4d d8	 mov	 DWORD PTR _nFreeCount$5[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 216  :         if (nFreeCount > 0)

  000e6	83 7d d8 00	 cmp	 DWORD PTR _nFreeCount$5[ebp], 0
  000ea	7e 47		 jle	 SHORT $LN7@SetTimeCel

; 218  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  000ec	8b 55 d8	 mov	 edx, DWORD PTR _nFreeCount$5[ebp]
  000ef	83 ea 01	 sub	 edx, 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000f2	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 218  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  000f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	83 c1 34	 add	 ecx, 52			; 00000034H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000f9	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 218  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  000fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00100	89 45 e4	 mov	 DWORD PTR _pTimerItem$[ebp], eax

; 219  :             ASSERT(pTimerItem != NULL);

  00103	83 7d e4 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  00107	75 14		 jne	 SHORT $LN13@SetTimeCel
  00109	68 db 00 00 00	 push	 219			; 000000dbH
  0010e	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00113	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00118	85 c0		 test	 eax, eax
  0011a	74 01		 je	 SHORT $LN13@SetTimeCel
  0011c	cc		 int	 3
$LN13@SetTimeCel:

; 220  :             m_TimerItemFree.RemoveAt(nFreeCount - 1);

  0011d	6a 01		 push	 1
  0011f	8b 55 d8	 mov	 edx, DWORD PTR _nFreeCount$5[ebp]
  00122	83 ea 01	 sub	 edx, 1
  00125	52		 push	 edx
  00126	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	83 c1 34	 add	 ecx, 52			; 00000034H
  0012c	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt

; 221  :         }
; 222  :         else

  00131	eb 70		 jmp	 SHORT $LN18@SetTimeCel
$LN7@SetTimeCel:

; 223  :         {
; 224  :             try

  00133	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 225  :             {
; 226  :                 pTimerItem = new tagTimerItem;

  00137	6a 14		 push	 20			; 00000014H
  00139	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0013e	83 c4 04	 add	 esp, 4
  00141	89 45 c8	 mov	 DWORD PTR tv65[ebp], eax
  00144	8b 45 c8	 mov	 eax, DWORD PTR tv65[ebp]
  00147	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  0014a	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp]
  0014d	89 4d e4	 mov	 DWORD PTR _pTimerItem$[ebp], ecx

; 227  :                 ASSERT(pTimerItem != NULL);

  00150	83 7d e4 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  00154	75 19		 jne	 SHORT $LN14@SetTimeCel
  00156	68 e3 00 00 00	 push	 227			; 000000e3H
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00160	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00165	89 45 c0	 mov	 DWORD PTR tv177[ebp], eax
  00168	83 7d c0 00	 cmp	 DWORD PTR tv177[ebp], 0
  0016c	74 01		 je	 SHORT $LN14@SetTimeCel
  0016e	cc		 int	 3
$LN14@SetTimeCel:

; 228  :                 if (pTimerItem == NULL)

  0016f	83 7d e4 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  00173	75 1c		 jne	 SHORT $LN10@SetTimeCel

; 229  :                     return false;

  00175	c6 45 ee 00	 mov	 BYTE PTR $T9[ebp], 0
  00179	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00180	8d 4d a8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00183	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00189	8a 45 ee	 mov	 al, BYTE PTR $T9[ebp]
  0018c	e9 e5 00 00 00	 jmp	 $LN1@SetTimeCel
$LN10@SetTimeCel:

; 230  :             }

  00191	eb 10		 jmp	 SHORT $LN18@SetTimeCel
__catch$?SetTimeCell@CTimerEngine@@UAE_NK@Z$0:

; 231  :             catch (...) { return false; }

  00193	c6 45 ed 00	 mov	 BYTE PTR $T8[ebp], 0
  00197	b8 00 00 00 00	 mov	 eax, $LN22@SetTimeCel
  0019c	c3		 ret	 0
  0019d	b8 00 00 00 00	 mov	 eax, $LN18@SetTimeCel
  001a2	c3		 ret	 0
$LN18@SetTimeCel:
  001a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001aa	eb 18		 jmp	 SHORT $LN21@SetTimeCel
$LN22@SetTimeCel:
  001ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001b3	8d 4d a8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  001bc	8a 45 ed	 mov	 al, BYTE PTR $T8[ebp]
  001bf	e9 b2 00 00 00	 jmp	 $LN1@SetTimeCel
$LN21@SetTimeCel:

; 232  :         }
; 233  :     }
; 234  : 
; 235  :     // 设置参数
; 236  :     ASSERT(pTimerItem != NULL);

  001c4	83 7d e4 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  001c8	75 14		 jne	 SHORT $LN15@SetTimeCel
  001ca	68 ec 00 00 00	 push	 236			; 000000ecH
  001cf	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001d4	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  001d9	85 c0		 test	 eax, eax
  001db	74 01		 je	 SHORT $LN15@SetTimeCel
  001dd	cc		 int	 3
$LN15@SetTimeCel:

; 237  :     pTimerItem->dwElapse = dwElapse;

  001de	8b 4d e4	 mov	 ecx, DWORD PTR _pTimerItem$[ebp]
  001e1	8b 55 e0	 mov	 edx, DWORD PTR _dwElapse$[ebp]
  001e4	89 11		 mov	 DWORD PTR [ecx], edx

; 238  :     pTimerItem->dwTimerID = dwTimerID;

  001e6	8b 45 e4	 mov	 eax, DWORD PTR _pTimerItem$[ebp]
  001e9	8b 4d 08	 mov	 ecx, DWORD PTR _dwTimerID$[ebp]
  001ec	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 239  :     pTimerItem->dwRepeatTimes = dwRepeat;

  001ef	8b 55 e4	 mov	 edx, DWORD PTR _pTimerItem$[ebp]
  001f2	8b 45 bc	 mov	 eax, DWORD PTR _dwRepeat$[ebp]
  001f5	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 240  :     pTimerItem->dwBindParameter = dwBindParameter;

  001f8	8b 4d e4	 mov	 ecx, DWORD PTR _pTimerItem$[ebp]
  001fb	8b 55 b8	 mov	 edx, DWORD PTR _dwBindParameter$[ebp]
  001fe	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 241  :     pTimerItem->dwTimeLeave = dwElapse + m_dwTimePass;

  00201	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00204	8b 4d e0	 mov	 ecx, DWORD PTR _dwElapse$[ebp]
  00207	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  0020a	8b 55 e4	 mov	 edx, DWORD PTR _pTimerItem$[ebp]
  0020d	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 242  : 
; 243  :     // 激活定时器
; 244  :     m_dwTimeLeave = __min(m_dwTimeLeave, dwElapse);

  00210	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00213	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00216	3b 4d e0	 cmp	 ecx, DWORD PTR _dwElapse$[ebp]
  00219	73 0b		 jae	 SHORT $LN16@SetTimeCel
  0021b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0021e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00221	89 45 d4	 mov	 DWORD PTR tv171[ebp], eax
  00224	eb 06		 jmp	 SHORT $LN17@SetTimeCel
$LN16@SetTimeCel:
  00226	8b 4d e0	 mov	 ecx, DWORD PTR _dwElapse$[ebp]
  00229	89 4d d4	 mov	 DWORD PTR tv171[ebp], ecx
$LN17@SetTimeCel:
  0022c	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0022f	8b 45 d4	 mov	 eax, DWORD PTR tv171[ebp]
  00232	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 245  :     if (bTimerExist == false) m_TimerItemActive.Add(pTimerItem);

  00235	0f b6 4d ef	 movzx	 ecx, BYTE PTR _bTimerExist$[ebp]
  00239	85 c9		 test	 ecx, ecx
  0023b	75 22		 jne	 SHORT $LN11@SetTimeCel
  0023d	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00240	83 c2 48	 add	 edx, 72			; 00000048H
  00243	89 55 d0	 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00246	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00249	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0024c	89 4d b4	 mov	 DWORD PTR _nIndex$2[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  0024f	8d 55 e4	 lea	 edx, DWORD PTR _pTimerItem$[ebp]
  00252	52		 push	 edx
  00253	8b 45 b4	 mov	 eax, DWORD PTR _nIndex$2[ebp]
  00256	50		 push	 eax
  00257	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow
$LN11@SetTimeCel:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 247  :     return false;

  0025f	c6 45 ec 00	 mov	 BYTE PTR $T7[ebp], 0
  00263	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0026a	8d 4d a8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0026d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  00273	8a 45 ec	 mov	 al, BYTE PTR $T7[ebp]
$LN1@SetTimeCel:

; 248  : }

  00276	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00279	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00280	59		 pop	 ecx
  00281	5f		 pop	 edi
  00282	5e		 pop	 esi
  00283	5b		 pop	 ebx
  00284	8b e5		 mov	 esp, ebp
  00286	5d		 pop	 ebp
  00287	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTimeCell@CTimerEngine@@UAE_NK@Z$2:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?SetTimeCell@CTimerEngine@@UAE_NK@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTimeCell@CTimerEngine@@UAE_NK@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTimeCell@CTimerEngine@@UAE_NK@Z ENDP		; CTimerEngine::SetTimeCell
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?SetTimer@CTimerEngine@@UAE_NKKKI@Z
_TEXT	SEGMENT
_ThreadLock$ = -80					; size = 12
_nIndex$2 = -68						; size = 4
tv184 = -64						; size = 4
$T3 = -60						; size = 4
tv65 = -56						; size = 4
$T4 = -52						; size = 4
_this$ = -48						; size = 4
tv178 = -44						; size = 4
_nFreeCount$5 = -40					; size = 4
_i$6 = -36						; size = 4
_pTimerItem$ = -32					; size = 4
_this$ = -28						; size = 4
$T7 = -21						; size = 1
$T8 = -20						; size = 1
$T9 = -19						; size = 1
$T10 = -18						; size = 1
_bTimerExist$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
_dwTimerID$ = 8						; size = 4
_dwElapse$ = 12						; size = 4
_dwRepeat$ = 16						; size = 4
_dwBindParameter$ = 20					; size = 4
?SetTimer@CTimerEngine@@UAE_NKKKI@Z PROC		; CTimerEngine::SetTimer, COMDAT
; _this$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetTimer@CTimerEngine@@UAE_NKKKI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :     // 锁定资源
; 130  :     CWHDataLocker ThreadLock(m_CriticalSection);

  0002f	6a 01		 push	 1
  00031	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 5c	 add	 eax, 92			; 0000005cH
  00037	50		 push	 eax
  00038	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHDataLocker@@QAE@AAVCCriticalSection@@_N@Z
  00041	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 131  : 
; 132  :     // 效验参数
; 133  :     ASSERT(dwRepeat > 0L);

  00048	83 7d 10 00	 cmp	 DWORD PTR _dwRepeat$[ebp], 0
  0004c	77 14		 ja	 SHORT $LN14@SetTimer
  0004e	68 85 00 00 00	 push	 133			; 00000085H
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00058	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005d	85 c0		 test	 eax, eax
  0005f	74 01		 je	 SHORT $LN14@SetTimer
  00061	cc		 int	 3
$LN14@SetTimer:

; 134  :     if (dwRepeat == 0)

  00062	83 7d 10 00	 cmp	 DWORD PTR _dwRepeat$[ebp], 0
  00066	75 1c		 jne	 SHORT $LN5@SetTimer

; 135  :         return false;

  00068	c6 45 ee 00	 mov	 BYTE PTR $T10[ebp], 0
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00073	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0007c	8a 45 ee	 mov	 al, BYTE PTR $T10[ebp]
  0007f	e9 19 02 00 00	 jmp	 $LN1@SetTimer
$LN5@SetTimer:

; 136  :     dwElapse = (dwElapse + m_dwTimerSpace - 1) / m_dwTimerSpace*m_dwTimerSpace;

  00084	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR _dwElapse$[ebp]
  0008d	8d 44 01 ff	 lea	 eax, DWORD PTR [ecx+eax-1]
  00091	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	33 d2		 xor	 edx, edx
  00096	f7 71 10	 div	 DWORD PTR [ecx+16]
  00099	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  0009c	0f af 42 10	 imul	 eax, DWORD PTR [edx+16]
  000a0	89 45 0c	 mov	 DWORD PTR _dwElapse$[ebp], eax

; 137  : 
; 138  :     // 查找定时器
; 139  :     bool bTimerExist = false;

  000a3	c6 45 ef 00	 mov	 BYTE PTR _bTimerExist$[ebp], 0

; 140  :     tagTimerItem * pTimerItem = NULL;

  000a7	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pTimerItem$[ebp], 0

; 141  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  000ae	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000b5	eb 09		 jmp	 SHORT $LN4@SetTimer
$LN2@SetTimer:
  000b7	8b 45 dc	 mov	 eax, DWORD PTR _i$6[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 dc	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@SetTimer:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000c0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  000c6	89 55 cc	 mov	 DWORD PTR $T4[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 141  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  000c9	8b 45 dc	 mov	 eax, DWORD PTR _i$6[ebp]
  000cc	3b 45 cc	 cmp	 eax, DWORD PTR $T4[ebp]
  000cf	7d 27		 jge	 SHORT $LN3@SetTimer
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000d1	8b 4d dc	 mov	 ecx, DWORD PTR _i$6[ebp]
  000d4	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 143  :         pTimerItem = m_TimerItemActive[i];

  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	83 c1 48	 add	 ecx, 72			; 00000048H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  000db	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 143  :         pTimerItem = m_TimerItemActive[i];

  000e0	8b 10		 mov	 edx, DWORD PTR [eax]
  000e2	89 55 e0	 mov	 DWORD PTR _pTimerItem$[ebp], edx

; 144  :         if (pTimerItem->dwTimerID == dwTimerID)

  000e5	8b 45 e0	 mov	 eax, DWORD PTR _pTimerItem$[ebp]
  000e8	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000eb	3b 4d 08	 cmp	 ecx, DWORD PTR _dwTimerID$[ebp]
  000ee	75 06		 jne	 SHORT $LN6@SetTimer

; 145  :         {
; 146  :             bTimerExist = true;

  000f0	c6 45 ef 01	 mov	 BYTE PTR _bTimerExist$[ebp], 1

; 147  :             break;

  000f4	eb 02		 jmp	 SHORT $LN3@SetTimer
$LN6@SetTimer:

; 148  :         }
; 149  :     }

  000f6	eb bf		 jmp	 SHORT $LN2@SetTimer
$LN3@SetTimer:

; 150  : 
; 151  :     // 创建定时器
; 152  :     if (bTimerExist == false)

  000f8	0f b6 55 ef	 movzx	 edx, BYTE PTR _bTimerExist$[ebp]
  000fc	85 d2		 test	 edx, edx
  000fe	0f 85 c6 00 00
	00		 jne	 $LN20@SetTimer
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00104	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0010a	89 4d d8	 mov	 DWORD PTR _nFreeCount$5[ebp], ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 155  :         if (nFreeCount > 0)

  0010d	83 7d d8 00	 cmp	 DWORD PTR _nFreeCount$5[ebp], 0
  00111	7e 47		 jle	 SHORT $LN8@SetTimer

; 157  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  00113	8b 55 d8	 mov	 edx, DWORD PTR _nFreeCount$5[ebp]
  00116	83 ea 01	 sub	 edx, 1
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00119	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 157  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  0011a	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	83 c1 34	 add	 ecx, 52			; 00000034H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00120	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 157  :             pTimerItem = m_TimerItemFree[nFreeCount - 1];

  00125	8b 00		 mov	 eax, DWORD PTR [eax]
  00127	89 45 e0	 mov	 DWORD PTR _pTimerItem$[ebp], eax

; 158  :             ASSERT(pTimerItem != NULL);

  0012a	83 7d e0 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  0012e	75 14		 jne	 SHORT $LN15@SetTimer
  00130	68 9e 00 00 00	 push	 158			; 0000009eH
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0013a	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0013f	85 c0		 test	 eax, eax
  00141	74 01		 je	 SHORT $LN15@SetTimer
  00143	cc		 int	 3
$LN15@SetTimer:

; 159  :             m_TimerItemFree.RemoveAt(nFreeCount - 1);

  00144	6a 01		 push	 1
  00146	8b 55 d8	 mov	 edx, DWORD PTR _nFreeCount$5[ebp]
  00149	83 ea 01	 sub	 edx, 1
  0014c	52		 push	 edx
  0014d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	83 c1 34	 add	 ecx, 52			; 00000034H
  00153	e8 00 00 00 00	 call	 ?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt

; 160  :         }
; 161  :         else

  00158	eb 70		 jmp	 SHORT $LN20@SetTimer
$LN8@SetTimer:

; 162  :         {
; 163  :             try

  0015a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 164  :             {
; 165  :                 pTimerItem = new tagTimerItem;

  0015e	6a 14		 push	 20			; 00000014H
  00160	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00165	83 c4 04	 add	 esp, 4
  00168	89 45 c8	 mov	 DWORD PTR tv65[ebp], eax
  0016b	8b 45 c8	 mov	 eax, DWORD PTR tv65[ebp]
  0016e	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  00171	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp]
  00174	89 4d e0	 mov	 DWORD PTR _pTimerItem$[ebp], ecx

; 166  :                 ASSERT(pTimerItem != NULL);

  00177	83 7d e0 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  0017b	75 19		 jne	 SHORT $LN16@SetTimer
  0017d	68 a6 00 00 00	 push	 166			; 000000a6H
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00187	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0018c	89 45 c0	 mov	 DWORD PTR tv184[ebp], eax
  0018f	83 7d c0 00	 cmp	 DWORD PTR tv184[ebp], 0
  00193	74 01		 je	 SHORT $LN16@SetTimer
  00195	cc		 int	 3
$LN16@SetTimer:

; 167  :                 if (pTimerItem == NULL)

  00196	83 7d e0 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  0019a	75 1c		 jne	 SHORT $LN11@SetTimer

; 168  :                     return false;

  0019c	c6 45 ed 00	 mov	 BYTE PTR $T9[ebp], 0
  001a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a7	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  001aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  001b0	8a 45 ed	 mov	 al, BYTE PTR $T9[ebp]
  001b3	e9 e5 00 00 00	 jmp	 $LN1@SetTimer
$LN11@SetTimer:

; 169  :             }

  001b8	eb 10		 jmp	 SHORT $LN20@SetTimer
__catch$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$0:

; 170  :             catch (...) { return false; }

  001ba	c6 45 ec 00	 mov	 BYTE PTR $T8[ebp], 0
  001be	b8 00 00 00 00	 mov	 eax, $LN24@SetTimer
  001c3	c3		 ret	 0
  001c4	b8 00 00 00 00	 mov	 eax, $LN20@SetTimer
  001c9	c3		 ret	 0
$LN20@SetTimer:
  001ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001d1	eb 18		 jmp	 SHORT $LN23@SetTimer
$LN24@SetTimer:
  001d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001da	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  001dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  001e3	8a 45 ec	 mov	 al, BYTE PTR $T8[ebp]
  001e6	e9 b2 00 00 00	 jmp	 $LN1@SetTimer
$LN23@SetTimer:

; 171  :         }
; 172  :     }
; 173  : 
; 174  :     // 设置参数
; 175  :     ASSERT(pTimerItem != NULL);

  001eb	83 7d e0 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  001ef	75 14		 jne	 SHORT $LN17@SetTimer
  001f1	68 af 00 00 00	 push	 175			; 000000afH
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  001fb	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00200	85 c0		 test	 eax, eax
  00202	74 01		 je	 SHORT $LN17@SetTimer
  00204	cc		 int	 3
$LN17@SetTimer:

; 176  :     pTimerItem->dwElapse = dwElapse;

  00205	8b 4d e0	 mov	 ecx, DWORD PTR _pTimerItem$[ebp]
  00208	8b 55 0c	 mov	 edx, DWORD PTR _dwElapse$[ebp]
  0020b	89 11		 mov	 DWORD PTR [ecx], edx

; 177  :     pTimerItem->dwTimerID = dwTimerID;

  0020d	8b 45 e0	 mov	 eax, DWORD PTR _pTimerItem$[ebp]
  00210	8b 4d 08	 mov	 ecx, DWORD PTR _dwTimerID$[ebp]
  00213	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 178  :     pTimerItem->dwRepeatTimes = dwRepeat;

  00216	8b 55 e0	 mov	 edx, DWORD PTR _pTimerItem$[ebp]
  00219	8b 45 10	 mov	 eax, DWORD PTR _dwRepeat$[ebp]
  0021c	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 179  :     pTimerItem->dwBindParameter = dwBindParameter;

  0021f	8b 4d e0	 mov	 ecx, DWORD PTR _pTimerItem$[ebp]
  00222	8b 55 14	 mov	 edx, DWORD PTR _dwBindParameter$[ebp]
  00225	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 180  :     pTimerItem->dwTimeLeave = dwElapse + m_dwTimePass;

  00228	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0022b	8b 4d 0c	 mov	 ecx, DWORD PTR _dwElapse$[ebp]
  0022e	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  00231	8b 55 e0	 mov	 edx, DWORD PTR _pTimerItem$[ebp]
  00234	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 181  : 
; 182  :     // 激活定时器
; 183  :     m_dwTimeLeave = __min(m_dwTimeLeave, dwElapse);

  00237	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0023a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0023d	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwElapse$[ebp]
  00240	73 0b		 jae	 SHORT $LN18@SetTimer
  00242	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00245	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00248	89 45 d4	 mov	 DWORD PTR tv178[ebp], eax
  0024b	eb 06		 jmp	 SHORT $LN19@SetTimer
$LN18@SetTimer:
  0024d	8b 4d 0c	 mov	 ecx, DWORD PTR _dwElapse$[ebp]
  00250	89 4d d4	 mov	 DWORD PTR tv178[ebp], ecx
$LN19@SetTimer:
  00253	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00256	8b 45 d4	 mov	 eax, DWORD PTR tv178[ebp]
  00259	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 184  :     if (bTimerExist == false) m_TimerItemActive.Add(pTimerItem);

  0025c	0f b6 4d ef	 movzx	 ecx, BYTE PTR _bTimerExist$[ebp]
  00260	85 c9		 test	 ecx, ecx
  00262	75 22		 jne	 SHORT $LN12@SetTimer
  00264	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  00267	83 c2 48	 add	 edx, 72			; 00000048H
  0026a	89 55 d0	 mov	 DWORD PTR _this$[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 106  : 	INT_PTR nIndex=m_nElementCount;

  0026d	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00270	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00273	89 4d bc	 mov	 DWORD PTR _nIndex$2[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00276	8d 55 e0	 lea	 edx, DWORD PTR _pTimerItem$[ebp]
  00279	52		 push	 edx
  0027a	8b 45 bc	 mov	 eax, DWORD PTR _nIndex$2[ebp]
  0027d	50		 push	 eax
  0027e	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow
$LN12@SetTimer:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 186  :     return false;

  00286	c6 45 eb 00	 mov	 BYTE PTR $T7[ebp], 0
  0028a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00291	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00294	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
  0029a	8a 45 eb	 mov	 al, BYTE PTR $T7[ebp]
$LN1@SetTimer:

; 187  : }

  0029d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002a7	59		 pop	 ecx
  002a8	5f		 pop	 edi
  002a9	5e		 pop	 esi
  002aa	5b		 pop	 ebx
  002ab	8b e5		 mov	 esp, ebp
  002ad	5d		 pop	 ebp
  002ae	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetTimer@CTimerEngine@@UAE_NKKKI@Z$2:
  00000	8d 4d b0	 lea	 ecx, DWORD PTR _ThreadLock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1CWHDataLocker@@UAE@XZ
__ehhandler$?SetTimer@CTimerEngine@@UAE_NKKKI@Z:
  00009	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00010	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00013	33 c8		 xor	 ecx, eax
  00015	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetTimer@CTimerEngine@@UAE_NKKKI@Z
  0001f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetTimer@CTimerEngine@@UAE_NKKKI@Z ENDP		; CTimerEngine::SetTimer
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?SetTimerEngineEvent@CTimerEngine@@UAE_NPAUIUnknownEx@@@Z
_TEXT	SEGMENT
tv130 = -12						; size = 4
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_pIUnknownEx$ = 8					; size = 4
?SetTimerEngineEvent@CTimerEngine@@UAE_NPAUIUnknownEx@@@Z PROC ; CTimerEngine::SetTimerEngineEvent, COMDAT
; _this$ = ecx

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 339  :     // 状态效验
; 340  :     ASSERT(m_bService == false);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00010	85 c9		 test	 ecx, ecx
  00012	74 14		 je	 SHORT $LN7@SetTimerEn
  00014	68 54 01 00 00	 push	 340			; 00000154H
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00023	85 c0		 test	 eax, eax
  00025	74 01		 je	 SHORT $LN7@SetTimerEn
  00027	cc		 int	 3
$LN7@SetTimerEn:

; 341  :     if (m_bService == true)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002f	83 f9 01	 cmp	 ecx, 1
  00032	75 07		 jne	 SHORT $LN2@SetTimerEn

; 342  :         return false;

  00034	32 c0		 xor	 al, al
  00036	e9 9a 00 00 00	 jmp	 $LN1@SetTimerEn
$LN2@SetTimerEn:

; 343  : 
; 344  :     // 设置接口
; 345  :     if (pIUnknownEx != NULL)

  0003b	83 7d 08 00	 cmp	 DWORD PTR _pIUnknownEx$[ebp], 0
  0003f	0f 84 84 00 00
	00		 je	 $LN3@SetTimerEn

; 346  :     {
; 347  :         // 查询接口
; 348  :         ASSERT(QUERY_OBJECT_PTR_INTERFACE(pIUnknownEx, ITimerEngineEvent) != NULL);

  00045	83 7d 08 00	 cmp	 DWORD PTR _pIUnknownEx$[ebp], 0
  00049	75 09		 jne	 SHORT $LN8@SetTimerEn
  0004b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
  00052	eb 1a		 jmp	 SHORT $LN9@SetTimerEn
$LN8@SetTimerEn:
  00054	68 00 01 01 06	 push	 100729088		; 06010100H
  00059	68 00 00 00 00	 push	 OFFSET ?IID_ITimerEngineEvent@@3U_GUID@@B
  0005e	8b 55 08	 mov	 edx, DWORD PTR _pIUnknownEx$[ebp]
  00061	8b 02		 mov	 eax, DWORD PTR [edx]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _pIUnknownEx$[ebp]
  00066	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00069	ff d2		 call	 edx
  0006b	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
$LN9@SetTimerEn:
  0006e	83 7d f8 00	 cmp	 DWORD PTR tv83[ebp], 0
  00072	75 14		 jne	 SHORT $LN10@SetTimerEn
  00074	68 5c 01 00 00	 push	 348			; 0000015cH
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0007e	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00083	85 c0		 test	 eax, eax
  00085	74 01		 je	 SHORT $LN10@SetTimerEn
  00087	cc		 int	 3
$LN10@SetTimerEn:

; 349  :         m_pITimerEngineEvent = QUERY_OBJECT_PTR_INTERFACE(pIUnknownEx, ITimerEngineEvent);

  00088	83 7d 08 00	 cmp	 DWORD PTR _pIUnknownEx$[ebp], 0
  0008c	75 09		 jne	 SHORT $LN11@SetTimerEn
  0008e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
  00095	eb 1a		 jmp	 SHORT $LN12@SetTimerEn
$LN11@SetTimerEn:
  00097	68 00 01 01 06	 push	 100729088		; 06010100H
  0009c	68 00 00 00 00	 push	 OFFSET ?IID_ITimerEngineEvent@@3U_GUID@@B
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _pIUnknownEx$[ebp]
  000a4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _pIUnknownEx$[ebp]
  000a9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ac	ff d0		 call	 eax
  000ae	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
$LN12@SetTimerEn:
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 55 f4	 mov	 edx, DWORD PTR tv130[ebp]
  000b7	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 350  : 
; 351  :         // 成功判断
; 352  :         if (m_pITimerEngineEvent == NULL)

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  000c1	75 04		 jne	 SHORT $LN5@SetTimerEn

; 353  :             return false;

  000c3	32 c0		 xor	 al, al
  000c5	eb 0e		 jmp	 SHORT $LN1@SetTimerEn
$LN5@SetTimerEn:

; 354  :     }

  000c7	eb 0a		 jmp	 SHORT $LN4@SetTimerEn
$LN3@SetTimerEn:

; 355  :     else m_pITimerEngineEvent = NULL;

  000c9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
$LN4@SetTimerEn:

; 356  : 
; 357  :     return true;

  000d3	b0 01		 mov	 al, 1
$LN1@SetTimerEn:

; 358  : }

  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
?SetTimerEngineEvent@CTimerEngine@@UAE_NPAUIUnknownEx@@@Z ENDP ; CTimerEngine::SetTimerEngineEvent
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?ConcludeService@CTimerEngine@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ConcludeService@CTimerEngine@@UAE_NXZ PROC		; CTimerEngine::ConcludeService, COMDAT
; _this$ = ecx

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 324  :     // 设置变量
; 325  :     m_bService = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 326  : 
; 327  :     // 停止线程
; 328  :     m_TimerThread.ConcludeThread(INFINITE);

  0000e	6a ff		 push	 -1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001c	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0001f	ff d2		 call	 edx

; 329  : 
; 330  :     // 删除定时器
; 331  :     KillAllTimer();

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002c	ff d0		 call	 eax

; 332  : 
; 333  :     return true;

  0002e	b0 01		 mov	 al, 1

; 334  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?ConcludeService@CTimerEngine@@UAE_NXZ ENDP		; CTimerEngine::ConcludeService
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?StartService@CTimerEngine@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?StartService@CTimerEngine@@UAE_NXZ PROC		; CTimerEngine::StartService, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 300  :     // 状态效验
; 301  :     ASSERT(m_bService == false);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 14		 je	 SHORT $LN6@StartServi
  00012	68 2d 01 00 00	 push	 301			; 0000012dH
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN6@StartServi
  00025	cc		 int	 3
$LN6@StartServi:

; 302  :     if (m_bService == true)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0002d	83 f9 01	 cmp	 ecx, 1
  00030	75 04		 jne	 SHORT $LN2@StartServi

; 303  :         return false;

  00032	32 c0		 xor	 al, al
  00034	eb 5a		 jmp	 SHORT $LN1@StartServi
$LN2@StartServi:

; 304  : 
; 305  :     // 设置变量
; 306  :     m_dwTimePass = 0L;

  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 307  :     m_dwTimeLeave = NO_TIME_LEAVE;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 308  :     if (m_TimerThread.InitThread(this, m_dwTimerSpace) == false)

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00050	52		 push	 edx
  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	50		 push	 eax
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 18	 add	 ecx, 24			; 00000018H
  0005b	e8 00 00 00 00	 call	 ?InitThread@CTimerThread@@QAE_NPAVCTimerEngine@@K@Z ; CTimerThread::InitThread
  00060	0f b6 c8	 movzx	 ecx, al
  00063	85 c9		 test	 ecx, ecx
  00065	75 04		 jne	 SHORT $LN3@StartServi

; 309  :         return false;

  00067	32 c0		 xor	 al, al
  00069	eb 25		 jmp	 SHORT $LN1@StartServi
$LN3@StartServi:

; 310  : 
; 311  :     // 启动服务
; 312  :     if (m_TimerThread.StartThread() == false)

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 18	 add	 ecx, 24			; 00000018H
  00071	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00074	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00077	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0007a	ff d2		 call	 edx
  0007c	0f b6 c0	 movzx	 eax, al
  0007f	85 c0		 test	 eax, eax
  00081	75 04		 jne	 SHORT $LN4@StartServi

; 313  :         return false;

  00083	32 c0		 xor	 al, al
  00085	eb 09		 jmp	 SHORT $LN1@StartServi
$LN4@StartServi:

; 314  : 
; 315  :     // 设置变量
; 316  :     m_bService = true;

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	c6 41 04 01	 mov	 BYTE PTR [ecx+4], 1

; 317  : 
; 318  :     return true;

  0008e	b0 01		 mov	 al, 1
$LN1@StartServi:

; 319  : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?StartService@CTimerEngine@@UAE_NXZ ENDP		; CTimerEngine::StartService
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?QueryInterface@CTimerEngine@@UAEPAXABU_GUID@@K@Z
_TEXT	SEGMENT
tv202 = -40						; size = 4
tv185 = -36						; size = 4
tv152 = -32						; size = 4
tv190 = -28						; size = 4
tv201 = -24						; size = 4
tv173 = -20						; size = 4
tv184 = -16						; size = 4
tv146 = -12						; size = 4
tv154 = -8						; size = 4
_this$ = -4						; size = 4
_Guid$ = 8						; size = 4
_dwQueryVer$ = 12					; size = 4
?QueryInterface@CTimerEngine@@UAEPAXABU_GUID@@K@Z PROC	; CTimerEngine::QueryInterface, COMDAT
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00009	6a 10		 push	 16			; 00000010H
  0000b	68 00 00 00 00	 push	 OFFSET ?IID_ITimerEngine@@3U_GUID@@B
  00010	8b 45 08	 mov	 eax, DWORD PTR _Guid$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memcmp
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001c	89 45 e0	 mov	 DWORD PTR tv152[ebp], eax
  0001f	83 7d e0 00	 cmp	 DWORD PTR tv152[ebp], 0
  00023	75 09		 jne	 SHORT $LN12@QueryInter
  00025	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
  0002c	eb 07		 jmp	 SHORT $LN10@QueryInter
$LN12@QueryInter:
  0002e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv154[ebp], 0
$LN10@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00035	83 7d f8 00	 cmp	 DWORD PTR tv154[ebp], 0
  00039	74 09		 je	 SHORT $LN8@QueryInter
  0003b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  00042	eb 07		 jmp	 SHORT $LN6@QueryInter
$LN8@QueryInter:
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv146[ebp], 0
$LN6@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 120  :     QUERYINTERFACE(ITimerEngine, Guid, dwQueryVer);

  0004b	0f b6 4d f4	 movzx	 ecx, BYTE PTR tv146[ebp]
  0004f	85 c9		 test	 ecx, ecx
  00051	74 20		 je	 SHORT $LN2@QueryInter
  00053	68 00 01 01 06	 push	 100729088		; 06010100H
  00058	8b 55 0c	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  00061	83 c4 08	 add	 esp, 8
  00064	0f b6 c0	 movzx	 eax, al
  00067	85 c0		 test	 eax, eax
  00069	74 08		 je	 SHORT $LN2@QueryInter
  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	e9 d0 00 00 00	 jmp	 $LN1@QueryInter
$LN2@QueryInter:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00073	6a 10		 push	 16			; 00000010H
  00075	68 00 00 00 00	 push	 OFFSET ?IID_IServiceModule@@3U_GUID@@B
  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _Guid$[ebp]
  0007d	51		 push	 ecx
  0007e	e8 00 00 00 00	 call	 _memcmp
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH
  00086	89 45 dc	 mov	 DWORD PTR tv185[ebp], eax
  00089	83 7d dc 00	 cmp	 DWORD PTR tv185[ebp], 0
  0008d	75 09		 jne	 SHORT $LN42@QueryInter
  0008f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv184[ebp], 1
  00096	eb 07		 jmp	 SHORT $LN40@QueryInter
$LN42@QueryInter:
  00098	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
$LN40@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  0009f	83 7d f0 00	 cmp	 DWORD PTR tv184[ebp], 0
  000a3	74 09		 je	 SHORT $LN38@QueryInter
  000a5	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv173[ebp], 1
  000ac	eb 07		 jmp	 SHORT $LN36@QueryInter
$LN38@QueryInter:
  000ae	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv173[ebp], 0
$LN36@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 121  :     QUERYINTERFACE(IServiceModule, Guid, dwQueryVer);

  000b5	0f b6 55 ec	 movzx	 edx, BYTE PTR tv173[ebp]
  000b9	85 d2		 test	 edx, edx
  000bb	74 1d		 je	 SHORT $LN3@QueryInter
  000bd	68 00 01 01 06	 push	 100729088		; 06010100H
  000c2	8b 45 0c	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  000cb	83 c4 08	 add	 esp, 8
  000ce	0f b6 c8	 movzx	 ecx, al
  000d1	85 c9		 test	 ecx, ecx
  000d3	74 05		 je	 SHORT $LN3@QueryInter
  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	eb 69		 jmp	 SHORT $LN1@QueryInter
$LN3@QueryInter:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  000da	6a 10		 push	 16			; 00000010H
  000dc	68 00 00 00 00	 push	 OFFSET ?IID_IUnknownEx@@3U_GUID@@B
  000e1	8b 55 08	 mov	 edx, DWORD PTR _Guid$[ebp]
  000e4	52		 push	 edx
  000e5	e8 00 00 00 00	 call	 _memcmp
  000ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ed	89 45 d8	 mov	 DWORD PTR tv202[ebp], eax
  000f0	83 7d d8 00	 cmp	 DWORD PTR tv202[ebp], 0
  000f4	75 09		 jne	 SHORT $LN72@QueryInter
  000f6	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
  000fd	eb 07		 jmp	 SHORT $LN70@QueryInter
$LN72@QueryInter:
  000ff	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv201[ebp], 0
$LN70@QueryInter:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00106	83 7d e8 00	 cmp	 DWORD PTR tv201[ebp], 0
  0010a	74 09		 je	 SHORT $LN68@QueryInter
  0010c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv190[ebp], 1
  00113	eb 07		 jmp	 SHORT $LN66@QueryInter
$LN68@QueryInter:
  00115	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv190[ebp], 0
$LN66@QueryInter:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 122  :     QUERYINTERFACE_IUNKNOWNEX(ITimerEngine, Guid, dwQueryVer);

  0011c	0f b6 45 e4	 movzx	 eax, BYTE PTR tv190[ebp]
  00120	85 c0		 test	 eax, eax
  00122	74 1d		 je	 SHORT $LN4@QueryInter
  00124	68 00 01 01 06	 push	 100729088		; 06010100H
  00129	8b 4d 0c	 mov	 ecx, DWORD PTR _dwQueryVer$[ebp]
  0012c	51		 push	 ecx
  0012d	e8 00 00 00 00	 call	 ?InterfaceVersionCompare@@YA_NKK@Z ; InterfaceVersionCompare
  00132	83 c4 08	 add	 esp, 8
  00135	0f b6 d0	 movzx	 edx, al
  00138	85 d2		 test	 edx, edx
  0013a	74 05		 je	 SHORT $LN4@QueryInter
  0013c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	eb 02		 jmp	 SHORT $LN1@QueryInter
$LN4@QueryInter:

; 123  :     return NULL;

  00141	33 c0		 xor	 eax, eax
$LN1@QueryInter:

; 124  : }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 08 00	 ret	 8
?QueryInterface@CTimerEngine@@UAEPAXABU_GUID@@K@Z ENDP	; CTimerEngine::QueryInterface
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.h
;	COMDAT ?Release@CTimerEngine@@UAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
?Release@CTimerEngine@@UAEXXZ PROC			; CTimerEngine::Release, COMDAT
; _this$ = ecx

; 94   :     virtual VOID Release() { delete this; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00012	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
  00015	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00019	74 14		 je	 SHORT $LN3@Release
  0001b	6a 01		 push	 1
  0001d	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00025	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00028	ff d2		 call	 edx
  0002a	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  0002d	eb 07		 jmp	 SHORT $LN1@Release
$LN3@Release:
  0002f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN1@Release:
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?Release@CTimerEngine@@UAEXXZ ENDP			; CTimerEngine::Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ??1CTimerEngine@@UAE@XZ
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
_i$6 = -32						; size = 4
_i$7 = -28						; size = 4
_pTimerItem$ = -24					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??1CTimerEngine@@UAE@XZ PROC				; CTimerEngine::~CTimerEngine, COMDAT
; _this$ = ecx

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTimerEngine@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 20	 sub	 esp, 32			; 00000020H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTimerEngine@@6B@
  00038	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3

; 94   :     // 停止服务
; 95   :     ConcludeService();

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?ConcludeService@CTimerEngine@@UAE_NXZ ; CTimerEngine::ConcludeService

; 96   : 
; 97   :     // 清理内存
; 98   :     tagTimerItem * pTimerItem = NULL;

  00047	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pTimerItem$[ebp], 0

; 99   :     for (INT_PTR i = 0; i < m_TimerItemFree.GetCount(); i++)

  0004e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$7[ebp], 0
  00055	eb 09		 jmp	 SHORT $LN4@CTimerEngi
$LN2@CTimerEngi:
  00057	8b 4d e4	 mov	 ecx, DWORD PTR _i$7[ebp]
  0005a	83 c1 01	 add	 ecx, 1
  0005d	89 4d e4	 mov	 DWORD PTR _i$7[ebp], ecx
$LN4@CTimerEngi:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  00060	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00063	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00066	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 99   :     for (INT_PTR i = 0; i < m_TimerItemFree.GetCount(); i++)

  00069	8b 4d e4	 mov	 ecx, DWORD PTR _i$7[ebp]
  0006c	3b 4d dc	 cmp	 ecx, DWORD PTR $T5[ebp]
  0006f	7d 7c		 jge	 SHORT $LN3@CTimerEngi
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00071	8b 55 e4	 mov	 edx, DWORD PTR _i$7[ebp]
  00074	52		 push	 edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 101  :         pTimerItem = m_TimerItemFree[i];

  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	83 c1 34	 add	 ecx, 52			; 00000034H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0007b	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 101  :         pTimerItem = m_TimerItemFree[i];

  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 e8	 mov	 DWORD PTR _pTimerItem$[ebp], eax

; 102  :         ASSERT(pTimerItem != NULL);

  00085	83 7d e8 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  00089	75 11		 jne	 SHORT $LN11@CTimerEngi
  0008b	6a 66		 push	 102			; 00000066H
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00092	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00097	85 c0		 test	 eax, eax
  00099	74 01		 je	 SHORT $LN11@CTimerEngi
  0009b	cc		 int	 3
$LN11@CTimerEngi:

; 103  :         SafeDelete(pTimerItem);

  0009c	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+12], 4
  000a0	8b 55 e8	 mov	 edx, DWORD PTR _pTimerItem$[ebp]
  000a3	89 55 d8	 mov	 DWORD PTR $T4[ebp], edx
  000a6	6a 14		 push	 20			; 00000014H
  000a8	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b1	83 c4 08	 add	 esp, 8
  000b4	eb 1b		 jmp	 SHORT $LN15@CTimerEngi
__catch$??1CTimerEngine@@UAE@XZ$0:
  000b6	33 c9		 xor	 ecx, ecx
  000b8	75 11		 jne	 SHORT $LN12@CTimerEngi
  000ba	6a 67		 push	 103			; 00000067H
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  000c1	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  000c6	85 c0		 test	 eax, eax
  000c8	74 01		 je	 SHORT $LN12@CTimerEngi
  000ca	cc		 int	 3
$LN12@CTimerEngi:
  000cb	b8 00 00 00 00	 mov	 eax, $LN24@CTimerEngi
  000d0	c3		 ret	 0
$LN15@CTimerEngi:
  000d1	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  000d8	eb 07		 jmp	 SHORT __tryend$??1CTimerEngine@@UAE@XZ$1
$LN24@CTimerEngi:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
  000da	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
__tryend$??1CTimerEngine@@UAE@XZ$1:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 103  :         SafeDelete(pTimerItem);

  000e1	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pTimerItem$[ebp], 0

; 104  :     }

  000e8	e9 6a ff ff ff	 jmp	 $LN2@CTimerEngi
$LN3@CTimerEngi:

; 105  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  000ed	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _i$6[ebp], 0
  000f4	eb 09		 jmp	 SHORT $LN7@CTimerEngi
$LN5@CTimerEngi:
  000f6	8b 45 e0	 mov	 eax, DWORD PTR _i$6[ebp]
  000f9	83 c0 01	 add	 eax, 1
  000fc	89 45 e0	 mov	 DWORD PTR _i$6[ebp], eax
$LN7@CTimerEngi:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 99   : 	return m_nElementCount;

  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00105	89 55 d4	 mov	 DWORD PTR $T3[ebp], edx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 105  :     for (INT_PTR i = 0; i < m_TimerItemActive.GetCount(); i++)

  00108	8b 45 e0	 mov	 eax, DWORD PTR _i$6[ebp]
  0010b	3b 45 d4	 cmp	 eax, DWORD PTR $T3[ebp]
  0010e	7d 7c		 jge	 SHORT $LN6@CTimerEngi
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  00110	8b 4d e0	 mov	 ecx, DWORD PTR _i$6[ebp]
  00113	51		 push	 ecx
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 107  :         pTimerItem = m_TimerItemActive[i];

  00114	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	83 c1 48	 add	 ecx, 72			; 00000048H
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 115  : 	return ElementAt(nIndex);

  0011a	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 107  :         pTimerItem = m_TimerItemActive[i];

  0011f	8b 10		 mov	 edx, DWORD PTR [eax]
  00121	89 55 e8	 mov	 DWORD PTR _pTimerItem$[ebp], edx

; 108  :         ASSERT(pTimerItem != NULL);

  00124	83 7d e8 00	 cmp	 DWORD PTR _pTimerItem$[ebp], 0
  00128	75 11		 jne	 SHORT $LN13@CTimerEngi
  0012a	6a 6c		 push	 108			; 0000006cH
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00131	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00136	85 c0		 test	 eax, eax
  00138	74 01		 je	 SHORT $LN13@CTimerEngi
  0013a	cc		 int	 3
$LN13@CTimerEngi:

; 109  :         SafeDelete(pTimerItem);

  0013b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+12], 6
  0013f	8b 4d e8	 mov	 ecx, DWORD PTR _pTimerItem$[ebp]
  00142	89 4d d0	 mov	 DWORD PTR $T2[ebp], ecx
  00145	6a 14		 push	 20			; 00000014H
  00147	8b 55 d0	 mov	 edx, DWORD PTR $T2[ebp]
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00150	83 c4 08	 add	 esp, 8
  00153	eb 1b		 jmp	 SHORT $LN17@CTimerEngi
__catch$??1CTimerEngine@@UAE@XZ$2:
  00155	33 c0		 xor	 eax, eax
  00157	75 11		 jne	 SHORT $LN14@CTimerEngi
  00159	6a 6d		 push	 109			; 0000006dH
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00160	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00165	85 c0		 test	 eax, eax
  00167	74 01		 je	 SHORT $LN14@CTimerEngi
  00169	cc		 int	 3
$LN14@CTimerEngi:
  0016a	b8 00 00 00 00	 mov	 eax, $LN26@CTimerEngi
  0016f	c3		 ret	 0
$LN17@CTimerEngi:
  00170	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  00177	eb 07		 jmp	 SHORT __tryend$??1CTimerEngine@@UAE@XZ$3
$LN26@CTimerEngi:
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
  00179	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
__tryend$??1CTimerEngine@@UAE@XZ$3:
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp

; 109  :         SafeDelete(pTimerItem);

  00180	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _pTimerItem$[ebp], 0

; 110  :     }

  00187	e9 6a ff ff ff	 jmp	 $LN5@CTimerEngi
$LN6@CTimerEngi:

; 111  :     m_TimerItemFree.RemoveAll();

  0018c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	83 c1 34	 add	 ecx, 52			; 00000034H
  00192	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll

; 112  :     m_TimerItemActive.RemoveAll();

  00197	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019a	83 c1 48	 add	 ecx, 72			; 00000048H
  0019d	e8 00 00 00 00	 call	 ?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll

; 113  : 
; 114  :     return;
; 115  : }

  001a2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a9	83 c1 5c	 add	 ecx, 92			; 0000005cH
  001ac	e8 00 00 00 00	 call	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
  001b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  001b5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	83 c1 48	 add	 ecx, 72			; 00000048H
  001bb	e8 00 00 00 00	 call	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
  001c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  001c4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	83 c1 34	 add	 ecx, 52			; 00000034H
  001ca	e8 00 00 00 00	 call	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
  001cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001d6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	83 c1 18	 add	 ecx, 24			; 00000018H
  001dc	e8 00 00 00 00	 call	 ??1CTimerThread@@UAE@XZ	; CTimerThread::~CTimerThread
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001eb	59		 pop	 ecx
  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CTimerEngine@@UAE@XZ$4:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1CTimerThread@@UAE@XZ	; CTimerThread::~CTimerThread
__unwindfunclet$??1CTimerEngine@@UAE@XZ$5:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 34	 add	 ecx, 52			; 00000034H
  00011	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
__unwindfunclet$??1CTimerEngine@@UAE@XZ$6:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 48	 add	 ecx, 72			; 00000048H
  0001c	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
__unwindfunclet$??1CTimerEngine@@UAE@XZ$7:
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00027	e9 00 00 00 00	 jmp	 ??1CCriticalSection@@UAE@XZ ; CCriticalSection::~CCriticalSection
__ehhandler$??1CTimerEngine@@UAE@XZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTimerEngine@@UAE@XZ
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTimerEngine@@UAE@XZ ENDP				; CTimerEngine::~CTimerEngine
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ??0CTimerEngine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTimerEngine@@QAE@XZ PROC				; CTimerEngine::CTimerEngine, COMDAT
; _this$ = ecx

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTimerEngine@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  00038	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ITimerEngine@@6B@
  00041	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTimerEngine@@6B@
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 18	 add	 ecx, 24			; 00000018H
  00050	e8 00 00 00 00	 call	 ??0CTimerThread@@QAE@XZ	; CTimerThread::CTimerThread
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 34	 add	 ecx, 52			; 00000034H
  00062	e8 00 00 00 00	 call	 ??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::CWHArray<tagTimerItem *,tagTimerItem * const &>
  00067	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 48	 add	 ecx, 72			; 00000048H
  00071	e8 00 00 00 00	 call	 ??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::CWHArray<tagTimerItem *,tagTimerItem * const &>
  00076	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00080	e8 00 00 00 00	 call	 ??0CCriticalSection@@QAE@XZ ; CCriticalSection::CCriticalSection

; 79   :     // 状态变量
; 80   :     m_bService = false;

  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 81   :     m_dwTimePass = 0L;

  0008c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 82   :     m_dwTimeLeave = NO_TIME_LEAVE;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [eax+12], -1

; 83   : 
; 84   :     // 配置变量
; 85   :     m_dwTimerSpace = 30;

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	c7 41 10 1e 00
	00 00		 mov	 DWORD PTR [ecx+16], 30	; 0000001eH

; 86   :     m_pITimerEngineEvent = NULL;

  000aa	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 87   : 
; 88   :     return;
; 89   : }

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTimerEngine@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 18	 add	 ecx, 24			; 00000018H
  00006	e9 00 00 00 00	 jmp	 ??1CTimerThread@@UAE@XZ	; CTimerThread::~CTimerThread
__unwindfunclet$??0CTimerEngine@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 34	 add	 ecx, 52			; 00000034H
  00011	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
__unwindfunclet$??0CTimerEngine@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 48	 add	 ecx, 72			; 00000048H
  0001c	e9 00 00 00 00	 jmp	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
__ehhandler$??0CTimerEngine@@QAE@XZ:
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTimerEngine@@QAE@XZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTimerEngine@@QAE@XZ ENDP				; CTimerEngine::CTimerEngine
; Function compile flags: /Odtp
;	COMDAT ??_G?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z PROC	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAEPAXI@Z ENDP	; CWHArray<tagTimerItem *,tagTimerItem * const &>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv79 = -20						; size = 4
tv78 = -16						; size = 4
_pNewData$3 = -12					; size = 4
_nGrowCount$4 = -8					; size = 4
_this$ = -4						; size = 4
_nNewCount$ = 8						; size = 4
?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::AllocMemory, COMDAT
; _this$ = ecx

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 414  : 	//效验参数
; 415  : 	ASSERT(nNewCount>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewCount$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN5@AllocMemor
  0000f	68 9f 01 00 00	 push	 415			; 0000019fH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN5@AllocMemor
  00022	cc		 int	 3
$LN5@AllocMemor:

; 416  : 
; 417  : 	if (nNewCount>m_nMaxCount)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  00029	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002c	0f 8e dd 00 00
	00		 jle	 $LN1@AllocMemor

; 418  : 	{
; 419  : 		//计算数目
; 420  : 		INT_PTR nGrowCount=m_nGrowCount;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	89 4d f8	 mov	 DWORD PTR _nGrowCount$4[ebp], ecx

; 421  : 		if (nGrowCount==0)

  0003b	83 7d f8 00	 cmp	 DWORD PTR _nGrowCount$4[ebp], 0
  0003f	75 45		 jne	 SHORT $LN3@AllocMemor

; 422  : 		{
; 423  : 			nGrowCount=m_nElementCount/8;

  00041	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00047	99		 cdq
  00048	83 e2 07	 and	 edx, 7
  0004b	03 c2		 add	 eax, edx
  0004d	c1 f8 03	 sar	 eax, 3
  00050	89 45 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], eax

; 424  : 			nGrowCount=(nGrowCount<4)?4:((nGrowCount>1024)?1024:nGrowCount);

  00053	83 7d f8 04	 cmp	 DWORD PTR _nGrowCount$4[ebp], 4
  00057	7d 09		 jge	 SHORT $LN8@AllocMemor
  00059	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR tv79[ebp], 4
  00060	eb 1e		 jmp	 SHORT $LN9@AllocMemor
$LN8@AllocMemor:
  00062	81 7d f8 00 04
	00 00		 cmp	 DWORD PTR _nGrowCount$4[ebp], 1024 ; 00000400H
  00069	7e 09		 jle	 SHORT $LN6@AllocMemor
  0006b	c7 45 f0 00 04
	00 00		 mov	 DWORD PTR tv78[ebp], 1024 ; 00000400H
  00072	eb 06		 jmp	 SHORT $LN7@AllocMemor
$LN6@AllocMemor:
  00074	8b 45 f8	 mov	 eax, DWORD PTR _nGrowCount$4[ebp]
  00077	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
$LN7@AllocMemor:
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  0007d	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
$LN9@AllocMemor:
  00080	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00083	89 55 f8	 mov	 DWORD PTR _nGrowCount$4[ebp], edx
$LN3@AllocMemor:

; 425  : 		}
; 426  : 		nNewCount+=nGrowCount;

  00086	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  00089	03 45 f8	 add	 eax, DWORD PTR _nGrowCount$4[ebp]
  0008c	89 45 08	 mov	 DWORD PTR _nNewCount$[ebp], eax

; 427  : 
; 428  : 		//申请内存
; 429  : 		TYPE * pNewData=(TYPE *) new BYTE[nNewCount*sizeof(TYPE)];

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _nNewCount$[ebp]
  00092	c1 e1 02	 shl	 ecx, 2
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000a1	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  000a4	89 55 f4	 mov	 DWORD PTR _pNewData$3[ebp], edx

; 430  : 		memcpy(pNewData,m_pData,m_nElementCount*sizeof(TYPE));

  000a7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ad	c1 e1 02	 shl	 ecx, 2
  000b0	51		 push	 ecx
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b7	50		 push	 eax
  000b8	8b 4d f4	 mov	 ecx, DWORD PTR _pNewData$3[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _memcpy
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  : 		memset(pNewData+m_nElementCount,0,(nNewCount-m_nElementCount)*sizeof(TYPE));

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	8b 45 08	 mov	 eax, DWORD PTR _nNewCount$[ebp]
  000ca	2b 42 10	 sub	 eax, DWORD PTR [edx+16]
  000cd	c1 e0 02	 shl	 eax, 2
  000d0	50		 push	 eax
  000d1	6a 00		 push	 0
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000d9	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  000dc	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _memset
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 432  : 		delete [] (BYTE *)m_pData;

  000e8	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000eb	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ee	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  000f1	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000fa	83 c4 04	 add	 esp, 4

; 433  : 
; 434  : 		//设置变量
; 435  : 		m_pData=pNewData;

  000fd	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00100	8b 45 f4	 mov	 eax, DWORD PTR _pNewData$3[ebp]
  00103	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 436  : 		m_nMaxCount=nNewCount;

  00106	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	8b 55 08	 mov	 edx, DWORD PTR _nNewCount$[ebp]
  0010c	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$LN1@AllocMemor:

; 437  : 	}
; 438  : 
; 439  : 	return;
; 440  : }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 04 00	 ret	 4
?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::AllocMemory
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??A?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::operator[], COMDAT
; _this$ = ecx

; 114  : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	return ElementAt(nIndex);

  00007	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt

; 116  : }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??A?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll, COMDAT
; _this$ = ecx

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 380  : 	if (m_nElementCount>0)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 44		 jle	 SHORT $LN1@RemoveAll

; 381  : 	{
; 382  : 		for (INT_PTR i=0;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00012	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00019	eb 09		 jmp	 SHORT $LN4@RemoveAll
$LN2@RemoveAll:
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0001e	83 c1 01	 add	 ecx, 1
  00021	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAll:
  00024	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0002d	7d 02		 jge	 SHORT $LN3@RemoveAll
  0002f	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN3@RemoveAll:

; 383  : 		memset(m_pData,0,m_nElementCount*sizeof(TYPE));

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	c1 e2 02	 shl	 edx, 2
  0003a	52		 push	 edx
  0003b	6a 00		 push	 0
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _memset
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 		m_nElementCount=0;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0
$LN1@RemoveAll:

; 385  : 	}
; 386  : 
; 387  : 	return;
; 388  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?RemoveAll@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXXZ ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z
_TEXT	SEGMENT
_nMoveCount$ = -12					; size = 4
_i$1 = -8						; size = 4
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_nCount$ = 12						; size = 4
?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt, COMDAT
; _this$ = ecx

; 360  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 361  : 	//效验参数
; 362  : 	ASSERT(nIndex>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN9@RemoveAt
  0000f	68 6a 01 00 00	 push	 362			; 0000016aH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN9@RemoveAt
  00022	cc		 int	 3
$LN9@RemoveAt:

; 363  : 	ASSERT(nCount>=0);

  00023	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00027	7d 14		 jge	 SHORT $LN10@RemoveAt
  00029	68 6b 01 00 00	 push	 363			; 0000016bH
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00033	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00038	85 c0		 test	 eax, eax
  0003a	74 01		 je	 SHORT $LN10@RemoveAt
  0003c	cc		 int	 3
$LN10@RemoveAt:

; 364  : 	ASSERT(nIndex+nCount<=m_nElementCount);

  0003d	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00040	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00049	7e 14		 jle	 SHORT $LN11@RemoveAt
  0004b	68 6c 01 00 00	 push	 364			; 0000016cH
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00055	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0005a	85 c0		 test	 eax, eax
  0005c	74 01		 je	 SHORT $LN11@RemoveAt
  0005e	cc		 int	 3
$LN11@RemoveAt:

; 365  : 	if ((nIndex<0)||(nCount<0)||((nIndex+nCount>m_nElementCount))) AfxThrowInvalidArgException();

  0005f	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00063	7c 14		 jl	 SHORT $LN6@RemoveAt
  00065	83 7d 0c 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00069	7c 0e		 jl	 SHORT $LN6@RemoveAt
  0006b	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0006e	03 55 0c	 add	 edx, DWORD PTR _nCount$[ebp]
  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00074	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00077	7e 05		 jle	 SHORT $LN5@RemoveAt
$LN6@RemoveAt:
  00079	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@RemoveAt:

; 366  : 
; 367  : 	//删除数据
; 368  : 	INT_PTR nMoveCount=m_nElementCount-(nIndex+nCount);

  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00081	03 4d 0c	 add	 ecx, DWORD PTR _nCount$[ebp]
  00084	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	2b c1		 sub	 eax, ecx
  0008c	89 45 f4	 mov	 DWORD PTR _nMoveCount$[ebp], eax

; 369  : 	for (INT_PTR i=0;i<nCount;i++) (m_pData+nIndex+i)->~TYPE();

  0008f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00096	eb 09		 jmp	 SHORT $LN4@RemoveAt
$LN2@RemoveAt:
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _i$1[ebp]
  0009b	83 c1 01	 add	 ecx, 1
  0009e	89 4d f8	 mov	 DWORD PTR _i$1[ebp], ecx
$LN4@RemoveAt:
  000a1	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  000a4	3b 55 0c	 cmp	 edx, DWORD PTR _nCount$[ebp]
  000a7	7d 02		 jge	 SHORT $LN3@RemoveAt
  000a9	eb ed		 jmp	 SHORT $LN2@RemoveAt
$LN3@RemoveAt:

; 370  : 	if (nMoveCount>0) memmove(m_pData+nIndex,m_pData+nIndex+nCount,nMoveCount*sizeof(TYPE));

  000ab	83 7d f4 00	 cmp	 DWORD PTR _nMoveCount$[ebp], 0
  000af	7e 2f		 jle	 SHORT $LN7@RemoveAt
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _nMoveCount$[ebp]
  000b4	c1 e0 02	 shl	 eax, 2
  000b7	50		 push	 eax
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000be	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000c1	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _nCount$[ebp]
  000c7	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000ca	50		 push	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000d1	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  000d4	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 _memmove
  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RemoveAt:

; 371  : 	m_nElementCount-=nCount;

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000e3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000e6	2b 45 0c	 sub	 eax, DWORD PTR _nCount$[ebp]
  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN8@RemoveAt:

; 372  : 
; 373  : 	return;
; 374  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
?RemoveAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHH@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::RemoveAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
_newElement$ = 12					; size = 4
?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	//效验参数
; 289  : 	ASSERT(nIndex>=0);

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7d 14		 jge	 SHORT $LN5@SetAtGrow
  0000d	68 21 01 00 00	 push	 289			; 00000121H
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00017	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001c	85 c0		 test	 eax, eax
  0001e	74 01		 je	 SHORT $LN5@SetAtGrow
  00020	cc		 int	 3
$LN5@SetAtGrow:

; 290  : 	if (nIndex<0) AfxThrowInvalidArgException();

  00021	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00025	7d 05		 jge	 SHORT $LN2@SetAtGrow
  00027	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@SetAtGrow:

; 291  : 
; 292  : 	//设置元素
; 293  : 	if (nIndex>=m_nElementCount) SetSize(m_nElementCount+1);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00032	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00035	7c 12		 jl	 SHORT $LN3@SetAtGrow
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0003d	83 c1 01	 add	 ecx, 1
  00040	51		 push	 ecx
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetSize@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetSize
$LN3@SetAtGrow:

; 294  : 	m_pData[nIndex]=newElement;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00052	8b 55 0c	 mov	 edx, DWORD PTR _newElement$[ebp]
  00055	8b 12		 mov	 edx, DWORD PTR [edx]
  00057	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@SetAtGrow:

; 295  : 
; 296  : 	return;
; 297  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?SetSize@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Where$ = -16						; size = 4
_i$2 = -12						; size = 4
_i$3 = -8						; size = 4
_this$ = -4						; size = 4
_nNewSize$ = 8						; size = 4
?SetSize@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetSize, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  : 	//效验参数
; 254  : 	ASSERT(nNewSize>=0);

  00009	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  0000d	7d 14		 jge	 SHORT $LN13@SetSize
  0000f	68 fe 00 00 00	 push	 254			; 000000feH
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN13@SetSize
  00022	cc		 int	 3
$LN13@SetSize:

; 255  : 	if (nNewSize<0)	AfxThrowInvalidArgException();

  00023	83 7d 08 00	 cmp	 DWORD PTR _nNewSize$[ebp], 0
  00027	7d 05		 jge	 SHORT $LN8@SetSize
  00029	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN8@SetSize:

; 256  : 	
; 257  : 	//设置大小
; 258  : 	AllocMemory(nNewSize);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _nNewSize$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::AllocMemory

; 259  : 	if (nNewSize>m_nElementCount)

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00040	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  00043	7e 35		 jle	 SHORT $LN9@SetSize

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0004b	89 55 f8	 mov	 DWORD PTR _i$3[ebp], edx
  0004e	eb 09		 jmp	 SHORT $LN4@SetSize
$LN2@SetSize:
  00050	8b 45 f8	 mov	 eax, DWORD PTR _i$3[ebp]
  00053	83 c0 01	 add	 eax, 1
  00056	89 45 f8	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@SetSize:
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0005c	3b 4d 08	 cmp	 ecx, DWORD PTR _nNewSize$[ebp]
  0005f	7d 17		 jge	 SHORT $LN3@SetSize
  00061	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00064	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _i$3[ebp]
  0006a	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  0006d	89 55 f0	 mov	 DWORD PTR __Where$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h

; 187  :         return _Where;

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Where$[ebp]
  00073	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h

; 261  : 		for (INT_PTR i=m_nElementCount;i<nNewSize;i++) new ((VOID *)(m_pData+i)) TYPE;

  00076	eb d8		 jmp	 SHORT $LN2@SetSize
$LN3@SetSize:

; 262  : 	}
; 263  : 	else if (nNewSize<m_nElementCount)

  00078	eb 4d		 jmp	 SHORT $LN10@SetSize
$LN9@SetSize:
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  00080	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00083	7d 42		 jge	 SHORT $LN10@SetSize

; 264  : 	{
; 265  : 		for (INT_PTR i=nNewSize;i<m_nElementCount;i++) (m_pData+i)->~TYPE();

  00085	8b 45 08	 mov	 eax, DWORD PTR _nNewSize$[ebp]
  00088	89 45 f4	 mov	 DWORD PTR _i$2[ebp], eax
  0008b	eb 09		 jmp	 SHORT $LN7@SetSize
$LN5@SetSize:
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR _i$2[ebp]
  00090	83 c1 01	 add	 ecx, 1
  00093	89 4d f4	 mov	 DWORD PTR _i$2[ebp], ecx
$LN7@SetSize:
  00096	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00099	8b 45 f4	 mov	 eax, DWORD PTR _i$2[ebp]
  0009c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0009f	7d 02		 jge	 SHORT $LN6@SetSize
  000a1	eb ea		 jmp	 SHORT $LN5@SetSize
$LN6@SetSize:

; 266  : 		memset(m_pData+nNewSize,0,(m_nElementCount-nNewSize)*sizeof(TYPE));

  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000a9	2b 55 08	 sub	 edx, DWORD PTR _nNewSize$[ebp]
  000ac	c1 e2 02	 shl	 edx, 2
  000af	52		 push	 edx
  000b0	6a 00		 push	 0
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000bb	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  000be	50		 push	 eax
  000bf	e8 00 00 00 00	 call	 _memset
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@SetSize:

; 267  : 	}
; 268  : 	m_nElementCount=nNewSize;

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	8b 55 08	 mov	 edx, DWORD PTR _nNewSize$[ebp]
  000cd	89 51 10	 mov	 DWORD PTR [ecx+16], edx
$LN12@SetSize:

; 269  : 
; 270  : 	return;
; 271  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 04 00	 ret	 4
?SetSize@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetSize
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	ASSERT((nIndex>=0)&&(nIndex<m_nElementCount));

  00007	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  0000b	7c 0b		 jl	 SHORT $LN4@ElementAt
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00013	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00016	7c 14		 jl	 SHORT $LN5@ElementAt
$LN4@ElementAt:
  00018	68 e9 00 00 00	 push	 233			; 000000e9H
  0001d	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00022	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00027	85 c0		 test	 eax, eax
  00029	74 01		 je	 SHORT $LN5@ElementAt
  0002b	cc		 int	 3
$LN5@ElementAt:

; 234  : 	if ((nIndex<0)&&(nIndex>=m_nElementCount)) AfxThrowInvalidArgException();

  0002c	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00030	7d 10		 jge	 SHORT $LN2@ElementAt
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00038	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0003b	7c 05		 jl	 SHORT $LN2@ElementAt
  0003d	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN2@ElementAt:

; 235  : 	
; 236  : 	return m_pData[nIndex];

  00042	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00045	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0004b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
$LN3@ElementAt:

; 237  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ElementAt@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEAAPAUtagTimerItem@@H@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::ElementAt
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Append@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABV1@@Z
_TEXT	SEGMENT
_nOldCount$1 = -12					; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
_Src$ = 8						; size = 4
?Append@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABV1@@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Append, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 193  : 	//效验参数
; 194  : 	ASSERT(this!=&Src);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	3b 45 08	 cmp	 eax, DWORD PTR _Src$[ebp]
  00010	75 14		 jne	 SHORT $LN8@Append
  00012	68 c2 00 00 00	 push	 194			; 000000c2H
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@LDFGAABH@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0001c	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00021	85 c0		 test	 eax, eax
  00023	74 01		 je	 SHORT $LN8@Append
  00025	cc		 int	 3
$LN8@Append:

; 195  : 	if (this==&Src) AfxThrowInvalidArgException();

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	3b 55 08	 cmp	 edx, DWORD PTR _Src$[ebp]
  0002c	75 05		 jne	 SHORT $LN5@Append
  0002e	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$LN5@Append:

; 196  : 
; 197  : 	//拷贝数组
; 198  : 	if (Src.m_nElementCount>0)

  00033	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  00036	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0003a	7e 6d		 jle	 SHORT $LN6@Append

; 199  : 	{
; 200  : 		INT_PTR nOldCount=m_nElementCount;

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	89 55 f4	 mov	 DWORD PTR _nOldCount$1[ebp], edx

; 201  : 		AllocMemory(m_nElementCount+Src.m_nElementCount);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004b	8b 55 08	 mov	 edx, DWORD PTR _Src$[ebp]
  0004e	03 4a 10	 add	 ecx, DWORD PTR [edx+16]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?AllocMemory@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXH@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::AllocMemory

; 202  : 		for (INT_PTR i=0;i<Src.m_nElementCount;i++)	m_pData[m_nElementCount+i]=Src.m_pData[i];

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00061	eb 09		 jmp	 SHORT $LN4@Append
$LN2@Append:
  00063	8b 45 f8	 mov	 eax, DWORD PTR _i$2[ebp]
  00066	83 c0 01	 add	 eax, 1
  00069	89 45 f8	 mov	 DWORD PTR _i$2[ebp], eax
$LN4@Append:
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  0006f	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00072	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  00075	7d 20		 jge	 SHORT $LN3@Append
  00077	8b 45 08	 mov	 eax, DWORD PTR _Src$[ebp]
  0007a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00080	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00083	03 45 f8	 add	 eax, DWORD PTR _i$2[ebp]
  00086	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00089	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0008c	8b 75 f8	 mov	 esi, DWORD PTR _i$2[ebp]
  0008f	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00092	89 0c 82	 mov	 DWORD PTR [edx+eax*4], ecx
  00095	eb cc		 jmp	 SHORT $LN2@Append
$LN3@Append:

; 203  : 		m_nElementCount+=Src.m_nElementCount;

  00097	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0009a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _Src$[ebp]
  000a0	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN6@Append:

; 204  : 	}
; 205  : 
; 206  : 	return m_nElementCount;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LN7@Append:

; 207  : }

  000af	5e		 pop	 esi
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
?Append@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABV1@@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Append
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?Add@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABQAUtagTimerItem@@@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_newElement$ = 8					; size = 4
?Add@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABQAUtagTimerItem@@@Z PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Add, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	INT_PTR nIndex=m_nElementCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f8	 mov	 DWORD PTR _nIndex$[ebp], ecx

; 107  : 	SetAtGrow(nIndex,newElement);

  00012	8b 55 08	 mov	 edx, DWORD PTR _newElement$[ebp]
  00015	52		 push	 edx
  00016	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?SetAtGrow@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEXHABQAUtagTimerItem@@@Z ; CWHArray<tagTimerItem *,tagTimerItem * const &>::SetAtGrow

; 108  : 	return nIndex;

  00022	8b 45 f8	 mov	 eax, DWORD PTR _nIndex$[ebp]

; 109  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Add@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAEHABQAUtagTimerItem@@@Z ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::Add
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ?GetCount@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCount@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QBEHXZ PROC ; CWHArray<tagTimerItem *,tagTimerItem * const &>::GetCount, COMDAT
; _this$ = ecx

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   : 	return m_nElementCount;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 100  : }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetCount@?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QBEHXZ ENDP ; CWHArray<tagTimerItem *,tagTimerItem * const &>::GetCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_i$2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ PROC	; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@

; 144  : 	if (m_pData!=NULL)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00019	74 3e		 je	 SHORT $LN6@CWHArray

; 145  : 	{
; 146  : 		for (INT_PTR i=0;i<m_nElementCount;i++)	(m_pData+i)->~TYPE();

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  00022	eb 09		 jmp	 SHORT $LN4@CWHArray
$LN2@CWHArray:
  00024	8b 55 f8	 mov	 edx, DWORD PTR _i$2[ebp]
  00027	83 c2 01	 add	 edx, 1
  0002a	89 55 f8	 mov	 DWORD PTR _i$2[ebp], edx
$LN4@CWHArray:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _i$2[ebp]
  00033	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00036	7d 02		 jge	 SHORT $LN3@CWHArray
  00038	eb ea		 jmp	 SHORT $LN2@CWHArray
$LN3@CWHArray:

; 147  : 		delete [] (BYTE *)m_pData;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0004c	83 c4 04	 add	 esp, 4

; 148  : 		m_pData=NULL;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00052	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@CWHArray:

; 149  : 	}
; 150  : 
; 151  : 	return;
; 152  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$CWHArray@PAUtagTimerItem@@ABQAU1@@@UAE@XZ ENDP	; CWHArray<tagTimerItem *,tagTimerItem * const &>::~CWHArray<tagTimerItem *,tagTimerItem * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\array.h
;	COMDAT ??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ PROC	; CWHArray<tagTimerItem *,tagTimerItem * const &>::CWHArray<tagTimerItem *,tagTimerItem * const &>, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CWHArray@PAUtagTimerItem@@ABQAU1@@@6B@

; 132  : 	m_pData=NULL;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 133  : 	m_nMaxCount=0;

  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 134  : 	m_nGrowCount=0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0

; 135  : 	m_nElementCount=0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 136  : 
; 137  : 	return;
; 138  : }

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0?$CWHArray@PAUtagTimerItem@@ABQAU1@@@QAE@XZ ENDP	; CWHArray<tagTimerItem *,tagTimerItem * const &>::CWHArray<tagTimerItem *,tagTimerItem * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GCTimerThread@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTimerThread@@UAEPAXI@Z PROC			; CTimerThread::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTimerThread@@UAE@XZ	; CTimerThread::~CTimerThread
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GCTimerThread@@UAEPAXI@Z ENDP			; CTimerThread::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?OnEventThreadRun@CTimerThread@@EAE_NXZ
_TEXT	SEGMENT
tv81 = -20						; size = 4
_dwHandleTickCount$1 = -16				; size = 4
_dwNowTickCount$ = -12					; size = 4
_dwTimerSpace$ = -8					; size = 4
_this$ = -4						; size = 4
?OnEventThreadRun@CTimerThread@@EAE_NXZ PROC		; CTimerThread::OnEventThreadRun, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   :     // 效验参数
; 51   :     ASSERT(m_pTimerEngine != NULL);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00010	75 11		 jne	 SHORT $LN4@OnEventThr
  00012	6a 33		 push	 51			; 00000033H
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00019	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  0001e	85 c0		 test	 eax, eax
  00020	74 01		 je	 SHORT $LN4@OnEventThr
  00022	cc		 int	 3
$LN4@OnEventThr:

; 52   : 
; 53   :     // 获取时间
; 54   :     DWORD dwTimerSpace = m_dwTimerSpace;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00029	89 45 f8	 mov	 DWORD PTR _dwTimerSpace$[ebp], eax

; 55   :     DWORD dwNowTickCount = GetTickCount();

  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00032	89 45 f4	 mov	 DWORD PTR _dwNowTickCount$[ebp], eax

; 56   : 
; 57   :     // 等待调整
; 58   :     if ((m_dwLastTickCount != 0L) && (dwNowTickCount > m_dwLastTickCount))

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0003c	74 37		 je	 SHORT $LN2@OnEventThr
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR _dwNowTickCount$[ebp]
  00044	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  00047	76 2c		 jbe	 SHORT $LN2@OnEventThr

; 59   :     {
; 60   :         DWORD dwHandleTickCount = dwNowTickCount - m_dwLastTickCount;

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	8b 55 f4	 mov	 edx, DWORD PTR _dwNowTickCount$[ebp]
  0004f	2b 51 14	 sub	 edx, DWORD PTR [ecx+20]
  00052	89 55 f0	 mov	 DWORD PTR _dwHandleTickCount$1[ebp], edx

; 61   :         dwTimerSpace = (dwTimerSpace > dwHandleTickCount) ? (dwTimerSpace - dwHandleTickCount) : 0L;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _dwTimerSpace$[ebp]
  00058	3b 45 f0	 cmp	 eax, DWORD PTR _dwHandleTickCount$1[ebp]
  0005b	76 0b		 jbe	 SHORT $LN5@OnEventThr
  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _dwTimerSpace$[ebp]
  00060	2b 4d f0	 sub	 ecx, DWORD PTR _dwHandleTickCount$1[ebp]
  00063	89 4d ec	 mov	 DWORD PTR tv81[ebp], ecx
  00066	eb 07		 jmp	 SHORT $LN6@OnEventThr
$LN5@OnEventThr:
  00068	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN6@OnEventThr:
  0006f	8b 55 ec	 mov	 edx, DWORD PTR tv81[ebp]
  00072	89 55 f8	 mov	 DWORD PTR _dwTimerSpace$[ebp], edx
$LN2@OnEventThr:

; 62   :     }
; 63   : 
; 64   :     // 定时处理
; 65   :     Sleep(dwTimerSpace);

  00075	8b 45 f8	 mov	 eax, DWORD PTR _dwTimerSpace$[ebp]
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 66   :     m_dwLastTickCount = GetTickCount();

  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 67   : 
; 68   :     // 时间处理
; 69   :     m_pTimerEngine->OnTimerThreadSink();

  0008b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008e	8b 4a 18	 mov	 ecx, DWORD PTR [edx+24]
  00091	e8 00 00 00 00	 call	 ?OnTimerThreadSink@CTimerEngine@@AAEXXZ ; CTimerEngine::OnTimerThreadSink

; 70   : 
; 71   :     return true;

  00096	b0 01		 mov	 al, 1

; 72   : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?OnEventThreadRun@CTimerThread@@EAE_NXZ ENDP		; CTimerThread::OnEventThreadRun
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?InitThread@CTimerThread@@QAE_NPAVCTimerEngine@@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pTimerEngine$ = 8					; size = 4
_dwTimerSpace$ = 12					; size = 4
?InitThread@CTimerThread@@QAE_NPAVCTimerEngine@@K@Z PROC ; CTimerThread::InitThread, COMDAT
; _this$ = ecx

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   :     // 效益参数
; 34   :     ASSERT(dwTimerSpace >= 10L);

  00007	83 7d 0c 0a	 cmp	 DWORD PTR _dwTimerSpace$[ebp], 10 ; 0000000aH
  0000b	73 11		 jae	 SHORT $LN4@InitThread
  0000d	6a 22		 push	 34			; 00000022H
  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  00014	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00019	85 c0		 test	 eax, eax
  0001b	74 01		 je	 SHORT $LN4@InitThread
  0001d	cc		 int	 3
$LN4@InitThread:

; 35   :     ASSERT(pTimerEngine != NULL);

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pTimerEngine$[ebp], 0
  00022	75 11		 jne	 SHORT $LN5@InitThread
  00024	6a 23		 push	 35			; 00000023H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@EADJNKDG@g?3?2?M?x?$LK?$PM?2happygamewh?2?$LH?$PO?N?q?$LG?K?2?O?$LF?M?$LD@
  0002b	e8 00 00 00 00	 call	 ?AfxAssertFailedLine@@YGHPBDH@Z ; AfxAssertFailedLine
  00030	85 c0		 test	 eax, eax
  00032	74 01		 je	 SHORT $LN5@InitThread
  00034	cc		 int	 3
$LN5@InitThread:

; 36   :     if (pTimerEngine == NULL)

  00035	83 7d 08 00	 cmp	 DWORD PTR _pTimerEngine$[ebp], 0
  00039	75 04		 jne	 SHORT $LN2@InitThread

; 37   :         return false;

  0003b	32 c0		 xor	 al, al
  0003d	eb 1e		 jmp	 SHORT $LN1@InitThread
$LN2@InitThread:

; 38   : 
; 39   :     // 设置变量
; 40   :     m_dwLastTickCount = 0L;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0

; 41   :     m_dwTimerSpace = dwTimerSpace;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _dwTimerSpace$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 42   :     m_pTimerEngine = pTimerEngine;

  00052	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00055	8b 45 08	 mov	 eax, DWORD PTR _pTimerEngine$[ebp]
  00058	89 42 18	 mov	 DWORD PTR [edx+24], eax

; 43   : 
; 44   :     return true;

  0005b	b0 01		 mov	 al, 1
$LN1@InitThread:

; 45   : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?InitThread@CTimerThread@@QAE_NPAVCTimerEngine@@K@Z ENDP ; CTimerThread::InitThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ??1CTimerThread@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTimerThread@@UAE@XZ PROC				; CTimerThread::~CTimerThread, COMDAT
; _this$ = ecx

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTimerThread@@6B@

; 28   : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1CWHThread@@MAE@XZ
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1CTimerThread@@UAE@XZ ENDP				; CTimerThread::~CTimerThread
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ??0CTimerThread@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTimerThread@@QAE@XZ PROC				; CTimerThread::CTimerThread, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0CWHThread@@IAE@XZ
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTimerThread@@6B@

; 15   :     // 设置变量
; 16   :     m_dwLastTickCount = 0L;

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 17   :     m_dwTimerSpace = 30;

  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	c7 42 10 1e 00
	00 00		 mov	 DWORD PTR [edx+16], 30	; 0000001eH

; 18   : 
; 19   :     // 组件接口
; 20   :     m_pTimerEngine = NULL;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 21   : 
; 22   :     return;
; 23   : }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??0CTimerThread@@QAE@XZ ENDP				; CTimerThread::CTimerThread
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ITimerEngine@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ITimerEngine@@QAE@XZ PROC				; ITimerEngine::ITimerEngine, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7ITimerEngine@@6B@
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0ITimerEngine@@QAE@XZ ENDP				; ITimerEngine::ITimerEngine
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IServiceModule@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IServiceModule@@QAE@XZ PROC				; IServiceModule::IServiceModule, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7IServiceModule@@6B@
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0IServiceModule@@QAE@XZ ENDP				; IServiceModule::IServiceModule
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 216  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00022	8b 7d cc	 mov	 edi, DWORD PTR _this$[ebp]
  00025	83 c7 18	 add	 edi, 24			; 00000018H
  00028	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0002d	8b f0		 mov	 esi, eax
  0002f	f3 a5		 rep movsd

; 218  : 
; 219  : 		if (is_same_v<_Elem2, wchar_t>)

  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 45		 je	 SHORT $LN2@Getvals

; 220  : 			{
; 221  : 			_Days = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getdays());

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 222  : 			_Months = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getmonths());

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 223  : 			_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 224  : 			}
; 225  : 		else

  0007d	eb 5e		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 226  : 			{
; 227  : 			_Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem *>(nullptr), _Cvt);

  0007f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 18	 add	 eax, 24			; 00000018H
  00085	50		 push	 eax
  00086	6a 00		 push	 0
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 228  : 			_Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem *>(nullptr), _Cvt);

  000a0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	83 c2 18	 add	 edx, 24			; 00000018H
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 229  : 			_Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem *>(nullptr), _Cvt);

  000c1	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	83 c2 18	 add	 edx, 24			; 00000018H
  000c7	52		 push	 edx
  000c8	6a 00		 push	 0
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 230  : 			}
; 231  : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 216  : 		{	// get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 		_Cvt = _Lobj._Getcvt();

  00015	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00022	8b 7d cc	 mov	 edi, DWORD PTR _this$[ebp]
  00025	83 c7 18	 add	 edi, 24			; 00000018H
  00028	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0002d	8b f0		 mov	 esi, eax
  0002f	f3 a5		 rep movsd

; 218  : 
; 219  : 		if (is_same_v<_Elem2, wchar_t>)

  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	85 c9		 test	 ecx, ecx
  00038	74 45		 je	 SHORT $LN2@Getvals

; 220  : 			{
; 221  : 			_Days = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getdays());

  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00049	83 c4 04	 add	 esp, 4
  0004c	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0004f	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 222  : 			_Months = (const _Elem *)_Maklocwcs((const wchar_t *)_Lobj._W_Getmonths());

  00052	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00061	83 c4 04	 add	 esp, 4
  00064	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 223  : 			_Ampm = (const _Elem *)_Maklocwcs(L":AM:am:PM:pm");

  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  0007a	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 224  : 			}
; 225  : 		else

  0007d	eb 5e		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 226  : 			{
; 227  : 			_Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem *>(nullptr), _Cvt);

  0007f	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 18	 add	 eax, 24			; 00000018H
  00085	50		 push	 eax
  00086	6a 00		 push	 0
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 228  : 			_Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem *>(nullptr), _Cvt);

  000a0	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	83 c2 18	 add	 edx, 24			; 00000018H
  000a6	52		 push	 edx
  000a7	6a 00		 push	 0
  000a9	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 229  : 			_Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem *>(nullptr), _Cvt);

  000c1	8b 55 cc	 mov	 edx, DWORD PTR _this$[ebp]
  000c4	83 c2 18	 add	 edx, 24			; 00000018H
  000c7	52		 push	 edx
  000c8	6a 00		 push	 0
  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 230  : 			}
; 231  : 		}

  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?InterfaceVersionCompare@@YA_NKK@Z
_TEXT	SEGMENT
_dwVersion$ = -40					; size = 4
_dwVersion$ = -36					; size = 4
_dwVersion$ = -32					; size = 4
_dwVersion$ = -28					; size = 4
_dwVersion$ = -24					; size = 4
_dwVersion$ = -20					; size = 4
_dwVersion$ = -16					; size = 4
_dwVersion$ = -12					; size = 4
$T1 = -8						; size = 1
$T2 = -7						; size = 1
$T3 = -6						; size = 1
$T4 = -5						; size = 1
$T5 = -4						; size = 1
$T6 = -3						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_dwQueryVer$ = 8					; size = 4
_dwInterfaceVer$ = 12					; size = 4
?InterfaceVersionCompare@@YA_NKK@Z PROC			; InterfaceVersionCompare, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dwQueryVer$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 57   : 	return ((BYTE *)&dwVersion)[1];

  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	c1 e1 00	 shl	 ecx, 0
  00014	8a 54 0d f4	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  00018	88 55 ff	 mov	 BYTE PTR $T8[ebp], dl

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _dwInterfaceVer$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 57   : 	return ((BYTE *)&dwVersion)[1];

  00021	b9 01 00 00 00	 mov	 ecx, 1
  00026	c1 e1 00	 shl	 ecx, 0
  00029	8a 54 0d f0	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  0002d	88 55 fe	 mov	 BYTE PTR $T7[ebp], dl

; 69   : 	if (GetSubVer(dwQueryVer)>GetSubVer(dwInterfaceVer)) return false;

  00030	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  00034	0f b6 4d fe	 movzx	 ecx, BYTE PTR $T7[ebp]
  00038	3b c1		 cmp	 eax, ecx
  0003a	7e 07		 jle	 SHORT $LN2@InterfaceV
  0003c	32 c0		 xor	 al, al
  0003e	e9 ae 00 00 00	 jmp	 $LN1@InterfaceV
$LN2@InterfaceV:

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  00043	8b 55 08	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  00046	89 55 ec	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 51   : 	return ((BYTE *)&dwVersion)[2];

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	d1 e0		 shl	 eax, 1
  00050	8a 4c 05 ec	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  00054	88 4d fd	 mov	 BYTE PTR $T6[ebp], cl

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  00057	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  0005a	89 55 e8	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 51   : 	return ((BYTE *)&dwVersion)[2];

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	d1 e0		 shl	 eax, 1
  00064	8a 4c 05 e8	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  00068	88 4d fc	 mov	 BYTE PTR $T5[ebp], cl

; 70   : 	if (GetMainVer(dwQueryVer)!=GetMainVer(dwInterfaceVer)) return false;

  0006b	0f b6 55 fd	 movzx	 edx, BYTE PTR $T6[ebp]
  0006f	0f b6 45 fc	 movzx	 eax, BYTE PTR $T5[ebp]
  00073	3b d0		 cmp	 edx, eax
  00075	74 04		 je	 SHORT $LN3@InterfaceV
  00077	32 c0		 xor	 al, al
  00079	eb 76		 jmp	 SHORT $LN1@InterfaceV
$LN3@InterfaceV:

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _dwQueryVer$[ebp]
  0007e	89 4d e4	 mov	 DWORD PTR _dwVersion$[ebp], ecx

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	6b c2 00	 imul	 eax, edx, 0
  00089	8a 4c 05 e4	 mov	 cl, BYTE PTR _dwVersion$[ebp+eax]
  0008d	88 4d fb	 mov	 BYTE PTR $T4[ebp], cl

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  00090	8b 55 0c	 mov	 edx, DWORD PTR _dwInterfaceVer$[ebp]
  00093	89 55 e0	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	6b c8 00	 imul	 ecx, eax, 0
  0009e	8a 54 0d e0	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  000a2	88 55 fa	 mov	 BYTE PTR $T3[ebp], dl

; 71   : 	if (GetBuildVer(dwQueryVer)!=GetBuildVer(dwInterfaceVer)) return false;

  000a5	0f b6 45 fb	 movzx	 eax, BYTE PTR $T4[ebp]
  000a9	0f b6 4d fa	 movzx	 ecx, BYTE PTR $T3[ebp]
  000ad	3b c1		 cmp	 eax, ecx
  000af	74 04		 je	 SHORT $LN4@InterfaceV
  000b1	32 c0		 xor	 al, al
  000b3	eb 3c		 jmp	 SHORT $LN1@InterfaceV
$LN4@InterfaceV:

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000b5	8b 55 08	 mov	 edx, DWORD PTR _dwQueryVer$[ebp]
  000b8	89 55 dc	 mov	 DWORD PTR _dwVersion$[ebp], edx

; 45   : 	return ((BYTE *)&dwVersion)[3];

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	6b c8 03	 imul	 ecx, eax, 3
  000c3	8a 54 0d dc	 mov	 dl, BYTE PTR _dwVersion$[ebp+ecx]
  000c7	88 55 f9	 mov	 BYTE PTR $T2[ebp], dl

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000ca	8b 45 0c	 mov	 eax, DWORD PTR _dwInterfaceVer$[ebp]
  000cd	89 45 d8	 mov	 DWORD PTR _dwVersion$[ebp], eax

; 45   : 	return ((BYTE *)&dwVersion)[3];

  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	6b d1 03	 imul	 edx, ecx, 3
  000d8	8a 44 15 d8	 mov	 al, BYTE PTR _dwVersion$[ebp+edx]
  000dc	88 45 f8	 mov	 BYTE PTR $T1[ebp], al

; 72   : 	if (GetProductVer(dwQueryVer)!=GetProductVer(dwInterfaceVer)) return false;

  000df	0f b6 4d f9	 movzx	 ecx, BYTE PTR $T2[ebp]
  000e3	0f b6 55 f8	 movzx	 edx, BYTE PTR $T1[ebp]
  000e7	3b ca		 cmp	 ecx, edx
  000e9	74 04		 je	 SHORT $LN5@InterfaceV
  000eb	32 c0		 xor	 al, al
  000ed	eb 02		 jmp	 SHORT $LN1@InterfaceV
$LN5@InterfaceV:

; 73   : 	return true;

  000ef	b0 01		 mov	 al, 1
$LN1@InterfaceV:

; 74   : };

  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
?InterfaceVersionCompare@@YA_NKK@Z ENDP			; InterfaceVersionCompare
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetBuildVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetBuildVer@@YAEK@Z PROC				; GetBuildVer, COMDAT

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   : 	return ((BYTE *)&dwVersion)[0];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 00	 imul	 ecx, eax, 0
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 64   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBuildVer@@YAEK@Z ENDP				; GetBuildVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetSubVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetSubVer@@YAEK@Z PROC					; GetSubVer, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 57   : 	return ((BYTE *)&dwVersion)[1];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	c1 e0 00	 shl	 eax, 0
  0000b	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 58   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSubVer@@YAEK@Z ENDP					; GetSubVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetMainVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetMainVer@@YAEK@Z PROC				; GetMainVer, COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   : 	return ((BYTE *)&dwVersion)[2];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	d1 e0		 shl	 eax, 1
  0000a	8a 44 05 08	 mov	 al, BYTE PTR _dwVersion$[ebp+eax]

; 52   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?GetMainVer@@YAEK@Z ENDP				; GetMainVer
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\全局定义\module.h
;	COMDAT ?GetProductVer@@YAEK@Z
_TEXT	SEGMENT
_dwVersion$ = 8						; size = 4
?GetProductVer@@YAEK@Z PROC				; GetProductVer, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 45   : 	return ((BYTE *)&dwVersion)[3];

  00003	b8 01 00 00 00	 mov	 eax, 1
  00008	6b c8 03	 imul	 ecx, eax, 3
  0000b	8a 44 0d 08	 mov	 al, BYTE PTR _dwVersion$[ebp+ecx]

; 46   : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetProductVer@@YAEK@Z ENDP				; GetProductVer
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0IUnknownEx@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknownEx@@QAE@XZ PROC				; IUnknownEx::IUnknownEx, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IUnknownEx@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0IUnknownEx@@QAE@XZ ENDP				; IUnknownEx::IUnknownEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv86 = -20						; size = 4
__Count$ = -16						; size = 4
__Ptrdest$ = -12					; size = 4
tv79 = -8						; size = 4
tv89 = -2						; size = 2
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 97   : 	{	// copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 98   : 	const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  0000f	83 c1 02	 add	 ecx, 2
  00012	89 4d ec	 mov	 DWORD PTR tv86[ebp], ecx
$LL6@Maklocwcs:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv79[ebp]
  00018	66 8b 02	 mov	 ax, WORD PTR [edx]
  0001b	66 89 45 fe	 mov	 WORD PTR tv89[ebp], ax
  0001f	83 45 f8 02	 add	 DWORD PTR tv79[ebp], 2
  00023	66 83 7d fe 00	 cmp	 WORD PTR tv89[ebp], 0
  00028	75 eb		 jne	 SHORT $LL6@Maklocwcs
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  0002d	2b 4d ec	 sub	 ecx, DWORD PTR tv86[ebp]
  00030	d1 f9		 sar	 ecx, 1
  00032	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00035	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  00038	83 c2 01	 add	 edx, 1
  0003b	89 55 f0	 mov	 DWORD PTR __Count$[ebp], edx

; 99   : 
; 100  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),

  0003e	6a 65		 push	 101			; 00000065H
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@DJFLDKBN@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  00045	6a 02		 push	 2
  00047	6a 02		 push	 2
  00049	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  0004c	50		 push	 eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00053	83 c4 14	 add	 esp, 20			; 00000014H
  00056	89 45 f4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 101  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 102  : 
; 103  : 	if (!_Ptrdest)

  00059	83 7d f4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  0005d	75 05		 jne	 SHORT $LN2@Maklocwcs

; 104  : 		_Xbad_alloc();

  0005f	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00064	8b 4d f0	 mov	 ecx, DWORD PTR __Count$[ebp]
  00067	d1 e1		 shl	 ecx, 1
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 _memcpy
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocnum

; 106  : 	return (_Ptrdest);

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 107  : 	}

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -64						; size = 8
__Mbst1$ = -56						; size = 8
tv69 = -48						; size = 4
tv146 = -44						; size = 4
__Count1$ = -40						; size = 4
__Ptrdest$ = -36					; size = 4
__Ptr1$ = -32						; size = 4
__Ptrnext$ = -28					; size = 4
tv143 = -24						; size = 4
__Count$ = -20						; size = 4
__Bytes$ = -16						; size = 4
__Wchars$ = -12						; size = 4
__Wc$ = -8						; size = 2
tv149 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 682  : 	{	// convert C string to wchar_t sequence using _Cvtvec

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 683  : 	size_t _Count, _Count1;
; 684  : 	size_t _Wchars;
; 685  : 	const char *_Ptr1;
; 686  : 	int _Bytes;
; 687  : 	wchar_t _Wc;
; 688  : 	mbstate_t _Mbst1 = {};

  00006	33 c0		 xor	 eax, eax
  00008	89 45 c8	 mov	 DWORD PTR __Mbst1$[ebp], eax
  0000b	89 45 cc	 mov	 DWORD PTR __Mbst1$[ebp+4], eax

; 689  : 
; 690  : 	_Count1 = _CSTD strlen(_Ptr) + 1;

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	89 4d e8	 mov	 DWORD PTR tv143[ebp], ecx
  00014	8b 55 e8	 mov	 edx, DWORD PTR tv143[ebp]
  00017	83 c2 01	 add	 edx, 1
  0001a	89 55 d4	 mov	 DWORD PTR tv146[ebp], edx
$LL12@Maklocstr:
  0001d	8b 45 e8	 mov	 eax, DWORD PTR tv143[ebp]
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	88 4d ff	 mov	 BYTE PTR tv149[ebp], cl
  00025	83 45 e8 01	 add	 DWORD PTR tv143[ebp], 1
  00029	80 7d ff 00	 cmp	 BYTE PTR tv149[ebp], 0
  0002d	75 ee		 jne	 SHORT $LL12@Maklocstr
  0002f	8b 55 e8	 mov	 edx, DWORD PTR tv143[ebp]
  00032	2b 55 d4	 sub	 edx, DWORD PTR tv146[ebp]
  00035	89 55 d0	 mov	 DWORD PTR tv69[ebp], edx
  00038	8b 45 d0	 mov	 eax, DWORD PTR tv69[ebp]
  0003b	83 c0 01	 add	 eax, 1
  0003e	89 45 d8	 mov	 DWORD PTR __Count1$[ebp], eax

; 691  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00041	8b 4d d8	 mov	 ecx, DWORD PTR __Count1$[ebp]
  00044	89 4d ec	 mov	 DWORD PTR __Count$[ebp], ecx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  0004e	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00051	89 55 e0	 mov	 DWORD PTR __Ptr1$[ebp], edx
  00054	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:

; 692  : 		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR __Bytes$[ebp]
  0005c	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
  0005f	8b 4d e0	 mov	 ecx, DWORD PTR __Ptr1$[ebp]
  00062	03 4d f0	 add	 ecx, DWORD PTR __Bytes$[ebp]
  00065	89 4d e0	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx
$LN4@Maklocstr:

; 691  : 	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;

  00071	83 7d ec 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00075	76 29		 jbe	 SHORT $LN3@Maklocstr

; 693  : 		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)

  00077	8b 45 10	 mov	 eax, DWORD PTR __Cvt$[ebp]
  0007a	50		 push	 eax
  0007b	8d 4d c8	 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0007e	51		 push	 ecx
  0007f	8b 55 ec	 mov	 edx, DWORD PTR __Count$[ebp]
  00082	52		 push	 edx
  00083	8b 45 e0	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  00086	50		 push	 eax
  00087	8d 4d f8	 lea	 ecx, DWORD PTR __Wc$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 __Mbrtowc
  00090	83 c4 14	 add	 esp, 20			; 00000014H
  00093	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00096	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0009a	7f 02		 jg	 SHORT $LN8@Maklocstr

; 694  : 			break;

  0009c	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 695  : 	++_Wchars;	// count terminating nul

  0009e	eb b6		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:
  000a0	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  000a3	83 c2 01	 add	 edx, 1
  000a6	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx

; 696  : 
; 697  : 	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),

  000a9	68 ba 02 00 00	 push	 698			; 000002baH
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@LKBGDILM@c?3?2program?5files?5?$CIx86?$CJ?2microsof@
  000b3	6a 02		 push	 2
  000b5	6a 02		 push	 2
  000b7	8b 45 f4	 mov	 eax, DWORD PTR __Wchars$[ebp]
  000ba	50		 push	 eax
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  000c1	83 c4 14	 add	 esp, 20			; 00000014H
  000c4	89 45 dc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 698  : 		_CRT_BLOCK, __FILE__, __LINE__);
; 699  : 
; 700  : 	if (!_Ptrdest)

  000c7	83 7d dc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  000cb	75 05		 jne	 SHORT $LN9@Maklocstr

; 701  : 		_Xbad_alloc();

  000cd	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 702  : 	wchar_t *_Ptrnext = _Ptrdest;

  000d2	8b 4d dc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  000d5	89 4d e4	 mov	 DWORD PTR __Ptrnext$[ebp], ecx

; 703  : 	mbstate_t _Mbst2 = {};

  000d8	33 d2		 xor	 edx, edx
  000da	89 55 c0	 mov	 DWORD PTR __Mbst2$[ebp], edx
  000dd	89 55 c4	 mov	 DWORD PTR __Mbst2$[ebp+4], edx

; 704  : 
; 705  : 	for (; 0 < _Wchars;

  000e0	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:

; 706  : 		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)

  000e2	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  000e5	2b 45 f0	 sub	 eax, DWORD PTR __Bytes$[ebp]
  000e8	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ee	03 4d f0	 add	 ecx, DWORD PTR __Bytes$[ebp]
  000f1	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000f4	8b 55 f4	 mov	 edx, DWORD PTR __Wchars$[ebp]
  000f7	83 ea 01	 sub	 edx, 1
  000fa	89 55 f4	 mov	 DWORD PTR __Wchars$[ebp], edx
  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  00100	83 c0 02	 add	 eax, 2
  00103	89 45 e4	 mov	 DWORD PTR __Ptrnext$[ebp], eax
$LN7@Maklocstr:

; 704  : 
; 705  : 	for (; 0 < _Wchars;

  00106	83 7d f4 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0010a	76 29		 jbe	 SHORT $LN6@Maklocstr

; 707  : 		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)

  0010c	8b 4d 10	 mov	 ecx, DWORD PTR __Cvt$[ebp]
  0010f	51		 push	 ecx
  00110	8d 55 c0	 lea	 edx, DWORD PTR __Mbst2$[ebp]
  00113	52		 push	 edx
  00114	8b 45 d8	 mov	 eax, DWORD PTR __Count1$[ebp]
  00117	50		 push	 eax
  00118	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0011b	51		 push	 ecx
  0011c	8b 55 e4	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  0011f	52		 push	 edx
  00120	e8 00 00 00 00	 call	 __Mbrtowc
  00125	83 c4 14	 add	 esp, 20			; 00000014H
  00128	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  0012b	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0012f	7f 02		 jg	 SHORT $LN10@Maklocstr

; 708  : 			break;

  00131	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 709  : 	*_Ptrnext = L'\0';

  00133	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:
  00135	33 c0		 xor	 eax, eax
  00137	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  0013a	66 89 01	 mov	 WORD PTR [ecx], ax

; 710  : 
; 711  : 	return (_Ptrdest);

  0013d	8b 45 dc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN11@Maklocstr:

; 712  : 	}

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 230  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 231  :         #pragma warning(push)
; 232  :         #pragma warning(disable : 4995 4996 6386)
; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00003	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00006	d1 e0		 shl	 eax, 1
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _memcpy
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  :         #pragma warning(pop)
; 235  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\atlmfc\include\afx.h
;	COMDAT ?AfxAssertFailedLine@@YGHPBDH@Z
_TEXT	SEGMENT
_msg$ = -36						; size = 28
_bResult$ = -8						; size = 4
_bQuit$ = -4						; size = 4
_lpszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
?AfxAssertFailedLine@@YGHPBDH@Z PROC			; AfxAssertFailedLine, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 313  : 	// we remove WM_QUIT because if it is in the queue then the message box
; 314  : 	// won't display
; 315  : 	MSG msg;
; 316  : 	BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);

  00006	6a 01		 push	 1
  00008	6a 12		 push	 18			; 00000012H
  0000a	6a 12		 push	 18			; 00000012H
  0000c	6a 00		 push	 0
  0000e	8d 45 dc	 lea	 eax, DWORD PTR _msg$[ebp]
  00011	50		 push	 eax
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekMessageA@20
  00018	89 45 fc	 mov	 DWORD PTR _bQuit$[ebp], eax

; 317  : 	BOOL bResult = _CrtDbgReport(_CRT_ASSERT, lpszFileName, nLine, NULL, NULL);

  0001b	6a 00		 push	 0
  0001d	6a 00		 push	 0
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _lpszFileName$[ebp]
  00026	52		 push	 edx
  00027	6a 02		 push	 2
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0002f	83 c4 14	 add	 esp, 20			; 00000014H
  00032	89 45 f8	 mov	 DWORD PTR _bResult$[ebp], eax

; 318  : 	if (bQuit)

  00035	83 7d fc 00	 cmp	 DWORD PTR _bQuit$[ebp], 0
  00039	74 0a		 je	 SHORT $LN2@AfxAssertF

; 319  : 		PostQuitMessage((int)msg.wParam);

  0003b	8b 45 e4	 mov	 eax, DWORD PTR _msg$[ebp+8]
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostQuitMessage@4
$LN2@AfxAssertF:

; 320  : 	return bResult;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _bResult$[ebp]

; 321  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?AfxAssertFailedLine@@YGHPBDH@Z ENDP			; AfxAssertFailedLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv68 = -8						; size = 4
tv76 = -4						; size = 4
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _guidOther$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _guidOne$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  0001b	83 7d f4 00	 cmp	 DWORD PTR tv74[ebp], 0
  0001f	75 09		 jne	 SHORT $LN7@
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN5@
$LN7@:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN5@:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

  00031	83 7d fc 00	 cmp	 DWORD PTR tv76[ebp], 0
  00035	74 09		 je	 SHORT $LN3@
  00037	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0003e	eb 07		 jmp	 SHORT $LN4@
$LN3@:
  00040	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@:
  00047	8a 45 f8	 mov	 al, BYTE PTR tv68[ebp]

; 195  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.17763.0\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
tv68 = -8						; size = 4
tv70 = -4						; size = 4
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00006	6a 10		 push	 16			; 00000010H
  00008	8b 45 0c	 mov	 eax, DWORD PTR _rguid2$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _memcmp
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
  00018	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0001b	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  0001f	75 09		 jne	 SHORT $LN3@IsEqualGUI
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@IsEqualGUI
$LN3@IsEqualGUI:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@IsEqualGUI:
  00031	8b 45 fc	 mov	 eax, DWORD PTR tv70[ebp]

; 162  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.16.27023\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 185  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 186  :         (void)_Size;
; 187  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 188  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
; File g:\网狐\happygamewh\服务端\系统模块\服务器组件\内核引擎\timerengine.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR ___n$[ebp]
  0000d	83 e9 01	 sub	 ecx, 1
  00010	89 4d 10	 mov	 DWORD PTR ___n$[ebp], ecx
  00013	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00017	76 11		 jbe	 SHORT $LN1@vector
  00019	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	8b 55 08	 mov	 edx, DWORD PTR ___t$[ebp]
  00022	03 55 0c	 add	 edx, DWORD PTR ___s$[ebp]
  00025	89 55 08	 mov	 DWORD PTR ___t$[ebp], edx
  00028	eb da		 jmp	 SHORT $LN2@vector
$LN1@vector:
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
